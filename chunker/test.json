{
  "content": [
    "258 ❘ CHAPTER 11 IntroducIng Hooks\ncomponents in order to provide reusable functionality to a deeply buried component is what is com-\nmonly known in the React world as “wrapper hell.” Figure 11-1 shows a view of the React Developer\nTools for a component tree that’s suffering badly from this condition.\nFIGURE 11- 1: Wrapper hell\nReact’s other big problem prior to hooks was that people found using classes to be unnecessarily\nconfusing and verbose. If you’ve made it this far into the book, I don’t need to explain this one to you\nagain. Most of the time, what requires 50 lines of code in a class can be done with a fraction of that\nby using a function.\nThe Built-i n Hooks ❘ 259\nAs you’ll see, beyond just having the ability to accomplish the same thing with less code, hooks also\ngive you the ability to split up your components into smaller parts by creating custom hooks.\nNow that you understand the motivation for hooks, let’s take a look at the specifics.\nRULES OF HOOKS",
    "by using a function.\nThe Built-i n Hooks ❘ 259\nAs you’ll see, beyond just having the ability to accomplish the same thing with less code, hooks also\ngive you the ability to split up your components into smaller parts by creating custom hooks.\nNow that you understand the motivation for hooks, let’s take a look at the specifics.\nRULES OF HOOKS\nAlthough different hooks accomplish different things, all of them have two important rules which\nmust be followed:\n1. Hooks can only be used in function components.\n2. Hooks must be called at the top level of your function components— meaning inside the\nfunction, but not inside of a statement or inner function. Because hooks need to run just once\nevery time your function component runs, they can’t be called from inside of conditional\nstatements, loops, or nested functions.\nTHE BUILT- IN HOOKS\nReact has 10 built-i n hooks that you can use without needing to install anything else. These built- in\nhooks are:\n➤➤ useState\n➤➤ useEffect\n➤➤ useContext",
    "function, but not inside of a statement or inner function. Because hooks need to run just once\nevery time your function component runs, they can’t be called from inside of conditional\nstatements, loops, or nested functions.\nTHE BUILT- IN HOOKS\nReact has 10 built-i n hooks that you can use without needing to install anything else. These built- in\nhooks are:\n➤➤ useState\n➤➤ useEffect\n➤➤ useContext\n➤➤ useReducer\n➤➤ useCallback\n➤➤ useMemo\n➤➤ useRef\n➤➤ useImperativeHandle\n➤➤ useLayoutEffect\n➤➤ useDebugValue\nThe first three hooks—u seState, useEffect, and useContext— are the basic hooks. They’re the\nones you’ll use most often and that are therefore the most important ones to understand.\nThe other seven hooks are called “Additional Hooks” in the React documentation. These are hooks\nthat you may only use occasionally (or never) or which are variations on the three basic hooks. There\nare some really useful things (and a couple that are essential, in my opinion) in this set of hooks,",
    "ones you’ll use most often and that are therefore the most important ones to understand.\nThe other seven hooks are called “Additional Hooks” in the React documentation. These are hooks\nthat you may only use occasionally (or never) or which are variations on the three basic hooks. There\nare some really useful things (and a couple that are essential, in my opinion) in this set of hooks,\nhowever, so I’m going to spend some time covering them and showing examples of how to use\nthem as well.\n260 ❘ CHAPTER 11 IntroducIng Hooks\nManaging State with useState\nOn the first render of a function component containing it, the useState hook creates a stateful\nvalue from the argument passed to it, along with the function for updating it. After the first render,\nuseState returns its most recent value after updates are applied. Like class properties (such as this\n.state), values created with useState persist between renders.\nAs with all of the hooks, the first step in using useState is to import it:",
    "value from the argument passed to it, along with the function for updating it. After the first render,\nuseState returns its most recent value after updates are applied. Like class properties (such as this\n.state), values created with useState persist between renders.\nAs with all of the hooks, the first step in using useState is to import it:\nimport {useState} from 'react';\nIMPORTING ALL THE HOOKS\nIn reality, since hooks are part of the React library, you can import all of the hooks\nat once by importing the entire React library and then referencing them using dot\nnotation, like this:\nimport React from 'react';\nconst [state,setState] = React.useState();\nAlthough there’s no real problem with using hooks this way, it’s more common, and\nperhaps more efficient, to import just the hooks you need individually using named\nimports. If your component makes use of multiple hooks, separate them with com-\nmas inside of the curly braces, like this:",
    "notation, like this:\nimport React from 'react';\nconst [state,setState] = React.useState();\nAlthough there’s no real problem with using hooks this way, it’s more common, and\nperhaps more efficient, to import just the hooks you need individually using named\nimports. If your component makes use of multiple hooks, separate them with com-\nmas inside of the curly braces, like this:\nimport {useState,useEffect,useCallback} from 'react';\nOnce you import useState into a component, you can use it as many times as you need to create\nstateful variables. React keeps track of stateful values in a function component based on the order\nin which they appear in the code, which is how it can return the latest value for each stateful vari-\nable each time the function renders. This is why hooks can’t be used inside of conditional or looping\ncode— doing so would cause the hooks in a function component to not always be called, or to not be",
    "in which they appear in the code, which is how it can return the latest value for each stateful vari-\nable each time the function renders. This is why hooks can’t be used inside of conditional or looping\ncode— doing so would cause the hooks in a function component to not always be called, or to not be\ncalled in the same order with each render, which would cause React to return unexpected values.\nListing 11-1 shows a simple example of using useState to keep track of the score and the current\nguess in a number guessing game.\nLISTING 11- 1: A number guessing game with useState\nimport {useState} from 'react';\nfunction NumberGuessing(props){\nconst [score,setScore] = useState(0);\nconst [guess,setGuess] = useState('');\nconst checkNumber =()=>{\nconst randomNumber = Math.floor(Math.random() * 10)+1;\nif (Number(guess) === randomNumber){\nThe Built-i n Hooks ❘ 261\nsetScore(()=>score+1);\n}\n}\nreturn (\n<>\nWhat number (between 1 and 10) am I thinking of?\n<input value={guess}\ntype=\"number\"\nmin=\"1\"",
    "function NumberGuessing(props){\nconst [score,setScore] = useState(0);\nconst [guess,setGuess] = useState('');\nconst checkNumber =()=>{\nconst randomNumber = Math.floor(Math.random() * 10)+1;\nif (Number(guess) === randomNumber){\nThe Built-i n Hooks ❘ 261\nsetScore(()=>score+1);\n}\n}\nreturn (\n<>\nWhat number (between 1 and 10) am I thinking of?\n<input value={guess}\ntype=\"number\"\nmin=\"1\"\nmax=\"10\"\nonChange={(e)=>setGuess(e.target.value)}\n/>\n<button onClick={checkNumber}>Guess!</button>\n<p>Your score: {score}</p>\n</>\n)\n}\nexport default NumberGuessing;\nIn the preceding example, the user’s guess is updated using an inline event handler in the onChange\nevent listener when the user enters a number into the number input field.\nWhen the button is clicked, the checkNumber function generates a random number between 1 and 10\nand then compares that number with the latest value stored in the guess stateful variable.",
    "</>\n)\n}\nexport default NumberGuessing;\nIn the preceding example, the user’s guess is updated using an inline event handler in the onChange\nevent listener when the user enters a number into the number input field.\nWhen the button is clicked, the checkNumber function generates a random number between 1 and 10\nand then compares that number with the latest value stored in the guess stateful variable.\nOne important thing to notice with the comparison is that I used the Number function to convert\nguess to a number. This is necessary because even numeric values from <input> elements are stored\nin the browser as strings. The random number variable is of the number data type, however, so to be\nable to do a strict comparison between them, one of them has to be converted.\nIf the two numbers match, the score variable is updated to its current value plus 1.\nJAVASCRIPT LESSON: STRICT EQUALITY\nJavaScript has two equality operators, == and ===. The difference between them is",
    "in the browser as strings. The random number variable is of the number data type, however, so to be\nable to do a strict comparison between them, one of them has to be converted.\nIf the two numbers match, the score variable is updated to its current value plus 1.\nJAVASCRIPT LESSON: STRICT EQUALITY\nJavaScript has two equality operators, == and ===. The difference between them is\nthat == will disregard the data type when comparing, and the === operator will com-\npare both the value and the data type of the values being compared.\nIf you’re coming to JavaScript from another programming language, the behavior of\nthe == operator will seem strange and mysterious. It’s simply not correct that “0” is\nequal to 0, for example.\nIn fact, the existence of the == operator (and its opposite, the != operator) in\nJava Script is widely regarded as a flaw in the language, because it has the potential\nto create mysterious behavior and errors. It is therefore best to avoid using == and to",
    "the == operator will seem strange and mysterious. It’s simply not correct that “0” is\nequal to 0, for example.\nIn fact, the existence of the == operator (and its opposite, the != operator) in\nJava Script is widely regarded as a flaw in the language, because it has the potential\nto create mysterious behavior and errors. It is therefore best to avoid using == and to\nalways perform strict equality comparisons.\n262 ❘ CHAPTER 11 IntroducIng Hooks\nSetting the Initial State\nTo set the initial state of a stateful variable created using useState, pass the initial value into\nuseState. The useState hook accepts a single argument, which can be any of JavaScript’s data types\n(or an expression that evaluates to a single value) or a function.\nIf you don’t pass an argument into useState, the resulting stateful variable will be created with an\ninitial value of undefined.\nIf the initial state is an expression, that expression will still run on each render, but the result will be",
    "(or an expression that evaluates to a single value) or a function.\nIf you don’t pass an argument into useState, the resulting stateful variable will be created with an\ninitial value of undefined.\nIf the initial state is an expression, that expression will still run on each render, but the result will be\nignored after the first render. For this reason, if your initial state is the result of an expensive calcu-\nlation (for example, it requires a network request), pass a function that returns the initial value to\nuseState, as shown here:\nconst [mailingList,setMailingList] = useState(()=>{\nconst initialMailingList = loadMailingList(props);\nreturn initialMailingList;\n});\nThe function will only be run on the first render of the component. React calls this lazy initial state.\nUsing the Setter Function\nLike the setState function in a class component, the setter function returned by useState will",
    "useState, as shown here:\nconst [mailingList,setMailingList] = useState(()=>{\nconst initialMailingList = loadMailingList(props);\nreturn initialMailingList;\n});\nThe function will only be run on the first render of the component. React calls this lazy initial state.\nUsing the Setter Function\nLike the setState function in a class component, the setter function returned by useState will\ntrigger a render. If you pass a setter function down to a child component and call it from that child\ncomponent, it will still operate on the original variable it was created with, as demonstrated by\nListing 11-2.\nLISTING 11- 2: Setter functions are bound to their creator components\nimport {useState} from 'react';\nfunction ButtonContainer(){\nconst [count,setCount] = useState(0);\nreturn (\n<>\n<MyButton count = {count} setCount = {setCount} /><br />\ncount value: {count}\n</>\n);\n}\nfunction MyButton(props){\nreturn (\n<button onClick = {()=>props.setCount(props.count+1)}>\nAdd 1 to the Count\n</button>\n);\n}",
    "LISTING 11- 2: Setter functions are bound to their creator components\nimport {useState} from 'react';\nfunction ButtonContainer(){\nconst [count,setCount] = useState(0);\nreturn (\n<>\n<MyButton count = {count} setCount = {setCount} /><br />\ncount value: {count}\n</>\n);\n}\nfunction MyButton(props){\nreturn (\n<button onClick = {()=>props.setCount(props.count+1)}>\nAdd 1 to the Count\n</button>\n);\n}\nexport default ButtonContainer;\nThe Built-i n Hooks ❘ 263\nFigure 11-2 shows the result of rendering the ButtonContainer component and clicking the button\n(which is rendered by the MyButton child component).\nFIGURE 11- 2: Passing a setter function as a prop\nThe setter function returned by useState can be used in two different ways: by passing it a function\nor by passing it a single value.\nPassing a Value to a Setter\nWhen you pass a single value (or an expression that evaluates to a single value) into a useState set-",
    "(which is rendered by the MyButton child component).\nFIGURE 11- 2: Passing a setter function as a prop\nThe setter function returned by useState can be used in two different ways: by passing it a function\nor by passing it a single value.\nPassing a Value to a Setter\nWhen you pass a single value (or an expression that evaluates to a single value) into a useState set-\nter function, the stateful variable attached to that useState function call will be set to the new value\nyou pass it:\nconst [guess,setGuess] = useState(''); // guess === ''\nsetGuess('7'); // guess === '7'\nsetGuess('3'); // guess === '3'\nUnlike when you use setState in a class component, useState’s setter functions do not merge\nobjects. If you pass an object into a useState setter function, the variable connected to that\nuseState function will be set to exactly that object.\nPassing a Function to a Setter\nThe other way to use useState setter functions is to pass them a function. This is the method that",
    "Unlike when you use setState in a class component, useState’s setter functions do not merge\nobjects. If you pass an object into a useState setter function, the variable connected to that\nuseState function will be set to exactly that object.\nPassing a Function to a Setter\nThe other way to use useState setter functions is to pass them a function. This is the method that\nshould be used when the new state of the variable is based on the previous state of the variable.\nPassing a function ensures that the setter function will always receive the latest value of the variable.\n264 ❘ CHAPTER 11 IntroducIng Hooks\nThe function you pass to a setter function will receive the previous value of the stateful variable as\nan argument, and it’s common to name this argument prev or the name of the variable with prev\nbefore it:\nconst [score,setScore] = useState(0); // score === 0\nsetScore((prevScore)=>prevScore+1); // score === 1\nSetter Function Value Comparison",
    "264 ❘ CHAPTER 11 IntroducIng Hooks\nThe function you pass to a setter function will receive the previous value of the stateful variable as\nan argument, and it’s common to name this argument prev or the name of the variable with prev\nbefore it:\nconst [score,setScore] = useState(0); // score === 0\nsetScore((prevScore)=>prevScore+1); // score === 1\nSetter Function Value Comparison\nIf the value that you pass into a setter function is the same as the current value of the state variable,\nthe setter function will “bail out” without re-r endering the component’s children.\nHooking into the Lifecycle with useEffect\nThe useEffect hook accepts a function, which it will run after each render of the function\ncomponent by default. The useEffect hook can be used to simulate the componentDidMount(),\ncomponentDidUpdate(), and componentWillUnmount() lifecycle methods in function components.\nThe purpose of useEffect is to allow you to run imperative code that may have side effects inside a",
    "The useEffect hook accepts a function, which it will run after each render of the function\ncomponent by default. The useEffect hook can be used to simulate the componentDidMount(),\ncomponentDidUpdate(), and componentWillUnmount() lifecycle methods in function components.\nThe purpose of useEffect is to allow you to run imperative code that may have side effects inside a\nfunction component. These side effects are the types of things that aren’t otherwise allowed in func-\ntion components, such as network requests, setting timers, and manipulating the DOM directly. The\nreason these types of operations aren’t otherwise possible in function components is that function\ncomponents are essentially just the render method of a component. Side effects shouldn’t be done in\nthe render method, even in class components, because the render method is likely to overwrite the\nresults of any side effects. Instead, side effects should be performed after the render method has run",
    "reason these types of operations aren’t otherwise possible in function components is that function\ncomponents are essentially just the render method of a component. Side effects shouldn’t be done in\nthe render method, even in class components, because the render method is likely to overwrite the\nresults of any side effects. Instead, side effects should be performed after the render method has run\nand the DOM has been updated.\nThis is why side effects are handled inside of lifecycle methods, such as constructor(),\ncomponentDidMount(), and componentDidUpdate() in class components.\nJAVASCRIPT LESSON: SIDE EFFECTS\nThe term “side effects” comes up frequently in React, but it’s not a React-s pecific\nterm. In computer science, a side effect is a result of an impure function. If you recall,\na pure function is one whose return value is always the same when given the same\narguments, and that doesn’t do anything that lasts past the running of the function\nexcept return a value.",
    "JAVASCRIPT LESSON: SIDE EFFECTS\nThe term “side effects” comes up frequently in React, but it’s not a React-s pecific\nterm. In computer science, a side effect is a result of an impure function. If you recall,\na pure function is one whose return value is always the same when given the same\narguments, and that doesn’t do anything that lasts past the running of the function\nexcept return a value.\nAnything that a function does that has an effect outside of the function, other than\nproducing a return value, is a side effect.\nSide effects in a browser- based application can include:\n➤➤ Modifying global variables.\n➤➤ Making a network request.\n➤➤ Changing the DOM.\n➤➤ Writing to a database or a file.\n➤➤ Modifying an argument.\nThe Built-i n Hooks ❘ 265\nUsing the Default useEffect Behavior\nIn its most basic form, useEffect simply accepts a function and executes it after each render is com-\nplete, as shown in Listing 11-3.\nLISTING 11- 3: The most basic form of useEffect",
    "➤➤ Modifying global variables.\n➤➤ Making a network request.\n➤➤ Changing the DOM.\n➤➤ Writing to a database or a file.\n➤➤ Modifying an argument.\nThe Built-i n Hooks ❘ 265\nUsing the Default useEffect Behavior\nIn its most basic form, useEffect simply accepts a function and executes it after each render is com-\nplete, as shown in Listing 11-3.\nLISTING 11- 3: The most basic form of useEffect\nimport {useEffect,useState} from 'react';\nfunction RenderCounter(){\nconst [count,setCount] = useState(0);\nuseEffect(()=>{console.log(count)});\nreturn(\n<>\nThis component will count how many times it renders.\n<button onClick={()=>setCount((prev)=>prev+1)}>Update State</button>\n</>\n);\n}\nexport default RenderCounter;\nWhen you run the component in Listing 11-3, it will count each time the function passed to\nuseEffect runs and log the current count to the browser’s JavaScript console.\nThis use of useEffect is similar to if you had passed this same function into both the",
    "<button onClick={()=>setCount((prev)=>prev+1)}>Update State</button>\n</>\n);\n}\nexport default RenderCounter;\nWhen you run the component in Listing 11-3, it will count each time the function passed to\nuseEffect runs and log the current count to the browser’s JavaScript console.\nThis use of useEffect is similar to if you had passed this same function into both the\ncomponentDidMount() and the componentDidUpdate() lifecycle methods in a class component.\nHowever, there is an important difference between these lifecycle methods and how useEffect\nworks. Namely, the timing of when a class component’s lifecycle methods run and when useEffect\nruns are different. Most of the time this isn’t an issue, but in some cases it can cause problems or\nglitches in the layout in the browser. I’ll discuss this and how to solve it when I cover the\nuseLayoutEffect hook.\nCleaning Up After Effects\nIf you use useEffect to set up subscriptions, set event listeners, or create timers, you run",
    "runs are different. Most of the time this isn’t an issue, but in some cases it can cause problems or\nglitches in the layout in the browser. I’ll discuss this and how to solve it when I cover the\nuseLayoutEffect hook.\nCleaning Up After Effects\nIf you use useEffect to set up subscriptions, set event listeners, or create timers, you run\nthe risk of introducing memory leaks into your React application. In class components, the\ncomponentWillUnmount() lifecycle method is used for cleaning up and avoiding memory leaks, as\nyou saw in Chapter 4.\nTo clean up after effects in function components you can return a function from the function passed\ninto useEffect. This function will run before the component is removed from the user interface. In\naddition, it will also run before every update of the component.\nAlthough it may seem inefficient for the cleanup function to run before every update of a component,",
    "you saw in Chapter 4.\nTo clean up after effects in function components you can return a function from the function passed\ninto useEffect. This function will run before the component is removed from the user interface. In\naddition, it will also run before every update of the component.\nAlthough it may seem inefficient for the cleanup function to run before every update of a component,\nif you think about how function components work, you’ll understand why this is necessary. Since\nJavaScript functions aren’t persistent, effects will run every time a component renders. If you’re creat-\ning a subscription to a data source, or a timer, this means that a new timer or subscription will be\n266 ❘ CHAPTER 11 IntroducIng Hooks\ncreated each time the component renders. If it renders multiple times and there’s nothing cleaning up\nthe multiple timers or subscriptions, you’ll have a memory leak.\nUsing a cleanup function in useEffect is optional.\nCustomizing useEffect",
    "ing a subscription to a data source, or a timer, this means that a new timer or subscription will be\n266 ❘ CHAPTER 11 IntroducIng Hooks\ncreated each time the component renders. If it renders multiple times and there’s nothing cleaning up\nthe multiple timers or subscriptions, you’ll have a memory leak.\nUsing a cleanup function in useEffect is optional.\nCustomizing useEffect\nThere are times when you don’t want to run an effect on every render, but instead only on the initial\nrender, or only when a specific value changes. To customize the behavior of useEffect, you can pass\nit an optional second argument. The second argument is an array of values that the effect depends on.\nFor example, Listing 11-4 shows a component that starts a timer and uses the default\nuseEffect behavior. With the default useEffect behavior, this timer is re- created each time the\ncomponent renders.\nLISTING 11- 4: Starting a timer with each render\nimport {useEffect} from 'react';\nfunction TimerFun(){",
    "For example, Listing 11-4 shows a component that starts a timer and uses the default\nuseEffect behavior. With the default useEffect behavior, this timer is re- created each time the\ncomponent renders.\nLISTING 11- 4: Starting a timer with each render\nimport {useEffect} from 'react';\nfunction TimerFun(){\nuseEffect(() => {\nlet time = 0;\nconst interval = setInterval(() => {\nconsole.log(time++);\n}, 1000);\nreturn () => clearInterval(interval);\n});\nreturn (<p>Check the console to see the timer.</p>);\n}\nexport default TimerFun;\nSince this component doesn’t use state or accept any props, there’s no reason for it to re- render, so the\ntimer will continue to increment and log a higher number each second for as long as the component is\nmounted in the browser window.\nIf this component were to re-r ender, however, the default behavior of useEffect would cause the\ncleanup function to run and a new timer to be created with each render, as shown in Listing 11-5.",
    "timer will continue to increment and log a higher number each second for as long as the component is\nmounted in the browser window.\nIf this component were to re-r ender, however, the default behavior of useEffect would cause the\ncleanup function to run and a new timer to be created with each render, as shown in Listing 11-5.\nLISTING 11- 5: Creating a new timer with each render\nimport {useEffect,useState} from 'react';\nfunction TimerRestartFun(props){\nconst [count,setCount] = useState(0);\nThe Built-i n Hooks ❘ 267\nuseEffect(() => {\nlet time = 0;\nconst interval = setInterval(() => {\nconsole.log(time++);\n}, 1000);\nreturn () => clearInterval(interval);\n});\nreturn (\n<p>Check the console to see the timer.\n<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>\n</p>\n);\n}\nexport default TimerRestartFun;\nEach time you click the button in the preceding example component, the state changes and the return",
    "useEffect(() => {\nlet time = 0;\nconst interval = setInterval(() => {\nconsole.log(time++);\n}, 1000);\nreturn () => clearInterval(interval);\n});\nreturn (\n<p>Check the console to see the timer.\n<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>\n</p>\n);\n}\nexport default TimerRestartFun;\nEach time you click the button in the preceding example component, the state changes and the return\nvalue changes, which causes the component to render, which causes a new timer to start, as shown in\nFigure 11-3.\nFIGURE 11- 3: Starting a new timer with each render\nBut what if you want to create a game that runs a timer to test how quickly you can click the button?\nOne way to do this would be to only start the timer after the component first mounts, rather than\nafter every render. The way to do this with useEffect is to pass it an empty array as the second argu-\nment, as shown in Listing 11-6.\n268 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11- 6: Passing an empty array to only run useEffect on mount",
    "One way to do this would be to only start the timer after the component first mounts, rather than\nafter every render. The way to do this with useEffect is to pass it an empty array as the second argu-\nment, as shown in Listing 11-6.\n268 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11- 6: Passing an empty array to only run useEffect on mount\nimport {useEffect,useState} from 'react';\nfunction TimerOnceFun(props){\nconst [count,setCount] = useState(0);\nuseEffect(() => {\nlet time = 0;\nconst interval = setInterval(() => {\nconsole.log(time++);\nif(time===10){\nconsole.log(`time's up!`);\nclearInterval(interval);\n}\n}, 1000);\nreturn () => clearInterval(interval);\n},[]);\nreturn (<p>Check the console to see the timer.\n<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>\n</p>);\n}\nexport default TimerOnceFun;\nWith the effect only running when the component mounts, the render caused by incrementing the\ncount variable no longer creates a new timer, as shown in Figure 11-4.",
    "clearInterval(interval);\n}\n}, 1000);\nreturn () => clearInterval(interval);\n},[]);\nreturn (<p>Check the console to see the timer.\n<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>\n</p>);\n}\nexport default TimerOnceFun;\nWith the effect only running when the component mounts, the render caused by incrementing the\ncount variable no longer creates a new timer, as shown in Figure 11-4.\nFIGURE 11- 4: Running an effect only after mounting\nThe Built-i n Hooks ❘ 269\nPassing an empty array as the second argument of useEffect causes it to simulate the behavior of\nthe componentDidMount() lifecycle method, and makes it a good place to put fetch requests for\ndata that won’t change during the life of the component, for example. The empty dependency array\nworks because the dependency array’s job is to say, “run the function when one of these values has\nchanged.” If there are no values in the dependency array, the effect only runs when it’s first created.",
    "the componentDidMount() lifecycle method, and makes it a good place to put fetch requests for\ndata that won’t change during the life of the component, for example. The empty dependency array\nworks because the dependency array’s job is to say, “run the function when one of these values has\nchanged.” If there are no values in the dependency array, the effect only runs when it’s first created.\nBut, what if you wanted to change the game so that the timer could be restarted when the user wants,\nor when the count gets up to a certain number, for example? What you need is to conditionally run\nuseEffect. To do this, you can make useEffect depend on one or more values that will determine\nwhen it runs, as shown in Listing 11-7.\nLISTING 11- 7: Specifying useEffect’s dependencies\nimport {useEffect,useState} from 'react';\nfunction TimerConditionalFun(props){\nconst [count,setCount] = useState(0);\nconst [gameNumber,setGameNumber] = useState(0);\nuseEffect(() => {\nlet time = 0;",
    "useEffect. To do this, you can make useEffect depend on one or more values that will determine\nwhen it runs, as shown in Listing 11-7.\nLISTING 11- 7: Specifying useEffect’s dependencies\nimport {useEffect,useState} from 'react';\nfunction TimerConditionalFun(props){\nconst [count,setCount] = useState(0);\nconst [gameNumber,setGameNumber] = useState(0);\nuseEffect(() => {\nlet time = 0;\nconst interval = setInterval(() => {\nconsole.log(time++);\nif(time===10){\nconsole.log(`time's up!`);\nclearInterval(interval);\n}\n}, 1000);\nreturn () => clearInterval(interval);\n},[gameNumber]);\nreturn (\n<>\n<h1>Game Number {gameNumber}</h1>\n<p>Click as fast as you can!\n<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>\n</p>\n<p>\n<button onClick={()=>setGameNumber((prev)=>prev+1)}>New Game</button>\n</p>\n</>\n);\n}\nexport default TimerConditionalFun;\nWhen the component in Listing 11-7 mounts, the timer will start, and it will only be restarted when\nthe value of gameNumber changes.",
    "<>\n<h1>Game Number {gameNumber}</h1>\n<p>Click as fast as you can!\n<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>\n</p>\n<p>\n<button onClick={()=>setGameNumber((prev)=>prev+1)}>New Game</button>\n</p>\n</>\n);\n}\nexport default TimerConditionalFun;\nWhen the component in Listing 11-7 mounts, the timer will start, and it will only be restarted when\nthe value of gameNumber changes.\n270 ❘ CHAPTER 11 IntroducIng Hooks\nEven when the benefits and results of conditionally running an effect aren’t as apparent as those\nin Listing 11-7, specifying the dependencies of an effect can often be a way to increase the perfor-\nmance of your user interface by eliminating unnecessary renders of components, as you’ll see in the\nnext section.\nRunning Asynchronous Code with useEffect\nBecause useEffect is asynchronous and runs after the component has rendered, it’s the ideal place to\nperform asynchronous tasks such as fetching data. Listing 11-8 shows a postal code lookup compo-",
    "mance of your user interface by eliminating unnecessary renders of components, as you’ll see in the\nnext section.\nRunning Asynchronous Code with useEffect\nBecause useEffect is asynchronous and runs after the component has rendered, it’s the ideal place to\nperform asynchronous tasks such as fetching data. Listing 11-8 shows a postal code lookup compo-\nnent that uses an effect hook to look up the U.S. city and state whenever the ZIP code entered into an\ninput field changes.\nLISTING 11- 8: Asynchronous requests with useEffect\nimport {useEffect, useState} from 'react';\nfunction ShippingAddress(props){\nconst [zipcode,setZipcode] = useState('');\nconst [city,setCity] = useState('');\nconst [state,setState] = useState('');\nconst API_URL = 'https://api.zip-\ncodes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';\nconst API_KEY = 'DEMOAPIKEY';\nconst updateZip = (e)=>{\ne.preventDefault();\nsetZipcode(e.target.zipcode.value);\n}\nuseEffect(()=>{\nif (zipcode){\nconst loadAddressData = async ()=>{",
    "const [zipcode,setZipcode] = useState('');\nconst [city,setCity] = useState('');\nconst [state,setState] = useState('');\nconst API_URL = 'https://api.zip-\ncodes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';\nconst API_KEY = 'DEMOAPIKEY';\nconst updateZip = (e)=>{\ne.preventDefault();\nsetZipcode(e.target.zipcode.value);\n}\nuseEffect(()=>{\nif (zipcode){\nconst loadAddressData = async ()=>{\nconst response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);\nconst data = await response.json();\nsetCity(data.City);\nsetState(data.State);\n}\nloadAddressData();\n}\n},[zipcode]);\nreturn (\n<form onSubmit={updateZip}>\nZipcode: <input type=\"text\" name=\"zipcode\" />\n<button type=\"submit\">Lookup City/State</button><br />\nCity: {city}<br />\nState: {state}<br />\nThe Built-i n Hooks ❘ 271\n</form>\n)\n}\nexport default ShippingAddress;\nThe result of running the component in Listing 11-8 is shown in Figure 11-5.\nFIGURE 11- 5: Performing an asynchronous request using useEffect",
    "return (\n<form onSubmit={updateZip}>\nZipcode: <input type=\"text\" name=\"zipcode\" />\n<button type=\"submit\">Lookup City/State</button><br />\nCity: {city}<br />\nState: {state}<br />\nThe Built-i n Hooks ❘ 271\n</form>\n)\n}\nexport default ShippingAddress;\nThe result of running the component in Listing 11-8 is shown in Figure 11-5.\nFIGURE 11- 5: Performing an asynchronous request using useEffect\nThis example uses a number of the techniques that you’ve learned about in the last couple of\nchapters, plus a couple of new ones, so let’s take a walk through the code step by step:\n1. On its initial render, the zipcode, city, and state variables are set to empty strings. The\nuseEffect hook runs, but the conditional statement that checks whether zipcode has a\nvalue that evaluates to a Boolean true prevents the inner function, loadAddress(), from\nbeing created or running.\n2. The user can enter text into an uncontrolled input. Because the input is uncontrolled, it",
    "1. On its initial render, the zipcode, city, and state variables are set to empty strings. The\nuseEffect hook runs, but the conditional statement that checks whether zipcode has a\nvalue that evaluates to a Boolean true prevents the inner function, loadAddress(), from\nbeing created or running.\n2. The user can enter text into an uncontrolled input. Because the input is uncontrolled, it\ndoesn’t cause the UI to render and useEffect doesn’t run. If this input were controlled, the\neffect would run on each keystroke because the value of zipcode would be changing.\n3. When the user clicks the button, the zipcode state variable is set by the\nupdateZip() function.\n4. The change to the zipcode variable causes a render. Because zipcode is listed as a depend-\nency for the useEffect hook, the effect runs.\n272 ❘ CHAPTER 11 IntroducIng Hooks\n5. This time, zipcode has a value that evaluates to true, so the inner function is created and\nthen runs.",
    "3. When the user clicks the button, the zipcode state variable is set by the\nupdateZip() function.\n4. The change to the zipcode variable causes a render. Because zipcode is listed as a depend-\nency for the useEffect hook, the effect runs.\n272 ❘ CHAPTER 11 IntroducIng Hooks\n5. This time, zipcode has a value that evaluates to true, so the inner function is created and\nthen runs.\n6. The loadAddress() function is an async function. Using the async keyword before the\nfunction definition allows the function to use the await statement to perform asynchro-\nnous tasks. In the case of this function, it will call the fetch command and then wait for\na response. When a response is received, the json() command reads the response into an\nobject named data.\n7. The data from the API is used to set the values of the city and state stateful variables. This\ncauses another render of the component. The zipcode hasn’t changed, so the useEffect\nhook won’t run.",
    "nous tasks. In the case of this function, it will call the fetch command and then wait for\na response. When a response is received, the json() command reads the response into an\nobject named data.\n7. The data from the API is used to set the values of the city and state stateful variables. This\ncauses another render of the component. The zipcode hasn’t changed, so the useEffect\nhook won’t run.\nThis component illustrates how to use effect dependencies to eliminate unnecessary renders, which\nare one of the most common types of performance problems in React components. It’s possible that\nthis component would still function without the dependency array, but it would make many unnec-\nessary API requests, which would slow down your component (at the least) and possibly cost you\nmoney if the API charges you for requests.\nSubscribing to Global Data with useContext\nGlobal data is data that’s used by all or many components in a program, such as a theme or user pref-",
    "this component would still function without the dependency array, but it would make many unnec-\nessary API requests, which would slow down your component (at the least) and possibly cost you\nmoney if the API charges you for requests.\nSubscribing to Global Data with useContext\nGlobal data is data that’s used by all or many components in a program, such as a theme or user pref-\nerences. It can be a hassle to have to pass global data from parent components to child components\nfor every component in an React app—e specially when your component tree has multiple levels.\nReact Context provides a way to share global data between components without having to manually\npass values as props. The useContext hook accepts a Context object as its argument and returns the\nmost recent value of that object.\nNOTE Chapter 17 covers the React Context API in detail, along with when and\nexactly how to use it.\nOne example of global data that can be passed to child components using Context is a style",
    "pass values as props. The useContext hook accepts a Context object as its argument and returns the\nmost recent value of that object.\nNOTE Chapter 17 covers the React Context API in detail, along with when and\nexactly how to use it.\nOne example of global data that can be passed to child components using Context is a style\ntheme. A theme refers to styles that are used by multiple components to give them a common look\nwithin an app.\nListing 11-9 shows an example of using the useContext hook in the child component to subscribe to\na Context object.\nLISTING 11- 9: Using Context with the useContext hook\nimport { ThemeContext } from './theme-c ontext'\nfunction App() {\nconst { theme } = React.useContext(ThemeContext)\nThe Built-i n Hooks ❘ 273\nreturn (\n<>\n<header\nclassName=\"App- header\"\nstyle={{ backgroundColor: theme.backgroundColor, color: theme.color }}\n>\n<h1>Welcome to my app.</h1>\n</header>\n</>\n)\n}\nexport default App;\nCombining Logic and State with useReducer",
    "import { ThemeContext } from './theme-c ontext'\nfunction App() {\nconst { theme } = React.useContext(ThemeContext)\nThe Built-i n Hooks ❘ 273\nreturn (\n<>\n<header\nclassName=\"App- header\"\nstyle={{ backgroundColor: theme.backgroundColor, color: theme.color }}\n>\n<h1>Welcome to my app.</h1>\n</header>\n</>\n)\n}\nexport default App;\nCombining Logic and State with useReducer\nThe useReducer hook is an alternative to useState that’s useful for complex state updates or situa-\ntions where the new state depends on the previous state. Whereas useState takes just an initial state\nas its argument, useReducer takes an initial state and a reducer as its arguments. A reducer is a pure\nfunction that takes the current state and an object called an action and returns the new state. In other\nwords, here’s the signature of a reducer function:\n(state, action) => newState\nThe useReducer hook returns a value and a dispatch function. A dispatch function can be used",
    "as its argument, useReducer takes an initial state and a reducer as its arguments. A reducer is a pure\nfunction that takes the current state and an object called an action and returns the new state. In other\nwords, here’s the signature of a reducer function:\n(state, action) => newState\nThe useReducer hook returns a value and a dispatch function. A dispatch function can be used\nin response to events, but instead of taking a value to set the stateful variable to, it takes an action\nobject. An action object has a type and an optional payload.\nUsing reducers is quite a bit more complicated than simple state updates, but once you see some\nexamples, they become much clearer. Listing 11-10 shows our old friend the Counter component, but\nrewritten to use a reducer.\nLISTING 11- 10: A Counter with useReducer\nimport {useReducer} from 'react';\nconst initialState = {count: 0};\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'increment':\nreturn {count: state.count + 1};",
    "examples, they become much clearer. Listing 11-10 shows our old friend the Counter component, but\nrewritten to use a reducer.\nLISTING 11- 10: A Counter with useReducer\nimport {useReducer} from 'react';\nconst initialState = {count: 0};\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'increment':\nreturn {count: state.count + 1};\ncase 'decrement':\nreturn {count: state.count - 1};\ndefault:\nthrow new Error();\n}\n}\nfunction Counter() {\nconst [state, dispatch] = useReducer(reducer, initialState);\ncontinues\n274 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 1-10 (continued)\nreturn (\n<>\nCount: {state.count}\n<button onClick={() => dispatch({type: 'decrement'})}>-< /button>\n<button onClick={() => dispatch({type: 'increment'})}>+</button>\n</>\n);\n}\nexport default Counter;\nIn Listing 11-10, the action only has a type property. But, if you wanted to have a more advanced\ncounter, you could add a payload that could be used to indicate how much to increment or decrement",
    "return (\n<>\nCount: {state.count}\n<button onClick={() => dispatch({type: 'decrement'})}>-< /button>\n<button onClick={() => dispatch({type: 'increment'})}>+</button>\n</>\n);\n}\nexport default Counter;\nIn Listing 11-10, the action only has a type property. But, if you wanted to have a more advanced\ncounter, you could add a payload that could be used to indicate how much to increment or decrement\nthe counter by, as shown in Listing 11-11.\nLISTING 11- 11: Passing a payload to a reducer\nimport {useReducer} from 'react';\nconst initialState = {count: 0};\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'increment':\nreturn {count: state.count + action.payload};\ncase 'decrement':\nreturn {count: state.count - action.payload};\ndefault:\nthrow new Error();\n}\n}\nfunction Counter() {\nconst [state, dispatch] = useReducer(reducer, initialState);\nreturn (\n<>\nCount: {state.count}\n<button onClick={() => dispatch({type: 'decrement', payload:4})}>- 4</\nbutton>",
    "switch (action.type) {\ncase 'increment':\nreturn {count: state.count + action.payload};\ncase 'decrement':\nreturn {count: state.count - action.payload};\ndefault:\nthrow new Error();\n}\n}\nfunction Counter() {\nconst [state, dispatch] = useReducer(reducer, initialState);\nreturn (\n<>\nCount: {state.count}\n<button onClick={() => dispatch({type: 'decrement', payload:4})}>- 4</\nbutton>\n<button onClick={() => dispatch({type: 'increment', payload:4})}>+4</\nbutton>\n</>\n);\n}\nexport default Counter;\nThe Built-i n Hooks ❘ 275\nMemoized Callbacks with useCallback\nFunctions that you define in components are normally re- created with each render. This is\nnot usually a problem. However, sometimes you do need to (or should for performance reasons)\nreturn a memoized version of a function to keep it available between renderings. This is where\nuseCallback comes in.\nListing 11-12 shows the most common use case for useCallback. In this example, the useEffect",
    "Functions that you define in components are normally re- created with each render. This is\nnot usually a problem. However, sometimes you do need to (or should for performance reasons)\nreturn a memoized version of a function to keep it available between renderings. This is where\nuseCallback comes in.\nListing 11-12 shows the most common use case for useCallback. In this example, the useEffect\nhook should call a function passed into it (which we call a callback function) when the value of\nthe phoneNumber variable changes. The useEffect hook has two dependencies—t he function and\nthe variable.\nBecause callback functions are re-c reated on each render, the effect in this example will still call its\ninternal function each time the component renders.\nListing 11- 12 Function dependencies cause unnecessary renders\nimport {useEffect,useState,useRef} from 'react';\nfunction CallMe(props){\nconst [phoneNumber,setPhoneNumber] = useState();\nconst [currentNumber,setCurrentNumber] = useState();",
    "Because callback functions are re-c reated on each render, the effect in this example will still call its\ninternal function each time the component renders.\nListing 11- 12 Function dependencies cause unnecessary renders\nimport {useEffect,useState,useRef} from 'react';\nfunction CallMe(props){\nconst [phoneNumber,setPhoneNumber] = useState();\nconst [currentNumber,setCurrentNumber] = useState();\nconst phoneInputRef = useRef();\nconst handleClick = (e)=>{\nsetPhoneNumber(currentNumber);\n}\nconst placeCall = () => {\nif(currentNumber){\nconsole.log(`dialing ${currentNumber}`);\n}\n};\nuseEffect(() => {\nplaceCall(phoneNumber);\n},[phoneNumber,placeCall]);\nreturn(\n<>\n<label>Enter the number to call:</label>\n<input type=\"phone\" ref={phoneInputRef}\nonChange={()=>{setCurrentNumber(phoneInputRef.current.value)}}/>\n<button onClick={handleClick}>\nPlace Call\n</button>\ncontinues\n276 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11-12 (continued)\n<h1>{currentNumber}</h1>\n</>\n);\n}\nexport default CallMe;",
    "placeCall(phoneNumber);\n},[phoneNumber,placeCall]);\nreturn(\n<>\n<label>Enter the number to call:</label>\n<input type=\"phone\" ref={phoneInputRef}\nonChange={()=>{setCurrentNumber(phoneInputRef.current.value)}}/>\n<button onClick={handleClick}>\nPlace Call\n</button>\ncontinues\n276 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11-12 (continued)\n<h1>{currentNumber}</h1>\n</>\n);\n}\nexport default CallMe;\nIf you try to run the preceding component using Create React App, you’ll get a warning in the con-\nsole, as shown in Figure 11-6.\nFIGURE 11- 6: Unnecessary renders warning due to a function dependency\nWhen you type into the input field, you’ll see that the placeCall() function is called each time the\ncomponent renders, which happens every time you type a character.\nAs the warning message tells you, there are two solutions to this problem. The first is to just define\nthe placeCall() function inside of the useEffect hook and then remove it from the dependencies\nlist, like this:\nuseEffect(() => {",
    "When you type into the input field, you’ll see that the placeCall() function is called each time the\ncomponent renders, which happens every time you type a character.\nAs the warning message tells you, there are two solutions to this problem. The first is to just define\nthe placeCall() function inside of the useEffect hook and then remove it from the dependencies\nlist, like this:\nuseEffect(() => {\nconst placeCall = () => {\nif(phoneNumber){\nconsole.log(`dialing ${phoneNumber}`);\n}\n};\nThe Built-i n Hooks ❘ 277\nplaceCall(phoneNumber);\n},[phoneNumber]);\nThe other solution, which is the correct one if you’re going to use the placeCall() function in more\nthan one place, is to memoize the callback function using useCallback, like this:\nconst placeCall = useCallback(() => {\nif(phoneNumber){\nconsole.log(`dialing ${phoneNumber}`);\n}\n},[phoneNumber]);\nThe useCallback hook creates a persistent version of the function that will only be re- created when",
    "The other solution, which is the correct one if you’re going to use the placeCall() function in more\nthan one place, is to memoize the callback function using useCallback, like this:\nconst placeCall = useCallback(() => {\nif(phoneNumber){\nconsole.log(`dialing ${phoneNumber}`);\n}\n},[phoneNumber]);\nThe useCallback hook creates a persistent version of the function that will only be re- created when\nthe phoneNumber variable changes. With this change, the useEffect hook will behave the way you\nwant it to—o nly calling the inner function when the value of phoneNumber changes— as shown in\nListing 11-13.\nLISTING 11- 13: Memoized callbacks fix the unnecessary effect problem\nimport {useEffect,useState,useRef,useCallback} from 'react';\nfunction CallMe(props){\nconst [phoneNumber,setPhoneNumber] = useState();\nconst [currentNumber,setCurrentNumber] = useState();\nconst phoneInputRef = useRef();\nconst handleClick = (e)=>{\nsetPhoneNumber(currentNumber);\n}\nconst placeCall = useCallback(() => {",
    "LISTING 11- 13: Memoized callbacks fix the unnecessary effect problem\nimport {useEffect,useState,useRef,useCallback} from 'react';\nfunction CallMe(props){\nconst [phoneNumber,setPhoneNumber] = useState();\nconst [currentNumber,setCurrentNumber] = useState();\nconst phoneInputRef = useRef();\nconst handleClick = (e)=>{\nsetPhoneNumber(currentNumber);\n}\nconst placeCall = useCallback(() => {\nif(phoneNumber){\nconsole.log(`dialing ${phoneNumber}`);\n}\n},[phoneNumber]);\nuseEffect(() => {\nplaceCall(phoneNumber);\n},[phoneNumber,placeCall]);\nreturn(\n<>\n<label>Enter the number to call:</label>\n<input type=\"phone\"\nref={phoneInputRef}\nonChange={()=>{setCurrentNumber(phoneInputRef.current.value)}}\n/>\n<button onClick={handleClick}>\nPlace Call\ncontinues\n278 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11-13 (continued)\n</button>\n<h1>{currentNumber}</h1>\n</>\n);\n}\nexport default CallMe;\nCaching Computed Values with useMemo",
    "return(\n<>\n<label>Enter the number to call:</label>\n<input type=\"phone\"\nref={phoneInputRef}\nonChange={()=>{setCurrentNumber(phoneInputRef.current.value)}}\n/>\n<button onClick={handleClick}>\nPlace Call\ncontinues\n278 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11-13 (continued)\n</button>\n<h1>{currentNumber}</h1>\n</>\n);\n}\nexport default CallMe;\nCaching Computed Values with useMemo\nThe useMemo hook memoizes (caches) values between renderings of a function component. It works\nthe same way as useCallback, except that it can cache any value type, not just functions.\nAs with useCallback, there are two reason to use useMemo:\n➤➤ To solve problems with unnecessary renders.\n➤➤ To solve performance problems related to computationally expensive calculations.\nSolving Unnecessary Renders\nI covered the first case already in the “Memoized Callbacks with useCallback” section. The issue\ncomes up when you have an object, array, or function serve as a dependency for a function that",
    "➤➤ To solve problems with unnecessary renders.\n➤➤ To solve performance problems related to computationally expensive calculations.\nSolving Unnecessary Renders\nI covered the first case already in the “Memoized Callbacks with useCallback” section. The issue\ncomes up when you have an object, array, or function serve as a dependency for a function that\nshould only be run when its dependencies change.\nIn JavaScript, when you create two objects (or functions, or arrays) with exactly the same properties,\nthe two objects are not equal to each other. You can test this by opening your browser’s JavaScript\nconsole and executing the following expressions:\n{} === {}\n[] === []\n() => {} === () => {}\nIn each case, the result will be false, as shown in Figure 11-7.\nFIGURE 11- 7: Testing referential equality\nThe Built-i n Hooks ❘ 279\nBecause of this, using an object, array, or function in a dependency array will result in the function",
    "console and executing the following expressions:\n{} === {}\n[] === []\n() => {} === () => {}\nIn each case, the result will be false, as shown in Figure 11-7.\nFIGURE 11- 7: Testing referential equality\nThe Built-i n Hooks ❘ 279\nBecause of this, using an object, array, or function in a dependency array will result in the function\nrunning on every render of the function component. Just as useCallback is the solution for callback\nfunctions, useMemo is the solution to unnecessary renders due to object or array dependencies.\nSolving Performance Problems\nNormally, JavaScript (and therefore calculations within React) is very fast. However, in rare cases, or\nwhen you do encounter a performance problem due to a computationally expensive operation,\nuseMemo can be used to solve it.\nFor example, the component in Listing 11-14 generates a chart from a large set of data. By using\nuseMemo to cache the chart, you can prevent it from being regenerated each time the component ren-",
    "when you do encounter a performance problem due to a computationally expensive operation,\nuseMemo can be used to solve it.\nFor example, the component in Listing 11-14 generates a chart from a large set of data. By using\nuseMemo to cache the chart, you can prevent it from being regenerated each time the component ren-\nders. Instead, it will only be generated when the data supplied to it changes.\nLISTING 11- 14: Solving performance problems with useMemo\nimport {useMemo} from 'react';\nimport {chartGenerator} from 'some-c hart- library';\nfunction Chart(props){\nconst giantChart = useMemo(()=>{\nreturn chartGenerator(props.chartData);\n},[props.chartData]);\nreturn {giantChart};\n}\nexport default Chart;\nAccessing Children Imperatively with useRef\nThe useRef hook returns a ref object with a mutable property named current. One use for a ref\nobject is to imperatively access the DOM. When a DOM node that a ref is attached to changes, the",
    "function Chart(props){\nconst giantChart = useMemo(()=>{\nreturn chartGenerator(props.chartData);\n},[props.chartData]);\nreturn {giantChart};\n}\nexport default Chart;\nAccessing Children Imperatively with useRef\nThe useRef hook returns a ref object with a mutable property named current. One use for a ref\nobject is to imperatively access the DOM. When a DOM node that a ref is attached to changes, the\nref object’s current property is updated. Changes to a ref do not cause the component to re- render.\nListing 11-15 shows a component that uses a ref to get the value of an uncontrolled <textarea> in\norder to count the number of words in it.\nLISTING 11- 15: Getting the value of a textarea and counting its words\nimport {useState,useRef} from 'react';\nfunction WordCount(props){\nconst textAreaRef = useRef();\nconst [wordCount,setWordCount] = useState(0);\ncontinues\n280 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11-15 (continued)\nconst countWords = () => {\nconst text = textAreaRef.current.value;",
    "order to count the number of words in it.\nLISTING 11- 15: Getting the value of a textarea and counting its words\nimport {useState,useRef} from 'react';\nfunction WordCount(props){\nconst textAreaRef = useRef();\nconst [wordCount,setWordCount] = useState(0);\ncontinues\n280 ❘ CHAPTER 11 IntroducIng Hooks\nLISTING 11-15 (continued)\nconst countWords = () => {\nconst text = textAreaRef.current.value;\nsetWordCount(text.split(\" \").length);\n}\nreturn (\n<>\n<textarea ref={textAreaRef} /><br />\n<button onClick={countWords}>Count Words</button>\n<p>{wordCount} words.</p>\n</>\n)\n}\nexport default WordCount;\nCustomizing Exposed Values with useImperativeHandle\nThe useImperativeHandle hook lets you create a “handle” or custom name for a value exposed to a\nparent component using a ref. This is useful when using React.forwardRef to forward a ref attrib-\nute from one component to its child.\nFor example, in Listing 11-16, a component called CountingBox is created that contains a",
    "}\nexport default WordCount;\nCustomizing Exposed Values with useImperativeHandle\nThe useImperativeHandle hook lets you create a “handle” or custom name for a value exposed to a\nparent component using a ref. This is useful when using React.forwardRef to forward a ref attrib-\nute from one component to its child.\nFor example, in Listing 11-16, a component called CountingBox is created that contains a\n<textarea>. The ref attribute passed into the CountingBox component will be forwarded and\nattached to the <textarea>. The useImperativeHandle hook is then used to make a new property\nof the ref.current object (called count in this case) available to the parent component.\nLISTING 11- 16: Customizing a value exposed by a ref\nimport {useState,useRef,useImperativeHandle,forwardRef} from 'react';\nconst CountingBox = forwardRef((props, ref) => {\nconst [text,setText] = useState('');\nuseImperativeHandle(ref, () => {\nreturn {count: text.split(\" \").length}\n},[text]);\nreturn (\n<>",
    "of the ref.current object (called count in this case) available to the parent component.\nLISTING 11- 16: Customizing a value exposed by a ref\nimport {useState,useRef,useImperativeHandle,forwardRef} from 'react';\nconst CountingBox = forwardRef((props, ref) => {\nconst [text,setText] = useState('');\nuseImperativeHandle(ref, () => {\nreturn {count: text.split(\" \").length}\n},[text]);\nreturn (\n<>\n<textarea value={text} onChange={(e)=>setText(e.target.value)} />\n</>);\n});\nfunction TextEdit(props){\nconst countingBoxRef = useRef();\nconst [wordCount,setWordCount] = useState(0);\nWriting Custom Hooks ❘ 281\nconst handleClick = (count) => {\nsetWordCount(count)\n}\nreturn (\n<>\n<CountingBox ref={countingBoxRef} /><br />\n<button onClick={()=>handleClick(countingBoxRef.current.count)}>\ncount words\n</button><br />\ncurrent count: {wordCount}<br />\n</>\n)\n}\nexport default TextEdit;\nNOTE Notice that useImperativeHandle has a third argument, which is a",
    "Writing Custom Hooks ❘ 281\nconst handleClick = (count) => {\nsetWordCount(count)\n}\nreturn (\n<>\n<CountingBox ref={countingBoxRef} /><br />\n<button onClick={()=>handleClick(countingBoxRef.current.count)}>\ncount words\n</button><br />\ncurrent count: {wordCount}<br />\n</>\n)\n}\nexport default TextEdit;\nNOTE Notice that useImperativeHandle has a third argument, which is a\ndependency array (similar to that used by useEffect, useCallback, and\nuseMemo). In the current version of React, useImperativeHandle memoizes the\nvalue of the handle, which can be a problem if you’re trying to get an updated\nvalue (as in this case). Specifying a dependency that changes with each render\nsolves the problem.\nThe useImperativeHandle hook is the least important hook to fully understand. In most cases, any-\nthing you want to do using useImperativeHandle can be better done by passing props from parent\ncomponents to child components.\nUpdating the DOM Synchronously with useLayoutEffect",
    "value (as in this case). Specifying a dependency that changes with each render\nsolves the problem.\nThe useImperativeHandle hook is the least important hook to fully understand. In most cases, any-\nthing you want to do using useImperativeHandle can be better done by passing props from parent\ncomponents to child components.\nUpdating the DOM Synchronously with useLayoutEffect\nThe useLayoutEffect hook is identical to useEffect in every way, except in when and how it exe-\ncutes. Whereas useEffect runs its functions asynchronously (that is, without blocking anything else)\nafter the component appears in the browser, useLayoutEffect runs its function before the DOM is\npainted to the browser, and it runs synchronously.\nThe useLayoutEffect hook can be used in cases where an effect results in changes to the DOM and\nwhere the useEffect hook may cause flicker or inconsistent display of the results.\nWRITING CUSTOM HOOKS",
    "after the component appears in the browser, useLayoutEffect runs its function before the DOM is\npainted to the browser, and it runs synchronously.\nThe useLayoutEffect hook can be used in cases where an effect results in changes to the DOM and\nwhere the useEffect hook may cause flicker or inconsistent display of the results.\nWRITING CUSTOM HOOKS\nCustom hooks are functions that make use of the built- in hooks to encapsulate reusable functional-\nity. Many different custom hooks have been written and are available for free on the web, either by\nthemselves as standalone components, or as features within React libraries. You can also write your\nown custom hooks.\n282 ❘ CHAPTER 11 IntroducIng Hooks\nCustom hooks, like the built-i n hooks, have names that start with use. This is a helpful convention\nrather than a requirement. To write a custom hook, write a function that uses at least one built- in\nhook and export a value from the function.",
    "themselves as standalone components, or as features within React libraries. You can also write your\nown custom hooks.\n282 ❘ CHAPTER 11 IntroducIng Hooks\nCustom hooks, like the built-i n hooks, have names that start with use. This is a helpful convention\nrather than a requirement. To write a custom hook, write a function that uses at least one built- in\nhook and export a value from the function.\nListing 11-17 shows a custom hook based on the zipcode lookup component from earlier in this\nchapter. When imported into a component, useZipLookup will take a zipcode as its argument and\nreturn an array containing the corresponding city and state.\nLISTING 11- 17: useZipLookup: a custom hook to return location data based on a ZIP code\nimport {useEffect,useState} from 'react';\nfunction useZipLookup(zipcode){\nconst [city,setCity] = useState('');\nconst [state,setState] = useState('');\nconst API_URL = 'https://api.zip-\ncodes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';",
    "return an array containing the corresponding city and state.\nLISTING 11- 17: useZipLookup: a custom hook to return location data based on a ZIP code\nimport {useEffect,useState} from 'react';\nfunction useZipLookup(zipcode){\nconst [city,setCity] = useState('');\nconst [state,setState] = useState('');\nconst API_URL = 'https://api.zip-\ncodes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';\nconst API_KEY = 'DEMOAPIKEY';\nuseEffect(()=>{\nif (zipcode){\nconst loadAddressData = async ()=>{\nconst response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);\nconst data = await response.json();\nsetCity(data.City);\nsetState(data.State);\n}\nloadAddressData();\n}\n},[zipcode]);\nreturn [city,state];\n}\nexport default useZipLookup;\nTo use the useZipLookup hook, import it into a component, pass it a ZIP code, and deconstruct the\nreturned array into two local variables, as shown in Listing 11-18.\nLISTING 11- 18: Using the useZipLookup custom hook\nimport {useRef,useState} from 'react';",
    "setCity(data.City);\nsetState(data.State);\n}\nloadAddressData();\n}\n},[zipcode]);\nreturn [city,state];\n}\nexport default useZipLookup;\nTo use the useZipLookup hook, import it into a component, pass it a ZIP code, and deconstruct the\nreturned array into two local variables, as shown in Listing 11-18.\nLISTING 11- 18: Using the useZipLookup custom hook\nimport {useRef,useState} from 'react';\nimport useZipLookup from './useZipLookup';\nfunction ShippingAddress2(props){\nconst [zipcode,setZipcode] = useState('');\nconst [city,state] = useZipLookup(zipcode);\nLabeling Custom Hooks with useDebugValue ❘ 283\nconst setZip = (e)=>{\ne.preventDefault();\nsetZipcode(e.target.zipcode.value);\n}\nreturn (\n<form onSubmit={setZip}>\nZipcode: <input type=\"text\" name=\"zipcode\" />\n<button type=\"submit\">Lookup City/State</button><br />\nCity: {city}<br />\nState: {state}<br />\n</form>\n)\n}\nexport default ShippingAddress2;\nBy creating the useZipLookup custom hook, we’ve made this functionality reusable and we simplified",
    "const setZip = (e)=>{\ne.preventDefault();\nsetZipcode(e.target.zipcode.value);\n}\nreturn (\n<form onSubmit={setZip}>\nZipcode: <input type=\"text\" name=\"zipcode\" />\n<button type=\"submit\">Lookup City/State</button><br />\nCity: {city}<br />\nState: {state}<br />\n</form>\n)\n}\nexport default ShippingAddress2;\nBy creating the useZipLookup custom hook, we’ve made this functionality reusable and we simplified\nthe component that outputs the user interface.\nLABELING CUSTOM HOOKS WITH USEDEBUGVALUE\nWhen you use a custom hook, it shows up in the React Developer Tools as a hook when you inspect a\ncomponent, as shown in Figure 11-8.\nFIGURE 11- 8: Inspecting a custom hook\nIt can be helpful for debugging in some cases to output a value from a custom hook. Normally, the\ntime- honored practice of JavaScript developers everywhere is to use console.log to output debug-\nging code to the console. However simple this may be, it doesn’t provide any context as to what\n284 ❘ CHAPTER 11 IntroducIng Hooks",
    "FIGURE 11- 8: Inspecting a custom hook\nIt can be helpful for debugging in some cases to output a value from a custom hook. Normally, the\ntime- honored practice of JavaScript developers everywhere is to use console.log to output debug-\nging code to the console. However simple this may be, it doesn’t provide any context as to what\n284 ❘ CHAPTER 11 IntroducIng Hooks\nfunction wrote the log message, unless you add that information into the console.log message.\nLogged messages tend to build up in your code over time, unless you’re careful about removing them\nwhen you no longer need them. But, when you remove them, you often end up adding them again\nwhen you’re debugging something related. Logging to the console, while essential sometimes, is less\nthan ideal.\nThe useDebugValue hook lets you export a value from a custom hook that will be visible next to the\nname of the hook in the React Developer Tools component inspector. This value can be anything you",
    "when you’re debugging something related. Logging to the console, while essential sometimes, is less\nthan ideal.\nThe useDebugValue hook lets you export a value from a custom hook that will be visible next to the\nname of the hook in the React Developer Tools component inspector. This value can be anything you\nwant. Listing 11-19 shows how to use useDebugValue in the useZipLookup component to display\nthe value of the zipcode parameter passed into it.\nLISTING 11- 19: Using useDebugValue\nimport {useEffect,useState,useDebugValue} from 'react';\nfunction useZipLookup(zipcode){\nconst [city,setCity] = useState('');\nconst [state,setState] = useState('');\nuseDebugValue(zipcode);\nconst API_URL = 'https://api.zip-\ncodes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';\nconst API_KEY = 'DEMOAPIKEY';\nuseEffect(()=>{\nif (zipcode){\nconst loadAddressData = async ()=>{\nconst response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);\nconst data = await response.json();\nsetCity(data.City);",
    "const [state,setState] = useState('');\nuseDebugValue(zipcode);\nconst API_URL = 'https://api.zip-\ncodes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';\nconst API_KEY = 'DEMOAPIKEY';\nuseEffect(()=>{\nif (zipcode){\nconst loadAddressData = async ()=>{\nconst response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);\nconst data = await response.json();\nsetCity(data.City);\nsetState(data.State);\n}\nloadAddressData();\n}\n},[zipcode]);\nreturn [city,state];\n}\nexport default useZipLookup;\nFigure 11-9 shows how the value from useDebugValue displays in the component inspector.\nThe useDebugValue hook can also optionally accept a formatting function as its second parameter.\nThis function receives the debug value and can be used for doing conversions or other formatting to\nthe debug value. The function only runs when the hook is actually being inspected.\nFinding and Using Custom Hooks ❘ 285\nFIGURE 11- 9: Viewing a Custom Hook’s debug value",
    "The useDebugValue hook can also optionally accept a formatting function as its second parameter.\nThis function receives the debug value and can be used for doing conversions or other formatting to\nthe debug value. The function only runs when the hook is actually being inspected.\nFinding and Using Custom Hooks ❘ 285\nFIGURE 11- 9: Viewing a Custom Hook’s debug value\nOne example of where using the formatting function is helpful would be a case where a date is stored\nas a UNIX timestamp, but you want to be able to view it in the component inspector in a human-\nreadable form. By using the formatting function, you can avoid doing the conversion except when the\nhook is actually being inspected. Here’s what that might look like, using a function from the moment\n.js date library:\nuseDebugValue(timestamp, timestamp=>timestamp.format(\"HH/mm/ss\"));\nFINDING AND USING CUSTOM HOOKS\nCustom hooks deliver on React’s promise of a simple way for developers to share reusable compo-",
    "hook is actually being inspected. Here’s what that might look like, using a function from the moment\n.js date library:\nuseDebugValue(timestamp, timestamp=>timestamp.format(\"HH/mm/ss\"));\nFINDING AND USING CUSTOM HOOKS\nCustom hooks deliver on React’s promise of a simple way for developers to share reusable compo-\nnents. Thousands of custom hooks have been created for just about any common functionality that a\ndeveloper might need.\nUnfortunately, finding out which custom hooks are available isn’t always easy, and this is complicated\nby hooks that have the same purpose and name but are part of different Node.js packages and have\ndifferent APIs. Here are a few of the more popular custom hooks that are currently available.\nuse- http\nThe useFetch hook that’s part of the use- http package (https://use- http.com) makes isomor-\nphic HTTP requests. What this means is that it can be used both on the server and in the browser.",
    "by hooks that have the same purpose and name but are part of different Node.js packages and have\ndifferent APIs. Here are a few of the more popular custom hooks that are currently available.\nuse- http\nThe useFetch hook that’s part of the use- http package (https://use- http.com) makes isomor-\nphic HTTP requests. What this means is that it can be used both on the server and in the browser.\nIt features caching, TypeScript support, automatic aborting of pending requests when a component\nunmounts, React Native, GraphQL, and retrying.\n286 ❘ CHAPTER 11 IntroducIng Hooks\nreact- fetch- hook\nReact Fetch Hook’s useFetch hook (https://www.npmjs.com/package/react- fetch- hook) takes\na URL and a response formatter function as parameters and returns a Boolean named isLoading and\nformatted data. In its most basic form, using this hook looks like this:\nconst {isLoading,data} = useFetch(\"http://example-u rl.com/api/users/1\");\naxios- hooks",
    "286 ❘ CHAPTER 11 IntroducIng Hooks\nreact- fetch- hook\nReact Fetch Hook’s useFetch hook (https://www.npmjs.com/package/react- fetch- hook) takes\na URL and a response formatter function as parameters and returns a Boolean named isLoading and\nformatted data. In its most basic form, using this hook looks like this:\nconst {isLoading,data} = useFetch(\"http://example-u rl.com/api/users/1\");\naxios- hooks\nThe useAxios hook (https://www.npmjs.com/package/axios- hooks) executes HTTP requests\nusing the popular Axios library. It takes a URL and an options object as parameters and returns an\nobject containing data, the loading status, and any error message that was returned by the URL. It\nalso returns a function that you can use to manually execute the HTTP request.\nListing 11-20 shows a simple example of using the useAxios hook.\nLISTING 11- 20: Using useAxios\nimport {useState} from 'react';\nimport useAxios from 'axios- hooks';\nimport {API_KEY} from './config';\nfunction WeatherWidget() {",
    "also returns a function that you can use to manually execute the HTTP request.\nListing 11-20 shows a simple example of using the useAxios hook.\nLISTING 11- 20: Using useAxios\nimport {useState} from 'react';\nimport useAxios from 'axios- hooks';\nimport {API_KEY} from './config';\nfunction WeatherWidget() {\nconst [city,setCity] = useState('London');\nconst [{data, loading, error}, refetch] =\nuseAxios(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${API_KEY}`);\nif (loading) return <p>Loading...</p>;\nif (error) return <p>There was an error. {error.message}</p>;\nreturn (\n<>\n<input type=\"text\" value={city} onChange={e=>setCity(e.target.value)} />\n<pre>{JSON.stringify(data,null,2)}</pre>\n</>\n);\n}\nexport default WeatherWidget;\nreact- hook- form\nReact Hook Form’s useForm hook makes building forms and validating data input simple. The\nuseForm hook returns a function called register() that you can pass as a ref to uncontrolled inputs",
    "return (\n<>\n<input type=\"text\" value={city} onChange={e=>setCity(e.target.value)} />\n<pre>{JSON.stringify(data,null,2)}</pre>\n</>\n);\n}\nexport default WeatherWidget;\nreact- hook- form\nReact Hook Form’s useForm hook makes building forms and validating data input simple. The\nuseForm hook returns a function called register() that you can pass as a ref to uncontrolled inputs\nwith name attributes. The handleSubmit() method returned by useForm will then handle all of the\ndata from your form.\nYou can pass options to each register() function to validate fields, make them required, and\nspecify other limits such as minimum and maximum values.\nListing 11-21 shows a basic use of useForm.\nFinding and Using Custom Hooks ❘ 287\nLISTING 11- 21: Using useForm\nimport {useForm} from 'react- hook- form';\nfunction SignUpForm() {\nconst {register, handleSubmit} = useForm();\nconst onSubmit = data => {\nconsole.log(data);\n};\nreturn (\n<form onSubmit = {handleSubmit(onSubmit)}>\n<label>First Name: </label>",
    "Listing 11-21 shows a basic use of useForm.\nFinding and Using Custom Hooks ❘ 287\nLISTING 11- 21: Using useForm\nimport {useForm} from 'react- hook- form';\nfunction SignUpForm() {\nconst {register, handleSubmit} = useForm();\nconst onSubmit = data => {\nconsole.log(data);\n};\nreturn (\n<form onSubmit = {handleSubmit(onSubmit)}>\n<label>First Name: </label>\n<input name=\"firstname\" {...register(\"firstname\",{required:true})} />\n<label>Last Name: </label>\n<input name=\"lastname\" {...register(\"lastname\",{required:true})} />\n<input type=\"submit\" />\n</form>\n);\n}\nexport default SignUpForm;\n@rehooks/local- storage\nThe useLocalStorage hook, which is part of the Rehooks library (https://github.com/rehooks),\nprovides functions for working with the browser’s local storage. Browser local storage is useful for\nstoring data between browser sessions. This is helpful for creating offline apps, for increasing the\nperformance of a web app, and for remembering the user’s state between sessions.",
    "@rehooks/local- storage\nThe useLocalStorage hook, which is part of the Rehooks library (https://github.com/rehooks),\nprovides functions for working with the browser’s local storage. Browser local storage is useful for\nstoring data between browser sessions. This is helpful for creating offline apps, for increasing the\nperformance of a web app, and for remembering the user’s state between sessions.\nAnother feature of useLocalStorage is that it can sync data between browser tabs.\nuse- local- storage- state\nThe useLocalStorageState hook (https://www.npmjs.com/package/use- local- storage-\nstate) takes a key and an optional default value and returns an array with three values: a value, a\nsetter function, and a Boolean named isPersistent. Here’s an example:\nconst [reminders, setReminders, isPersistent] =\nuseLocalState('reminders',['sleep','eat food']);\nThe first two return values work the same as the values returned by useState. The third tells",
    "state) takes a key and an optional default value and returns an array with three values: a value, a\nsetter function, and a Boolean named isPersistent. Here’s an example:\nconst [reminders, setReminders, isPersistent] =\nuseLocalState('reminders',['sleep','eat food']);\nThe first two return values work the same as the values returned by useState. The third tells\nyou whether the value is stored in memory or in local storage. By default, of course, any\nvalue you create using useLocalStorageState will be stored in localStorage. In the event that\nlocalStorage isn’t available for some reason, useLocalStorageState will fall back to just keeping\nthe value in memory.\n288 ❘ CHAPTER 11 IntroducIng Hooks\nOther Fun Hooks\nGoing beyond the basic tasks that are used in most modern user interfaces, other custom hooks\nencapsulate functionality that’s more specialized or even just for fun. Here are a few custom hooks\nthat fall into this category:",
    "localStorage isn’t available for some reason, useLocalStorageState will fall back to just keeping\nthe value in memory.\n288 ❘ CHAPTER 11 IntroducIng Hooks\nOther Fun Hooks\nGoing beyond the basic tasks that are used in most modern user interfaces, other custom hooks\nencapsulate functionality that’s more specialized or even just for fun. Here are a few custom hooks\nthat fall into this category:\n➤➤ The useGeolocation hook (https://github.com/streamich/react- use) tracks a user’s\ngeographic location.\n➤➤ The useNetworkStatus hook (https://github.com/rehooks/network- status) returns\ninformation about a user’s current network status.\n➤➤ The useKonomiCode hook (https://stackblitz.com/edit/use- konami- code) is an eas-\nter egg hook for detecting when a user has entered the famous Konomi Code (↑ ↑ ↓ ↓ ← →\n← → B A), which is used as a cheat code in many video games.\nLists of Hooks\nFinding custom hooks for just about any purpose is becoming easier thanks to some great lists of",
    "information about a user’s current network status.\n➤➤ The useKonomiCode hook (https://stackblitz.com/edit/use- konami- code) is an eas-\nter egg hook for detecting when a user has entered the famous Konomi Code (↑ ↑ ↓ ↓ ← →\n← → B A), which is used as a cheat code in many video games.\nLists of Hooks\nFinding custom hooks for just about any purpose is becoming easier thanks to some great lists of\nhooks being maintained and updated by the React community. Here are a few of the lists of hooks\nthat are currently available:\n➤➤ Hooks.guide (https://hooks- guide.netlify.app/). A curated and categorized\nlist of hooks.\n➤➤ Collection of React Hooks (https://nikgraf.github.io/react- hooks/). A searchable\ncollection of hooks that anyone can add to.\n➤➤ Use Hooks (https://use- hooks.org/). Provides a tool for scaffolding React hooks and a\nlist of hooks created using the scaffolding.\nSUMMARY\nHooks aren’t just a new and better way of doing something in React; they dramatically improve the",
    "list of hooks.\n➤➤ Collection of React Hooks (https://nikgraf.github.io/react- hooks/). A searchable\ncollection of hooks that anyone can add to.\n➤➤ Use Hooks (https://use- hooks.org/). Provides a tool for scaffolding React hooks and a\nlist of hooks created using the scaffolding.\nSUMMARY\nHooks aren’t just a new and better way of doing something in React; they dramatically improve the\nentire React development experience, they make learning React easier, and they solve the problem of\ncreating a standard and simple way to share code between components.\nIn this chapter, you learned:\n➤➤ What React Hooks are.\n➤➤ Why React Hooks were created.\n➤➤ How to use each of the built-i n hooks.\n➤➤ How to use and create custom hooks.\n➤➤ How to find pre-b uilt custom hooks.\nIn the next chapter you’ll learn how to manage complex user interfaces and applications by associat-\ning URLs with components and layouts using React Router.\n12\nRouting",
    "In this chapter, you learned:\n➤➤ What React Hooks are.\n➤➤ Why React Hooks were created.\n➤➤ How to use each of the built-i n hooks.\n➤➤ How to use and create custom hooks.\n➤➤ How to find pre-b uilt custom hooks.\nIn the next chapter you’ll learn how to manage complex user interfaces and applications by associat-\ning URLs with components and layouts using React Router.\n12\nRouting\nUntil now, every user interface example you’ve seen in this book has only had a single screen\nand everything the application can do is displayed at once. In the real world, apps have multiple\nmodes, tabs, and screens. The ability to change from an app’s main screen to a settings screen,\nfor example, makes it possible for user interfaces to do more while not overwhelming the user\nwith complexity and clutter.\nIn this chapter, you’ll learn:\n➤➤ What routing is and why you need it.\n➤➤ How routing works in single page applications.\n➤➤ How to install and use React Router.\n➤➤ How to create basic routes.",
    "for example, makes it possible for user interfaces to do more while not overwhelming the user\nwith complexity and clutter.\nIn this chapter, you’ll learn:\n➤➤ What routing is and why you need it.\n➤➤ How routing works in single page applications.\n➤➤ How to install and use React Router.\n➤➤ How to create basic routes.\n➤➤ How to create navigation.\n➤➤ How to create nested routes.\n➤➤ How to use React Router’s hooks.\nWHAT IS ROUTING?\nThe most basic concept behind the web (what we call Web 1.0) is that a web browser requests\na web page from a web (HTTP) server using a unique URL. The web server then responds with\nan HTML page that is rendered in the browser, as shown in Figure 12‑1.\nWhen a user clicks a link on a web page, it requests a new HTML page, which the browser\ndownloads and displays instead of the current page. Browsers and servers maintain a user’s\nstate between different web pages by using browser cookies, the localStorage API, and\nserver‑ side data."
  ]
}