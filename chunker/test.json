{
  "content": [
    "222 ❘ CHAPTER 8 Forms\nCONTROLLED INPUTS VS. UNCONTROLLED INPUTS\nThe default behavior of an input element is to allow the user to change its value directly. In one- way\ndata flow, on the other hand, every interaction with the user interface results in an event which, when\nhandled, updates the state. Changes to state then update the user interface.\nReact calls a form input that can be directly manipulated by the user an uncontrolled input, and one\nthat can only be changed through changes to the state object a controlled input.\nFigure 8-1 illustrates the difference between controlled and uncontrolled inputs.\nFIGURE 8- 1: Controlled and uncontrolled inputs\nTo create an uncontrolled input, omit the value attribute from the JSX code for that input, as shown\nin Listing 8-1.\nLISTING 8- 1: Omiting the value attribute creates an uncontrolled input\nfunction SignUp(props){\nreturn(\n<form>\n<input type=\"text\" name=\"emailAddress\" />\n<button>Sign up for our newsletter</button>\n</form>\n)\n}",
    "FIGURE 8- 1: Controlled and uncontrolled inputs\nTo create an uncontrolled input, omit the value attribute from the JSX code for that input, as shown\nin Listing 8-1.\nLISTING 8- 1: Omiting the value attribute creates an uncontrolled input\nfunction SignUp(props){\nreturn(\n<form>\n<input type=\"text\" name=\"emailAddress\" />\n<button>Sign up for our newsletter</button>\n</form>\n)\n}\nexport default SignUp;\nFigure 8-2 shows the result of rendering the preceding component and typing into the input. This is\nexactly the behavior you’d expect with an HTML form.\nControlled Inputs vs. Uncontrolled Inputs ❘ 223\nFIGURE 8- 2: Rendering an uncontrolled input\nTo make this form be controlled, add a value attribute, as shown in Listing 8-2.\nLISTING 8- 2: Adding the value attribute creates a controlled input\nfunction SignUp(props){\nreturn(\n<form>\n<input value=\"\" type=\"text\" name=\"emailAddress\" />\n<button>Sign up for our newsletter</button>\n</form>\n)\n}\nexport default SignUp;",
    "FIGURE 8- 2: Rendering an uncontrolled input\nTo make this form be controlled, add a value attribute, as shown in Listing 8-2.\nLISTING 8- 2: Adding the value attribute creates a controlled input\nfunction SignUp(props){\nreturn(\n<form>\n<input value=\"\" type=\"text\" name=\"emailAddress\" />\n<button>Sign up for our newsletter</button>\n</form>\n)\n}\nexport default SignUp;\nSimply adding the value attribute causes React to “control” the input. Now, when you render the\nSignUp component and try to type into it, nothing will happen. It’s impossible to demonstrate noth-\ning happening in a figure, so if you’d like to see this, you can create a component similar to the one in\nListing 8-2 or download the example code from this book’s GitHub repository.\nUpdating a Controlled Input\nUnless your goal is to create an input that can’t be edited, a controlled input must also have an event\nlistener attribute and an event handler function. Even though the internal state of the input element",
    "Listing 8-2 or download the example code from this book’s GitHub repository.\nUpdating a Controlled Input\nUnless your goal is to create an input that can’t be edited, a controlled input must also have an event\nlistener attribute and an event handler function. Even though the internal state of the input element\nin Listing 8-2 doesn’t change when you type into it, it still fires a change event with every keystroke.\n224 ❘ CHAPTER 8 Forms\nUsing the onChange event listener, you can detect this event and use the target.value property of\nthe Event object to update the state property, which can then be assigned to the value attribute of\nthe input.\nThe process for controlling a controlled input is the same in function and class components, but the\nJavaScript code you need to write in each differs somewhat.\nControlling an Input in a Function Component\nListing 8-3 shows a controlled text input that updates using one- way data flow in a function\ncomponent.",
    "the input.\nThe process for controlling a controlled input is the same in function and class components, but the\nJavaScript code you need to write in each differs somewhat.\nControlling an Input in a Function Component\nListing 8-3 shows a controlled text input that updates using one- way data flow in a function\ncomponent.\nLISTING 8- 3: Updating an input element with one-w ay data flow\nimport {useState} from 'react';\nfunction SignUp(props){\nconst [emailAddress,setEmailAddress] = useState('');\nconst handleChange = (e)=>{\nsetEmailAddress(e.target.value);\n}\nreturn(\n<>\n<form>\n<label>Enter your email address:\n<input value={emailAddress} onChange={handleChange} type=\"text\" />\n</label>\n</form>\n<p>Your email address: {emailAddress}</p>\n</>\n)\n}\nexport default SignUp;\nWhen you run this component in a browser, typing into the input updates the value of the\nemailAddress state variable, which is used as the value of the input and is also output in the para-",
    "}\nreturn(\n<>\n<form>\n<label>Enter your email address:\n<input value={emailAddress} onChange={handleChange} type=\"text\" />\n</label>\n</form>\n<p>Your email address: {emailAddress}</p>\n</>\n)\n}\nexport default SignUp;\nWhen you run this component in a browser, typing into the input updates the value of the\nemailAddress state variable, which is used as the value of the input and is also output in the para-\ngraph below the input. The input behaves like a normal HTML input, but the component also has\naccess to the value of the input.\nControlling an Input in a Class Component\nIn a class component, controlling an input works the same way, but the JavaScript is slightly differ-\nent and a bit more verbose because of the need to write and bind the event handler and to correctly\naddress the state property.\nListing 8-4 shows the same controlled input as Listing 8-3, but written as a class component.\nControlled Inputs vs. Uncontrolled Inputs ❘ 225\nLISTING 8- 4: Controlling an input in a class component",
    "ent and a bit more verbose because of the need to write and bind the event handler and to correctly\naddress the state property.\nListing 8-4 shows the same controlled input as Listing 8-3, but written as a class component.\nControlled Inputs vs. Uncontrolled Inputs ❘ 225\nLISTING 8- 4: Controlling an input in a class component\nimport {Component} from 'react';\nclass SignUp extends Component{\nconstructor(props){\nsuper(props);\nthis.state = {\nemailAddress:''\n}\nthis.handleChange = this.handleChange.bind(this);\n}\nhandleChange(e){\nthis.setState({emailAddress:e.target.value});\n}\nrender(){\nreturn(\n<>\n<form>\n<label>Enter your email address:\n<input value={this.state.emailAddress} onChange={this.handleChange}\ntype=\"text\" />\n</label>\n</form>\n<p>Your email address: {this.state.emailAddress}</p>\n</>\n)\n}\n}\nexport default SignUp;\nThe class component in Listing 8-4 can be written a bit more succinctly by using arrow functions, an",
    "this.setState({emailAddress:e.target.value});\n}\nrender(){\nreturn(\n<>\n<form>\n<label>Enter your email address:\n<input value={this.state.emailAddress} onChange={this.handleChange}\ntype=\"text\" />\n</label>\n</form>\n<p>Your email address: {this.state.emailAddress}</p>\n</>\n)\n}\n}\nexport default SignUp;\nThe class component in Listing 8-4 can be written a bit more succinctly by using arrow functions, an\ninline event handler, and by creating state as a class property, as shown in Listing 8-5.\nLISTING 8- 5: Simplifying a controlled input in a class\nimport {Component} from 'react';\nclass SignUp extends Component{\nstate = {emailAddress:''};\nrender(){\nreturn(\n<>\n<form>\n<label>Enter your email address:\n<input value={this.state.emailAddress}\nonChange={(e)=>{this.setState({emailAddress:e.target.value})}}\ntype=\"text\" />\ncontinues\n226 ❘ CHAPTER 8 Forms\nLISTING 8-5 (continued)\n</label>\n</form>\n<p>Your email address: {this.state.emailAddress}</p>\n</>\n)\n}\n}\nexport default SignUp;\nLIFTING UP INPUT STATE",
    "state = {emailAddress:''};\nrender(){\nreturn(\n<>\n<form>\n<label>Enter your email address:\n<input value={this.state.emailAddress}\nonChange={(e)=>{this.setState({emailAddress:e.target.value})}}\ntype=\"text\" />\ncontinues\n226 ❘ CHAPTER 8 Forms\nLISTING 8-5 (continued)\n</label>\n</form>\n<p>Your email address: {this.state.emailAddress}</p>\n</>\n)\n}\n}\nexport default SignUp;\nLIFTING UP INPUT STATE\nMost of the time, when you have a form in a user interface, input into the form should affect some\nother part of the user interface. For example, words typed into a search form are used to perform a\nsearch, and then the searched-f or words and the search results are presented in some sort of results\ncomponent, as shown in Figure 8-3.\nFIGURE 8- 3: Form input often affects other components\nLifting Up Input State ❘ 227\nBecause the search term entered into the search form in Figure 8-3 needs to be used by other compo-",
    "search, and then the searched-f or words and the search results are presented in some sort of results\ncomponent, as shown in Figure 8-3.\nFIGURE 8- 3: Form input often affects other components\nLifting Up Input State ❘ 227\nBecause the search term entered into the search form in Figure 8-3 needs to be used by other compo-\nnents, the state variable that the search form updates should be lifted up to a common ancestor of the\nsearch form and search results components.\nListings 8-6, 8- 7, and 8-8 show three components that might make up a very basic version of the\nsearch interface from Figure 8-3. Notice that the setSearchTerm function is passed down to the\nSearchInput component and the searchTerm variable is passed down to both the SearchInput and\nSearchResults components.\nLISTING 8- 6: The SearchBox component\nimport {useState} from 'react';\nimport SearchInput from './SearchInput';\nimport SearchResults from './SearchResults';\nfunction SearchBox(){",
    "search interface from Figure 8-3. Notice that the setSearchTerm function is passed down to the\nSearchInput component and the searchTerm variable is passed down to both the SearchInput and\nSearchResults components.\nLISTING 8- 6: The SearchBox component\nimport {useState} from 'react';\nimport SearchInput from './SearchInput';\nimport SearchResults from './SearchResults';\nfunction SearchBox(){\nconst [searchTerm,setSearchTerm] = useState('');\nreturn(\n<>\n<SearchInput searchTerm = {searchTerm} setSearchTerm = {setSearchTerm} />\n<SearchResults searchTerm = {searchTerm}/>\n</>\n);\n}\nexport default SearchBox;\nLISTING 8- 7: The SearchInput component\nfunction SearchInput(props){\nconst handleChange = (e)=>{\nprops.setSearchTerm(e.target.value);\n}\nreturn(\n<label>Enter your search term:\n<input type=\"text\" value={props.searchTerm} onChange={handleChange} />\n</label>\n);\n}\nexport default SearchInput;\nLISTING 8- 8: The SearchResults component\nfunction SearchResults(props){\nreturn(",
    ");\n}\nexport default SearchBox;\nLISTING 8- 7: The SearchInput component\nfunction SearchInput(props){\nconst handleChange = (e)=>{\nprops.setSearchTerm(e.target.value);\n}\nreturn(\n<label>Enter your search term:\n<input type=\"text\" value={props.searchTerm} onChange={handleChange} />\n</label>\n);\n}\nexport default SearchInput;\nLISTING 8- 8: The SearchResults component\nfunction SearchResults(props){\nreturn(\n<p>You're searching for: {props.searchTerm}</p>\ncontinues\n228 ❘ CHAPTER 8 Forms\nLISTING 8-8 (continued)\n);\n}\nexport default SearchResults;\nAs you saw in Chapter 6, lifting state up minimizes the number of components that need to be state-\nful. Having a single stateful component eliminates duplication of data processing and provides the\napplication with a single source of truth. In other words, the behavior of the subcomponents can be\nknown and tested based on how the state changes in the stateful component.\nUSING UNCONTROLLED INPUTS",
    "As you saw in Chapter 6, lifting state up minimizes the number of components that need to be state-\nful. Having a single stateful component eliminates duplication of data processing and provides the\napplication with a single source of truth. In other words, the behavior of the subcomponents can be\nknown and tested based on how the state changes in the stateful component.\nUSING UNCONTROLLED INPUTS\nUsing controlled inputs ensures that your user interface strictly adheres to the pattern of one-w ay\ndata binding, and it enables you to easily work with the current values of your input fields. However,\nit also creates a lot of overhead work that may be unnecessary.\nFor example, a “Contact Us” form within a user interface doesn’t need to store the data entered into\nit or do anything with the data as it’s being entered. Essentially, such a form isn’t really part of the\nlarger application at all, and there’s maybe no reason for React to track and run an event handler",
    "it also creates a lot of overhead work that may be unnecessary.\nFor example, a “Contact Us” form within a user interface doesn’t need to store the data entered into\nit or do anything with the data as it’s being entered. Essentially, such a form isn’t really part of the\nlarger application at all, and there’s maybe no reason for React to track and run an event handler\nfunction for every keystroke that someone enters into a textarea input. Binding each input of a large\nform can be tedious and the additional processing that it takes to listen for and respond to a large\nnumber of form inputs can create performance issues.\nIn cases where you don’t need to track the user’s input as they’re typing and you don’t need to store\nthe input in state, it may be a better choice to use uncontrolled inputs and simply attach an event\nlistener to the form itself to run a function when the form is submitted.\nListing 8-9 shows a comment form, such as you might see on a blog, which uses an uncontrolled",
    "In cases where you don’t need to track the user’s input as they’re typing and you don’t need to store\nthe input in state, it may be a better choice to use uncontrolled inputs and simply attach an event\nlistener to the form itself to run a function when the form is submitted.\nListing 8-9 shows a comment form, such as you might see on a blog, which uses an uncontrolled\ninput. When the user submits the form, an event handler function runs that retrieves the data from\nthe uncontrolled input and adds it to the state.\nLISTING 8- 9: A blog comment interface using an uncontrolled input\nimport {useState,useRef} from 'react';\nfunction BlogComment(props){\nconst [comments,setComments] = useState([]);\nconst textAreaRef = useRef(null);\nconst recordComment = (e)=>{\ne.preventDefault();\nsetComments([...comments,textAreaRef.current.value]);\n}\nconst commentList = comments.map((comment,index)=>{\nreturn (<p key={index}>{comment}</p>);\n})\nreturn(\n<>\nUsing Different Form Elements ❘ 229",
    "import {useState,useRef} from 'react';\nfunction BlogComment(props){\nconst [comments,setComments] = useState([]);\nconst textAreaRef = useRef(null);\nconst recordComment = (e)=>{\ne.preventDefault();\nsetComments([...comments,textAreaRef.current.value]);\n}\nconst commentList = comments.map((comment,index)=>{\nreturn (<p key={index}>{comment}</p>);\n})\nreturn(\n<>\nUsing Different Form Elements ❘ 229\n<form onSubmit={recordComment}>\n<p>Enter your comment:</p>\n<textarea ref={textAreaRef}></textarea><br />\n<button>Submit Comment</button>\n<p>All Comments:</p>\n{commentList}\n</form>\n</>\n);\n}\nexport default BlogComment;\nTo get values from uncontrolled inputs, you can use a technique called a ref. The ref creates a refer-\nence to the underlying DOM node, which allows React to access its properties directly. You’ll learn\nmore about refs and how and when to use them in Chapter 9.\nUSING DIFFERENT FORM ELEMENTS\nHTML input elements are the most commonly used types of interactive elements. By changing the",
    "To get values from uncontrolled inputs, you can use a technique called a ref. The ref creates a refer-\nence to the underlying DOM node, which allows React to access its properties directly. You’ll learn\nmore about refs and how and when to use them in Chapter 9.\nUSING DIFFERENT FORM ELEMENTS\nHTML input elements are the most commonly used types of interactive elements. By changing the\ntype attribute of the input element, you can create inputs for a large and growing number of data\ntypes, including:\n➤➤ button\n➤➤ checkbox\n➤➤ color\n➤➤ date\n➤➤ datetime- local\n➤➤ email\n➤➤ file\n➤➤ hidden\n➤➤ image\n➤➤ month\n➤➤ number\n➤➤ password\n➤➤ radio\n➤➤ range\n➤➤ reset\n➤➤ search\n➤➤ submit\n➤➤ tel\n230 ❘ CHAPTER 8 Forms\n➤➤ text\n➤➤ time\n➤➤ url\n➤➤ week\nThe different input types may look different or have different validation that they perform on user\ninput. For example, the number input type will only allow numbers to be entered, the color input",
    "➤➤ date\n➤➤ datetime- local\n➤➤ email\n➤➤ file\n➤➤ hidden\n➤➤ image\n➤➤ month\n➤➤ number\n➤➤ password\n➤➤ radio\n➤➤ range\n➤➤ reset\n➤➤ search\n➤➤ submit\n➤➤ tel\n230 ❘ CHAPTER 8 Forms\n➤➤ text\n➤➤ time\n➤➤ url\n➤➤ week\nThe different input types may look different or have different validation that they perform on user\ninput. For example, the number input type will only allow numbers to be entered, the color input\ntype will display a color picker (in browsers that support it), and the hidden input type doesn’t dis-\nplay anything in the browser window.\nControlling the Input Element\nWith the exception of the input types that create buttons, and the special case of the file input type,\nthe way to get the value of a controlled input element in React is by using the onChange attribute.\nThe button inputs (submit, reset, and button) use the onClick attribute. The button element,\nwhich does the same thing as an input with a type of button, also uses the onClick attribute.",
    "With the exception of the input types that create buttons, and the special case of the file input type,\nthe way to get the value of a controlled input element in React is by using the onChange attribute.\nThe button inputs (submit, reset, and button) use the onClick attribute. The button element,\nwhich does the same thing as an input with a type of button, also uses the onClick attribute.\nThe file input, which allows you to choose a file from your computer to upload to the browser, is a\nread- only input. In React, an input with the type of file is always uncontrolled.\nControlling a textarea\nIn HTML, a textarea element’s value is its children, as shown in Listing 8-10.\nLISTING 8- 10: An HTML textarea’s value is its children\n<textarea name=\"terms- of- use\">\nMake sure to read all of these terms of use. By reading this book, you agree\nto learn React and to never try to mutate a prop or forget to bind an event\nhandler in a class component. Furthermore, although it is not required, you",
    "In HTML, a textarea element’s value is its children, as shown in Listing 8-10.\nLISTING 8- 10: An HTML textarea’s value is its children\n<textarea name=\"terms- of- use\">\nMake sure to read all of these terms of use. By reading this book, you agree\nto learn React and to never try to mutate a prop or forget to bind an event\nhandler in a class component. Furthermore, although it is not required, you\nagree to consider writing a review of this book and to tell your friends how\ngreat this book is.\n</textarea>\nIn React, a textarea is written more like an input element: as an empty element (meaning it doesn’t\nhave an end tag or content) with a value attribute. You can use the onChange event listener to handle\ninput into a textarea in React, as shown in Listing 8-11.\nLISTING 8- 11: Using a textarea in React\nfunction TermsOfUse(props){\nreturn(\n<textarea value={props.terms} onChange={props.updateTerms} />\n);\n}\nexport default TermsOfUse;\nPreventing Default Actions ❘ 231\nControlling a Select Element",
    "have an end tag or content) with a value attribute. You can use the onChange event listener to handle\ninput into a textarea in React, as shown in Listing 8-11.\nLISTING 8- 11: Using a textarea in React\nfunction TermsOfUse(props){\nreturn(\n<textarea value={props.terms} onChange={props.updateTerms} />\n);\n}\nexport default TermsOfUse;\nPreventing Default Actions ❘ 231\nControlling a Select Element\nA select element in HTML creates a dropdown list, with any number of option element chil-\ndren forming the items in the dropdown list. In HTML, each option element has a Boolean attrib-\nute named selected, which determines the current value of the select element, as shown in\nListing 8-12.\nLISTING 8- 12: A select element in HTML\n<select name=\"pizza- type\">\n<option value=\"thin\">Thin Crust</option>\n<option value=\"thick\">Thick Crust</option>\n<option value=\"deep\">Deep Dish</option>\n<option value=\"detroit\" selected>Detroit-s tyle</option>\n<option value=\"chicago\">Chicago-s tyle</option>\n</select>",
    "Listing 8-12.\nLISTING 8- 12: A select element in HTML\n<select name=\"pizza- type\">\n<option value=\"thin\">Thin Crust</option>\n<option value=\"thick\">Thick Crust</option>\n<option value=\"deep\">Deep Dish</option>\n<option value=\"detroit\" selected>Detroit-s tyle</option>\n<option value=\"chicago\">Chicago-s tyle</option>\n</select>\nIn React, the select element has a value attribute that determines which option is currently\nselected, and the onChange attribute on the select input can be used to detect and handle changes to\nthe currently selected option, as shown in Listing 8-13.\nLISTING 8- 13: Using a select input in React\nfunction SizeSelect(props){\nreturn(\n<select name=\"size\" value={props.size} onChange={props.changeSize}>\n<option value=\"xs\">Extra Small</option>\n<option value=\"sm\">Small</option>\n<option vlue=\"md\">Medium</option>\n<option value=\"lg\">Large</option>\n<option value=\"xl\">Extra Large</option>\n</select>\n);\n}\nexport default SizeSelect;\nPREVENTING DEFAULT ACTIONS",
    "LISTING 8- 13: Using a select input in React\nfunction SizeSelect(props){\nreturn(\n<select name=\"size\" value={props.size} onChange={props.changeSize}>\n<option value=\"xs\">Extra Small</option>\n<option value=\"sm\">Small</option>\n<option vlue=\"md\">Medium</option>\n<option value=\"lg\">Large</option>\n<option value=\"xl\">Extra Large</option>\n</select>\n);\n}\nexport default SizeSelect;\nPREVENTING DEFAULT ACTIONS\nWhen you submit a form in a browser window, the default action that the browser will take is to\nreload the current page, passing the values from the form as a querystring appended to the URL.\nYou can change the default action of the form element by using the action and method attributes\nof the form element. The action attribute changes the URL that the form will submit to, and the\nmethod attribute changes the HTTP method used to submit the form (either using HTTP GET or\nHTTP POST).\n232 ❘ CHAPTER 8 Forms"
  ]
}