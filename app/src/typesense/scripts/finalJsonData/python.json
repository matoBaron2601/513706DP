{
  "content": [
    "Learning Python\n\n\f\fFOURTH EDITION\n\nLearning Python\n\nMark Lutz\n\nBeijing • Cambridge • Farnham • Köln • Sebastopol • Taipei • Tokyo\n\n\fLearning Python, Fourth Edition\nby Mark Lutz\nCopyright © 2009 Mark Lutz. All rights reserved.\nPrinted in the United States of America.\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions\nare also available for most titles (http://my.safaribooksonline.com). For more information, contact our\ncorporate/institutional sales department: (800) 998-9938 or corporate@oreilly.com.\n\nEditor: Julie Steele\nProduction Editor: Sumita Mukherji\nCopyeditor: Rachel Head\nProduction Services: Newgen North America\n\nIndexer: John Bickelhaupt\nCover Designer: Karen Montgomery\nInterior Designer: David Futato\nIllustrator: Robert Romano\n\nPrinting History:\nMarch 1999:\nDecember 2003:\nOctober 2007:\nSeptember 2009:",
    "Editor: Julie Steele\nProduction Editor: Sumita Mukherji\nCopyeditor: Rachel Head\nProduction Services: Newgen North America\n\nIndexer: John Bickelhaupt\nCover Designer: Karen Montgomery\nInterior Designer: David Futato\nIllustrator: Robert Romano\n\nPrinting History:\nMarch 1999:\nDecember 2003:\nOctober 2007:\nSeptember 2009:\n\nFirst Edition.\nSecond Edition.\nThird Edition.\nFourth Edition.",
    "Indexer: John Bickelhaupt\nCover Designer: Karen Montgomery\nInterior Designer: David Futato\nIllustrator: Robert Romano\n\nPrinting History:\nMarch 1999:\nDecember 2003:\nOctober 2007:\nSeptember 2009:\n\nFirst Edition.\nSecond Edition.\nThird Edition.\nFourth Edition.\n\nNutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo are registered trademarks of\nO’Reilly Media, Inc. Learning Python, the image of a wood rat, and related trade dress are trademarks\nof O’Reilly Media, Inc.\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as\ntrademarks. Where those designations appear in this book, and O’Reilly Media, Inc., was aware of a\ntrademark claim, the designations have been printed in caps or initial caps.\nWhile every precaution has been taken in the preparation of this book, the publisher and author assume\nno responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.",
    "ISBN: 978-0-596-15806-4\n[M]\n1252944666\n\n\fTo Vera.\nYou are my life.\n\n\f\fTable of Contents\n\nPreface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxi",
    "To Vera.\nYou are my life.\n\n\f\fTable of Contents\n\nPreface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxi\n\nPart I. Getting Started\n1. A Python Q&A Session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\nWhy Do People Use Python?\nSoftware Quality\nDeveloper Productivity\nIs Python a “Scripting Language”?\nOK, but What’s the Downside?\nWho Uses Python Today?\nWhat Can I Do with Python?\nSystems Programming\nGUIs\nInternet Scripting\nComponent Integration\nDatabase Programming\nRapid Prototyping\nNumeric and Scientific Programming\nGaming, Images, Serial Ports, XML, Robots, and More\nHow Is Python Supported?\nWhat Are Python’s Technical Strengths?\nIt’s Object-Oriented\nIt’s Free\nIt’s Portable\nIt’s Powerful\nIt’s Mixable\nIt’s Easy to Use\nIt’s Easy to Learn\nIt’s Named After Monty Python\nHow Does Python Stack Up to Language X?",
    "3\n4\n5\n5\n7\n7\n9\n9\n9\n10\n10\n11\n11\n11\n12\n12\n13\n13\n13\n14\n15\n16\n16\n17\n17\n17\nvii\n\n\fChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n18\n19\n19\n\n2. How Python Runs Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nIntroducing the Python Interpreter\nProgram Execution\nThe Programmer’s View\nPython’s View\nExecution Model Variations\nPython Implementation Alternatives\nExecution Optimization Tools\nFrozen Binaries\nOther Execution Options\nFuture Possibilities?\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n23\n24\n24\n26\n29\n29\n30\n32\n33\n33\n34\n34\n34",
    "23\n24\n24\n26\n29\n29\n30\n32\n33\n33\n34\n34\n34\n\n3. How You Run Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nThe Interactive Prompt\nRunning Code Interactively\nWhy the Interactive Prompt?\nUsing the Interactive Prompt\nSystem Command Lines and Files\nA First Script\nRunning Files with Command Lines\nUsing Command Lines and Files\nUnix Executable Scripts (#!)\nClicking File Icons\nClicking Icons on Windows\nThe input Trick\nOther Icon-Click Limitations\nModule Imports and Reloads\nThe Grander Module Story: Attributes\nimport and reload Usage Notes\nUsing exec to Run Module Files\nThe IDLE User Interface\nIDLE Basics\nUsing IDLE\nAdvanced IDLE Tools\nOther IDEs\nOther Launch Options\nviii | Table of Contents\n\n35\n37\n38\n39\n41\n42\n43\n44\n46\n47\n47\n49\n50\n51\n53\n56\n57\n58\n58\n60\n62\n63\n64",
    "35\n37\n38\n39\n41\n42\n43\n44\n46\n47\n47\n49\n50\n51\n53\n56\n57\n58\n58\n60\n62\n63\n64\n\n\fEmbedding Calls\nFrozen Binary Executables\nText Editor Launch Options\nStill Other Launch Options\nFuture Possibilities?\nWhich Option Should I Use?\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part I Exercises\n\n64\n65\n65\n66\n66\n66\n68\n68\n69\n70\n\nPart II. Types and Operations\n4. Introducing Python Object Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nWhy Use Built-in Types?\nPython’s Core Data Types\nNumbers\nStrings\nSequence Operations\nImmutability\nType-Specific Methods\nGetting Help\nOther Ways to Code Strings\nPattern Matching\nLists\nSequence Operations\nType-Specific Operations\nBounds Checking\nNesting\nComprehensions\nDictionaries\nMapping Operations\nNesting Revisited\nSorting Keys: for Loops\nIteration and Optimization\nMissing Keys: if Tests\nTuples\nWhy Tuples?\nFiles\nOther File-Like Tools\nOther Core Types\nHow to Break Your Code’s Flexibility",
    "76\n77\n78\n80\n80\n82\n82\n84\n85\n85\n86\n86\n87\n87\n88\n88\n90\n90\n91\n93\n94\n95\n96\n97\n97\n99\n99\n100\n\nTable of Contents | ix\n\n\fUser-Defined Classes\nAnd Everything Else\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n101\n102\n103\n103\n104\n\n5. Numeric Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\nNumeric Type Basics\nNumeric Literals\nBuilt-in Numeric Tools\nPython Expression Operators\nNumbers in Action\nVariables and Basic Expressions\nNumeric Display Formats\nComparisons: Normal and Chained\nDivision: Classic, Floor, and True\nInteger Precision\nComplex Numbers\nHexadecimal, Octal, and Binary Notation\nBitwise Operations\nOther Built-in Numeric Tools\nOther Numeric Types\nDecimal Type\nFraction Type\nSets\nBooleans\nNumeric Extensions\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n105\n106\n108\n108\n113\n113\n115\n116\n117\n121\n122\n122\n124\n125\n127\n127\n129\n133\n139\n140\n141\n141\n141",
    "105\n106\n108\n108\n113\n113\n115\n116\n117\n121\n122\n122\n124\n125\n127\n127\n129\n133\n139\n140\n141\n141\n141\n\n6. The Dynamic Typing Interlude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nThe Case of the Missing Declaration Statements\nVariables, Objects, and References\nTypes Live with Objects, Not Variables\nObjects Are Garbage-Collected\nShared References\nShared References and In-Place Changes\nShared References and Equality\nDynamic Typing Is Everywhere\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nx | Table of Contents\n\n143\n144\n145\n146\n148\n149\n151\n152\n153\n153\n154",
    "7. Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155\nString Literals\nSingle- and Double-Quoted Strings Are the Same\nEscape Sequences Represent Special Bytes\nRaw Strings Suppress Escapes\nTriple Quotes Code Multiline Block Strings\nStrings in Action\nBasic Operations\nIndexing and Slicing\nString Conversion Tools\nChanging Strings\nString Methods\nString Method Examples: Changing Strings\nString Method Examples: Parsing Text\nOther Common String Methods in Action\nThe Original string Module (Gone in 3.0)\nString Formatting Expressions\nAdvanced String Formatting Expressions\nDictionary-Based String Formatting Expressions\nString Formatting Method Calls\nThe Basics\nAdding Keys, Attributes, and Offsets\nAdding Specific Formatting\nComparison to the % Formatting Expression\nWhy the New Format Method?\nGeneral Type Categories\nTypes Share Operation Sets by Categories\nMutable Types Can Be Changed In-Place\nChapter Summary",
    "Advanced String Formatting Expressions\nDictionary-Based String Formatting Expressions\nString Formatting Method Calls\nThe Basics\nAdding Keys, Attributes, and Offsets\nAdding Specific Formatting\nComparison to the % Formatting Expression\nWhy the New Format Method?\nGeneral Type Categories\nTypes Share Operation Sets by Categories\nMutable Types Can Be Changed In-Place\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "157\n158\n158\n161\n162\n163\n164\n165\n169\n171\n172\n174\n176\n177\n178\n179\n181\n182\n183\n184\n184\n185\n187\n190\n193\n194\n194\n195\n195\n196\n\n8. Lists and Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197\nLists\nLists in Action\nBasic List Operations\nList Iteration and Comprehensions\nIndexing, Slicing, and Matrixes\nChanging Lists In-Place\nDictionaries\nDictionaries in Action\nBasic Dictionary Operations\nChanging Dictionaries In-Place\n\n197\n200\n200\n200\n201\n202\n207\n209\n209\n210\nTable of Contents | xi\n\n\fMore Dictionary Methods\nA Languages Table\nDictionary Usage Notes\nOther Ways to Make Dictionaries\nDictionary Changes in Python 3.0\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n211\n212\n213\n216\n217\n223\n224\n224",
    "More Dictionary Methods\nA Languages Table\nDictionary Usage Notes\nOther Ways to Make Dictionaries\nDictionary Changes in Python 3.0\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n211\n212\n213\n216\n217\n223\n224\n224\n\n9. Tuples, Files, and Everything Else . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225\nTuples\nTuples in Action\nWhy Lists and Tuples?\nFiles\nOpening Files\nUsing Files\nFiles in Action\nOther File Tools\nType Categories Revisited\nObject Flexibility\nReferences Versus Copies\nComparisons, Equality, and Truth\nPython 3.0 Dictionary Comparisons\nThe Meaning of True and False in Python\nPython’s Type Hierarchies\nType Objects\nOther Types in Python\nBuilt-in Type Gotchas\nAssignment Creates References, Not Copies\nRepetition Adds One Level Deep\nBeware of Cyclic Data Structures\nImmutable Types Can’t Be Changed In-Place\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part II Exercises",
    "225\n227\n229\n229\n230\n231\n232\n238\n239\n241\n241\n244\n246\n246\n248\n249\n250\n251\n251\n252\n252\n253\n253\n254\n254\n255\n\nPart III. Statements and Syntax\n10. Introducing Python Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nPython Program Structure Revisited\nPython’s Statements\n\nxii | Table of Contents\n\n261\n262\n\n\fA Tale of Two ifs\nWhat Python Adds\nWhat Python Removes\nWhy Indentation Syntax?\nA Few Special Cases\nA Quick Example: Interactive Loops\nA Simple Interactive Loop\nDoing Math on User Inputs\nHandling Errors by Testing Inputs\nHandling Errors with try Statements\nNesting Code Three Levels Deep\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n264\n264\n265\n266\n269\n271\n271\n272\n273\n274\n275\n276\n276\n277",
    "264\n264\n265\n266\n269\n271\n271\n272\n273\n274\n275\n276\n276\n277\n\n11. Assignments, Expressions, and Prints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\nAssignment Statements\nAssignment Statement Forms\nSequence Assignments\nExtended Sequence Unpacking in Python 3.0\nMultiple-Target Assignments\nAugmented Assignments\nVariable Name Rules\nExpression Statements\nExpression Statements and In-Place Changes\nPrint Operations\nThe Python 3.0 print Function\nThe Python 2.6 print Statement\nPrint Stream Redirection\nVersion-Neutral Printing\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n279\n280\n281\n284\n288\n289\n292\n295\n296\n297\n298\n300\n302\n306\n308\n308\n308",
    "279\n280\n281\n284\n288\n289\n292\n295\n296\n297\n298\n300\n302\n306\n308\n308\n308\n\n12. if Tests and Syntax Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311\nif Statements\nGeneral Format\nBasic Examples\nMultiway Branching\nPython Syntax Rules\nBlock Delimiters: Indentation Rules\nStatement Delimiters: Lines and Continuations\nA Few Special Cases\n\n311\n311\n312\n312\n314\n315\n317\n318\nTable of Contents | xiii\n\n\fTruth Tests\nThe if/else Ternary Expression\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n320\n321\n324\n324\n324",
    "311\n311\n312\n312\n314\n315\n317\n318\nTable of Contents | xiii\n\n\fTruth Tests\nThe if/else Ternary Expression\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n320\n321\n324\n324\n324\n\n13. while and for Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nwhile Loops\nGeneral Format\nExamples\nbreak, continue, pass, and the Loop else\nGeneral Loop Format\npass\ncontinue\nbreak\nLoop else\nfor Loops\nGeneral Format\nExamples\nLoop Coding Techniques\nCounter Loops: while and range\nNonexhaustive Traversals: range and Slices\nChanging Lists: range\nParallel Traversals: zip and map\nGenerating Both Offsets and Items: enumerate\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n327\n328\n328\n329\n329\n330\n331\n331\n332\n334\n334\n335\n341\n342\n343\n344\n345\n348\n349\n349\n350",
    "327\n328\n328\n329\n329\n330\n331\n331\n332\n334\n334\n335\n341\n342\n343\n344\n345\n348\n349\n349\n350\n\n14. Iterations and Comprehensions, Part 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351\nIterators: A First Look\nThe Iteration Protocol: File Iterators\nManual Iteration: iter and next\nOther Built-in Type Iterators\nList Comprehensions: A First Look\nList Comprehension Basics\nUsing List Comprehensions on Files\nExtended List Comprehension Syntax\nOther Iteration Contexts\nNew Iterables in Python 3.0\nThe range Iterator\nThe map, zip, and filter Iterators\nMultiple Versus Single Iterators\nxiv | Table of Contents\n\n351\n352\n354\n356\n358\n359\n359\n361\n362\n366\n367\n368\n369\n\n\fDictionary View Iterators\nOther Iterator Topics\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n370\n372\n372\n372\n373",
    "351\n352\n354\n356\n358\n359\n359\n361\n362\n366\n367\n368\n369\n\n\fDictionary View Iterators\nOther Iterator Topics\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n370\n372\n372\n372\n373\n\n15. The Documentation Interlude . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375\nPython Documentation Sources\n# Comments\nThe dir Function\nDocstrings: __doc__\nPyDoc: The help Function\nPyDoc: HTML Reports\nThe Standard Manual Set\nWeb Resources\nPublished Books\nCommon Coding Gotchas\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part III Exercises\n\n375\n376\n376\n377\n380\n383\n386\n387\n387\n387\n389\n389\n390\n390",
    "375\n376\n376\n377\n380\n383\n386\n387\n387\n387\n389\n389\n390\n390\n\nPart IV. Functions\n16. Function Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395\nWhy Use Functions?\nCoding Functions\ndef Statements\ndef Executes at Runtime\nA First Example: Definitions and Calls\nDefinition\nCalls\nPolymorphism in Python\nA Second Example: Intersecting Sequences\nDefinition\nCalls\nPolymorphism Revisited\nLocal Variables\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n396\n396\n398\n399\n400\n400\n400\n401\n402\n402\n403\n403\n404\n404\n405\n405\n\nTable of Contents | xv",
    "396\n396\n398\n399\n400\n400\n400\n401\n402\n402\n403\n403\n404\n404\n405\n405\n\nTable of Contents | xv\n\n\f17. Scopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\nPython Scope Basics\nScope Rules\nName Resolution: The LEGB Rule\nScope Example\nThe Built-in Scope\nThe global Statement\nMinimize Global Variables\nMinimize Cross-File Changes\nOther Ways to Access Globals\nScopes and Nested Functions\nNested Scope Details\nNested Scope Examples\nThe nonlocal Statement\nnonlocal Basics\nnonlocal in Action\nWhy nonlocal?\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n407\n408\n410\n411\n412\n414\n415\n416\n418\n419\n419\n419\n425\n425\n426\n429\n432\n433\n434",
    "407\n408\n410\n411\n412\n414\n415\n416\n418\n419\n419\n419\n425\n425\n426\n429\n432\n433\n434\n\n18. Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\nArgument-Passing Basics\nArguments and Shared References\nAvoiding Mutable Argument Changes\nSimulating Output Parameters\nSpecial Argument-Matching Modes\nThe Basics\nMatching Syntax\nThe Gritty Details\nKeyword and Default Examples\nArbitrary Arguments Examples\nPython 3.0 Keyword-Only Arguments\nThe min Wakeup Call!\nFull Credit\nBonus Points\nThe Punch Line...\nGeneralized Set Functions\nEmulating the Python 3.0 print Function\nUsing Keyword-Only Arguments\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nxvi | Table of Contents\n\n435\n436\n438\n439\n440\n441\n442\n443\n444\n446\n450\n453\n454\n455\n456\n456\n457\n459\n460\n461\n462",
    "435\n436\n438\n439\n440\n441\n442\n443\n444\n446\n450\n453\n454\n455\n456\n456\n457\n459\n460\n461\n462\n\n\f19. Advanced Function Topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463\nFunction Design Concepts\nRecursive Functions\nSummation with Recursion\nCoding Alternatives\nLoop Statements Versus Recursion\nHandling Arbitrary Structures\nFunction Objects: Attributes and Annotations\nIndirect Function Calls\nFunction Introspection\nFunction Attributes\nFunction Annotations in 3.0\nAnonymous Functions: lambda\nlambda Basics\nWhy Use lambda?\nHow (Not) to Obfuscate Your Python Code\nNested lambdas and Scopes\nMapping Functions over Sequences: map\nFunctional Programming Tools: filter and reduce\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n463\n465\n465\n466\n467\n468\n469\n469\n470\n471\n472\n474\n474\n475\n477\n478\n479\n481\n483\n483\n483",
    "463\n465\n465\n466\n467\n468\n469\n469\n470\n471\n472\n474\n474\n475\n477\n478\n479\n481\n483\n483\n483\n\n20. Iterations and Comprehensions, Part 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485\nList Comprehensions Revisited: Functional Tools\nList Comprehensions Versus map\nAdding Tests and Nested Loops: filter\nList Comprehensions and Matrixes\nComprehending List Comprehensions\nIterators Revisited: Generators\nGenerator Functions: yield Versus return\nGenerator Expressions: Iterators Meet Comprehensions\nGenerator Functions Versus Generator Expressions\nGenerators Are Single-Iterator Objects\nEmulating zip and map with Iteration Tools\nValue Generation in Built-in Types and Classes\n3.0 Comprehension Syntax Summary\nComprehending Set and Dictionary Comprehensions\nExtended Comprehension Syntax for Sets and Dictionaries\nTiming Iteration Alternatives\nTiming Module\nTiming Script\nTiming Results\n\n485\n486\n487\n489\n490\n492\n492\n497\n498\n499\n500\n506\n507\n507\n508\n509\n509\n510\n511",
    "485\n486\n487\n489\n490\n492\n492\n497\n498\n499\n500\n506\n507\n507\n508\n509\n509\n510\n511\n\nTable of Contents | xvii\n\n\fTiming Module Alternatives\nOther Suggestions\nFunction Gotchas\nLocal Names Are Detected Statically\nDefaults and Mutable Objects\nFunctions Without returns\nEnclosing Scope Loop Variables\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part IV Exercises\n\n513\n517\n518\n518\n520\n522\n522\n522\n523\n523\n524\n\nPart V. Modules\n21. Modules: The Big Picture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\nWhy Use Modules?\nPython Program Architecture\nHow to Structure a Program\nImports and Attributes\nStandard Library Modules\nHow Imports Work\n1. Find It\n2. Compile It (Maybe)\n3. Run It\nThe Module Search Path\nConfiguring the Search Path\nSearch Path Variations\nThe sys.path List\nModule File Selection\nAdvanced Module Selection Concepts\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "529\n530\n531\n531\n533\n533\n534\n534\n535\n535\n537\n538\n538\n539\n540\n541\n541\n542\n\n22. Module Coding Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543\nModule Creation\nModule Usage\nThe import Statement\nThe from Statement\nThe from * Statement\nImports Happen Only Once\nimport and from Are Assignments\n\nxviii | Table of Contents\n\n543\n544\n544\n545\n545\n546\n546\n\n\fCross-File Name Changes\nimport and from Equivalence\nPotential Pitfalls of the from Statement\nModule Namespaces\nFiles Generate Namespaces\nAttribute Name Qualification\nImports Versus Scopes\nNamespace Nesting\nReloading Modules\nreload Basics\nreload Example\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n547\n548\n548\n550\n550\n552\n552\n553\n554\n555\n556\n558\n558\n558",
    "Cross-File Name Changes\nimport and from Equivalence\nPotential Pitfalls of the from Statement\nModule Namespaces\nFiles Generate Namespaces\nAttribute Name Qualification\nImports Versus Scopes\nNamespace Nesting\nReloading Modules\nreload Basics\nreload Example\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n547\n548\n548\n550\n550\n552\n552\n553\n554\n555\n556\n558\n558\n558\n\n23. Module Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561\nPackage Import Basics\nPackages and Search Path Settings\nPackage __init__.py Files\nPackage Import Example\nfrom Versus import with Packages\nWhy Use Package Imports?\nA Tale of Three Systems\nPackage Relative Imports\nChanges in Python 3.0\nRelative Import Basics\nWhy Relative Imports?\nThe Scope of Relative Imports\nModule Lookup Rules Summary\nRelative Imports in Action\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "561\n562\n563\n564\n566\n566\n567\n569\n570\n570\n572\n574\n575\n575\n581\n582\n582\n\n24. Advanced Module Topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 583\nData Hiding in Modules\nMinimizing from * Damage: _X and __all__\nEnabling Future Language Features\nMixed Usage Modes: __name__ and __main__\nUnit Tests with __name__\nUsing Command-Line Arguments with __name__\nChanging the Module Search Path\nThe as Extension for import and from\n\n583\n584\n584\n585\n586\n587\n590\n591\nTable of Contents | xix\n\n\fModules Are Objects: Metaprograms\nImporting Modules by Name String\nTransitive Module Reloads\nModule Design Concepts\nModule Gotchas\nStatement Order Matters in Top-Level Code\nfrom Copies Names but Doesn’t Link\nfrom * Can Obscure the Meaning of Variables\nreload May Not Impact from Imports\nreload, from, and Interactive Testing\nRecursive from Imports May Not Work\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part V Exercises",
    "591\n594\n595\n598\n599\n599\n600\n601\n601\n602\n603\n604\n604\n605\n605\n\nPart VI. Classes and OOP\n25. OOP: The Big Picture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611\nWhy Use Classes?\nOOP from 30,000 Feet\nAttribute Inheritance Search\nClasses and Instances\nClass Method Calls\nCoding Class Trees\nOOP Is About Code Reuse\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n612\n613\n613\n615\n616\n616\n619\n622\n622\n622\n\n26. Class Coding Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625\nClasses Generate Multiple Instance Objects\nClass Objects Provide Default Behavior\nInstance Objects Are Concrete Items\nA First Example\nClasses Are Customized by Inheritance\nA Second Example\nClasses Are Attributes in Modules\nClasses Can Intercept Python Operators\nA Third Example\nWhy Use Operator Overloading?\nThe World’s Simplest Python Class\n\nxx | Table of Contents",
    "xx | Table of Contents\n\n625\n626\n626\n627\n629\n630\n631\n633\n634\n636\n636\n\n\fClasses Versus Dictionaries\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n639\n641\n641\n641",
    "27. A More Realistic Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 643\nStep 1: Making Instances\nCoding Constructors\nTesting As You Go\nUsing Code Two Ways\nStep 2: Adding Behavior Methods\nCoding Methods\nStep 3: Operator Overloading\nProviding Print Displays\nStep 4: Customizing Behavior by Subclassing\nCoding Subclasses\nAugmenting Methods: The Bad Way\nAugmenting Methods: The Good Way\nPolymorphism in Action\nInherit, Customize, and Extend\nOOP: The Big Idea\nStep 5: Customizing Constructors, Too\nOOP Is Simpler Than You May Think\nOther Ways to Combine Classes\nStep 6: Using Introspection Tools\nSpecial Class Attributes\nA Generic Display Tool\nInstance Versus Class Attributes\nName Considerations in Tool Classes\nOur Classes’ Final Form\nStep 7 (Final): Storing Objects in a Database\nPickles and Shelves\nStoring Objects on a Shelve Database\nExploring Shelves Interactively\nUpdating Objects on a Shelve\nFuture Directions\nChapter Summary",
    "Step 6: Using Introspection Tools\nSpecial Class Attributes\nA Generic Display Tool\nInstance Versus Class Attributes\nName Considerations in Tool Classes\nOur Classes’ Final Form\nStep 7 (Final): Storing Objects in a Database\nPickles and Shelves\nStoring Objects on a Shelve Database\nExploring Shelves Interactively\nUpdating Objects on a Shelve\nFuture Directions\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "644\n644\n645\n646\n648\n649\n651\n652\n653\n653\n654\n654\n656\n657\n658\n658\n660\n660\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n674\n675\n677\n677\n678\n\n28. Class Coding Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681\nThe class Statement\nGeneral Form\n\n681\n681\nTable of Contents | xxi\n\n\fExample\nMethods\nMethod Example\nCalling Superclass Constructors\nOther Method Call Possibilities\nInheritance\nAttribute Tree Construction\nSpecializing Inherited Methods\nClass Interface Techniques\nAbstract Superclasses\nPython 2.6 and 3.0 Abstract Superclasses\nNamespaces: The Whole Story\nSimple Names: Global Unless Assigned\nAttribute Names: Object Namespaces\nThe “Zen” of Python Namespaces: Assignments Classify Names\nNamespace Dictionaries\nNamespace Links\nDocumentation Strings Revisited\nClasses Versus Modules\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "682\n684\n685\n686\n686\n687\n687\n687\n689\n690\n692\n693\n693\n693\n694\n696\n699\n701\n703\n703\n703\n704\n\n29. Operator Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 705\nThe Basics\nConstructors and Expressions: __init__ and __sub__\nCommon Operator Overloading Methods\nIndexing and Slicing: __getitem__ and __setitem__\nIntercepting Slices\nIndex Iteration: __getitem__\nIterator Objects: __iter__ and __next__\nUser-Defined Iterators\nMultiple Iterators on One Object\nMembership: __contains__, __iter__, and __getitem__\nAttribute Reference: __getattr__ and __setattr__\nOther Attribute Management Tools\nEmulating Privacy for Instance Attributes: Part 1\nString Representation: __repr__ and __str__\nRight-Side and In-Place Addition: __radd__ and __iadd__\nIn-Place Addition\nCall Expressions: __call__\nFunction Interfaces and Callback-Based Code\nComparisons: __lt__, __gt__, and Others\n\nxxii | Table of Contents",
    "xxii | Table of Contents\n\n705\n706\n706\n708\n708\n710\n711\n712\n714\n716\n718\n719\n720\n721\n723\n725\n725\n727\n728\n\n\fThe 2.6 __cmp__ Method (Removed in 3.0)\nBoolean Tests: __bool__ and __len__\nObject Destruction: __del__\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n729\n730\n732\n733\n734\n734",
    "The 2.6 __cmp__ Method (Removed in 3.0)\nBoolean Tests: __bool__ and __len__\nObject Destruction: __del__\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n729\n730\n732\n733\n734\n734\n\n30. Designing with Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 737\nPython and OOP\nOverloading by Call Signatures (or Not)\nOOP and Inheritance: “Is-a” Relationships\nOOP and Composition: “Has-a” Relationships\nStream Processors Revisited\nOOP and Delegation: “Wrapper” Objects\nPseudoprivate Class Attributes\nName Mangling Overview\nWhy Use Pseudoprivate Attributes?\nMethods Are Objects: Bound or Unbound\nUnbound Methods are Functions in 3.0\nBound Methods and Other Callable Objects\nMultiple Inheritance: “Mix-in” Classes\nCoding Mix-in Display Classes\nClasses Are Objects: Generic Object Factories\nWhy Factories?\nOther Design-Related Topics\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "737\n738\n739\n740\n742\n745\n747\n748\n748\n750\n752\n754\n756\n757\n768\n769\n770\n770\n770\n771\n\n31. Advanced Class Topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 773\nExtending Built-in Types\nExtending Types by Embedding\nExtending Types by Subclassing\nThe “New-Style” Class Model\nNew-Style Class Changes\nType Model Changes\nDiamond Inheritance Change\nNew-Style Class Extensions\nInstance Slots\nClass Properties\n__getattribute__ and Descriptors\nMetaclasses\nStatic and Class Methods\n\n773\n774\n775\n777\n778\n779\n783\n788\n788\n792\n794\n794\n795\nTable of Contents | xxiii",
    "773\n774\n775\n777\n778\n779\n783\n788\n788\n792\n794\n794\n795\nTable of Contents | xxiii\n\n\fWhy the Special Methods?\nStatic Methods in 2.6 and 3.0\nStatic Method Alternatives\nUsing Static and Class Methods\nCounting Instances with Static Methods\nCounting Instances with Class Methods\nDecorators and Metaclasses: Part 1\nFunction Decorator Basics\nA First Function Decorator Example\nClass Decorators and Metaclasses\nFor More Details\nClass Gotchas\nChanging Class Attributes Can Have Side Effects\nChanging Mutable Class Attributes Can Have Side Effects, Too\nMultiple Inheritance: Order Matters\nMethods, Classes, and Nested Scopes\nDelegation-Based Classes in 3.0: __getattr__ and built-ins\n“Overwrapping-itis”\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part VI Exercises\n\n795\n796\n798\n799\n800\n802\n804\n804\n805\n807\n808\n808\n808\n810\n811\n812\n814\n814\n815\n815\n815\n816",
    "795\n796\n798\n799\n800\n802\n804\n804\n805\n807\n808\n808\n808\n810\n811\n812\n814\n814\n815\n815\n815\n816\n\nPart VII. Exceptions and Tools\n32. Exception Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 825\nWhy Use Exceptions?\nException Roles\nExceptions: The Short Story\nDefault Exception Handler\nCatching Exceptions\nRaising Exceptions\nUser-Defined Exceptions\nTermination Actions\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n825\n826\n827\n827\n828\n829\n830\n830\n833\n833\n833\n\n33. Exception Coding Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835\nThe try/except/else Statement\ntry Statement Clauses\nThe try else Clause\n\nxxiv | Table of Contents\n\n835\n837\n839",
    "825\n826\n827\n827\n828\n829\n830\n830\n833\n833\n833\n\n33. Exception Coding Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 835\nThe try/except/else Statement\ntry Statement Clauses\nThe try else Clause\n\nxxiv | Table of Contents\n\n835\n837\n839\n\n\fExample: Default Behavior\nExample: Catching Built-in Exceptions\nThe try/finally Statement\nExample: Coding Termination Actions with try/finally\nUnified try/except/finally\nUnified try Statement Syntax\nCombining finally and except by Nesting\nUnified try Example\nThe raise Statement\nPropagating Exceptions with raise\nPython 3.0 Exception Chaining: raise from\nThe assert Statement\nExample: Trapping Constraints (but Not Errors!)\nwith/as Context Managers\nBasic Usage\nThe Context Management Protocol\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n840\n841\n842\n843\n844\n845\n845\n846\n848\n849\n849\n850\n851\n851\n852\n853\n855\n856\n856",
    "840\n841\n842\n843\n844\n845\n845\n846\n848\n849\n849\n850\n851\n851\n852\n853\n855\n856\n856\n\n34. Exception Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 857\nExceptions: Back to the Future\nString Exceptions Are Right Out!\nClass-Based Exceptions\nCoding Exceptions Classes\nWhy Exception Hierarchies?\nBuilt-in Exception Classes\nBuilt-in Exception Categories\nDefault Printing and State\nCustom Print Displays\nCustom Data and Behavior\nProviding Exception Details\nProviding Exception Methods\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n858\n858\n859\n859\n861\n864\n865\n866\n867\n868\n868\n869\n870\n871\n871\n\n35. Designing with Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 873\nNesting Exception Handlers\nExample: Control-Flow Nesting\nExample: Syntactic Nesting\nException Idioms\nExceptions Aren’t Always Errors\n\n873\n875\n875\n877\n877\nTable of Contents | xxv",
    "858\n858\n859\n859\n861\n864\n865\n866\n867\n868\n868\n869\n870\n871\n871\n\n35. Designing with Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 873\nNesting Exception Handlers\nExample: Control-Flow Nesting\nExample: Syntactic Nesting\nException Idioms\nExceptions Aren’t Always Errors\n\n873\n875\n875\n877\n877\nTable of Contents | xxv\n\n\fFunctions Can Signal Conditions with raise\nClosing Files and Server Connections\nDebugging with Outer try Statements\nRunning In-Process Tests\nMore on sys.exc_info\nException Design Tips and Gotchas\nWhat Should Be Wrapped\nCatching Too Much: Avoid Empty except and Exception\nCatching Too Little: Use Class-Based Categories\nCore Language Summary\nThe Python Toolset\nDevelopment Tools for Larger Projects\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\nTest Your Knowledge: Part VII Exercises\n\n878\n878\n879\n880\n881\n882\n882\n883\n885\n885\n886\n887\n890\n891\n891\n891",
    "878\n878\n879\n880\n881\n882\n882\n883\n885\n885\n886\n887\n890\n891\n891\n891\n\nPart VIII. Advanced Topics\n36. Unicode and Byte Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 895\nString Changes in 3.0\nString Basics\nCharacter Encoding Schemes\nPython’s String Types\nText and Binary Files\nPython 3.0 Strings in Action\nLiterals and Basic Properties\nConversions\nCoding Unicode Strings\nCoding ASCII Text\nCoding Non-ASCII Text\nEncoding and Decoding Non-ASCII text\nOther Unicode Coding Techniques\nConverting Encodings\nCoding Unicode Strings in Python 2.6\nSource File Character Set Encoding Declarations\nUsing 3.0 Bytes Objects\nMethod Calls\nSequence Operations\nOther Ways to Make bytes Objects\nMixing String Types\nUsing 3.0 (and 2.6) bytearray Objects\n\nxxvi | Table of Contents\n\n896\n897\n897\n899\n900\n902\n902\n903\n904\n905\n905\n906\n907\n909\n910\n912\n913\n913\n914\n915\n916\n917",
    "xxvi | Table of Contents\n\n896\n897\n897\n899\n900\n902\n902\n903\n904\n905\n905\n906\n907\n909\n910\n912\n913\n913\n914\n915\n916\n917\n\n\fUsing Text and Binary Files\nText File Basics\nText and Binary Modes in 3.0\nType and Content Mismatches\nUsing Unicode Files\nReading and Writing Unicode in 3.0\nHandling the BOM in 3.0\nUnicode Files in 2.6\nOther String Tool Changes in 3.0\nThe re Pattern Matching Module\nThe struct Binary Data Module\nThe pickle Object Serialization Module\nXML Parsing Tools\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n920\n920\n921\n923\n924\n924\n926\n928\n929\n929\n930\n932\n934\n937\n937\n937",
    "920\n920\n921\n923\n924\n924\n926\n928\n929\n929\n930\n932\n934\n937\n937\n937\n\n37. Managed Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 941\nWhy Manage Attributes?\nInserting Code to Run on Attribute Access\nProperties\nThe Basics\nA First Example\nComputed Attributes\nCoding Properties with Decorators\nDescriptors\nThe Basics\nA First Example\nComputed Attributes\nUsing State Information in Descriptors\nHow Properties and Descriptors Relate\n__getattr__ and __getattribute__\nThe Basics\nA First Example\nComputed Attributes\n__getattr__ and __getattribute__ Compared\nManagement Techniques Compared\nIntercepting Built-in Operation Attributes\nDelegation-Based Managers Revisited\nExample: Attribute Validations\nUsing Properties to Validate\nUsing Descriptors to Validate\nUsing __getattr__ to Validate\n\n941\n942\n943\n943\n944\n945\n946\n947\n948\n950\n952\n953\n955\n956\n957\n959\n961\n962\n963\n966\n970\n973\n973\n975\n977\n\nTable of Contents | xxvii",
    "941\n942\n943\n943\n944\n945\n946\n947\n948\n950\n952\n953\n955\n956\n957\n959\n961\n962\n963\n966\n970\n973\n973\n975\n977\n\nTable of Contents | xxvii\n\n\fUsing __getattribute__ to Validate\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n978\n979\n980\n980",
    "38. Decorators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 983\nWhat’s a Decorator?\nManaging Calls and Instances\nManaging Functions and Classes\nUsing and Defining Decorators\nWhy Decorators?\nThe Basics\nFunction Decorators\nClass Decorators\nDecorator Nesting\nDecorator Arguments\nDecorators Manage Functions and Classes, Too\nCoding Function Decorators\nTracing Calls\nState Information Retention Options\nClass Blunders I: Decorating Class Methods\nTiming Calls\nAdding Decorator Arguments\nCoding Class Decorators\nSingleton Classes\nTracing Object Interfaces\nClass Blunders II: Retaining Multiple Instances\nDecorators Versus Manager Functions\nWhy Decorators? (Revisited)\nManaging Functions and Classes Directly\nExample: “Private” and “Public” Attributes\nImplementing Private Attributes\nImplementation Details I\nGeneralizing for Public Declarations, Too\nImplementation Details II\nOpen Issues\nPython Isn’t About Control",
    "Tracing Object Interfaces\nClass Blunders II: Retaining Multiple Instances\nDecorators Versus Manager Functions\nWhy Decorators? (Revisited)\nManaging Functions and Classes Directly\nExample: “Private” and “Public” Attributes\nImplementing Private Attributes\nImplementation Details I\nGeneralizing for Public Declarations, Too\nImplementation Details II\nOpen Issues\nPython Isn’t About Control\nExample: Validating Function Arguments\nThe Goal\nA Basic Range-Testing Decorator for Positional Arguments\nGeneralizing for Keywords and Defaults, Too\nImplementation Details\nOpen Issues",
    "xxviii | Table of Contents\n\n983\n984\n984\n984\n985\n986\n986\n990\n993\n994\n995\n996\n996\n997\n1001\n1006\n1008\n1011\n1011\n1013\n1016\n1018\n1019\n1021\n1023\n1023\n1025\n1026\n1029\n1030\n1034\n1034\n1034\n1035\n1037\n1040\n1042\n\n\fDecorator Arguments Versus Function Annotations\nOther Applications: Type Testing (If You Insist!)\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers\n\n1043\n1045\n1046\n1047\n1047",
    "1043\n1045\n1046\n1047\n1047\n\n39. Metaclasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1051\nTo Metaclass or Not to Metaclass\nIncreasing Levels of Magic\nThe Downside of “Helper” Functions\nMetaclasses Versus Class Decorators: Round 1\nThe Metaclass Model\nClasses Are Instances of type\nMetaclasses Are Subclasses of Type\nClass Statement Protocol\nDeclaring Metaclasses\nCoding Metaclasses\nA Basic Metaclass\nCustomizing Construction and Initialization\nOther Metaclass Coding Techniques\nInstances Versus Inheritance\nExample: Adding Methods to Classes\nManual Augmentation\nMetaclass-Based Augmentation\nMetaclasses Versus Class Decorators: Round 2\nExample: Applying Decorators to Methods\nTracing with Decoration Manually\nTracing with Metaclasses and Decorators\nApplying Any Decorator to Methods\nMetaclasses Versus Class Decorators: Round 3\nChapter Summary\nTest Your Knowledge: Quiz\nTest Your Knowledge: Answers",
    "1052\n1052\n1054\n1056\n1058\n1058\n1061\n1061\n1062\n1063\n1064\n1065\n1065\n1068\n1070\n1070\n1071\n1073\n1076\n1076\n1077\n1079\n1080\n1084\n1084\n1085\n\nPart IX. Appendixes\nA. Installation and Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1089\nB. Solutions to End-of-Part Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1101\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1139\n\nTable of Contents | xxix\n\n\f\fPreface",
    "This book provides an introduction to the Python programming language. Python is a\npopular open source programming language used for both standalone programs and\nscripting applications in a wide variety of domains. It is free, portable, powerful, and\nremarkably easy and fun to use. Programmers from every corner of the software industry have found Python’s focus on developer productivity and software quality to be\na strategic advantage in projects both large and small.\nWhether you are new to programming or are a professional developer, this book’s goal\nis to bring you quickly up to speed on the fundamentals of the core Python language.\nAfter reading this book, you will know enough about Python to apply it in whatever\napplication domains you choose to explore.\nBy design, this book is a tutorial that focuses on the core Python language itself, rather\nthan specific applications of it. As such, it’s intended to serve as the first in a two-volume\nset:",
    "After reading this book, you will know enough about Python to apply it in whatever\napplication domains you choose to explore.\nBy design, this book is a tutorial that focuses on the core Python language itself, rather\nthan specific applications of it. As such, it’s intended to serve as the first in a two-volume\nset:\n• Learning Python, this book, teaches Python itself.\n• Programming Python, among others, shows what you can do with Python after\nyou’ve learned it.\nThat is, applications-focused books such as Programming Python pick up where this\nbook leaves off, exploring Python’s role in common domains such as the Web, graphical\nuser interfaces (GUIs), and databases. In addition, the book Python Pocket Reference\nprovides additional reference materials not included here, and it is designed to supplement this book.\nBecause of this book’s foundations focus, though, it is able to present Python fundamentals with more depth than many programmers see when first learning the language.",
    "user interfaces (GUIs), and databases. In addition, the book Python Pocket Reference\nprovides additional reference materials not included here, and it is designed to supplement this book.\nBecause of this book’s foundations focus, though, it is able to present Python fundamentals with more depth than many programmers see when first learning the language.\nAnd because it’s based upon a three-day Python training class with quizzes and exercises throughout, this book serves as a self-paced introduction to the language.",
    "xxxi",
    "About This Fourth Edition\nThis fourth edition of this book has changed in three ways. This edition:\n• Covers both Python 3.0 and Python 2.6—it emphasizes 3.0, but notes differences\nin 2.6\n• Includes a set of new chapters mainly targeted at advanced core-language topics\n• Reorganizes some existing material and expands it with new examples for clarity\nAs I write this edition in 2009, Python comes in two flavors—version 3.0 is an emerging\nand incompatible mutation of the language, and 2.6 retains backward compatibility\nwith the vast body of existing Python code. Although Python 3 is viewed as the future\nof Python, Python 2 is still widely used and will be supported in parallel with Python\n3 for years to come. While 3.0 is largely the same language, it runs almost no code\nwritten for prior releases (the mutation of print from statement to function alone,\naesthetically sound as it may be, breaks nearly every Python program ever written).",
    "of Python, Python 2 is still widely used and will be supported in parallel with Python\n3 for years to come. While 3.0 is largely the same language, it runs almost no code\nwritten for prior releases (the mutation of print from statement to function alone,\naesthetically sound as it may be, breaks nearly every Python program ever written).\nThis split presents a bit of a dilemma for both programmers and book authors. While\nit would be easier for a book to pretend that Python 2 never existed and cover 3 only,\nthis would not address the needs of the large Python user base that exists today. A vast\namount of existing code was written for Python 2, and it won’t be going away any time\nsoon. And while newcomers to the language can focus on Python 3, anyone who must\nuse code written in the past needs to keep one foot in the Python 2 world today. Since\nit may be years before all third-party libraries and extensions are ported to Python 3,\nthis fork might not be entirely temporary.",
    "Coverage for Both 3.0 and 2.6\nTo address this dichotomy and to meet the needs of all potential readers, this edition\nof this book has been updated to cover both Python 3.0 and Python 2.6 (and later\nreleases in the 3.X and 2.X lines). It’s intended for programmers using Python 2, programmers using Python 3, and programmers stuck somewhere between the two.\nThat is, you can use this book to learn either Python line. Although the focus here is\non 3.0 primarily, 2.6 differences and tools are also noted along the way for programmers\nusing older code. While the two versions are largely the same, they diverge in some\nimportant ways, and I’ll point these out along the way.\nFor instance, I’ll use 3.0 print calls in most examples, but will describe the 2.6 print\nstatement, too, so you can make sense of earlier code. I’ll also freely introduce new\nfeatures, such as the nonlocal statement in 3.0 and the string format method in 2.6 and",
    "important ways, and I’ll point these out along the way.\nFor instance, I’ll use 3.0 print calls in most examples, but will describe the 2.6 print\nstatement, too, so you can make sense of earlier code. I’ll also freely introduce new\nfeatures, such as the nonlocal statement in 3.0 and the string format method in 2.6 and\n3.0, and will point out when such extensions are not present in older Pythons.\nIf you are learning Python for the first time and don’t need to use any legacy code, I\nencourage you to begin with Python 3.0; it cleans up some longstanding warts in the\nlanguage, while retaining all the original core ideas and adding some nice new tools.",
    "xxxii | Preface",
    "Many popular Python libraries and tools will likely be available for Python 3.0 by the\ntime you read these words, especially given the file I/O performance improvements\nexpected in the upcoming 3.1 release. If you are using a system based on Python 2.X,\nhowever, you’ll find that this book addresses your concerns, too, and will help you\nmigrate to 3.0 in the future.\nBy proxy, this edition addresses other Python version 2 and 3 releases as well, though\nsome older version 2.X code may not be able to run all the examples here. Although\nclass decorators are available in both Python 2.6 and 3.0, for example, you cannot use\nthem in an older Python 2.X that did not yet have this feature. See Tables P-1 and P-2\nlater in this Preface for summaries of 2.6 and 3.0 changes.\nShortly before going to press, this book was also augmented with notes\nabout prominent extensions in the upcoming Python 3.1 release—\ncomma separators and automatic field numbering in string format",
    "them in an older Python 2.X that did not yet have this feature. See Tables P-1 and P-2\nlater in this Preface for summaries of 2.6 and 3.0 changes.\nShortly before going to press, this book was also augmented with notes\nabout prominent extensions in the upcoming Python 3.1 release—\ncomma separators and automatic field numbering in string format\nmethod calls, multiple context manager syntax in with statements, new\nmethods for numbers, and so on. Because Python 3.1 was targeted primarily at optimization, this book applies directly to this new release as\nwell. In fact, because Python 3.1 supersedes 3.0, and because the latest\nPython is usually the best Python to fetch and use anyhow, in this book\nthe term “Python 3.0” generally refers to the language variations introduced by Python 3.0 but that are present in the entire 3.X line.",
    "New Chapters\nAlthough the main purpose of this edition is to update the examples and material from\nthe preceding edition for 3.0 and 2.6, I’ve also added five new chapters to address new\ntopics and add context:\n• Chapter 27 is a new class tutorial, using a more realistic example to explore the\nbasics of Python object-oriented programming (OOP).\n• Chapter 36 provides details on Unicode and byte strings and outlines string and\nfile differences between 3.0 and 2.6.\n• Chapter 37 collects managed attribute tools such as properties and provides new\ncoverage of descriptors.\n• Chapter 38 presents function and class decorators and works through comprehensive examples.\n• Chapter 39 covers metaclasses and compares and contrasts them with decorators.\nThe first of these chapters provides a gradual, step-by-step tutorial for using classes and\nOOP in Python. It’s based upon a live demonstration I have been using in recent years",
    "coverage of descriptors.\n• Chapter 38 presents function and class decorators and works through comprehensive examples.\n• Chapter 39 covers metaclasses and compares and contrasts them with decorators.\nThe first of these chapters provides a gradual, step-by-step tutorial for using classes and\nOOP in Python. It’s based upon a live demonstration I have been using in recent years\nin the training classes I teach, but has been honed here for use in a book. The chapter\nis designed to show OOP in a more realistic context than earlier examples and to",
    "Preface | xxxiii",
    "illustrate how class concepts come together into larger, working programs. I hope it\nworks as well here as it has in live classes.\nThe last four of these new chapters are collected in a new final part of the book, “Advanced Topics.” Although these are technically core language topics, not every Python\nprogrammer needs to delve into the details of Unicode text or metaclasses. Because of\nthis, these four chapters have been separated out into this new part, and are officially\noptional reading. The details of Unicode and binary data strings, for example, have been\nmoved to this final part because most programmers use simple ASCII strings and don’t\nneed to know about these topics. Similarly, decorators and metaclasses are specialist\ntopics that are usually of more interest to API builders than application programmers.\nIf you do use such tools, though, or use code that does, these new advanced topic",
    "moved to this final part because most programmers use simple ASCII strings and don’t\nneed to know about these topics. Similarly, decorators and metaclasses are specialist\ntopics that are usually of more interest to API builders than application programmers.\nIf you do use such tools, though, or use code that does, these new advanced topic\nchapters should help you master the basics. In addition, these chapters’ examples include case studies that tie core language concepts together, and they are more substantial than those in most of the rest of the book. Because this new part is optional\nreading, it has end-of-chapter quizzes but no end-of-part exercises.",
    "Changes to Existing Material\nIn addition, some material from the prior edition has been reorganized, or supplemented with new examples. Multiple inheritance, for instance, gets a new case study example that lists class trees in Chapter 30; new examples for generators that manually\nimplement map and zip are provided in Chapter 20; static and class methods are illustrated by new code in Chapter 31; package relative imports are captured in action in\nChapter 23; and the __contains__, __bool__, and __index__ operator overloading methods are illustrated by example now as well in Chapter 29, along with the new\noverloading protocols for slicing and comparison.\nThis edition also incorporates some reorganization for clarity. For instance, to accommodate new material and topics, and to avoid chapter topic overload, five prior chapters\nhave been split into two each here. The result is new standalone chapters on operator",
    "overloading protocols for slicing and comparison.\nThis edition also incorporates some reorganization for clarity. For instance, to accommodate new material and topics, and to avoid chapter topic overload, five prior chapters\nhave been split into two each here. The result is new standalone chapters on operator\noverloading, scopes and arguments, exception statement details, and comprehension\nand iteration topics. Some reordering has been done within the existing chapters as\nwell, to improve topic flow.\nThis edition also tries to minimize forward references with some reordering, though\nPython 3.0’s changes make this impossible in some cases: to understand printing and\nthe string format method, you now must know keyword arguments for functions; to\nunderstand dictionary key lists and key tests, you must now know iteration; to use\nexec to run code, you need to be able to use file objects; and so on. A linear reading",
    "Python 3.0’s changes make this impossible in some cases: to understand printing and\nthe string format method, you now must know keyword arguments for functions; to\nunderstand dictionary key lists and key tests, you must now know iteration; to use\nexec to run code, you need to be able to use file objects; and so on. A linear reading\nstill probably makes the most sense, but some topics may require nonlinear jumps and\nrandom lookups.\nAll told, there have been hundreds of changes in this edition. The next section’s tables\nalone document 27 additions and 57 changes in Python. In fact, it’s fair to say that this",
    "xxxiv | Preface\n\n\fedition is somewhat more advanced, because Python is somewhat more advanced. As\nfor Python 3.0 itself, though, you’re probably better off discovering most of this book’s\nchanges for yourself, rather than reading about them further in this Preface.",
    "Specific Language Extensions in 2.6 and 3.0\nIn general, Python 3.0 is a cleaner language, but it is also in some ways a more sophisticated language. In fact, some of its changes seem to assume you must already know\nPython in order to learn Python! The prior section outlined some of the more prominent\ncircular knowledge dependencies in 3.0; as a random example, the rationale for wrapping dictionary views in a list call is incredibly subtle and requires substantial foreknowledge. Besides teaching Python fundamentals, this book serves to help bridge this\nknowledge gap.\nTable P-1 lists the most prominent new language features covered in this edition, along\nwith the primary chapters in which they appear.\nTable P-1. Extensions in Python 2.6 and 3.0\nExtension\n\nCovered in chapter(s)\n\nThe print function in 3.0\n\n11\n\nThe nonlocal x,y statement in 3.0\n\n17\n\nThe str.format method in 2.6 and 3.0\n\n7\n\nString types in 3.0: str for Unicode text, bytes for binary data\n\n7, 36",
    "Covered in chapter(s)\n\nThe print function in 3.0\n\n11\n\nThe nonlocal x,y statement in 3.0\n\n17\n\nThe str.format method in 2.6 and 3.0\n\n7\n\nString types in 3.0: str for Unicode text, bytes for binary data\n\n7, 36\n\nText and binary file distinctions in 3.0\n\n9, 36\n\nClass decorators in 2.6 and 3.0: @private('age')\n\n31, 38\n\nNew iterators in 3.0: range, map, zip\n\n14, 20\n\nDictionary views in 3.0: D.keys, D.values, D.items\n\n8, 14\n\nDivision operators in 3.0: remainders, / and //\n\n5\n\nSet literals in 3.0: {a, b, c}\n\n5\n\nSet comprehensions in 3.0: {x**2 for x in seq}\n\n4, 5, 14, 20\n\nDictionary comprehensions in 3.0: {x: x**2 for x in seq}\n\n4, 8, 14, 20\n\nBinary digit-string support in 2.6 and 3.0: 0b0101, bin(I)\n\n5\n\nThe fraction number type in 2.6 and 3.0: Fraction(1, 3)\n\n5\n\nFunction annotations in 3.0: def f(a:99, b:str)->int\n\n19\n\nKeyword-only arguments in 3.0: def f(a, *b, c, **d)\n\n18, 20\n\nExtended sequence unpacking in 3.0: a, *b = seq\n\n11, 13\n\nRelative import syntax for packages enabled in 3.0: from .",
    "4, 8, 14, 20\n\nBinary digit-string support in 2.6 and 3.0: 0b0101, bin(I)\n\n5\n\nThe fraction number type in 2.6 and 3.0: Fraction(1, 3)\n\n5\n\nFunction annotations in 3.0: def f(a:99, b:str)->int\n\n19\n\nKeyword-only arguments in 3.0: def f(a, *b, c, **d)\n\n18, 20\n\nExtended sequence unpacking in 3.0: a, *b = seq\n\n11, 13\n\nRelative import syntax for packages enabled in 3.0: from .\n\n23\n\nContext managers enabled in 2.6 and 3.0: with/as\n\n33, 35\n\nException syntax changes in 3.0: raise, except/as, superclass\n\n33, 34\n\nPreface | xxxv\n\n\fExtension\n\nCovered in chapter(s)\n\nException chaining in 3.0: raise e2 from e1\n\n33\n\nReserved word changes in 2.6 and 3.0\n\n11\n\nNew-style class cutover in 3.0\n\n31\n\nProperty decorators in 2.6 and 3.0: @property\n\n37\n\nDescriptor use in 2.6 and 3.0\n\n31, 38\n\nMetaclass use in 2.6 and 3.0\n\n31, 39\n\nAbstract base classes support in 2.6 and 3.0\n\n28",
    "33, 34\n\nPreface | xxxv\n\n\fExtension\n\nCovered in chapter(s)\n\nException chaining in 3.0: raise e2 from e1\n\n33\n\nReserved word changes in 2.6 and 3.0\n\n11\n\nNew-style class cutover in 3.0\n\n31\n\nProperty decorators in 2.6 and 3.0: @property\n\n37\n\nDescriptor use in 2.6 and 3.0\n\n31, 38\n\nMetaclass use in 2.6 and 3.0\n\n31, 39\n\nAbstract base classes support in 2.6 and 3.0\n\n28\n\nSpecific Language Removals in 3.0\nIn addition to extensions, a number of language tools have been removed in 3.0 in an\neffort to clean up its design. Table P-2 summarizes the changes that impact this book,\ncovered in various chapters of this edition. Many of the removals listed in Table P-2\nhave direct replacements, some of which are also available in 2.6 to support future\nmigration to 3.0.\nTable P-2. Removals in Python 3.0 that impact this book\nRemoved\n\nReplacement\n\nCovered in chapter(s)\n\nreload(M)\n\nimp.reload(M) (or exec)\n\n3, 22\n\napply(f, ps, ks)\n\nf(*ps, **ks)\n\n18\n\n`X`\n\nrepr(X)\n\n5\n\nX <> Y\n\nX != Y\n\n5\n\nlong\n\nint\n\n5\n\n9999L",
    "Replacement\n\nCovered in chapter(s)\n\nreload(M)\n\nimp.reload(M) (or exec)\n\n3, 22\n\napply(f, ps, ks)\n\nf(*ps, **ks)\n\n18\n\n`X`\n\nrepr(X)\n\n5\n\nX <> Y\n\nX != Y\n\n5\n\nlong\n\nint\n\n5\n\n9999L\n\n9999\n\n5\n\nD.has_key(K)\n\nK in D (or D.get(key) != None)\n\n8\n\nraw_input\n\ninput\n\n3, 10\n\nold input\n\neval(input())\n\n3\n\nxrange\n\nrange\n\n14\n\nfile\n\nopen (and io module classes)\n\n9\n\nX.next\n\nX.__next__, called by next(X)\n\n14, 20, 29\n\nX.__getslice__\n\nX.__getitem__ passed a slice object\n\n7, 29\n\nX.__setslice__\n\nX.__setitem__ passed a slice object\n\n7, 29\n\nreduce\n\nfunctools.reduce (or loop code)\n\n14, 19\n\nexecfile(filename)\n\nexec(open(filename).read())\n\n3\n\nexec open(filename)\n\nexec(open(filename).read())\n\n3\n\n0777\n\n0o777\n\n5\n\nprint x, y\n\nprint(x, y)\n\n11\n\nxxxvi | Preface\n\n\fRemoved\n\nReplacement\n\nCovered in chapter(s)\n\nprint >> F, x, y\n\nprint(x, y, file=F)\n\n11\n\nprint x, y,\n\nprint(x, y, end=' ')\n\n11\n\nu'ccc'\n\n'ccc'\n\n7, 36\n\n'bbb' for byte strings\n\nb'bbb'\n\n7, 9, 36\n\nraise E, V\n\nraise E(V)\n\n32, 33, 34\n\nexcept E, X:\n\nexcept E as X:\n\n32, 33, 34",
    "3\n\nexec open(filename)\n\nexec(open(filename).read())\n\n3\n\n0777\n\n0o777\n\n5\n\nprint x, y\n\nprint(x, y)\n\n11\n\nxxxvi | Preface\n\n\fRemoved\n\nReplacement\n\nCovered in chapter(s)\n\nprint >> F, x, y\n\nprint(x, y, file=F)\n\n11\n\nprint x, y,\n\nprint(x, y, end=' ')\n\n11\n\nu'ccc'\n\n'ccc'\n\n7, 36\n\n'bbb' for byte strings\n\nb'bbb'\n\n7, 9, 36\n\nraise E, V\n\nraise E(V)\n\n32, 33, 34\n\nexcept E, X:\n\nexcept E as X:\n\n32, 33, 34\n\ndef f((a, b)):\n\ndef f(x): (a, b) = x\n\n11, 18, 20\n\nfile.xreadlines\n\nfor line in file: (or X=iter(file))\n\n13, 14\n\nD.keys(), etc. as lists\n\nlist(D.keys()) (dictionary views)\n\n8, 14\n\nmap(), range(), etc. as lists\n\nlist(map()), list(range()) (built-ins)\n\n14\n\nmap(None, ...)\n\nzip (or manual code to pad results)\n\n13, 20\n\nX=D.keys(); X.sort()\n\nsorted(D) (or list(D.keys()))\n\n4, 8, 14\n\ncmp(x, y)\n\n(x > y) - (x < y)\n\n29\n\nX.__cmp__(y)\n\n__lt__, __gt__, __eq__, etc.\n\n29\n\nX.__nonzero__\n\nX.__bool__\n\n29\n\nX.__hex__, X.__oct__\n\nX._index__\n\n29\n\nSort comparison functions\n\nUse key=transform or reverse=True\n\n8",
    "list(map()), list(range()) (built-ins)\n\n14\n\nmap(None, ...)\n\nzip (or manual code to pad results)\n\n13, 20\n\nX=D.keys(); X.sort()\n\nsorted(D) (or list(D.keys()))\n\n4, 8, 14\n\ncmp(x, y)\n\n(x > y) - (x < y)\n\n29\n\nX.__cmp__(y)\n\n__lt__, __gt__, __eq__, etc.\n\n29\n\nX.__nonzero__\n\nX.__bool__\n\n29\n\nX.__hex__, X.__oct__\n\nX._index__\n\n29\n\nSort comparison functions\n\nUse key=transform or reverse=True\n\n8\n\nDictionary <, >, <=, >=\n\nCompare sorted(D.items()) (or loop code)\n\n8, 9\n\ntypes.ListType\n\nlist (types is for nonbuilt-in names only)\n\n9\n\n__metaclass__ = M\n\nclass C(metaclass=M):\n\n28, 31, 39\n\n__builtin__\n\nbuiltins (renamed)\n\n17\n\nTkinter\n\ntkinter (renamed)\n\n18, 19, 24, 29, 30\n\nsys.exc_type, exc_value\n\nsys.exc_info()[0], [1]\n\n34, 35\n\nfunction.func_code\n\nfunction.__code__\n\n19, 38\n\n__getattr__ run by built-ins\n\nRedefine __X__ methods in wrapper classes\n\n30, 37, 38\n\n-t, –tt command-line switches\n\nInconsistent tabs/spaces use is always an error\n\n10, 12\n\nfrom ... *, within a function",
    "__builtin__\n\nbuiltins (renamed)\n\n17\n\nTkinter\n\ntkinter (renamed)\n\n18, 19, 24, 29, 30\n\nsys.exc_type, exc_value\n\nsys.exc_info()[0], [1]\n\n34, 35\n\nfunction.func_code\n\nfunction.__code__\n\n19, 38\n\n__getattr__ run by built-ins\n\nRedefine __X__ methods in wrapper classes\n\n30, 37, 38\n\n-t, –tt command-line switches\n\nInconsistent tabs/spaces use is always an error\n\n10, 12\n\nfrom ... *, within a function\n\nMay only appear at the top level of a file\n\n22\n\nimport mod, in same package\n\nfrom . import mod, package-relative form\n\n23\n\nclass MyException:\n\nclass MyException(Exception):\n\n34\n\nexceptions module\n\nBuilt-in scope, library manual\n\n34\n\nthread, Queue modules\n\n_thread, queue (both renamed)\n\n17\n\nanydbm module\n\ndbm (renamed)\n\n27\n\ncPickle module\n\n_pickle (renamed, used automatically)\n\n9\n\nos.popen2/3/4\n\nsubprocess.Popen (os.popen retained)\n\n14\n\nString-based exceptions\n\nClass-based exceptions (also required in 2.6)\n\n32, 33, 34\n\nPreface | xxxvii\n\n\fRemoved\n\nReplacement\n\nCovered in chapter(s)",
    "Built-in scope, library manual\n\n34\n\nthread, Queue modules\n\n_thread, queue (both renamed)\n\n17\n\nanydbm module\n\ndbm (renamed)\n\n27\n\ncPickle module\n\n_pickle (renamed, used automatically)\n\n9\n\nos.popen2/3/4\n\nsubprocess.Popen (os.popen retained)\n\n14\n\nString-based exceptions\n\nClass-based exceptions (also required in 2.6)\n\n32, 33, 34\n\nPreface | xxxvii\n\n\fRemoved\n\nReplacement\n\nCovered in chapter(s)\n\nString module functions\n\nString object methods\n\n7\n\nUnbound methods\n\nFunctions (staticmethod to call via instance)\n\n30, 31\n\nMixed type comparisons, sorts\n\nNonnumeric mixed type comparisons are errors\n\n5, 9",
    "There are additional changes in Python 3.0 that are not listed in this table, simply\nbecause they don’t affect this book. Changes in the standard library, for instance, might\nhave a larger impact on applications-focused books like Programming Python than they\ndo here; although most standard library functionality is still present, Python 3.0 takes\nfurther liberties with renaming modules, grouping them into packages, and so on. For\na more comprehensive list of changes in 3.0, see the “What’s New in Python 3.0”\ndocument in Python’s standard manual set.\nIf you are migrating from Python 2.X to Python 3.X, be sure to also see the 2to3 automatic code conversion script that is available with Python 3.0. It can’t translate everything, but it does a reasonable job of converting the majority of 2.X code to run under\n3.X. As I write this, a new 3to2 back-conversion project is also underway to translate\nPython 3.X code to run in 2.X environments. Either tool may prove useful if you must",
    "3.X. As I write this, a new 3to2 back-conversion project is also underway to translate\nPython 3.X code to run in 2.X environments. Either tool may prove useful if you must\nmaintain code for both Python lines; see the Web for details.\nBecause this fourth edition is mostly a fairly straightforward update for 3.0 with a\nhandful of new chapters, and because it’s only been two years since the prior edition\nwas published, the rest of this Preface is taken from the prior edition with only minor\nupdating.",
    "About The Third Edition\nIn the four years between the publication of the second and third editions of this book\nthere were substantial changes in Python itself, and in the topics I presented in Python\ntraining sessions. The third edition reflected these changes, and also incorporated a\nhandful of structural changes.\n\nThe Third Edition’s Python Language Changes\nOn the language front, the third edition was thoroughly updated to reflect Python 2.5\nand all changes to the language since the publication of the second edition in late 2003.\n(The second edition was based largely on Python 2.2, with some 2.3 features grafted\non at the end of the project.) In addition, discussions of anticipated changes in the\nupcoming Python 3.0 release were incorporated where appropriate. Here are some of\nthe major language topics for which new or expanded coverage was provided (chapter\nnumbers here have been updated to reflect the fourth edition):\n\nxxxviii | Preface",
    "• The new B if A else C conditional expression (Chapter 19)\n• with/as context managers (Chapter 33)\n• try/except/finally unification (Chapter 33)\n• Relative import syntax (Chapter 23)\n• Generator expressions (Chapter 20)\n• New generator function features (Chapter 20)\n• Function decorators (Chapter 31)\n• The set object type (Chapter 5)\n• New built-in functions: sorted, sum, any, all, enumerate (Chapters 13 and 14)\n• The decimal fixed-precision object type (Chapter 5)\n• Files, list comprehensions, and iterators (Chapters 14 and 20)\n• New development tools: Eclipse, distutils, unittest and doctest, IDLE enhancements, Shedskin, and so on (Chapters 2 and 35)\nSmaller language changes (for instance, the widespread use of True and False; the new\nsys.exc_info for fetching exception details; and the demise of string-based exceptions,\nstring methods, and the apply and reduce built-ins) are discussed throughout the book.",
    "• New development tools: Eclipse, distutils, unittest and doctest, IDLE enhancements, Shedskin, and so on (Chapters 2 and 35)\nSmaller language changes (for instance, the widespread use of True and False; the new\nsys.exc_info for fetching exception details; and the demise of string-based exceptions,\nstring methods, and the apply and reduce built-ins) are discussed throughout the book.\nThe third edition also expanded coverage of some of the features that were new in the\nsecond edition, including three-limit slices and the arbitrary arguments call syntax that\nsubsumed apply.",
    "The Third Edition’s Python Training Changes\nBesides such language changes, the third edition was augmented with new topics and\nexamples presented in my Python training sessions. Changes included (chapter numbers again updated to reflect those in the fourth edition):\n• A new chapter introducing built-in types (Chapter 4)\n• A new chapter introducing statement syntax (Chapter 10)\n• A new full chapter on dynamic typing, with enhanced coverage (Chapter 6)\n• An expanded OOP introduction (Chapter 25)\n• New examples for files, scopes, statement nesting, classes, exceptions, and more\nMany additions and changes were made with Python beginners in mind, and some\ntopics were moved to appear at the places where they proved simplest to digest in\ntraining classes. List comprehensions and iterators, for example, now make their initial\nappearance in conjunction with the for loop statement, instead of later with functional\ntools.\n\nPreface | xxxix",
    "Preface | xxxix\n\n\fCoverage of many original core language topics also was substantially expanded in the\nthird edition, with new discussions and examples added. Because this text has become\nsomething of a de facto standard resource for learning the core Python language, the\npresentation was made more complete and augmented with new use cases throughout.\nIn addition, a new set of Python tips and tricks, gleaned from 10 years of teaching classes\nand 15 years of using Python for real work, was incorporated, and the exercises were\nupdated and expanded to reflect current Python best practices, new language features,\nand common beginners’ mistakes witnessed firsthand in classes. Overall, the core language coverage was expanded.",
    "The Third Edition’s Structural Changes\nBecause the material was more complete, it was split into bite-sized chunks. The core\nlanguage material was organized into many multichapter parts to make it easier to\ntackle. Types and statements, for instance, are now two top-level parts, with one chapter for each major type and statement topic. Exercises and “gotchas” (common mistakes) were also moved from chapter ends to part ends, appearing at the end of the last\nchapter in each part.\nIn the third edition, I also augmented the end-of-part exercises with end-of-chapter\nsummaries and end-of-chapter quizzes to help you review chapters as you complete\nthem. Each chapter concludes with a set of questions to help you review and test your\nunderstanding of the chapter’s material. Unlike the end-of-part exercises, whose solutions are presented in Appendix B, the solutions to the end-of-chapter quizzes appear\nimmediately after the questions; I encourage you to look at the solutions even if you’re",
    "them. Each chapter concludes with a set of questions to help you review and test your\nunderstanding of the chapter’s material. Unlike the end-of-part exercises, whose solutions are presented in Appendix B, the solutions to the end-of-chapter quizzes appear\nimmediately after the questions; I encourage you to look at the solutions even if you’re\nsure you’ve answered the questions correctly because the answers are a sort of review\nin themselves.\nDespite all the new topics, the book is still oriented toward Python newcomers and is\ndesigned to be a first Python text for programmers. Because it is largely based on timetested training experience and materials, it can still serve as a self-paced introductory\nPython class.",
    "The Third Edition’s Scope Changes\nAs of its third edition, this book is intended as a tutorial on the core Python language,\nand nothing else. It’s about learning the language in an in-depth fashion, before applying it in application-level programming. The presentation here is bottom-up and\ngradual, but it provides a complete look at the entire language, in isolation from its\napplication roles.\nFor some, “learning Python” involves spending an hour or two going through a tutorial\non the Web. This works for already advanced programmers, up to a point; Python is,\nafter all, relatively simple in comparison to other languages. The problem with this fasttrack approach is that its practitioners eventually stumble onto unusual cases and get\nxl | Preface",
    "stuck—variables change out from under them, mutable default arguments mutate inexplicably, and so on. The goal here is instead to provide a solid grounding in Python\nfundamentals, so that even the unusual cases will make sense when they crop up.\nThis scope is deliberate. By restricting our gaze to language fundamentals, we can investigate them here in more satisfying depth. Other texts, described ahead, pick up\nwhere this book leaves off and provide a more complete look at application-level topics\nand additional reference materials. The purpose of the book you are reading now is\nsolely to teach Python itself so that you can apply it to whatever domain you happen\nto work in.\n\nAbout This Book\nThis section underscores some important points about this book in general, regardless\nof its edition number. No book addresses every possible audience, so it’s important to\nunderstand a book’s goals up front.",
    "This Book’s Prerequisites\nThere are no absolute prerequisites to speak of, really. Both true beginners and crusty\nprogramming veterans have used this book successfully. If you are motivated to learn\nPython, this text will probably work for you. In general, though, I have found that any\nexposure to programming or scripting before this book can be helpful, even if not\nrequired for every reader.\nThis book is designed to be an introductory-level Python text for programmers.* It may\nnot be an ideal text for someone who has never touched a computer before (for instance,\nwe’re not going to spend any time exploring what a computer is), but I haven’t made\nmany assumptions about your programming background or education.\nOn the other hand, I won’t insult readers by assuming they are “dummies,” either,\nwhatever that means—it’s easy to do useful things in Python, and this book will show\nyou how. The text occasionally contrasts Python with languages such as C, C++, Java,",
    "many assumptions about your programming background or education.\nOn the other hand, I won’t insult readers by assuming they are “dummies,” either,\nwhatever that means—it’s easy to do useful things in Python, and this book will show\nyou how. The text occasionally contrasts Python with languages such as C, C++, Java,\nand Pascal, but you can safely ignore these comparisons if you haven’t used such languages in the past.",
    "This Book’s Scope and Other Books\nAlthough this book covers all the essentials of the Python language, I’ve kept its scope\nnarrow in the interests of speed and size. To keep things simple, this book focuses on\ncore concepts, uses small and self-contained examples to illustrate points, and\n* And by “programmers,” I mean anyone who has written a single line of code in any programming or scripting\nlanguage in the past. If this doesn’t include you, you will probably find this book useful anyhow, but be aware\nthat it will spend more time teaching Python than programming fundamentals.\n\nPreface | xli",
    "sometimes omits the small details that are readily available in reference manuals. Because of that, this book is probably best described as an introduction and a steppingstone to more advanced and complete texts.\nFor example, we won’t talk much about Python/C integration—a complex topic that\nis nevertheless central to many Python-based systems. We also won’t talk much about\nPython’s history or development processes. And popular Python applications such as\nGUIs, system tools, and network scripting get only a short glance, if they are mentioned\nat all. Naturally, this scope misses some of the big picture.\nBy and large, Python is about raising the quality bar a few notches in the scripting world.\nSome of its ideas require more context than can be provided here, and I’d be remiss if\nI didn’t recommend further study after you finish this book. I hope that most readers",
    "at all. Naturally, this scope misses some of the big picture.\nBy and large, Python is about raising the quality bar a few notches in the scripting world.\nSome of its ideas require more context than can be provided here, and I’d be remiss if\nI didn’t recommend further study after you finish this book. I hope that most readers\nof this book will eventually go on to gain a more complete understanding of applicationlevel programming from other texts.\nBecause of its beginner’s focus, Learning Python is designed to be naturally complemented by O’Reilly’s other Python books. For instance, Programming Python, another\nbook I authored, provides larger and more complete examples, along with tutorials on\napplication programming techniques, and was explicitly designed to be a follow-up\ntext to the one you are reading now. Roughly, the current editions of Learning\nPython and Programming Python reflect the two halves of their author’s training",
    "book I authored, provides larger and more complete examples, along with tutorials on\napplication programming techniques, and was explicitly designed to be a follow-up\ntext to the one you are reading now. Roughly, the current editions of Learning\nPython and Programming Python reflect the two halves of their author’s training\nmaterials—the core language, and application programming. In addition, O’Reilly’s\nPython Pocket Reference serves as a quick reference supplement for looking up some\nof the finer details skipped here.\nOther follow-up books can also provide references, additional examples, or details\nabout using Python in specific domains such as the Web and GUIs. For instance,\nO’Reilly’s Python in a Nutshell and Sams’s Python Essential Reference serve as useful\nreferences, and O’Reilly’s Python Cookbook offers a library of self-contained examples\nfor people already familiar with application programming techniques. Because reading",
    "about using Python in specific domains such as the Web and GUIs. For instance,\nO’Reilly’s Python in a Nutshell and Sams’s Python Essential Reference serve as useful\nreferences, and O’Reilly’s Python Cookbook offers a library of self-contained examples\nfor people already familiar with application programming techniques. Because reading\nbooks is such a subjective experience, I encourage you to browse on your own to find\nadvanced texts that suit your needs. Regardless of which books you choose, though,\nkeep in mind that the rest of the Python story requires studying examples that are more\nrealistic than there is space for here.\nHaving said that, I think you’ll find this book to be a good first text on Python, despite\nits limited scope (and perhaps because of it). You’ll learn everything you need to get\nstarted writing useful standalone Python programs and scripts. By the time you’ve finished this book, you will have learned not only the language itself, but also how to apply",
    "realistic than there is space for here.\nHaving said that, I think you’ll find this book to be a good first text on Python, despite\nits limited scope (and perhaps because of it). You’ll learn everything you need to get\nstarted writing useful standalone Python programs and scripts. By the time you’ve finished this book, you will have learned not only the language itself, but also how to apply\nit well to your day-to-day tasks. And you’ll be equipped to tackle more advanced topics\nand examples as they come your way.",
    "xlii | Preface",
    "This Book’s Style and Structure\nThis book is based on training materials developed for a three-day hands-on Python\ncourse. You’ll find quizzes at the end of each chapter, and exercises at the end of the\nlast chapter of each part. Solutions to chapter quizzes appear in the chapters themselves,\nand solutions to part exercises show up in Appendix B. The quizzes are designed to\nreview material, while the exercises are designed to get you coding right away and are\nusually one of the highlights of the course.\nI strongly recommend working through the quizzes and exercises along the way, not\nonly to gain Python programming experience, but also because some of the exercises\nraise issues not covered elsewhere in the book. The solutions in the chapters and in\nAppendix B should help you if you get stuck (and you are encouraged to peek at the\nanswers as much and as often as you like).\nThe overall structure of this book is also derived from class materials. Because this text",
    "only to gain Python programming experience, but also because some of the exercises\nraise issues not covered elsewhere in the book. The solutions in the chapters and in\nAppendix B should help you if you get stuck (and you are encouraged to peek at the\nanswers as much and as often as you like).\nThe overall structure of this book is also derived from class materials. Because this text\nis designed to introduce language basics quickly, I’ve organized the presentation by\nmajor language features, not examples. We’ll take a bottom-up approach here: from\nbuilt-in object types, to statements, to program units, and so on. Each chapter is fairly\nself-contained, but later chapters draw upon ideas introduced in earlier ones (e.g., by\nthe time we get to classes, I’ll assume you know how to write functions), so a linear\nreading makes the most sense for most readers.",
    "major language features, not examples. We’ll take a bottom-up approach here: from\nbuilt-in object types, to statements, to program units, and so on. Each chapter is fairly\nself-contained, but later chapters draw upon ideas introduced in earlier ones (e.g., by\nthe time we get to classes, I’ll assume you know how to write functions), so a linear\nreading makes the most sense for most readers.\nIn general terms, this book presents the Python language in a linear fashion. It is organized with one part per major language feature—types, functions, and so forth—and\nmost of the examples are small and self-contained (some might also call the examples\nin this text artificial, but they illustrate the points it aims to make). More specifically,\nhere is what you will find:\nPart I, Getting Started\nWe begin with a general overview of Python that answers commonly asked initial\nquestions—why people use the language, what it’s useful for, and so on. The first",
    "most of the examples are small and self-contained (some might also call the examples\nin this text artificial, but they illustrate the points it aims to make). More specifically,\nhere is what you will find:\nPart I, Getting Started\nWe begin with a general overview of Python that answers commonly asked initial\nquestions—why people use the language, what it’s useful for, and so on. The first\nchapter introduces the major ideas underlying the technology to give you some\nbackground context. Then the technical material of the book begins, as we explore\nthe ways that both we and Python run programs. The goal of this part of the book\nis to give you just enough information to be able to follow along with later examples\nand exercises.\nPart II, Types and Operations\nNext, we begin our tour of the Python language, studying Python’s major built-in\nobject types in depth: numbers, lists, dictionaries, and so on. You can get a lot done",
    "the ways that both we and Python run programs. The goal of this part of the book\nis to give you just enough information to be able to follow along with later examples\nand exercises.\nPart II, Types and Operations\nNext, we begin our tour of the Python language, studying Python’s major built-in\nobject types in depth: numbers, lists, dictionaries, and so on. You can get a lot done\nin Python with these tools alone. This is the most substantial part of the book\nbecause we lay groundwork here for later chapters. We’ll also look at dynamic\ntyping and its references—keys to using Python well—in this part.",
    "Preface | xliii",
    "Part III, Statements and Syntax\nThe next part moves on to introduce Python’s statements—the code you type to\ncreate and process objects in Python. It also presents Python’s general syntax\nmodel. Although this part focuses on syntax, it also introduces some related tools,\nsuch as the PyDoc system, and explores coding alternatives.\nPart IV, Functions\nThis part begins our look at Python’s higher-level program structure tools. Functions turn out to be a simple way to package code for reuse and avoid code redundancy. In this part, we will explore Python’s scoping rules, argument-passing\ntechniques, and more.\nPart V, Modules\nPython modules let you organize statements and functions into larger components,\nand this part illustrates how to create, use, and reload modules. We’ll also look at\nsome more advanced topics here, such as module packages, module reloading, and\nthe __name__ variable.\nPart VI, Classes and OOP",
    "techniques, and more.\nPart V, Modules\nPython modules let you organize statements and functions into larger components,\nand this part illustrates how to create, use, and reload modules. We’ll also look at\nsome more advanced topics here, such as module packages, module reloading, and\nthe __name__ variable.\nPart VI, Classes and OOP\nHere, we explore Python’s object-oriented programming tool, the class—an optional but powerful way to structure code for customization and reuse. As you’ll\nsee, classes mostly reuse ideas we will have covered by this point in the book, and\nOOP in Python is mostly about looking up names in linked objects. As you’ll also\nsee, OOP is optional in Python, but it can shave development time substantially,\nespecially for long-term strategic project development.\nPart VII, Exceptions and Tools",
    "see, classes mostly reuse ideas we will have covered by this point in the book, and\nOOP in Python is mostly about looking up names in linked objects. As you’ll also\nsee, OOP is optional in Python, but it can shave development time substantially,\nespecially for long-term strategic project development.\nPart VII, Exceptions and Tools\nWe conclude the language fundamentals coverage in this text with a look at Python’s exception handling model and statements, plus a brief overview of development tools that will become more useful when you start writing larger programs\n(debugging and testing tools, for instance). Although exceptions are a fairly lightweight tool, this part appears after the discussion of classes because exceptions\nshould now all be classes.\nPart VIII, Advanced Topics (new in the fourth edition)\nIn the final part, we explore some advanced topics. Here, we study Unicode and\nbyte strings, managed attribute tools like properties and descriptors, function and",
    "should now all be classes.\nPart VIII, Advanced Topics (new in the fourth edition)\nIn the final part, we explore some advanced topics. Here, we study Unicode and\nbyte strings, managed attribute tools like properties and descriptors, function and\nclass decorators, and metaclasses. These chapters are all optional reading, because\nnot all programmers need to understand the subjects they address. On the other\nhand, readers who must process internationalized text or binary data, or are responsible for developing APIs for other programmers to use, should find something\nof interest in this part.\nPart IX, Appendixes\nThe book wraps up with a pair of appendixes that give platform-specific tips for\nusing Python on various computers (Appendix A) and provide solutions to the endof-part exercises (Appendix B). Solutions to end-of-chapter quizzes appear in the\nchapters themselves.",
    "xliv | Preface\n\n\fNote that the index and table of contents can be used to hunt for details, but there are\nno reference appendixes in this book (this book is a tutorial, not a reference). As mentioned earlier, you can consult Python Pocket Reference, as well as other books, and the\nfree Python reference manuals maintained at http://www.python.org for syntax and\nbuilt-in tool details.",
    "Book Updates\nImprovements happen (and so do mis^H^H^H typos). Updates, supplements, and corrections for this book will be maintained (or referenced) on the Web at one of the\nfollowing sites:\nhttp://www.oreilly.com/catalog/9780596158064 (O’Reilly’s web page for the book)\nhttp://www.rmi.net/~lutz (the author’s site)\nhttp://www.rmi.net/~lutz/about-lp.html (the author’s web page for the book)\nThe last of these three URLs points to a web page for this book where I will post updates,\nbut be sure to search the Web if this link becomes invalid. If I could become more\nclairvoyant, I would, but the Web changes faster than printed books.",
    "About the Programs in This Book\nThis fourth edition of this book, and all the program examples in it, is based on Python\nversion 3.0. In addition, most of its examples run under Python 2.6, as described in the\ntext, and notes for Python 2.6 readers are mixed in along the way.\nBecause this text focuses on the core language, however, you can be fairly sure that\nmost of what it has to say won’t change very much in future releases of Python. Most\nof this book applies to earlier Python versions, too, except when it does not; naturally,\nif you try using extensions added after the release you’ve got, all bets are off.\nAs a rule of thumb, the latest Python is the best Python. Because this book focuses on\nthe core language, most of it also applies to Jython, the Java-based Python language\nimplementation, as well as other Python implementations described in Chapter 2.\nSource code for the book’s examples, as well as exercise solutions, can be fetched from",
    "As a rule of thumb, the latest Python is the best Python. Because this book focuses on\nthe core language, most of it also applies to Jython, the Java-based Python language\nimplementation, as well as other Python implementations described in Chapter 2.\nSource code for the book’s examples, as well as exercise solutions, can be fetched from\nthe book’s website at http://www.oreilly.com/catalog/9780596158064/. So, how do you\nrun the examples? We’ll study startup details in Chapter 3, so please stay tuned for\ninformation on this front.",
    "Using Code Examples\nThis book is here to help you get your job done. In general, you may use the code in\nthis book in your programs and documentation. You do not need to contact us for\npermission unless you’re reproducing a significant portion of the code. For example,\n\nPreface | xlv",
    "Preface | xlv\n\n\fwriting a program that uses several chunks of code from this book does not require\npermission. Selling or distributing a CD-ROM of examples from O’Reilly books does\nrequire permission. Answering a question by citing this book and quoting example\ncode does not require permission. Incorporating a significant amount of example code\nfrom this book into your product’s documentation does require permission.\nWe appreciate, but do not require, attribution. An attribution usually includes the title,\nauthor, publisher, and ISBN. For example: “Learning Python, Fourth Edition, by Mark\nLutz. Copyright 2009 Mark Lutz, 978-0-596-15806-4.”\nIf you feel your use of code examples falls outside fair use or the permission given above,\nfeel free to contact us at permissions@oreilly.com.\n\nFont Conventions\nThis book uses the following typographical conventions:\nItalic\nUsed for email addresses, URLs, filenames, pathnames, and emphasizing new\nterms when they are first introduced\nConstant width",
    "Font Conventions\nThis book uses the following typographical conventions:\nItalic\nUsed for email addresses, URLs, filenames, pathnames, and emphasizing new\nterms when they are first introduced\nConstant width\n\nUsed for the contents of files and the output from commands, and to designate\nmodules, methods, statements, and commands\nConstant width bold\n\nUsed in code sections to show commands or text that would be typed by the user,\nand, occasionally, to highlight portions of code\nConstant width italic\n\nUsed for replaceables and some comments in code sections\n<Constant width>\n\nIndicates a syntactic unit that should be replaced with real code\nIndicates a tip, suggestion, or general note relating to the nearby text.\n\nIndicates a warning or caution relating to the nearby text.\n\nxlvi | Preface",
    "Used for replaceables and some comments in code sections\n<Constant width>\n\nIndicates a syntactic unit that should be replaced with real code\nIndicates a tip, suggestion, or general note relating to the nearby text.\n\nIndicates a warning or caution relating to the nearby text.\n\nxlvi | Preface\n\n\fNotes specific to this book: In this book’s examples, the % character at\nthe start of a system command line stands for the system’s prompt,\nwhatever that may be on your machine (e.g., C:\\Python30> in a DOS\nwindow). Don’t type the % character (or the system prompt it sometimes\nstands for) yourself.\nSimilarly, in interpreter interaction listings, do not type the >>>\nand ... characters shown at the start of lines—these are prompts that\nPython displays. Type just the text after these prompts. To help you\nremember this, user inputs are shown in bold font in this book.\nAlso, you normally don’t need to type text that starts with a # in listings;\nas you’ll learn, these are comments, not executable code.",
    "Safari® Books Online\nSafari Books Online is an on-demand digital library that lets you easily\nsearch over 7,500 technology and creative reference books and videos to\nfind the answers you need quickly.\nWith a subscription, you can read any page and watch any video from our library online.\nRead books on your cell phone and mobile devices. Access new titles before they are\navailable for print, and get exclusive access to manuscripts in development and post\nfeedback for the authors. Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from\ntons of other time-saving features.\nO’Reilly Media has uploaded this book to the Safari Books Online service. To have full\ndigital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com.",
    "How to Contact Us\nPlease address comments and questions concerning this book to the publisher:\nO’Reilly Media, Inc.\n1005 Gravenstein Highway North\nSebastopol, CA 95472\n800-998-9938 (in the United States or Canada)\n707-829-0515 (international or local)\n707-829-0104 (fax)\nWe will also maintain a web page for this book, where we list errata, examples, and\nany additional information. You can access this page at:\nhttp://www.oreilly.com/catalog/9780596158064/\n\nPreface | xlvii\n\n\fTo comment or ask technical questions about this book, send email to:\nbookquestions@oreilly.com\nFor more information about our books, conferences, Resource Centers, and the\nO’Reilly Network, see our website at:\nhttp://www.oreilly.com\nFor book updates, be sure to also see the other links mentioned earlier in this Preface.",
    "Acknowledgments\nAs I write this fourth edition of this book in 2009, I can’t help but be in a sort of “mission\naccomplished” state of mind. I have now been using and promoting Python for 17 years,\nand have been teaching it for 12 years. Despite the passage of time and events, I am still\nconstantly amazed at how successful Python has been over the years. It has grown in\nways that most of us could not possibly have imagined in 1992. So, at the risk of\nsounding like a hopelessly self-absorbed author, you’ll have to pardon a few words of\nreminiscing, congratulations, and thanks here.\nIt’s been the proverbial long and winding road. Looking back today, when I first discovered Python in 1992, I had no idea what an impact it would have on the next 17\nyears of my life. Two years after writing the first edition of Programming Python in\n1995, I began traveling around the country and the world teaching Python to beginners",
    "reminiscing, congratulations, and thanks here.\nIt’s been the proverbial long and winding road. Looking back today, when I first discovered Python in 1992, I had no idea what an impact it would have on the next 17\nyears of my life. Two years after writing the first edition of Programming Python in\n1995, I began traveling around the country and the world teaching Python to beginners\nand experts. Since finishing the first edition of Learning Python in 1999, I’ve been an\nindependent Python trainer and writer, thanks largely to Python’s exponential growth\nin popularity.\nAs I write these words in mid-2009, I have written 12 Python books (4 editions of 3).\nI have also been teaching Python for more than a decade; have taught some 225 Python\ntraining sessions in the U.S., Europe, Canada, and Mexico; and have met over 3,000\nstudents along the way. Besides racking up frequent flyer miles, these classes helped\nme refine this text as well as my other Python books. Over the years, teaching honed",
    "I have also been teaching Python for more than a decade; have taught some 225 Python\ntraining sessions in the U.S., Europe, Canada, and Mexico; and have met over 3,000\nstudents along the way. Besides racking up frequent flyer miles, these classes helped\nme refine this text as well as my other Python books. Over the years, teaching honed\nthe books, and vice versa. In fact, the book you’re reading is derived almost entirely\nfrom my classes.\nBecause of this, I’d like to thank all the students who have participated in my courses\nduring the last 12 years. Along with changes in Python itself, your feedback played a\nhuge role in shaping this text. (There’s nothing quite as instructive as watching 3,000\nstudents repeat the same beginner’s mistakes!) This edition owes its changes primarily\nto classes held after 2003, though every class held since 1997 has in some way helped\nrefine this book. I’d especially like to single out clients who hosted classes in Dublin,",
    "huge role in shaping this text. (There’s nothing quite as instructive as watching 3,000\nstudents repeat the same beginner’s mistakes!) This edition owes its changes primarily\nto classes held after 2003, though every class held since 1997 has in some way helped\nrefine this book. I’d especially like to single out clients who hosted classes in Dublin,\nMexico City, Barcelona, London, Edmonton, and Puerto Rico; better perks would be\nhard to imagine.\nI’d also like to express my gratitude to everyone who played a part in producing this\nbook. To the editors who worked on this project: Julie Steele on this edition, Tatiana\nxlviii | Preface",
    "Apandi on the prior edition, and many others on earlier editions. To Doug Hellmann\nand Jesse Noller for taking part in the technical review of this book. And to O’Reilly\nfor giving me a chance to work on those 12 book projects—it’s been net fun (and only\nfeels a little like the movie Groundhog Day).\nI want to thank my original coauthor David Ascher as well for his work on the first two\neditions of this book. David contributed the “Outer Layers” part in prior editions,\nwhich we unfortunately had to trim to make room for new core language materials in\nthe third edition. To compensate, I added a handful of more advanced programs as a\nself-study final exercise in the third edition, and added both new advanced examples\nand a new complete part for advanced topics in the fourth edition. Also see the prior\nnotes in this Preface about follow-up application-level texts you may want to consult\nonce you’ve learned the fundamentals here.",
    "the third edition. To compensate, I added a handful of more advanced programs as a\nself-study final exercise in the third edition, and added both new advanced examples\nand a new complete part for advanced topics in the fourth edition. Also see the prior\nnotes in this Preface about follow-up application-level texts you may want to consult\nonce you’ve learned the fundamentals here.\nFor creating such an enjoyable and useful language, I owe additional thanks to Guido\nvan Rossum and the rest of the Python community. Like most open source systems,\nPython is the product of many heroic efforts. After 17 years of programming Python, I\nstill find it to be seriously fun. It’s been my privilege to watch Python grow from a new\nkid on the scripting languages block to a widely used tool, deployed in some fashion\nby almost every organization writing software. That has been an exciting endeavor to\nbe a part of, and I’d like to thank and congratulate the entire Python community for a\njob well done.",
    "still find it to be seriously fun. It’s been my privilege to watch Python grow from a new\nkid on the scripting languages block to a widely used tool, deployed in some fashion\nby almost every organization writing software. That has been an exciting endeavor to\nbe a part of, and I’d like to thank and congratulate the entire Python community for a\njob well done.\nI also want to thank my original editor at O’Reilly, the late Frank Willison. This book\nwas largely Frank’s idea, and it reflects the contagious vision he had. In looking back,\nFrank had a profound impact on both my own career and that of Python itself. It is not\nan exaggeration to say that Frank was responsible for much of the fun and success of\nPython when it was new. We still miss him.\nFinally, a few personal notes of thanks. To OQO for the best toys so far (while they\nlasted). To the late Carl Sagan for inspiring an 18-year-old kid from Wisconsin. To my",
    "Frank had a profound impact on both my own career and that of Python itself. It is not\nan exaggeration to say that Frank was responsible for much of the fun and success of\nPython when it was new. We still miss him.\nFinally, a few personal notes of thanks. To OQO for the best toys so far (while they\nlasted). To the late Carl Sagan for inspiring an 18-year-old kid from Wisconsin. To my\nMom, for courage. And to all the large corporations I’ve come across over the years,\nfor reminding me how lucky I have been to be self-employed for the last decade!\nTo my children, Mike, Sammy, and Roxy, for whatever futures you will choose to make.\nYou were children when I began with Python, and you seem to have somehow grown\nup along the way; I’m proud of you. Life may compel us down paths all our own, but\nthere will always be a path home.\nAnd most of all, to Vera, my best friend, my girlfriend, and my wife. The best day of",
    "To my children, Mike, Sammy, and Roxy, for whatever futures you will choose to make.\nYou were children when I began with Python, and you seem to have somehow grown\nup along the way; I’m proud of you. Life may compel us down paths all our own, but\nthere will always be a path home.\nAnd most of all, to Vera, my best friend, my girlfriend, and my wife. The best day of\nmy life was the day I finally found you. I don’t know what the next 50 years hold, but\nI do know that I want to spend all of them holding you.\n—Mark Lutz\nSarasota, Florida\nJuly 2009",
    "Preface | xlix\n\n\f\fPART I\n\nGetting Started\n\n\f\fCHAPTER 1\n\nA Python Q&A Session\n\nIf you’ve bought this book, you may already know what Python is and why it’s an\nimportant tool to learn. If you don’t, you probably won’t be sold on Python until you’ve\nlearned the language by reading the rest of this book and have done a project or two.\nBut before we jump into details, the first few pages of this book will briefly introduce\nsome of the main reasons behind Python’s popularity. To begin sculpting a definition\nof Python, this chapter takes the form of a question-and-answer session, which poses\nsome of the most common questions asked by beginners.",
    "Why Do People Use Python?\nBecause there are many programming languages available today, this is the usual first\nquestion of newcomers. Given that there are roughly 1 million Python users out there\nat the moment, there really is no way to answer this question with complete accuracy;\nthe choice of development tools is sometimes based on unique constraints or personal\npreference.\nBut after teaching Python to roughly 225 groups and over 3,000 students during the\nlast 12 years, some common themes have emerged. The primary factors cited by Python\nusers seem to be these:\nSoftware quality\nFor many, Python’s focus on readability, coherence, and software quality in general\nsets it apart from other tools in the scripting world. Python code is designed to be\nreadable, and hence reusable and maintainable—much more so than traditional\nscripting languages. The uniformity of Python code makes it easy to understand,\neven if you did not write it. In addition, Python has deep support for more advanced",
    "sets it apart from other tools in the scripting world. Python code is designed to be\nreadable, and hence reusable and maintainable—much more so than traditional\nscripting languages. The uniformity of Python code makes it easy to understand,\neven if you did not write it. In addition, Python has deep support for more advanced\nsoftware reuse mechanisms, such as object-oriented programming (OOP).\nDeveloper productivity\nPython boosts developer productivity many times beyond compiled or statically\ntyped languages such as C, C++, and Java. Python code is typically one-third to\none-fifth the size of equivalent C++ or Java code. That means there is less to type,\n3",
    "less to debug, and less to maintain after the fact. Python programs also run immediately, without the lengthy compile and link steps required by some other tools,\nfurther boosting programmer speed.\nProgram portability\nMost Python programs run unchanged on all major computer platforms. Porting\nPython code between Linux and Windows, for example, is usually just a matter of\ncopying a script’s code between machines. Moreover, Python offers multiple options for coding portable graphical user interfaces, database access programs, webbased systems, and more. Even operating system interfaces, including program\nlaunches and directory processing, are as portable in Python as they can possibly\nbe.\nSupport libraries\nPython comes with a large collection of prebuilt and portable functionality, known\nas the standard library. This library supports an array of application-level programming tasks, from text pattern matching to network scripting. In addition,",
    "launches and directory processing, are as portable in Python as they can possibly\nbe.\nSupport libraries\nPython comes with a large collection of prebuilt and portable functionality, known\nas the standard library. This library supports an array of application-level programming tasks, from text pattern matching to network scripting. In addition,\nPython can be extended with both homegrown libraries and a vast collection of\nthird-party application support software. Python’s third-party domain offers tools\nfor website construction, numeric programming, serial port access, game development, and much more. The NumPy extension, for instance, has been described\nas a free and more powerful equivalent to the Matlab numeric programming\nsystem.\nComponent integration\nPython scripts can easily communicate with other parts of an application, using a\nvariety of integration mechanisms. Such integrations allow Python to be used as a",
    "as a free and more powerful equivalent to the Matlab numeric programming\nsystem.\nComponent integration\nPython scripts can easily communicate with other parts of an application, using a\nvariety of integration mechanisms. Such integrations allow Python to be used as a\nproduct customization and extension tool. Today, Python code can invoke C and\nC++ libraries, can be called from C and C++ programs, can integrate with Java\nand .NET components, can communicate over frameworks such as COM, can\ninterface with devices over serial ports, and can interact over networks with interfaces like SOAP, XML-RPC, and CORBA. It is not a standalone tool.\nEnjoyment\nBecause of Python’s ease of use and built-in toolset, it can make the act of programming more pleasure than chore. Although this may be an intangible benefit,\nits effect on productivity is an important asset.\nOf these factors, the first two (quality and productivity) are probably the most compelling benefits to most Python users.",
    "Software Quality\nBy design, Python implements a deliberately simple and readable syntax and a highly\ncoherent programming model. As a slogan at a recent Python conference attests, the\nnet result is that Python seems to “fit your brain”—that is, features of the language\ninteract in consistent and limited ways and follow naturally from a small set of core\n4 | Chapter 1: A Python Q&A Session",
    "concepts. This makes the language easier to learn, understand, and remember. In practice, Python programmers do not need to constantly refer to manuals when reading or\nwriting code; it’s a consistently designed system that many find yields surprisingly\nregular-looking code.\nBy philosophy, Python adopts a somewhat minimalist approach. This means that although there are usually multiple ways to accomplish a coding task, there is usually\njust one obvious way, a few less obvious alternatives, and a small set of coherent interactions everywhere in the language. Moreover, Python doesn’t make arbitrary decisions for you; when interactions are ambiguous, explicit intervention is preferred over\n“magic.” In the Python way of thinking, explicit is better than implicit, and simple is\nbetter than complex.*\nBeyond such design themes, Python includes tools such as modules and OOP that\nnaturally promote code reusability. And because Python is focused on quality, so too,",
    "“magic.” In the Python way of thinking, explicit is better than implicit, and simple is\nbetter than complex.*\nBeyond such design themes, Python includes tools such as modules and OOP that\nnaturally promote code reusability. And because Python is focused on quality, so too,\nnaturally, are Python programmers.",
    "Developer Productivity\nDuring the great Internet boom of the mid-to-late 1990s, it was difficult to find enough\nprogrammers to implement software projects; developers were asked to implement\nsystems as fast as the Internet evolved. Today, in an era of layoffs and economic recession, the picture has shifted. Programming staffs are often now asked to accomplish\nthe same tasks with even fewer people.\nIn both of these scenarios, Python has shined as a tool that allows programmers to get\nmore done with less effort. It is deliberately optimized for speed of development—its\nsimple syntax, dynamic typing, lack of compile steps, and built-in toolset allow programmers to develop programs in a fraction of the time needed when using some other\ntools. The net effect is that Python typically boosts developer productivity many times\nbeyond the levels supported by traditional languages. That’s good news in both boom\nand bust times, and everywhere the software industry goes in between.",
    "Is Python a “Scripting Language”?\nPython is a general-purpose programming language that is often applied in scripting\nroles. It is commonly defined as an object-oriented scripting language—a definition that\nblends support for OOP with an overall orientation toward scripting roles. In fact,\npeople often use the word “script” instead of “program” to describe a Python code file.\nIn this book, the terms “script” and “program” are used interchangeably, with a slight\n\n* For a more complete look at the Python philosophy, type the command import this at any Python interactive\nprompt (you’ll see how in Chapter 2). This invokes an “Easter egg” hidden in Python—a collection of design\nprinciples underlying Python. The acronym EIBTI is now fashionable jargon for the “explicit is better than\nimplicit” rule.\n\nIs Python a “Scripting Language”? | 5",
    "preference for “script” to describe a simpler top-level file and “program” to refer to a\nmore sophisticated multifile application.\nBecause the term “scripting language” has so many different meanings to different\nobservers, some would prefer that it not be applied to Python at all. In fact, people tend\nto make three very different associations, some of which are more useful than others,\nwhen they hear Python labeled as such:\nShell tools\nSometimes when people hear Python described as a scripting language, they think\nit means that Python is a tool for coding operating-system-oriented scripts. Such\nprograms are often launched from console command lines and perform tasks such\nas processing text files and launching other programs.\nPython programs can and do serve such roles, but this is just one of dozens of\ncommon Python application domains. It is not just a better shell-script language.\nControl language",
    "it means that Python is a tool for coding operating-system-oriented scripts. Such\nprograms are often launched from console command lines and perform tasks such\nas processing text files and launching other programs.\nPython programs can and do serve such roles, but this is just one of dozens of\ncommon Python application domains. It is not just a better shell-script language.\nControl language\nTo others, scripting refers to a “glue” layer used to control and direct (i.e., script)\nother application components. Python programs are indeed often deployed in the\ncontext of larger applications. For instance, to test hardware devices, Python programs may call out to components that give low-level access to a device. Similarly,\nprograms may run bits of Python code at strategic points to support end-user\nproduct customization without the need to ship and recompile the entire system’s\nsource code.\nPython’s simplicity makes it a naturally flexible control tool. Technically, though,",
    "programs may run bits of Python code at strategic points to support end-user\nproduct customization without the need to ship and recompile the entire system’s\nsource code.\nPython’s simplicity makes it a naturally flexible control tool. Technically, though,\nthis is also just a common Python role; many (perhaps most) Python programmers\ncode standalone scripts without ever using or knowing about any integrated components. It is not just a control language.\nEase of use\nProbably the best way to think of the term “scripting language” is that it refers to\na simple language used for quickly coding tasks. This is especially true when the\nterm is applied to Python, which allows much faster program development than\ncompiled languages like C++. Its rapid development cycle fosters an exploratory,\nincremental mode of programming that has to be experienced to be appreciated.\nDon’t be fooled, though—Python is not just for simple tasks. Rather, it makes tasks",
    "term is applied to Python, which allows much faster program development than\ncompiled languages like C++. Its rapid development cycle fosters an exploratory,\nincremental mode of programming that has to be experienced to be appreciated.\nDon’t be fooled, though—Python is not just for simple tasks. Rather, it makes tasks\nsimple by its ease of use and flexibility. Python has a simple feature set, but it allows\nprograms to scale up in sophistication as needed. Because of that, it is commonly\nused for quick tactical tasks and longer-term strategic development.\nSo, is Python a scripting language or not? It depends on whom you ask. In general, the\nterm “scripting” is probably best used to describe the rapid and flexible mode of development that Python supports, rather than a particular application domain.",
    "6 | Chapter 1: A Python Q&A Session",
    "OK, but What’s the Downside?\nAfter using it for 17 years and teaching it for 12, the only downside to Python I’ve found\nis that, as currently implemented, its execution speed may not always be as fast as that\nof compiled languages such as C and C++.\nWe’ll talk about implementation concepts in detail later in this book. In short, the\nstandard implementations of Python today compile (i.e., translate) source code statements to an intermediate format known as byte code and then interpret the byte code.\nByte code provides portability, as it is a platform-independent format. However, because Python is not compiled all the way down to binary machine code (e.g., instructions for an Intel chip), some programs will run more slowly in Python than in a fully\ncompiled language like C.\nWhether you will ever care about the execution speed difference depends on what kinds\nof programs you write. Python has been optimized numerous times, and Python code",
    "compiled language like C.\nWhether you will ever care about the execution speed difference depends on what kinds\nof programs you write. Python has been optimized numerous times, and Python code\nruns fast enough by itself in most application domains. Furthermore, whenever you do\nsomething “real” in a Python script, like processing a file or constructing a graphical\nuser interface (GUI), your program will actually run at C speed, since such tasks are\nimmediately dispatched to compiled C code inside the Python interpreter. More fundamentally, Python’s speed-of-development gain is often far more important than any\nspeed-of-execution loss, especially given modern computer speeds.\nEven at today’s CPU speeds, though, there still are some domains that do require optimal execution speeds. Numeric programming and animation, for example, often need\nat least their core number-crunching components to run at C speed (or better). If you",
    "speed-of-execution loss, especially given modern computer speeds.\nEven at today’s CPU speeds, though, there still are some domains that do require optimal execution speeds. Numeric programming and animation, for example, often need\nat least their core number-crunching components to run at C speed (or better). If you\nwork in such a domain, you can still use Python—simply split off the parts of the\napplication that require optimal speed into compiled extensions, and link those into\nyour system for use in Python scripts.\nWe won’t talk about extensions much in this text, but this is really just an instance of\nthe Python-as-control-language role we discussed earlier. A prime example of this dual\nlanguage strategy is the NumPy numeric programming extension for Python; by combining compiled and optimized numeric extension libraries with the Python language,\nNumPy turns Python into a numeric programming tool that is efficient and easy to use.",
    "the Python-as-control-language role we discussed earlier. A prime example of this dual\nlanguage strategy is the NumPy numeric programming extension for Python; by combining compiled and optimized numeric extension libraries with the Python language,\nNumPy turns Python into a numeric programming tool that is efficient and easy to use.\nYou may never need to code such extensions in your own Python work, but they provide\na powerful optimization mechanism if you ever do.",
    "Who Uses Python Today?\nAt this writing, the best estimate anyone can seem to make of the size of the Python\nuser base is that there are roughly 1 million Python users around the world today (plus\nor minus a few). This estimate is based on various statistics, like download rates and\ndeveloper surveys. Because Python is open source, a more exact count is difficult—\nthere are no license registrations to tally. Moreover, Python is automatically included\n\nWho Uses Python Today? | 7",
    "with Linux distributions, Macintosh computers, and some products and hardware,\nfurther clouding the user-base picture.\nIn general, though, Python enjoys a large user base and a very active developer community. Because Python has been around for some 19 years and has been widely used,\nit is also very stable and robust. Besides being employed by individual users, Python is\nalso being applied in real revenue-generating products by real companies. For instance:\n• Google makes extensive use of Python in its web search systems, and employs\nPython’s creator.\n• The YouTube video sharing service is largely written in Python.\n• The popular BitTorrent peer-to-peer file sharing system is a Python program.\n• Google’s popular App Engine web development framework uses Python as its application language.\n• EVE Online, a Massively Multiplayer Online Game (MMOG), makes extensive use\nof Python.\n• Maya, a powerful integrated 3D modeling and animation system, provides a\nPython scripting API.",
    "• The popular BitTorrent peer-to-peer file sharing system is a Python program.\n• Google’s popular App Engine web development framework uses Python as its application language.\n• EVE Online, a Massively Multiplayer Online Game (MMOG), makes extensive use\nof Python.\n• Maya, a powerful integrated 3D modeling and animation system, provides a\nPython scripting API.\n• Intel, Cisco, Hewlett-Packard, Seagate, Qualcomm, and IBM use Python for hardware testing.\n• Industrial Light & Magic, Pixar, and others use Python in the production of animated movies.\n• JPMorgan Chase, UBS, Getco, and Citadel apply Python for financial market\nforecasting.\n• NASA, Los Alamos, Fermilab, JPL, and others use Python for scientific programming tasks.\n• iRobot uses Python to develop commercial robotic devices.\n• ESRI uses Python as an end-user customization tool for its popular GIS mapping\nproducts.\n• The NSA uses Python for cryptography and intelligence analysis.",
    "• JPMorgan Chase, UBS, Getco, and Citadel apply Python for financial market\nforecasting.\n• NASA, Los Alamos, Fermilab, JPL, and others use Python for scientific programming tasks.\n• iRobot uses Python to develop commercial robotic devices.\n• ESRI uses Python as an end-user customization tool for its popular GIS mapping\nproducts.\n• The NSA uses Python for cryptography and intelligence analysis.\n• The IronPort email server product uses more than 1 million lines of Python code\nto do its job.\n• The One Laptop Per Child (OLPC) project builds its user interface and activity\nmodel in Python.\nAnd so on. Probably the only common thread amongst the companies using Python\ntoday is that Python is used all over the map, in terms of application domains. Its\ngeneral-purpose nature makes it applicable to almost all fields, not just one. In fact, it’s\nsafe to say that virtually every substantial organization writing software is using Python,",
    "model in Python.\nAnd so on. Probably the only common thread amongst the companies using Python\ntoday is that Python is used all over the map, in terms of application domains. Its\ngeneral-purpose nature makes it applicable to almost all fields, not just one. In fact, it’s\nsafe to say that virtually every substantial organization writing software is using Python,\nwhether for short-term tactical tasks, such as testing and administration, or for longterm strategic product development. Python has proven to work well in both modes.",
    "8 | Chapter 1: A Python Q&A Session\n\n\fFor more details on companies using Python today, see Python’s website at http://www\n.python.org.",
    "For more details on companies using Python today, see Python’s website at http://www\n.python.org.\n\nWhat Can I Do with Python?\nIn addition to being a well-designed programming language, Python is useful for accomplishing real-world tasks—the sorts of things developers do day in and day out.\nIt’s commonly used in a variety of domains, as a tool for scripting other components\nand implementing standalone programs. In fact, as a general-purpose language,\nPython’s roles are virtually unlimited: you can use it for everything from website development and gaming to robotics and spacecraft control.\nHowever, the most common Python roles currently seem to fall into a few broad categories. The next few sections describe some of Python’s most common applications\ntoday, as well as tools used in each domain. We won’t be able to explore the tools\nmentioned here in any depth—if you are interested in any of these topics, see the Python\nwebsite or other resources for more details.",
    "Systems Programming\nPython’s built-in interfaces to operating-system services make it ideal for writing portable, maintainable system-administration tools and utilities (sometimes called shell\ntools). Python programs can search files and directory trees, launch other programs, do\nparallel processing with processes and threads, and so on.\nPython’s standard library comes with POSIX bindings and support for all the usual OS\ntools: environment variables, files, sockets, pipes, processes, multiple threads, regular\nexpression pattern matching, command-line arguments, standard stream interfaces,\nshell-command launchers, filename expansion, and more. In addition, the bulk of Python’s system interfaces are designed to be portable; for example, a script that copies\ndirectory trees typically runs unchanged on all major Python platforms. The Stackless\nPython system, used by EVE Online, also offers advanced solutions to multiprocessing\nrequirements.",
    "GUIs\nPython’s simplicity and rapid turnaround also make it a good match for graphical user\ninterface programming. Python comes with a standard object-oriented interface to the\nTk GUI API called tkinter (Tkinter in 2.6) that allows Python programs to implement\nportable GUIs with a native look and feel. Python/tkinter GUIs run unchanged on\nMicrosoft Windows, X Windows (on Unix and Linux), and the Mac OS (both Classic\nand OS X). A free extension package, PMW, adds advanced widgets to the tkinter\ntoolkit. In addition, the wxPython GUI API, based on a C++ library, offers an alternative\ntoolkit for constructing portable GUIs in Python.\n\nWhat Can I Do with Python? | 9",
    "What Can I Do with Python? | 9\n\n\fHigher-level toolkits such as PythonCard and Dabo are built on top of base APIs such\nas wxPython and tkinter. With the proper library, you can also use GUI support in\nother toolkits in Python, such as Qt with PyQt, GTK with PyGTK, MFC with\nPyWin32, .NET with IronPython, and Swing with Jython (the Java version of Python,\ndescribed in Chapter 2) or JPype. For applications that run in web browsers or have\nsimple interface requirements, both Jython and Python web frameworks and serverside CGI scripts, described in the next section, provide additional user interface\noptions.",
    "Internet Scripting\nPython comes with standard Internet modules that allow Python programs to perform\na wide variety of networking tasks, in client and server modes. Scripts can communicate\nover sockets; extract form information sent to server-side CGI scripts; transfer files by\nFTP; parse, generate, and analyze XML files; send, receive, compose, and parse email;\nfetch web pages by URLs; parse the HTML and XML of fetched web pages; communicate over XML-RPC, SOAP, and Telnet; and more. Python’s libraries make these\ntasks remarkably simple.\nIn addition, a large collection of third-party tools are available on the Web for doing\nInternet programming in Python. For instance, the HTMLGen system generates HTML\nfiles from Python class-based descriptions, the mod_python package runs Python efficiently within the Apache web server and supports server-side templating with its Python Server Pages, and the Jython system provides for seamless Python/Java integration",
    "Internet programming in Python. For instance, the HTMLGen system generates HTML\nfiles from Python class-based descriptions, the mod_python package runs Python efficiently within the Apache web server and supports server-side templating with its Python Server Pages, and the Jython system provides for seamless Python/Java integration\nand supports coding of server-side applets that run on clients.\nIn addition, full-blown web development framework packages for Python, such as\nDjango, TurboGears, web2py, Pylons, Zope, and WebWare, support quick construction\nof full-featured and production-quality websites with Python. Many of these include\nfeatures such as object-relational mappers, a Model/View/Controller architecture,\nserver-side scripting and templating, and AJAX support, to provide complete and\nenterprise-level web development solutions.",
    "Component Integration\nWe discussed the component integration role earlier when describing Python as a control language. Python’s ability to be extended by and embedded in C and C++ systems\nmakes it useful as a flexible glue language for scripting the behavior of other systems\nand components. For instance, integrating a C library into Python enables Python to\ntest and launch the library’s components, and embedding Python in a product enables\nonsite customizations to be coded without having to recompile the entire product (or\nship its source code at all).\n\n10 | Chapter 1: A Python Q&A Session",
    "10 | Chapter 1: A Python Q&A Session\n\n\fTools such as the SWIG and SIP code generators can automate much of the work\nneeded to link compiled components into Python for use in scripts, and the Cython\nsystem allows coders to mix Python and C-like code. Larger frameworks, such as Python’s COM support on Windows, the Jython Java-based implementation, the IronPython .NET-based implementation, and various CORBA toolkits for Python, provide\nalternative ways to script components. On Windows, for example, Python scripts can\nuse frameworks to script Word and Excel.",
    "Database Programming\nFor traditional database demands, there are Python interfaces to all commonly used\nrelational database systems—Sybase, Oracle, Informix, ODBC, MySQL, PostgreSQL,\nSQLite, and more. The Python world has also defined a portable database API for accessing SQL database systems from Python scripts, which looks the same on a variety\nof underlying database systems. For instance, because the vendor interfaces implement\nthe portable API, a script written to work with the free MySQL system will work largely\nunchanged on other systems (such as Oracle); all you have to do is replace the underlying vendor interface.\nPython’s standard pickle module provides a simple object persistence system—it allows\nprograms to easily save and restore entire Python objects to files and file-like objects.\nOn the Web, you’ll also find a third-party open source system named ZODB that provides a complete object-oriented database system for Python scripts, and others (such",
    "Python’s standard pickle module provides a simple object persistence system—it allows\nprograms to easily save and restore entire Python objects to files and file-like objects.\nOn the Web, you’ll also find a third-party open source system named ZODB that provides a complete object-oriented database system for Python scripts, and others (such\nas SQLObject and SQLAlchemy) that map relational tables onto Python’s class model.\nFurthermore, as of Python 2.5, the in-process SQLite embedded SQL database engine\nis a standard part of Python itself.",
    "Rapid Prototyping\nTo Python programs, components written in Python and C look the same. Because of\nthis, it’s possible to prototype systems in Python initially, and then move selected components to a compiled language such as C or C++ for delivery. Unlike some prototyping\ntools, Python doesn’t require a complete rewrite once the prototype has solidified. Parts\nof the system that don’t require the efficiency of a language such as C++ can remain\ncoded in Python for ease of maintenance and use.",
    "Numeric and Scientific Programming\nThe NumPy numeric programming extension for Python mentioned earlier includes\nsuch advanced tools as an array object, interfaces to standard mathematical libraries,\nand much more. By integrating Python with numeric routines coded in a compiled\nlanguage for speed, NumPy turns Python into a sophisticated yet easy-to-use numeric\nprogramming tool that can often replace existing code written in traditional compiled\nlanguages such as FORTRAN or C++. Additional numeric tools for Python support\n\nWhat Can I Do with Python? | 11\n\n\fanimation, 3D visualization, parallel processing, and so on. The popular SciPy and\nScientificPython extensions, for example, provide additional libraries of scientific programming tools and use NumPy code.",
    "Gaming, Images, Serial Ports, XML, Robots, and More\nPython is commonly applied in more domains than can be mentioned here. For example, you can do:\n• Game programming and multimedia in Python with the pygame system\n• Serial port communication on Windows, Linux, and more with the PySerial\nextension\n• Image processing with PIL, PyOpenGL, Blender, Maya, and others\n• Robot control programming with the PyRo toolkit\n• XML parsing with the xml library package, the xmlrpclib module, and third-party\nextensions\n• Artificial intelligence programming with neural network simulators and expert\nsystem shells\n• Natural language analysis with the NLTK package\nYou can even play solitaire with the PySol program. You’ll find support for many such\nfields at the PyPI websites, and via web searches (search Google or http://www.python\n.org for links).",
    "extensions\n• Artificial intelligence programming with neural network simulators and expert\nsystem shells\n• Natural language analysis with the NLTK package\nYou can even play solitaire with the PySol program. You’ll find support for many such\nfields at the PyPI websites, and via web searches (search Google or http://www.python\n.org for links).\nMany of these specific domains are largely just instances of Python’s component integration role in action again. Adding it as a frontend to libraries of components written\nin a compiled language such as C makes Python useful for scripting in a wide variety\nof domains. As a general-purpose language that supports integration, Python is widely\napplicable.",
    "How Is Python Supported?\nAs a popular open source system, Python enjoys a large and active development community that responds to issues and develops enhancements with a speed that many\ncommercial software developers would find remarkable (if not downright shocking).\nPython developers coordinate work online with a source-control system. Changes follow a formal PEP (Python Enhancement Proposal) protocol and must be accompanied\nby extensions to Python’s extensive regression testing system. In fact, modifying\nPython today is roughly as involved as changing commercial software—a far cry from\nPython’s early days, when an email to its creator would suffice, but a good thing given\nits current large user base.\n\n12 | Chapter 1: A Python Q&A Session",
    "12 | Chapter 1: A Python Q&A Session\n\n\fThe PSF (Python Software Foundation), a formal nonprofit group, organizes conferences and deals with intellectual property issues. Numerous Python conferences are\nheld around the world; O’Reilly’s OSCON and the PSF’s PyCon are the largest. The\nformer of these addresses multiple open source projects, and the latter is a Python-only\nevent that has experienced strong growth in recent years. Attendance at PyCon 2008\nnearly doubled from the prior year, growing from 586 attendees in 2007 to over 1,000\nin 2008. This was on the heels of a 40% attendance increase in 2007, from 410 in 2006.\nPyCon 2009 had 943 attendees, a slight decrease from 2008, but a still very strong\nshowing during a global recession.",
    "What Are Python’s Technical Strengths?\nNaturally, this is a developer’s question. If you don’t already have a programming\nbackground, the language in the next few sections may be a bit baffling—don’t worry,\nwe’ll explore all of these terms in more detail as we proceed through this book. For\ndevelopers, though, here is a quick introduction to some of Python’s top technical\nfeatures.",
    "It’s Object-Oriented\nPython is an object-oriented language, from the ground up. Its class model supports\nadvanced notions such as polymorphism, operator overloading, and multiple inheritance; yet, in the context of Python’s simple syntax and typing, OOP is remarkably easy\nto apply. In fact, if you don’t understand these terms, you’ll find they are much easier\nto learn with Python than with just about any other OOP language available.\nBesides serving as a powerful code structuring and reuse device, Python’s OOP nature\nmakes it ideal as a scripting tool for object-oriented systems languages such as C++\nand Java. For example, with the appropriate glue code, Python programs can subclass\n(specialize) classes implemented in C++, Java, and C#.\nOf equal significance, OOP is an option in Python; you can go far without having to\nbecome an object guru all at once. Much like C++, Python supports both procedural\nand object-oriented programming modes. Its object-oriented tools can be applied if",
    "and Java. For example, with the appropriate glue code, Python programs can subclass\n(specialize) classes implemented in C++, Java, and C#.\nOf equal significance, OOP is an option in Python; you can go far without having to\nbecome an object guru all at once. Much like C++, Python supports both procedural\nand object-oriented programming modes. Its object-oriented tools can be applied if\nand when constraints allow. This is especially useful in tactical development modes,\nwhich preclude design phases.",
    "It’s Free\nPython is completely free to use and distribute. As with other open source software,\nsuch as Tcl, Perl, Linux, and Apache, you can fetch the entire Python system’s source\ncode for free on the Internet. There are no restrictions on copying it, embedding it in\nyour systems, or shipping it with your products. In fact, you can even sell Python’s\nsource code, if you are so inclined.\n\nWhat Are Python’s Technical Strengths? | 13",
    "But don’t get the wrong idea: “free” doesn’t mean “unsupported.” On the contrary,\nthe Python online community responds to user queries with a speed that most commercial software help desks would do well to try to emulate. Moreover, because Python\ncomes with complete source code, it empowers developers, leading to the creation of\na large team of implementation experts. Although studying or changing a programming\nlanguage’s implementation isn’t everyone’s idea of fun, it’s comforting to know that\nyou can do so if you need to. You’re not dependent on the whims of a commercial\nvendor; the ultimate documentation source is at your disposal.\nAs mentioned earlier, Python development is performed by a community that largely\ncoordinates its efforts over the Internet. It consists of Python’s creator—Guido van\nRossum, the officially anointed Benevolent Dictator for Life (BDFL) of Python—plus a\nsupporting cast of thousands. Language changes must follow a formal enhancement",
    "vendor; the ultimate documentation source is at your disposal.\nAs mentioned earlier, Python development is performed by a community that largely\ncoordinates its efforts over the Internet. It consists of Python’s creator—Guido van\nRossum, the officially anointed Benevolent Dictator for Life (BDFL) of Python—plus a\nsupporting cast of thousands. Language changes must follow a formal enhancement\nprocedure and be scrutinized by both other developers and the BDFL. Happily, this\ntends to make Python more conservative with changes than some other languages.",
    "It’s Portable\nThe standard implementation of Python is written in portable ANSI C, and it compiles\nand runs on virtually every major platform currently in use. For example, Python programs run today on everything from PDAs to supercomputers. As a partial list, Python\nis available on:\n• Linux and Unix systems\n• Microsoft Windows and DOS (all modern flavors)\n• Mac OS (both OS X and Classic)\n• BeOS, OS/2, VMS, and QNX\n• Real-time systems such as VxWorks\n• Cray supercomputers and IBM mainframes\n• PDAs running Palm OS, PocketPC, and Linux\n• Cell phones running Symbian OS and Windows Mobile\n• Gaming consoles and iPods\n• And more\nLike the language interpreter itself, the standard library modules that ship with Python\nare implemented to be as portable across platform boundaries as possible. Further,\nPython programs are automatically compiled to portable byte code, which runs the\nsame on any platform with a compatible version of Python installed (more on this in\nthe next chapter).",
    "14 | Chapter 1: A Python Q&A Session\n\n\fWhat that means is that Python programs using the core language and standard libraries\nrun the same on Linux, Windows, and most other systems with a Python interpreter.\nMost Python ports also contain platform-specific extensions (e.g., COM support on\nWindows), but the core Python language and libraries work the same everywhere. As\nmentioned earlier, Python also includes an interface to the Tk GUI toolkit called tkinter\n(Tkinter in 2.6), which allows Python programs to implement full-featured graphical\nuser interfaces that run on all major GUI platforms without program changes.",
    "It’s Powerful\nFrom a features perspective, Python is something of a hybrid. Its toolset places it between traditional scripting languages (such as Tcl, Scheme, and Perl) and systems development languages (such as C, C++, and Java). Python provides all the simplicity\nand ease of use of a scripting language, along with more advanced software-engineering\ntools typically found in compiled languages. Unlike some scripting languages, this\ncombination makes Python useful for large-scale development projects. As a preview,\nhere are some of the main things you’ll find in Python’s toolbox:\nDynamic typing\nPython keeps track of the kinds of objects your program uses when it runs; it\ndoesn’t require complicated type and size declarations in your code. In fact, as\nyou’ll see in Chapter 6, there is no such thing as a type or variable declaration\nanywhere in Python. Because Python code does not constrain data types, it is also\nusually automatically applicable to a whole range of objects.",
    "Dynamic typing\nPython keeps track of the kinds of objects your program uses when it runs; it\ndoesn’t require complicated type and size declarations in your code. In fact, as\nyou’ll see in Chapter 6, there is no such thing as a type or variable declaration\nanywhere in Python. Because Python code does not constrain data types, it is also\nusually automatically applicable to a whole range of objects.\nAutomatic memory management\nPython automatically allocates objects and reclaims (“garbage collects”) them\nwhen they are no longer used, and most can grow and shrink on demand. As you’ll\nlearn, Python keeps track of low-level memory details so you don’t have to.\nProgramming-in-the-large support\nFor building larger systems, Python includes tools such as modules, classes, and\nexceptions. These tools allow you to organize systems into components, use OOP\nto reuse and customize code, and handle events and errors gracefully.\nBuilt-in object types",
    "learn, Python keeps track of low-level memory details so you don’t have to.\nProgramming-in-the-large support\nFor building larger systems, Python includes tools such as modules, classes, and\nexceptions. These tools allow you to organize systems into components, use OOP\nto reuse and customize code, and handle events and errors gracefully.\nBuilt-in object types\nPython provides commonly used data structures such as lists, dictionaries, and\nstrings as intrinsic parts of the language; as you’ll see, they’re both flexible and easy\nto use. For instance, built-in objects can grow and shrink on demand, can be\narbitrarily nested to represent complex information, and more.\nBuilt-in tools\nTo process all those object types, Python comes with powerful and standard operations, including concatenation (joining collections), slicing (extracting sections), sorting, mapping, and more.",
    "What Are Python’s Technical Strengths? | 15\n\n\fLibrary utilities\nFor more specific tasks, Python also comes with a large collection of precoded\nlibrary tools that support everything from regular expression matching to networking. Once you learn the language itself, Python’s library tools are where much\nof the application-level action occurs.\nThird-party utilities\nBecause Python is open source, developers are encouraged to contribute precoded\ntools that support tasks beyond those supported by its built-ins; on the Web, you’ll\nfind free support for COM, imaging, CORBA ORBs, XML, database access, and\nmuch more.\nDespite the array of tools in Python, it retains a remarkably simple syntax and design.\nThe result is a powerful programming tool with all the usability of a scripting language.",
    "It’s Mixable\nPython programs can easily be “glued” to components written in other languages in a\nvariety of ways. For example, Python’s C API lets C programs call and be called by\nPython programs flexibly. That means you can add functionality to the Python system\nas needed, and use Python programs within other environments or systems.\nMixing Python with libraries coded in languages such as C or C++, for instance, makes\nit an easy-to-use frontend language and customization tool. As mentioned earlier, this\nalso makes Python good at rapid prototyping; systems may be implemented in Python\nfirst, to leverage its speed of development, and later moved to C for delivery, one piece\nat a time, according to performance demands.",
    "It’s Easy to Use\nTo run a Python program, you simply type it and run it. There are no intermediate\ncompile and link steps, like there are for languages such as C or C++. Python executes\nprograms immediately, which makes for an interactive programming experience and\nrapid turnaround after program changes—in many cases, you can witness the effect of\na program change as fast as you can type it.\nOf course, development cycle turnaround is only one aspect of Python’s ease of use. It\nalso provides a deliberately simple syntax and powerful built-in tools. In fact, some\nhave gone so far as to call Python “executable pseudocode.” Because it eliminates much\nof the complexity in other tools, Python programs are simpler, smaller, and more flexible than equivalent programs in languages like C, C++, and Java.\n\n16 | Chapter 1: A Python Q&A Session",
    "16 | Chapter 1: A Python Q&A Session\n\n\fIt’s Easy to Learn\nThis brings us to a key point of this book: compared to other programming languages,\nthe core Python language is remarkably easy to learn. In fact, you can expect to be\ncoding significant Python programs in a matter of days (or perhaps in just hours, if\nyou’re already an experienced programmer). That’s good news for professional developers seeking to learn the language to use on the job, as well as for end users of systems\nthat expose a Python layer for customization or control.\nToday, many systems rely on the fact that end users can quickly learn enough Python\nto tailor their Python customizations’ code onsite, with little or no support. Although\nPython does have advanced programming tools, its core language will still seem simple\nto beginners and gurus alike.",
    "It’s Named After Monty Python\nOK, this isn’t quite a technical strength, but it does seem to be a surprisingly well-kept\nsecret that I wish to expose up front. Despite all the reptile icons in the Python world,\nthe truth is that Python creator Guido van Rossum named it after the BBC comedy\nseries Monty Python’s Flying Circus. He is a big fan of Monty Python, as are many\nsoftware developers (indeed, there seems to almost be a symmetry between the two\nfields).\nThis legacy inevitably adds a humorous quality to Python code examples. For instance,\nthe traditional “foo” and “bar” for generic variable names become “spam” and “eggs”\nin the Python world. The occasional “Brian,” “ni,” and “shrubbery” likewise owe their\nappearances to this namesake. It even impacts the Python community at large: talks at\nPython conferences are regularly billed as “The Spanish Inquisition.”",
    "the traditional “foo” and “bar” for generic variable names become “spam” and “eggs”\nin the Python world. The occasional “Brian,” “ni,” and “shrubbery” likewise owe their\nappearances to this namesake. It even impacts the Python community at large: talks at\nPython conferences are regularly billed as “The Spanish Inquisition.”\nAll of this is, of course, very funny if you are familiar with the show, but less so otherwise. You don’t need to be familiar with the series to make sense of examples that\nborrow references to Monty Python (including many you will see in this book), but at\nleast you now know their root.",
    "How Does Python Stack Up to Language X?\nFinally, to place it in the context of what you may already know, people sometimes\ncompare Python to languages such as Perl, Tcl, and Java. We talked about performance\nearlier, so here we’ll focus on functionality. While other languages are also useful tools\nto know and use, many people find that Python:\n\nHow Does Python Stack Up to Language X? | 17",
    "• Is more powerful than Tcl. Python’s support for “programming in the large” makes\nit applicable to the development of larger systems.\n• Has a cleaner syntax and simpler design than Perl, which makes it more readable\nand maintainable and helps reduce program bugs.\n• Is simpler and easier to use than Java. Python is a scripting language, but Java\ninherits much of the complexity and syntax of systems languages such as C++.\n• Is simpler and easier to use than C++, but it doesn’t often compete with C++; as\na scripting language, Python typically serves different roles.\n• Is both more powerful and more cross-platform than Visual Basic. Its open source\nnature also means it is not controlled by a single company.\n• Is more readable and general-purpose than PHP. Python is sometimes used to\nconstruct websites, but it’s also widely used in nearly every other computer domain, from robotics to movie animation.\n• Is more mature and has a more readable syntax than Ruby. Unlike Ruby and Java,",
    "nature also means it is not controlled by a single company.\n• Is more readable and general-purpose than PHP. Python is sometimes used to\nconstruct websites, but it’s also widely used in nearly every other computer domain, from robotics to movie animation.\n• Is more mature and has a more readable syntax than Ruby. Unlike Ruby and Java,\nOOP is an option in Python—Python does not impose OOP on users or projects\nto which it may not apply.\n• Has the dynamic flavor of languages like SmallTalk and Lisp, but also has a simple,\ntraditional syntax accessible to developers as well as end users of customizable\nsystems.\nEspecially for programs that do more than scan text files, and that might have to be\nread in the future by others (or by you!), many people find that Python fits the bill better\nthan any other scripting or programming language available today. Furthermore, unless\nyour application requires peak performance, Python is often a viable alternative to",
    "systems.\nEspecially for programs that do more than scan text files, and that might have to be\nread in the future by others (or by you!), many people find that Python fits the bill better\nthan any other scripting or programming language available today. Furthermore, unless\nyour application requires peak performance, Python is often a viable alternative to\nsystems development languages such as C, C++, and Java: Python code will be much\nless difficult to write, debug, and maintain.\nOf course, your author has been a card-carrying Python evangelist since 1992, so take\nthese comments as you may. They do, however, reflect the common experience of many\ndevelopers who have taken time to explore what Python has to offer.",
    "Chapter Summary\nAnd that concludes the hype portion of this book. In this chapter, we’ve explored some\nof the reasons that people pick Python for their programming tasks. We’ve also seen\nhow it is applied and looked at a representative sample of who is using it today. My\ngoal is to teach Python, though, not to sell it. The best way to judge a language is to\nsee it in action, so the rest of this book focuses entirely on the language details we’ve\nglossed over here.\nThe next two chapters begin our technical introduction to the language. In them, we’ll\nexplore ways to run Python programs, peek at Python’s byte code execution model,\nand introduce the basics of module files for saving code. The goal will be to give you\n18 | Chapter 1: A Python Q&A Session\n\n\fjust enough information to run the examples and exercises in the rest of the book. You\nwon’t really start programming per se until Chapter 4, but make sure you have a handle\non the startup details before moving on.",
    "Test Your Knowledge: Quiz\nIn this edition of the book, we will be closing each chapter with a quick pop quiz about\nthe material presented therein to help you review the key concepts. The answers for\nthese quizzes appear immediately after the questions, and you are encouraged to read\nthe answers once you’ve taken a crack at the questions yourself. In addition to these\nend-of-chapter quizzes, you’ll find lab exercises at the end of each part of the book,\ndesigned to help you start coding Python on your own. For now, here’s your first test.\nGood luck!\n1. What are the six main reasons that people choose to use Python?\n2. Name four notable companies or organizations using Python today.\n3. Why might you not want to use Python in an application?\n4. What can you do with Python?\n5. What’s the significance of the Python import this statement?\n6. Why does “spam” show up in so many Python examples in books and on the Web?\n7. What is your favorite color?",
    "Test Your Knowledge: Answers\nHow did you do? Here are the answers I came up with, though there may be multiple\nsolutions to some quiz questions. Again, even if you’re sure you got a question right, I\nencourage you to look at these answers for additional context. See the chapter’s text\nfor more details if any of these responses don’t make sense to you.\n1. Software quality, developer productivity, program portability, support libraries,\ncomponent integration, and simple enjoyment. Of these, the quality and productivity themes seem to be the main reasons that people choose to use Python.\n2. Google, Industrial Light & Magic, EVE Online, Jet Propulsion Labs, Maya, ESRI,\nand many more. Almost every organization doing software development uses Python in some fashion, whether for long-term strategic product development or for\nshort-term tactical tasks such as testing and system administration.\n3. Python’s downside is performance: it won’t run as quickly as fully compiled",
    "2. Google, Industrial Light & Magic, EVE Online, Jet Propulsion Labs, Maya, ESRI,\nand many more. Almost every organization doing software development uses Python in some fashion, whether for long-term strategic product development or for\nshort-term tactical tasks such as testing and system administration.\n3. Python’s downside is performance: it won’t run as quickly as fully compiled\nlanguages like C and C++. On the other hand, it’s quick enough for most applications, and typical Python code runs at close to C speed anyhow because it invokes",
    "Test Your Knowledge: Answers | 19\n\n\flinked-in C code in the interpreter. If speed is critical, compiled extensions are\navailable for number-crunching parts of an application.\n4. You can use Python for nearly anything you can do with a computer, from website\ndevelopment and gaming to robotics and spacecraft control.\n5. import this triggers an Easter egg inside Python that displays some of the design\nphilosophies underlying the language. You’ll learn how to run this statement in\nthe next chapter.\n6. “Spam” is a reference from a famous Monty Python skit in which people trying to\norder food in a cafeteria are drowned out by a chorus of Vikings singing about\nspam. Oh, and it’s also a common variable name in Python scripts....\n7. Blue. No, yellow!",
    "Python Is Engineering, Not Art\nWhen Python first emerged on the software scene in the early 1990s, it spawned what\nis now something of a classic conflict between its proponents and those of another\npopular scripting language, Perl. Personally, I think the debate is tired and unwarranted\ntoday—developers are smart enough to draw their own conclusions. Still, this is one\nof the most common topics I’m asked about on the training road, so it seems fitting to\nsay a few words about it here.\nThe short story is this: you can do everything in Python that you can in Perl, but you can\nread your code after you do it. That’s it—their domains largely overlap, but Python is\nmore focused on producing readable code. For many, the enhanced readability of Python translates to better code reusability and maintainability, making Python a better\nchoice for programs that will not be written once and thrown away. Perl code is easy",
    "read your code after you do it. That’s it—their domains largely overlap, but Python is\nmore focused on producing readable code. For many, the enhanced readability of Python translates to better code reusability and maintainability, making Python a better\nchoice for programs that will not be written once and thrown away. Perl code is easy\nto write, but difficult to read. Given that most software has a lifespan much longer than\nits initial creation, many see Python as a more effective tool.\nThe somewhat longer story reflects the backgrounds of the designers of the two languages and underscores some of the main reasons people choose to use Python. Python’s creator is a mathematician by training; as such, he produced a language with a\nhigh degree of uniformity—its syntax and toolset are remarkably coherent. Moreover,\nlike math, Python’s design is orthogonal—most of the language follows from a small\nset of core concepts. For instance, once one grasps Python’s flavor of polymorphism,",
    "high degree of uniformity—its syntax and toolset are remarkably coherent. Moreover,\nlike math, Python’s design is orthogonal—most of the language follows from a small\nset of core concepts. For instance, once one grasps Python’s flavor of polymorphism,\nthe rest is largely just details.\nBy contrast, the creator of the Perl language is a linguist, and its design reflects this\nheritage. There are many ways to accomplish the same tasks in Perl, and language\nconstructs interact in context-sensitive and sometimes quite subtle ways—much like\nnatural language. As the well-known Perl motto states, “There’s more than one way to\ndo it.” Given this design, both the Perl language and its user community have historically encouraged freedom of expression when writing code. One person’s Perl code can\nbe radically different from another’s. In fact, writing unique, tricky code is often a\nsource of pride among Perl users.",
    "20 | Chapter 1: A Python Q&A Session",
    "But as anyone who has done any substantial code maintenance should be able to attest,\nfreedom of expression is great for art, but lousy for engineering. In engineering, we need\na minimal feature set and predictability. In engineering, freedom of expression can lead\nto maintenance nightmares. As more than one Perl user has confided to me, the result\nof too much freedom is often code that is much easier to rewrite from scratch than to\nmodify.\nConsider this: when people create a painting or a sculpture, they do so for themselves\nfor purely aesthetic purposes. The possibility of someone else having to change that\npainting or sculpture later does not enter into it. This is a critical difference between\nart and engineering. When people write software, they are not writing it for themselves.\nIn fact, they are not even writing primarily for the computer. Rather, good programmers\nknow that code is written for the next human being who has to read it in order to",
    "painting or sculpture later does not enter into it. This is a critical difference between\nart and engineering. When people write software, they are not writing it for themselves.\nIn fact, they are not even writing primarily for the computer. Rather, good programmers\nknow that code is written for the next human being who has to read it in order to\nmaintain or reuse it. If that person cannot understand the code, it’s all but useless in a\nrealistic development scenario.\nThis is where many people find that Python most clearly differentiates itself from\nscripting languages like Perl. Because Python’s syntax model almost forces users to\nwrite readable code, Python programs lend themselves more directly to the full software\ndevelopment cycle. And because Python emphasizes ideas such as limited interactions,\ncode uniformity and regularity, and feature consistency, it more directly fosters code\nthat can be used long after it is first written.",
    "scripting languages like Perl. Because Python’s syntax model almost forces users to\nwrite readable code, Python programs lend themselves more directly to the full software\ndevelopment cycle. And because Python emphasizes ideas such as limited interactions,\ncode uniformity and regularity, and feature consistency, it more directly fosters code\nthat can be used long after it is first written.\nIn the long run, Python’s focus on code quality in itself boosts programmer productivity, as well as programmer satisfaction. Python programmers can be creative, too, of\ncourse, and as we’ll see, the language does offer multiple solutions for some tasks. At\nits core, though, Python encourages good engineering in ways that other scripting languages often do not.\nAt least, that’s the common consensus among many people who have adopted Python.\nYou should always judge such claims for yourself, of course, by learning what Python\nhas to offer. To help you get started, let’s move on to the next chapter.",
    "Test Your Knowledge: Answers | 21\n\n\f\fCHAPTER 2\n\nHow Python Runs Programs\n\nThis chapter and the next take a quick look at program execution—how you launch\ncode, and how Python runs it. In this chapter, we’ll study the Python interpreter.\nChapter 3 will then show you how to get your own programs up and running.\nStartup details are inherently platform-specific, and some of the material in these two\nchapters may not apply to the platform you work on, so you should feel free to skip\nparts not relevant to your intended use. Likewise, more advanced readers who have\nused similar tools in the past and prefer to get to the meat of the language quickly may\nwant to file some of this chapter away as “for future reference.” For the rest of you, let’s\nlearn how to run some code.",
    "Introducing the Python Interpreter\nSo far, I’ve mostly been talking about Python as a programming language. But, as currently implemented, it’s also a software package called an interpreter. An interpreter is\na kind of program that executes other programs. When you write a Python program,\nthe Python interpreter reads your program and carries out the instructions it contains.\nIn effect, the interpreter is a layer of software logic between your code and the computer\nhardware on your machine.\nWhen the Python package is installed on your machine, it generates a number of components—minimally, an interpreter and a support library. Depending on how you use\nit, the Python interpreter may take the form of an executable program, or a set of\nlibraries linked into another program. Depending on which flavor of Python you run,\nthe interpreter itself may be implemented as a C program, a set of Java classes, or\nsomething else. Whatever form it takes, the Python code you write must always be run",
    "it, the Python interpreter may take the form of an executable program, or a set of\nlibraries linked into another program. Depending on which flavor of Python you run,\nthe interpreter itself may be implemented as a C program, a set of Java classes, or\nsomething else. Whatever form it takes, the Python code you write must always be run\nby this interpreter. And to enable that, you must install a Python interpreter on your\ncomputer.\nPython installation details vary by platform and are covered in more depth in Appendix A. In short:",
    "23",
    "• Windows users fetch and run a self-installing executable file that puts Python on\ntheir machines. Simply double-click and say Yes or Next at all prompts.\n• Linux and Mac OS X users probably already have a usable Python preinstalled on\ntheir computers—it’s a standard component on these platforms today.\n• Some Linux and Mac OS X users (and most Unix users) compile Python from its\nfull source code distribution package.\n• Linux users can also find RPM files, and Mac OS X users can find various Macspecific installation packages.\n• Other platforms have installation techniques relevant to those platforms. For\ninstance, Python is available on cell phones, game consoles, and iPods, but installation details vary widely.\nPython itself may be fetched from the downloads page on the website, http://www\n.python.org. It may also be found through various other distribution channels. Keep in\nmind that you should always check to see whether Python is already present before",
    "instance, Python is available on cell phones, game consoles, and iPods, but installation details vary widely.\nPython itself may be fetched from the downloads page on the website, http://www\n.python.org. It may also be found through various other distribution channels. Keep in\nmind that you should always check to see whether Python is already present before\ninstalling it. If you’re working on Windows, you’ll usually find Python in the Start\nmenu, as captured in Figure 2-1 (these menu options are discussed in the next chapter).\nOn Unix and Linux, Python probably lives in your /usr directory tree.\nBecause installation details are so platform-specific, we’ll finesse the rest of this story\nhere. For more details on the installation process, consult Appendix A. For the purposes\nof this chapter and the next, I’ll assume that you’ve got Python ready to go.",
    "Program Execution\nWhat it means to write and run a Python script depends on whether you look at these\ntasks as a programmer, or as a Python interpreter. Both views offer important perspectives on Python programming.\n\nThe Programmer’s View\nIn its simplest form, a Python program is just a text file containing Python statements.\nFor example, the following file, named script0.py, is one of the simplest Python scripts\nI could dream up, but it passes for a fully functional Python program:\nprint('hello world')\nprint(2 ** 100)\n\nThis file contains two Python print statements, which simply print a string (the text in\nquotes) and a numeric expression result (2 to the power 100) to the output stream.\nDon’t worry about the syntax of this code yet—for this chapter, we’re interested only\nin getting it to run. I’ll explain the print statement, and why you can raise 2 to the\npower 100 in Python without overflowing, in the next parts of this book.\n\n24 | Chapter 2: How Python Runs Programs",
    "24 | Chapter 2: How Python Runs Programs\n\n\fFigure 2-1. When installed on Windows, this is how Python shows up in your Start button menu. This\ncan vary a bit from release to release, but IDLE starts a development GUI, and Python starts a simple\ninteractive session. Also here are the standard manuals and the PyDoc documentation engine (Module\nDocs).\n\nYou can create such a file of statements with any text editor you like. By convention,\nPython program files are given names that end in .py; technically, this naming scheme\nis required only for files that are “imported,” as shown later in this book, but most\nPython files have .py names for consistency.\nAfter you’ve typed these statements into a text file, you must tell Python to execute the\nfile—which simply means to run all the statements in the file from top to bottom, one\nafter another. As you’ll see in the next chapter, you can launch Python program files\nProgram Execution | 25",
    "by shell command lines, by clicking their icons, from within IDEs, and with other\nstandard techniques. If all goes well, when you execute the file, you’ll see the results of\nthe two print statements show up somewhere on your computer—by default, usually\nin the same window you were in when you ran the program:\nhello world\n1267650600228229401496703205376\n\nFor example, here’s what happened when I ran this script from a DOS command line\non a Windows laptop (typically called a Command Prompt window, found in the Accessories program menu), to make sure it didn’t have any silly typos:\nC:\\temp> python script0.py\nhello world\n1267650600228229401496703205376\n\nWe’ve just run a Python script that prints a string and a number. We probably won’t\nwin any programming awards with this code, but it’s enough to capture the basics of\nprogram execution.",
    "We’ve just run a Python script that prints a string and a number. We probably won’t\nwin any programming awards with this code, but it’s enough to capture the basics of\nprogram execution.\n\nPython’s View\nThe brief description in the prior section is fairly standard for scripting languages, and\nit’s usually all that most Python programmers need to know. You type code into text\nfiles, and you run those files through the interpreter. Under the hood, though, a bit\nmore happens when you tell Python to “go.” Although knowledge of Python internals\nis not strictly required for Python programming, a basic understanding of the runtime\nstructure of Python can help you grasp the bigger picture of program execution.\nWhen you instruct Python to run your script, there are a few steps that Python carries\nout before your code actually starts crunching away. Specifically, it’s first compiled to\nsomething called “byte code” and then routed to something called a “virtual machine.”",
    "Byte code compilation\nInternally, and almost completely hidden from you, when you execute a program\nPython first compiles your source code (the statements in your file) into a format known\nas byte code. Compilation is simply a translation step, and byte code is a lower-level,\nplatform-independent representation of your source code. Roughly, Python translates\neach of your source statements into a group of byte code instructions by decomposing\nthem into individual steps. This byte code translation is performed to speed\nexecution—byte code can be run much more quickly than the original source code\nstatements in your text file.\nYou’ll notice that the prior paragraph said that this is almost completely hidden from\nyou. If the Python process has write access on your machine, it will store the byte code\nof your programs in files that end with a .pyc extension (“.pyc” means compiled “.py”\nsource). You will see these files show up on your computer after you’ve run a few",
    "26 | Chapter 2: How Python Runs Programs",
    "programs alongside the corresponding source code files (that is, in the same\ndirectories).\nPython saves byte code like this as a startup speed optimization. The next time you run\nyour program, Python will load the .pyc files and skip the compilation step, as long as\nyou haven’t changed your source code since the byte code was last saved. Python automatically checks the timestamps of source and byte code files to know when it must\nrecompile—if you resave your source code, byte code is automatically re-created the\nnext time your program is run.\nIf Python cannot write the byte code files to your machine, your program still works—\nthe byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you’ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs—Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are",
    "the byte code is generated in memory and simply discarded on program exit.* However,\nbecause .pyc files speed startup time, you’ll want to make sure they are written for larger\nprograms. Byte code files are also one way to ship Python programs—Python is happy\nto run a program if all it can find are .pyc files, even if the original .py source files are\nabsent. (See “Frozen Binaries” on page 32 for another shipping option.)",
    "The Python Virtual Machine (PVM)\nOnce your program has been compiled to byte code (or the byte code has been loaded\nfrom existing .pyc files), it is shipped off for execution to something generally known\nas the Python Virtual Machine (PVM, for the more acronym-inclined among you). The\nPVM sounds more impressive than it is; really, it’s not a separate program, and it need\nnot be installed by itself. In fact, the PVM is just a big loop that iterates through your\nbyte code instructions, one by one, to carry out their operations. The PVM is the runtime engine of Python; it’s always present as part of the Python system, and it’s the\ncomponent that truly runs your scripts. Technically, it’s just the last step of what is\ncalled the “Python interpreter.”\nFigure 2-2 illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is",
    "component that truly runs your scripts. Technically, it’s just the last step of what is\ncalled the “Python interpreter.”\nFigure 2-2 illustrates the runtime structure described here. Keep in mind that all of this\ncomplexity is deliberately hidden from Python programmers. Byte code compilation is\nautomatic, and the PVM is just part of the Python system that you have installed on\nyour machine. Again, programmers simply code and run files of statements.",
    "Performance implications\nReaders with a background in fully compiled languages such as C and C++ might notice\na few differences in the Python model. For one thing, there is usually no build or “make”\nstep in Python work: code runs immediately after it is written. For another, Python byte\ncode is not binary machine code (e.g., instructions for an Intel chip). Byte code is a\nPython-specific representation.\n\n* And, strictly speaking, byte code is saved only for files that are imported, not for the top-level file of a program.\nWe’ll explore imports in Chapter 3, and again in Part V. Byte code is also never saved for code typed at the\ninteractive prompt, which is described in Chapter 3.\n\nProgram Execution | 27\n\n\fFigure 2-2. Python’s traditional runtime execution model: source code you type is translated to byte\ncode, which is then run by the Python Virtual Machine. Your code is automatically compiled, but then\nit is interpreted.",
    "Program Execution | 27\n\n\fFigure 2-2. Python’s traditional runtime execution model: source code you type is translated to byte\ncode, which is then run by the Python Virtual Machine. Your code is automatically compiled, but then\nit is interpreted.\n\nThis is why some Python code may not run as fast as C or C++ code, as described in\nChapter 1—the PVM loop, not the CPU chip, still must interpret the byte code, and\nbyte code instructions require more work than CPU instructions. On the other hand,\nunlike in classic interpreters, there is still an internal compile step—Python does not\nneed to reanalyze and reparse each source statement repeatedly. The net effect is that\npure Python code runs at speeds somewhere between those of a traditional compiled\nlanguage and a traditional interpreted language. See Chapter 1 for more on Python\nperformance tradeoffs.",
    "Development implications\nAnother ramification of Python’s execution model is that there is really no distinction\nbetween the development and execution environments. That is, the systems that compile and execute your source code are really one and the same. This similarity may have\na bit more significance to readers with a background in traditional compiled languages,\nbut in Python, the compiler is always present at runtime and is part of the system that\nruns programs.\nThis makes for a much more rapid development cycle. There is no need to precompile\nand link before execution may begin; simply type and run the code. This also adds a\nmuch more dynamic flavor to the language—it is possible, and often very convenient,\nfor Python programs to construct and execute other Python programs at runtime. The\neval and exec built-ins, for instance, accept and run strings containing Python program\ncode. This structure is also why Python lends itself to product customization—because",
    "much more dynamic flavor to the language—it is possible, and often very convenient,\nfor Python programs to construct and execute other Python programs at runtime. The\neval and exec built-ins, for instance, accept and run strings containing Python program\ncode. This structure is also why Python lends itself to product customization—because\nPython code can be changed on the fly, users can modify the Python parts of a system\nonsite without needing to have or compile the entire system’s code.\nAt a more fundamental level, keep in mind that all we really have in Python is runtime—\nthere is no initial compile-time phase at all, and everything happens as the program is\nrunning. This even includes operations such as the creation of functions and classes\nand the linkage of modules. Such events occur before execution in more static languages, but happen as programs execute in Python. As we’ll see, the net effect makes\nfor a much more dynamic programming experience than that to which some readers",
    "running. This even includes operations such as the creation of functions and classes\nand the linkage of modules. Such events occur before execution in more static languages, but happen as programs execute in Python. As we’ll see, the net effect makes\nfor a much more dynamic programming experience than that to which some readers\nmay be accustomed.",
    "28 | Chapter 2: How Python Runs Programs\n\n\fExecution Model Variations\nBefore moving on, I should point out that the internal execution flow described in the\nprior section reflects the standard implementation of Python today but is not really a\nrequirement of the Python language itself. Because of that, the execution model is prone\nto changing with time. In fact, there are already a few systems that modify the picture\nin Figure 2-2 somewhat. Let’s take a few moments to explore the most prominent of\nthese variations.\n\nPython Implementation Alternatives\nReally, as this book is being written, there are three primary implementations of the\nPython language—CPython, Jython, and IronPython—along with a handful of secondary implementations such as Stackless Python. In brief, CPython is the standard implementation; all the others have very specific purposes and roles. All implement the\nsame Python language but execute programs in different ways.",
    "CPython\nThe original, and standard, implementation of Python is usually called CPython, when\nyou want to contrast it with the other two. Its name comes from the fact that it is coded\nin portable ANSI C language code. This is the Python that you fetch from http://www\n.python.org, get with the ActivePython distribution, and have automatically on most\nLinux and Mac OS X machines. If you’ve found a preinstalled version of Python on\nyour machine, it’s probably CPython, unless your company is using Python in very\nspecialized ways.\nUnless you want to script Java or .NET applications with Python, you probably want\nto use the standard CPython system. Because it is the reference implementation of the\nlanguage, it tends to run the fastest, be the most complete, and be more robust than\nthe alternative systems. Figure 2-2 reflects CPython’s runtime architecture.",
    "Jython\nThe Jython system (originally known as JPython) is an alternative implementation of\nthe Python language, targeted for integration with the Java programming language.\nJython consists of Java classes that compile Python source code to Java byte code and\nthen route the resulting byte code to the Java Virtual Machine (JVM). Programmers\nstill code Python statements in .py text files as usual; the Jython system essentially just\nreplaces the rightmost two bubbles in Figure 2-2 with Java-based equivalents.\nJython’s goal is to allow Python code to script Java applications, much as CPython\nallows Python to script C and C++ components. Its integration with Java is remarkably\nseamless. Because Python code is translated to Java byte code, it looks and feels like a\ntrue Java program at runtime. Jython scripts can serve as web applets and servlets, build\nJava-based GUIs, and so on. Moreover, Jython includes integration support that allows\nExecution Model Variations | 29",
    "Python code to import and use Java classes as though they were coded in Python.\nBecause Jython is slower and less robust than CPython, though, it is usually seen as a\ntool of interest primarily to Java developers looking for a scripting language to be a\nfrontend to Java code.",
    "IronPython\nA third implementation of Python, and newer than both CPython and Jython,\nIronPython is designed to allow Python programs to integrate with applications coded\nto work with Microsoft’s .NET Framework for Windows, as well as the Mono open\nsource equivalent for Linux. .NET and its C# programming language runtime system\nare designed to be a language-neutral object communication layer, in the spirit of Microsoft’s earlier COM model. IronPython allows Python programs to act as both client\nand server components, accessible from other .NET languages.\nBy implementation, IronPython is very much like Jython (and, in fact, was developed\nby the same creator)—it replaces the last two bubbles in Figure 2-2 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus—it is primarily of interest to developers integrating Python with .NET components. Because it is being developed by Microsoft, though, IronPython might also be",
    "by the same creator)—it replaces the last two bubbles in Figure 2-2 with equivalents\nfor execution in the .NET environment. Also, like Jython, IronPython has a special\nfocus—it is primarily of interest to developers integrating Python with .NET components. Because it is being developed by Microsoft, though, IronPython might also be\nable to leverage some important optimization tools for better performance.\nIronPython’s scope is still evolving as I write this; for more details, consult the Python\nonline resources or search the Web.†",
    "Execution Optimization Tools\nCPython, Jython, and IronPython all implement the Python language in similar ways:\nby compiling source code to byte code and executing the byte code on an appropriate\nvirtual machine. Still other systems, including the Psyco just-in-time compiler and the\nShedskin C++ translator, instead attempt to optimize the basic execution model. These\nsystems are not required knowledge at this point in your Python career, but a quick\nlook at their place in the execution model might help demystify the model in general.\n\nThe Psyco just-in-time compiler\nThe Psyco system is not another Python implementation, but rather a component that\nextends the byte code execution model to make programs run faster. In terms of\nFigure 2-2, Psyco is an enhancement to the PVM that collects and uses type information\nwhile the program runs to translate portions of the program’s byte code all the way\ndown to real binary machine code for faster execution. Psyco accomplishes this",
    "† Jython and IronPython are completely independent implementations of Python that compile Python source\nfor different runtime architectures. It is also possible to access Java and .NET software from standard CPython\nprograms: JPype and Python for .NET systems, for example, allow CPython code to call out to Java and .NET\ncomponents.\n\n30 | Chapter 2: How Python Runs Programs",
    "translation without requiring changes to the code or a separate compilation step during\ndevelopment.\nRoughly, while your program runs, Psyco collects information about the kinds of objects being passed around; that information can be used to generate highly efficient\nmachine code tailored for those object types. Once generated, the machine code then\nreplaces the corresponding part of the original byte code to speed your program’s overall execution. The net effect is that, with Psyco, your program becomes much quicker\nover time and as it is running. In ideal cases, some Python code may become as fast as\ncompiled C code under Psyco.\nBecause this translation from byte code happens at program runtime, Psyco is generally\nknown as a just-in-time (JIT) compiler. Psyco is actually a bit different from the JIT\ncompilers some readers may have seen for the Java language, though. Really, Psyco is\na specializing JIT compiler—it generates machine code tailored to the data types that",
    "compiled C code under Psyco.\nBecause this translation from byte code happens at program runtime, Psyco is generally\nknown as a just-in-time (JIT) compiler. Psyco is actually a bit different from the JIT\ncompilers some readers may have seen for the Java language, though. Really, Psyco is\na specializing JIT compiler—it generates machine code tailored to the data types that\nyour program actually uses. For example, if a part of your program uses different data\ntypes at different times, Psyco may generate a different version of machine code to\nsupport each different type combination.\nPsyco has been shown to speed Python code dramatically. According to its web page,\nPsyco provides “2x to 100x speed-ups, typically 4x, with an unmodified Python interpreter and unmodified source code, just a dynamically loadable C extension module.”\nOf equal significance, the largest speedups are realized for algorithmic code written in",
    "support each different type combination.\nPsyco has been shown to speed Python code dramatically. According to its web page,\nPsyco provides “2x to 100x speed-ups, typically 4x, with an unmodified Python interpreter and unmodified source code, just a dynamically loadable C extension module.”\nOf equal significance, the largest speedups are realized for algorithmic code written in\npure Python—exactly the sort of code you might normally migrate to C to optimize.\nWith Psyco, such migrations become even less important.\nPsyco is not yet a standard part of Python; you will have to fetch and install it separately.\nIt is also still something of a research project, so you’ll have to track its evolution online.\nIn fact, at this writing, although Psyco can still be fetched and installed by itself, it\nappears that much of the system may eventually be absorbed into the newer “PyPy”\nproject—an attempt to reimplement Python’s PVM in Python code, to better support\noptimizations like Psyco.",
    "It is also still something of a research project, so you’ll have to track its evolution online.\nIn fact, at this writing, although Psyco can still be fetched and installed by itself, it\nappears that much of the system may eventually be absorbed into the newer “PyPy”\nproject—an attempt to reimplement Python’s PVM in Python code, to better support\noptimizations like Psyco.\nPerhaps the largest downside of Psyco is that it currently only generates machine code\nfor Intel x86 architecture chips, though this includes Windows and Linux boxes and\nrecent Macs. For more details on the Psyco extension, and other JIT efforts that may\narise, consult http://www.python.org; you can also check out Psyco’s home page, which\ncurrently resides at http://psyco.sourceforge.net.",
    "The Shedskin C++ translator\nShedskin is an emerging system that takes a different approach to Python program\nexecution—it attempts to translate Python source code to C++ code, which your computer’s C++ compiler then compiles to machine code. As such, it represents a platformneutral approach to running Python code. Shedskin is still somewhat experimental as\nI write these words, and it limits Python programs to an implicit statically typed constraint that is technically not normal Python, so we won’t go into further detail here.\nExecution Model Variations | 31\n\n\fInitial results, though, show that it has the potential to outperform both standard Python and the Psyco extension in terms of execution speed, and it is a promising project.\nSearch the Web for details on the project’s current status.",
    "Frozen Binaries\nSometimes when people ask for a “real” Python compiler, what they’re really seeking\nis simply a way to generate standalone binary executables from their Python programs.\nThis is more a packaging and shipping idea than an execution-flow concept, but it’s\nsomewhat related. With the help of third-party tools that you can fetch off the Web, it\nis possible to turn your Python programs into true executables, known as frozen binaries in the Python world.\nFrozen binaries bundle together the byte code of your program files, along with the\nPVM (interpreter) and any Python support files your program needs, into a single\npackage. There are some variations on this theme, but the end result can be a single\nbinary executable program (e.g., an .exe file on Windows) that can easily be shipped\nto customers. In Figure 2-2, it is as though the byte code and PVM are merged into a\nsingle component—a frozen binary file.",
    "PVM (interpreter) and any Python support files your program needs, into a single\npackage. There are some variations on this theme, but the end result can be a single\nbinary executable program (e.g., an .exe file on Windows) that can easily be shipped\nto customers. In Figure 2-2, it is as though the byte code and PVM are merged into a\nsingle component—a frozen binary file.\nToday, three primary systems are capable of generating frozen binaries: py2exe (for\nWindows), PyInstaller (which is similar to py2exe but also works on Linux and Unix\nand is capable of generating self-installing binaries), and freeze (the original). You may\nhave to fetch these tools separately from Python itself, but they are available free of\ncharge. They are also constantly evolving, so consult http://www.python.org or your\nfavorite web search engine for more on these tools. To give you an idea of the scope of\nthese systems, py2exe can freeze standalone programs that use the tkinter, PMW,",
    "have to fetch these tools separately from Python itself, but they are available free of\ncharge. They are also constantly evolving, so consult http://www.python.org or your\nfavorite web search engine for more on these tools. To give you an idea of the scope of\nthese systems, py2exe can freeze standalone programs that use the tkinter, PMW,\nwxPython, and PyGTK GUI libraries; programs that use the pygame game programming toolkit; win32com client programs; and more.\nFrozen binaries are not the same as the output of a true compiler—they run byte code\nthrough a virtual machine. Hence, apart from a possible startup improvement, frozen\nbinaries run at the same speed as the original source files. Frozen binaries are not small\n(they contain a PVM), but by current standards they are not unusually large either.",
    "Frozen binaries are not the same as the output of a true compiler—they run byte code\nthrough a virtual machine. Hence, apart from a possible startup improvement, frozen\nbinaries run at the same speed as the original source files. Frozen binaries are not small\n(they contain a PVM), but by current standards they are not unusually large either.\nBecause Python is embedded in the frozen binary, though, it does not have to be installed on the receiving end to run your program. Moreover, because your code is embedded in the frozen binary, it is more effectively hidden from recipients.\nThis single file-packaging scheme is especially appealing to developers of commercial\nsoftware. For instance, a Python-coded user interface program based on the tkinter\ntoolkit can be frozen into an executable file and shipped as a self-contained program\non a CD or on the Web. End users do not need to install (or even have to know about)\nPython to run the shipped program.",
    "32 | Chapter 2: How Python Runs Programs",
    "Other Execution Options\nStill other schemes for running Python programs have more focused goals:\n• The Stackless Python system is a standard CPython implementation variant that\ndoes not save state on the C language call stack. This makes Python more easy to\nport to small stack architectures, provides efficient multiprocessing options, and\nfosters novel programming structures such as coroutines.\n• The Cython system (based on work done by the Pyrex project) is a hybrid language\nthat combines Python code with the ability to call C functions and use C type\ndeclarations for variables, parameters, and class attributes. Cython code can be\ncompiled to C code that uses the Python/C API, which may then be compiled\ncompletely. Though not completely compatible with standard Python, Cython can\nbe useful both for wrapping external C libraries and for coding efficient C extensions for Python.\nFor more details on these systems, search the Web for recent links.",
    "Future Possibilities?\nFinally, note that the runtime execution model sketched here is really an artifact of the\ncurrent implementation of Python, not of the language itself. For instance, it’s not\nimpossible that a full, traditional compiler for translating Python source code to machine code may appear during the shelf life of this book (although one has not in nearly\ntwo decades!). New byte code formats and implementation variants may also be adopted in the future. For instance:\n• The Parrot project aims to provide a common byte code format, virtual machine,\nand optimization techniques for a variety of programming languages (see http://\nwww.python.org). Python’s own PVM runs Python code more efficiently than Parrot, but it’s unclear how Parrot will evolve.\n• The PyPy project is an attempt to reimplement the PVM in Python itself to enable\nnew implementation techniques. Its goal is to produce a fast and flexible implementation of Python.",
    "and optimization techniques for a variety of programming languages (see http://\nwww.python.org). Python’s own PVM runs Python code more efficiently than Parrot, but it’s unclear how Parrot will evolve.\n• The PyPy project is an attempt to reimplement the PVM in Python itself to enable\nnew implementation techniques. Its goal is to produce a fast and flexible implementation of Python.\n• The Google-sponsored Unladen Swallow project aims to make standard Python\nfaster by a factor of at least 5, and fast enough to replace the C language in many\ncontexts. It is an optimization branch of CPython, intended to be fully compatible\nand significantly faster. This project also hopes to remove the Python multithreading Global Interpreter Lock (GIL), which prevents pure Python threads from truly\noverlapping in time. This is currently an emerging project being developed as open\nsource by Google engineers; it is initially targeting Python 2.6, though 3.0 may",
    "and significantly faster. This project also hopes to remove the Python multithreading Global Interpreter Lock (GIL), which prevents pure Python threads from truly\noverlapping in time. This is currently an emerging project being developed as open\nsource by Google engineers; it is initially targeting Python 2.6, though 3.0 may\nacquire its changes too. Search Google for up-to-date details.\nAlthough such future implementation schemes may alter the runtime structure of Python somewhat, it seems likely that the byte code compiler will still be the standard for\nExecution Model Variations | 33",
    "some time to come. The portability and runtime flexibility of byte code are important\nfeatures of many Python systems. Moreover, adding type constraint declarations to\nsupport static compilation would break the flexibility, conciseness, simplicity, and\noverall spirit of Python coding. Due to Python’s highly dynamic nature, any future\nimplementation will likely retain many artifacts of the current PVM.\n\nChapter Summary\nThis chapter introduced the execution model of Python (how Python runs your programs) and explored some common variations on that model (just-in-time compilers\nand the like). Although you don’t really need to come to grips with Python internals to\nwrite Python scripts, a passing acquaintance with this chapter’s topics will help you\ntruly understand how your programs run once you start coding them. In the next\nchapter, you’ll start actually running some code of your own. First, though, here’s the\nusual chapter quiz.",
    "Test Your Knowledge: Quiz\n1. What is the Python interpreter?\n2. What is source code?\n3. What is byte code?\n4. What is the PVM?\n5. Name two variations on Python’s standard execution model.\n6. How are CPython, Jython, and IronPython different?",
    "Test Your Knowledge: Answers\n1. The Python interpreter is a program that runs the Python programs you write.\n2. Source code is the statements you write for your program—it consists of text in\ntext files that normally end with a .py extension.\n3. Byte code is the lower-level form of your program after Python compiles it. Python\nautomatically stores byte code in files with a .pyc extension.\n4. The PVM is the Python Virtual Machine—the runtime engine of Python that interprets your compiled byte code.\n5. Psyco, Shedskin, and frozen binaries are all variations on the execution model.\n6. CPython is the standard implementation of the language. Jython and IronPython\nimplement Python programs for use in Java and .NET environments, respectively;\nthey are alternative compilers for Python.\n\n34 | Chapter 2: How Python Runs Programs\n\n\fCHAPTER 3\n\nHow You Run Programs",
    "OK, it’s time to start running some code. Now that you have a handle on program\nexecution, you’re finally ready to start some real Python programming. At this point,\nI’ll assume that you have Python installed on your computer; if not, see the prior chapter\nand Appendix A for installation and configuration hints.\nThere are a variety of ways to tell Python to execute the code you type. This chapter\ndiscusses all the program launching techniques in common use today. Along the way,\nyou’ll learn how to type code interactively and how to save it in files to be run with\nsystem command lines, icon clicks, module imports and reloads, exec calls, menu options in GUIs such as IDLE, and more.\nIf you just want to find out how to run a Python program quickly, you may be tempted\nto read the parts of this chapter that pertain only to your platform and move on to",
    "you’ll learn how to type code interactively and how to save it in files to be run with\nsystem command lines, icon clicks, module imports and reloads, exec calls, menu options in GUIs such as IDLE, and more.\nIf you just want to find out how to run a Python program quickly, you may be tempted\nto read the parts of this chapter that pertain only to your platform and move on to\nChapter 4. But don’t skip the material on module imports, as that’s essential to understanding Python’s program architecture. I also encourage you to at least skim the\nsections on IDLE and other IDEs, so you’ll know what tools are available for when you\nstart developing more sophisticated Python programs.",
    "The Interactive Prompt\nPerhaps the simplest way to run Python programs is to type them at Python’s interactive\ncommand line, sometimes called the interactive prompt. There are a variety of ways to\nstart this command line: in an IDE, from a system console, and so on. Assuming the\ninterpreter is installed as an executable program on your system, the most platformneutral way to start an interactive interpreter session is usually just to type python at\nyour operating system’s prompt, without any arguments. For example:\n\n35\n\n\f% python\nPython 3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)] ...\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>",
    "Typing the word “python” at your system shell prompt like this begins an interactive\nPython session; the “%” character at the start of this listing stands for a generic system\nprompt in this book—it’s not input that you type yourself. The notion of a system shell\nprompt is generic, but exactly how you access it varies by platform:\n• On Windows, you can type python in a DOS console window (a.k.a. the Command\nPrompt, usually found in the Accessories section of the Start→Programs menu) or\nin the Start→Run... dialog box.\n• On Unix, Linux, and Mac OS X, you might type this command in a shell or terminal\nwindow (e.g., in an xterm or console running a shell such as ksh or csh).\n• Other systems may use similar or platform-specific devices. On handheld devices,\nfor example, you generally click the Python icon in the home or application window\nto launch an interactive session.\nIf you have not set your shell’s PATH environment variable to include Python’s install",
    "window (e.g., in an xterm or console running a shell such as ksh or csh).\n• Other systems may use similar or platform-specific devices. On handheld devices,\nfor example, you generally click the Python icon in the home or application window\nto launch an interactive session.\nIf you have not set your shell’s PATH environment variable to include Python’s install\ndirectory, you may need to replace the word “python” with the full path to the Python\nexecutable on your machine. On Unix, Linux, and similar, /usr/local/bin/python\nor /usr/bin/python will often suffice. On Windows, try typing C:\\Python30\\python (for\nversion 3.0):\nC:\\misc> c:\\python30\\python\nPython 3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)] ...\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>",
    "Alternatively, you can run a change-directory command to go to Python’s install directory before typing “python”—try the cd c:\\python30 command on Windows, for\nexample:\nC:\\misc> cd C:\\Python30\nC:\\Python30> python\nPython 3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)] ...\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n\nOn Windows, besides typing python in a shell window, you can also begin similar\ninteractive sessions by starting IDLE’s main window (discussed later) or by selecting\nthe “Python (command line)” menu option from the Start button menu for Python, as\nshown in Figure 2-1 back in Chapter 2. Both spawn a Python interactive prompt with\nequivalent functionality; typing a shell command isn’t necessary.\n\n36 | Chapter 3: How You Run Programs",
    "36 | Chapter 3: How You Run Programs\n\n\fRunning Code Interactively\nHowever it’s started, the Python interactive session begins by printing two lines of\ninformational text (which I’ll omit from most of this book’s examples to save space),\nthen prompts for input with >>> when it’s waiting for you to type a new Python statement or expression. When working interactively, the results of your code are displayed\nafter the >>> lines after you press the Enter key.\nFor instance, here are the results of two Python print statements (print is really a\nfunction call in Python 3.0, but not in 2.6, so the parentheses here are required in 3.0\nonly):\n% python\n>>> print('Hello world!')\nHello world!\n>>> print(2 ** 8)\n256",
    "Again, you don’t need to worry about the details of the print statements shown here\nyet; we’ll start digging into syntax in the next chapter. In short, they print a Python\nstring and an integer, as shown by the output lines that appear after each >>> input line\n(2 ** 8 means 2 raised to the power 8 in Python).\nWhen coding interactively like this, you can type as many Python commands as you\nlike; each is run immediately after it’s entered. Moreover, because the interactive session automatically prints the results of expressions you type, you don’t usually need to\nsay “print” explicitly at this prompt:\n>>> lumberjack = 'okay'\n>>> lumberjack\n'okay'\n>>> 2 ** 8\n256\n>>>\n%\n\n<== Use Ctrl-D (on Unix) or Ctrl-Z (on Windows) to exit",
    "<== Use Ctrl-D (on Unix) or Ctrl-Z (on Windows) to exit\n\nHere, the fist line saves a value by assigning it to a variable, and the last two lines typed\nare expressions (lumberjack and 2 ** 8)—their results are displayed automatically. To\nexit an interactive session like this one and return to your system shell prompt, type\nCtrl-D on Unix-like machines; on MS-DOS and Windows systems, type Ctrl-Z to exit.\nIn the IDLE GUI discussed later, either type Ctrl-D or simply close the window.\nNow, we didn’t do much in this session’s code—just typed some Python print and\nassignment statements, along with a few expressions, which we’ll study in detail later.\nThe main thing to notice is that the interpreter executes the code entered on each line\nimmediately, when the Enter key is pressed.\n\nThe Interactive Prompt | 37",
    "The Interactive Prompt | 37\n\n\fFor example, when we typed the first print statement at the >>> prompt, the output (a\nPython string) was echoed back right away. There was no need to create a source-code\nfile, and no need to run the code through a compiler and linker first, as you’d normally\ndo when using a language such as C or C++. As you’ll see in later chapters, you can\nalso run multiline statements at the interactive prompt; such a statement runs immediately after you’ve entered all of its lines and pressed Enter twice to add a blank line.\n\nWhy the Interactive Prompt?\nThe interactive prompt runs code and echoes results as you go, but it doesn’t save your\ncode in a file. Although this means you won’t do the bulk of your coding in interactive\nsessions, the interactive prompt turns out to be a great place to both experiment with\nthe language and test program files on the fly.",
    "Experimenting\nBecause code is executed immediately, the interactive prompt is a perfect place to experiment with the language and will be used often in this book to demonstrate smaller\nexamples. In fact, this is the first rule of thumb to remember: if you’re ever in doubt\nabout how a piece of Python code works, fire up the interactive command line and try\nit out to see what happens.\nFor instance, suppose you’re reading a Python program’s code and you come across\nan expression like 'Spam!' * 8 whose meaning you don’t understand. At this point,\nyou can spend 10 minutes wading through manuals and books to try to figure out what\nthe code does, or you can simply run it interactively:\n>>> 'Spam!' * 8\n'Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!'\n\n<== Learning by trying",
    "<== Learning by trying\n\nThe immediate feedback you receive at the interactive prompt is often the quickest way\nto deduce what a piece of code does. Here, it’s clear that it does string repetition: in\nPython * means multiply for numbers, but repeat for strings—it’s like concatenating a\nstring to itself repeatedly (more on strings in Chapter 4).\nChances are good that you won’t break anything by experimenting this way—at least,\nnot yet. To do real damage, like deleting files and running shell commands, you must\nreally try, by importing modules explicitly (you also need to know more about Python’s\nsystem interfaces in general before you will become that dangerous!). Straight Python\ncode is almost always safe to run.\nFor instance, watch what happens when you make a mistake at the interactive prompt:\n\n38 | Chapter 3: How You Run Programs\n\n\f>>> X\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'X' is not defined\n\n<== Making mistakes",
    "38 | Chapter 3: How You Run Programs\n\n\f>>> X\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'X' is not defined\n\n<== Making mistakes\n\nIn Python, using a variable before it has been assigned a value is always an error (otherwise, if names were filled in with defaults, some errors might go undetected). We’ll\nlearn more about that later; the important point here is that you don’t crash Python or\nyour computer when you make a mistake this way. Instead, you get a meaningful error\nmessage pointing out the mistake and the line of code that made it, and you can continue on in your session or script. In fact, once you get comfortable with Python, its\nerror messages may often provide as much debugging support as you’ll need (you’ll\nread more on debugging in the sidebar “Debugging Python Code” on page 67).",
    "Testing\nBesides serving as a tool for experimenting while you’re learning the language, the\ninteractive interpreter is also an ideal place to test code you’ve written in files. You can\nimport your module files interactively and run tests on the tools they define by typing\ncalls at the interactive prompt.\nFor instance, of the following tests a function in a precoded module that ships with\nPython in its standard library (it prints the name of the directory you’re currently\nworking in), but you can do the same once you start writing module files of your own:\n>>> import os\n>>> os.getcwd()\n'c:\\\\Python30'\n\n<== Testing on the fly",
    "<== Testing on the fly\n\nMore generally, the interactive prompt is a place to test program components, regardless of their source—you can import and test functions and classes in your Python files,\ntype calls to linked-in C functions, exercise Java classes under Jython, and more. Partly\nbecause of its interactive nature, Python supports an experimental and exploratory\nprogramming style you’ll find convenient when getting started.",
    "Using the Interactive Prompt\nAlthough the interactive prompt is simple to use, there are a few tips that beginners\nshould keep in mind. I’m including lists of common mistakes like this in this chapter\nfor reference, but they might also spare you from a few headaches if you read them up\nfront:\n• Type Python commands only. First of all, remember that you can only type Python code at the Python prompt, not system commands. There are ways to run\nsystem commands from within Python code (e.g., with os.system), but they are\nnot as direct as simply typing the commands themselves.\n\nThe Interactive Prompt | 39",
    "• print statements are required only in files. Because the interactive interpreter\nautomatically prints the results of expressions, you do not need to type complete\nprint statements interactively. This is a nice feature, but it tends to confuse users\nwhen they move on to writing code in files: within a code file, you must use\nprint statements to see your output because expression results are not automatically echoed. Remember, you must say print in files, but not interactively.\n• Don’t indent at the interactive prompt (yet). When typing Python programs,\neither interactively or into a text file, be sure to start all your unnested statements\nin column 1 (that is, all the way to the left). If you don’t, Python may print a\n“SyntaxError” message, because blank space to the left of your code is taken to be\nindentation that groups nested statements. Until Chapter 10, all statements you\nwrite will be unnested, so this includes everything for now. This seems to be a",
    "in column 1 (that is, all the way to the left). If you don’t, Python may print a\n“SyntaxError” message, because blank space to the left of your code is taken to be\nindentation that groups nested statements. Until Chapter 10, all statements you\nwrite will be unnested, so this includes everything for now. This seems to be a\nrecurring confusion in introductory Python classes. Remember, a leading space\ngenerates an error message.\n• Watch out for prompt changes for compound statements. We won’t meet\ncompound (multiline) statements until Chapter 4, and not in earnest until Chapter 10, but as a preview, you should know that when typing lines 2 and beyond of\na compound statement interactively, the prompt may change. In the simple shell\nwindow interface, the interactive prompt changes to ... instead of >>> for lines 2\nand beyond; in the IDLE interface, lines after the first are automatically indented.\nYou’ll see why this matters in Chapter 10. For now, if you happen to come across",
    "a compound statement interactively, the prompt may change. In the simple shell\nwindow interface, the interactive prompt changes to ... instead of >>> for lines 2\nand beyond; in the IDLE interface, lines after the first are automatically indented.\nYou’ll see why this matters in Chapter 10. For now, if you happen to come across\na ... prompt or a blank line when entering your code, it probably means that you’ve\nsomehow confused interactive Python into thinking you’re typing a multiline\nstatement. Try hitting the Enter key or a Ctrl-C combination to get back to the\nmain prompt. The >>> and ... prompt strings can also be changed (they are available in the built-in module sys), but I’ll assume they have not been in the book’s\nexample listings.\n• Terminate compound statements at the interactive prompt with a blank\nline. At the interactive prompt, inserting a blank line (by hitting the Enter key at\nthe start of a line) is necessary to tell interactive Python that you’re done typing the",
    "example listings.\n• Terminate compound statements at the interactive prompt with a blank\nline. At the interactive prompt, inserting a blank line (by hitting the Enter key at\nthe start of a line) is necessary to tell interactive Python that you’re done typing the\nmultiline statement. That is, you must press Enter twice to make a compound\nstatement run. By contrast, blank lines are not required in files and are simply\nignored if present. If you don’t press Enter twice at the end of a compound statement when working interactively, you’ll appear to be stuck in a limbo state, because\nthe interactive interpreter will do nothing at all—it’s waiting for you to press Enter\nagain!\n• The interactive prompt runs one statement at a time. At the interactive prompt,\nyou must run one statement to completion before typing another. This is natural\nfor simple statements, because pressing the Enter key runs the statement entered.\nFor compound statements, though, remember that you must submit a blank line",
    "again!\n• The interactive prompt runs one statement at a time. At the interactive prompt,\nyou must run one statement to completion before typing another. This is natural\nfor simple statements, because pressing the Enter key runs the statement entered.\nFor compound statements, though, remember that you must submit a blank line\nto terminate the statement and make it run before you can type the next statement.",
    "40 | Chapter 3: How You Run Programs\n\n\fEntering multiline statements\nAt the risk of repeating myself, I received emails from readers who’d gotten burned by\nthe last two points as I was updating this chapter, so it probably merits emphasis. I’ll\nintroduce multiline (a.k.a. compound) statements in the next chapter, and we’ll explore\ntheir syntax more formally later in this book. Because their behavior differs slightly in\nfiles and at the interactive prompt, though, two cautions are in order here.\nFirst, be sure to terminate multiline compound statements like for loops and if tests\nat the interactive prompt with a blank line. You must press the Enter key twice, to terminate the whole multiline statement and then make it run. For example (pun not\nintended...):\n>>> for x in 'spam':\n...\nprint(x)\n...\n\n<== Press Enter twice here to make this loop run",
    "<== Press Enter twice here to make this loop run\n\nYou don’t need the blank line after compound statements in a script file, though; this\nis required only at the interactive prompt. In a file, blank lines are not required and are\nsimply ignored when present; at the interactive prompt, they terminate multiline\nstatements.\nAlso bear in mind that the interactive prompt runs just one statement at a time: you\nmust press Enter twice to run a loop or other multiline statement before you can type\nthe next statement:\n>>> for x in 'spam':\n...\nprint(x)\n... print('done')\nFile \"<stdin>\", line 3\nprint('done')\n^\nSyntaxError: invalid syntax\n\n<== Need to press Enter twice before a new statement\n\nThis means you can’t cut and paste multiple lines of code into the interactive prompt,\nunless the code includes blank lines after each compound statement. Such code is better\nrun in a file—the next section’s topic.",
    "<== Need to press Enter twice before a new statement\n\nThis means you can’t cut and paste multiple lines of code into the interactive prompt,\nunless the code includes blank lines after each compound statement. Such code is better\nrun in a file—the next section’s topic.\n\nSystem Command Lines and Files\nAlthough the interactive prompt is great for experimenting and testing, it has one big\ndisadvantage: programs you type there go away as soon as the Python interpreter executes them. Because the code you type interactively is never stored in a file, you can’t\nrun it again without retyping it from scratch. Cut-and-paste and command recall can\nhelp some here, but not much, especially when you start writing larger programs. To\ncut and paste code from an interactive session, you would have to edit out Python\nprompts, program outputs, and so on—not exactly a modern software development\nmethodology!\n\nSystem Command Lines and Files | 41",
    "To save programs permanently, you need to write your code in files, which are usually\nknown as modules. Modules are simply text files containing Python statements. Once\ncoded, you can ask the Python interpreter to execute the statements in such a file any\nnumber of times, and in a variety of ways—by system command lines, by file icon clicks,\nby options in the IDLE user interface, and more. Regardless of how it is run, Python\nexecutes all the code in a module file from top to bottom each time you run the file.\nTerminology in this domain can vary somewhat. For instance, module files are often\nreferred to as programs in Python—that is, a program is considered to be a series of\nprecoded statements stored in a file for repeated execution. Module files that are run\ndirectly are also sometimes called scripts—an informal term usually meaning a top-level\nprogram file. Some reserve the term “module” for a file imported from another file.",
    "referred to as programs in Python—that is, a program is considered to be a series of\nprecoded statements stored in a file for repeated execution. Module files that are run\ndirectly are also sometimes called scripts—an informal term usually meaning a top-level\nprogram file. Some reserve the term “module” for a file imported from another file.\n(More on the meaning of “top-level” and imports in a few moments.)\nWhatever you call them, the next few sections explore ways to run code typed into\nmodule files. In this section, you’ll learn how to run files in the most basic way: by\nlisting their names in a python command line entered at your computer’s system\nprompt. Though it might seem primitive to some, for many programmers a system shell\ncommand-line window, together with a text editor window, constitutes as much of an\nintegrated development environment as they will ever need.",
    "A First Script\nLet’s get started. Open your favorite text editor (e.g., vi, Notepad, or the IDLE editor),\nand type the following statements into a new text file named script1.py:\n# A first Python script\nimport sys\nprint(sys.platform)\nprint(2 ** 100)\nx = 'Spam!'\nprint(x * 8)\n\n# Load a library module\n# Raise 2 to a power\n# String repetition",
    "# Load a library module\n# Raise 2 to a power\n# String repetition\n\nThis file is our first official Python script (not counting the two-liner in Chapter 2). You\nshouldn’t worry too much about this file’s code, but as a brief description, this file:\n• Imports a Python module (libraries of additional tools), to fetch the name of the\nplatform\n• Runs three print function calls, to display the script’s results\n• Uses a variable named x, created when it’s assigned, to hold onto a string object\n• Applies various object operations that we’ll begin studying in the next chapter\nThe sys.platform here is just a string that identifies the kind of computer you’re working on; it lives in a standard Python module called sys, which you must import to load\n(again, more on imports later).\n\n42 | Chapter 3: How You Run Programs",
    "For color, I’ve also added some formal Python comments here—the text after the #\ncharacters. Comments can show up on lines by themselves, or to the right of code on\na line. The text after a # is simply ignored as a human-readable comment and is not\nconsidered part of the statement’s syntax. If you’re copying this code, you can ignore\nthe comments as well. In this book, we usually use a different formatting style to make\ncomments more visually distinctive, but they’ll appear as normal text in your code.\nAgain, don’t focus on the syntax of the code in this file for now; we’ll learn about all\nof it later. The main point to notice is that you’ve typed this code into a file, rather than\nat the interactive prompt. In the process, you’ve coded a fully functional Python script.\nNotice that the module file is called script1.py. As for all top-level files, it could also be\ncalled simply script, but files of code you want to import into a client have to end with",
    "of it later. The main point to notice is that you’ve typed this code into a file, rather than\nat the interactive prompt. In the process, you’ve coded a fully functional Python script.\nNotice that the module file is called script1.py. As for all top-level files, it could also be\ncalled simply script, but files of code you want to import into a client have to end with\na .py suffix. We’ll study imports later in this chapter. Because you may want to import\nthem in the future, it’s a good idea to use .py suffixes for most Python files that you\ncode. Also, some text editors detect Python files by their .py suffix; if the suffix is not\npresent, you may not get features like syntax colorization and automatic indentation.",
    "Running Files with Command Lines\nOnce you’ve saved this text file, you can ask Python to run it by listing its full filename\nas the first argument to a python command, typed at the system shell prompt:\n% python script1.py\nwin32\n1267650600228229401496703205376\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!",
    "Again, you can type such a system shell command in whatever your system provides\nfor command-line entry—a Windows Command Prompt window, an xterm window,\nor similar. Remember to replace “python” with a full directory path, as before, if your\nPATH setting is not configured.\nIf all works as planned, this shell command makes Python run the code in this file line\nby line, and you will see the output of the script’s three print statements—the name\nof the underlying platform, 2 raised to the power 100, and the result of the same string\nrepetition expression we saw earlier (again, more on the last two of these in Chapter 4).\nIf all didn’t work as planned, you’ll get an error message—make sure you’ve entered\nthe code in your file exactly as shown, and try again. We’ll talk about debugging options\nin the sidebar “Debugging Python Code” on page 67, but at this point in the book\nyour best bet is probably rote imitation.",
    "repetition expression we saw earlier (again, more on the last two of these in Chapter 4).\nIf all didn’t work as planned, you’ll get an error message—make sure you’ve entered\nthe code in your file exactly as shown, and try again. We’ll talk about debugging options\nin the sidebar “Debugging Python Code” on page 67, but at this point in the book\nyour best bet is probably rote imitation.\nBecause this scheme uses shell command lines to start Python programs, all the usual\nshell syntax applies. For instance, you can route the output of a Python script to a file\nto save it for later use or inspection by using special shell syntax:\n% python script1.py > saveit.txt",
    "System Command Lines and Files | 43\n\n\fIn this case, the three output lines shown in the prior run are stored in the file\nsaveit.txt instead of being printed. This is generally known as stream redirection; it\nworks for input and output text and is available on Windows and Unix-like systems.\nIt also has little to do with Python (Python simply supports it), so we will skip further\ndetails on shell redirection syntax here.\nIf you are working on a Windows platform, this example works the same, but the system\nprompt is normally different:\nC:\\Python30> python script1.py\nwin32\n1267650600228229401496703205376\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!\n\nAs usual, be sure to type the full path to Python if you haven’t set your PATH environment\nvariable to include this path or run a change-directory command to go to the path:\nD:\\temp> C:\\python30\\python script1.py\nwin32\n1267650600228229401496703205376\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!",
    "As usual, be sure to type the full path to Python if you haven’t set your PATH environment\nvariable to include this path or run a change-directory command to go to the path:\nD:\\temp> C:\\python30\\python script1.py\nwin32\n1267650600228229401496703205376\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!\n\nOn all recent versions of Windows, you can also type just the name of your script, and\nomit the name of Python itself. Because newer Windows systems use the Windows\nRegistry to find a program with which to run a file, you don’t need to name “python”\non the command line explicitly to run a .py file. The prior command, for example, could\nbe simplified to this on most Windows machines:\nD:\\temp> script1.py",
    "Finally, remember to give the full path to your script file if it lives in a different directory\nfrom the one in which you are working. For example, the following system command\nline, run from D:\\other, assumes Python is in your system path but runs a file located\nelsewhere:\nD:\\other> python c:\\code\\otherscript.py\n\nIf your PATH doesn’t include Python’s directory, and neither Python nor your script file\nis in the directory you’re working in, use full paths for both:\nD:\\other> C:\\Python30\\python c:\\code\\otherscript.py\n\nUsing Command Lines and Files\nRunning program files from system command lines is also a fairly straightforward\nlaunch option, especially if you are familiar with command lines in general from prior\nwork. For newcomers, though, here are a few pointers about common beginner traps\nthat might help you avoid some frustration:\n\n44 | Chapter 3: How You Run Programs",
    "• Beware of automatic extensions on Windows. If you use the Notepad program\nto code program files on Windows, be careful to pick the type All Files when it\ncomes time to save your file, and give the file a .py suffix explicitly. Otherwise,\nNotepad will save your file with a .txt extension (e.g., as script1.py.txt), making it\ndifficult to run in some launching schemes.\nWorse, Windows hides file extensions by default, so unless you have changed your\nview options you may not even notice that you’ve coded a text file and not a Python\nfile. The file’s icon may give this away—if it doesn’t have a snake on it, you may\nhave trouble. Uncolored code in IDLE and files that open to edit instead of run\nwhen clicked are other symptoms of this problem.\nMicrosoft Word similarly adds a .doc extension by default; much worse, it adds\nformatting characters that are not legal Python syntax. As a rule of thumb, always\npick All Files when saving under Windows, or use a more programmer-friendly",
    "have trouble. Uncolored code in IDLE and files that open to edit instead of run\nwhen clicked are other symptoms of this problem.\nMicrosoft Word similarly adds a .doc extension by default; much worse, it adds\nformatting characters that are not legal Python syntax. As a rule of thumb, always\npick All Files when saving under Windows, or use a more programmer-friendly\ntext editor such as IDLE. IDLE does not even add a .py suffix automatically—a\nfeature programmers tend to like, but users do not.\n• Use file extensions and directory paths at system prompts, but not for imports. Don’t forget to type the full name of your file in system command lines—\nthat is, use python script1.py rather than python script1. By contrast, Python’s\nimport statements, which we’ll meet later in this chapter, omit both the .py file\nsuffix and the directory path (e.g., import script1). This may seem trivial, but\nconfusing these two is a common mistake.",
    "that is, use python script1.py rather than python script1. By contrast, Python’s\nimport statements, which we’ll meet later in this chapter, omit both the .py file\nsuffix and the directory path (e.g., import script1). This may seem trivial, but\nconfusing these two is a common mistake.\nAt the system prompt, you are in a system shell, not Python, so Python’s module\nfile search rules do not apply. Because of that, you must include both the .py extension and, if necessary, the full directory path leading to the file you wish to run.\nFor instance, to run a file that resides in a different directory from the one in\nwhich you are working, you would typically list its full path (e.g.,\npython d:\\tests\\spam.py). Within Python code, however, you can just say\nimport spam and rely on the Python module search path to locate your file, as\ndescribed later.\n• Use print statements in files. Yes, we’ve already been over this, but it is such a",
    "which you are working, you would typically list its full path (e.g.,\npython d:\\tests\\spam.py). Within Python code, however, you can just say\nimport spam and rely on the Python module search path to locate your file, as\ndescribed later.\n• Use print statements in files. Yes, we’ve already been over this, but it is such a\ncommon mistake that it’s worth repeating at least once here. Unlike in interactive\ncoding, you generally must use print statements to see output from program files.\nIf you don’t see any output, make sure you’ve said “print” in your file. Again,\nthough, print statements are not required in an interactive session, since Python\nautomatically echoes expression results; prints don’t hurt here, but are superfluous\nextra typing.",
    "System Command Lines and Files | 45",
    "Unix Executable Scripts (#!)\nIf you are going to use Python on a Unix, Linux, or Unix-like system, you can also turn\nfiles of Python code into executable programs, much as you would for programs coded\nin a shell language such as csh or ksh. Such files are usually called executable scripts.\nIn simple terms, Unix-style executable scripts are just normal text files containing Python statements, but with two special properties:\n• Their first line is special. Scripts usually start with a line that begins with the\ncharacters #! (often called “hash bang”), followed by the path to the Python interpreter on your machine.\n• They usually have executable privileges. Script files are usually marked as executable to tell the operating system that they may be run as top-level programs.\nOn Unix systems, a command such as chmod +x file.py usually does the trick.\nLet’s look at an example for Unix-like systems. Use your text editor again to create a\nfile of Python code called brian:",
    "• They usually have executable privileges. Script files are usually marked as executable to tell the operating system that they may be run as top-level programs.\nOn Unix systems, a command such as chmod +x file.py usually does the trick.\nLet’s look at an example for Unix-like systems. Use your text editor again to create a\nfile of Python code called brian:\n#!/usr/local/bin/python\nprint('The Bright Side ' + 'of Life...')",
    "# + means concatenate for strings",
    "The special line at the top of the file tells the system where the Python interpreter lives.\nTechnically, the first line is a Python comment. As mentioned earlier, all comments in\nPython programs start with a # and span to the end of the line; they are a place to insert\nextra information for human readers of your code. But when a comment such as the\nfirst line in this file appears, it’s special because the operating system uses it to find an\ninterpreter for running the program code in the rest of the file.\nAlso, note that this file is called simply brian, without the .py suffix used for the module\nfile earlier. Adding a .py to the name wouldn’t hurt (and might help you remember that\nthis is a Python program file), but because you don’t plan on letting other modules\nimport the code in this file, the name of the file is irrelevant. If you give the file executable\nprivileges with a chmod +x brian shell command, you can run it from the operating",
    "file earlier. Adding a .py to the name wouldn’t hurt (and might help you remember that\nthis is a Python program file), but because you don’t plan on letting other modules\nimport the code in this file, the name of the file is irrelevant. If you give the file executable\nprivileges with a chmod +x brian shell command, you can run it from the operating\nsystem shell as though it were a binary program:\n% brian\nThe Bright Side of Life...",
    "A note for Windows users: the method described here is a Unix trick, and it may not\nwork on your platform. Not to worry; just use the basic command-line technique explored earlier. List the file’s name on an explicit python command line:*\n* As we discussed when exploring command lines, modern Windows versions also let you type just the name\nof a .py file at the system command line—they use the Registry to determine that the file should be opened\nwith Python (e.g., typing brian.py is equivalent to typing python brian.py). This command-line mode is\nsimilar in spirit to the Unix #!, though it is system-wide on Windows, not per-file. Note that some\nprograms may actually interpret and use a first #! line on Windows much like on Unix, but the DOS system\nshell on Windows simply ignores it.\n\n46 | Chapter 3: How You Run Programs\n\n\fC:\\misc> python brian\nThe Bright Side of Life...",
    "46 | Chapter 3: How You Run Programs\n\n\fC:\\misc> python brian\nThe Bright Side of Life...\n\nIn this case, you don’t need the special #! comment at the top (although Python just\nignores it if it’s present), and the file doesn’t need to be given executable privileges. In\nfact, if you want to run files portably between Unix and Microsoft Windows, your life\nwill probably be simpler if you always use the basic command-line approach, not Unixstyle scripts, to launch programs.\n\nThe Unix env Lookup Trick\nOn some Unix systems, you can avoid hardcoding the path to the Python interpreter\nby writing the special first-line comment like this:\n#!/usr/bin/env python\n...script goes here...",
    "The Unix env Lookup Trick\nOn some Unix systems, you can avoid hardcoding the path to the Python interpreter\nby writing the special first-line comment like this:\n#!/usr/bin/env python\n...script goes here...\n\nWhen coded this way, the env program locates the Python interpreter according to your\nsystem search path settings (i.e., in most Unix shells, by looking in all the directories\nlisted in the PATH environment variable). This scheme can be more portable, as you\ndon’t need to hardcode a Python install path in the first line of all your scripts.\nProvided you have access to env everywhere, your scripts will run no matter where\nPython lives on your system—you need only change the PATH environment variable\nsettings across platforms, not in the first line in all your scripts. Of course, this assumes\nthat env lives in the same place everywhere (on some machines, it may be\nin /sbin, /bin, or elsewhere); if not, all portability bets are off!",
    "Clicking File Icons\nOn Windows, the Registry makes opening files with icon clicks easy. Python automatically registers itself to be the program that opens Python program files when they are\nclicked. Because of that, it is possible to launch the Python programs you write by\nsimply clicking (or double-clicking) on their file icons with your mouse cursor.\nOn non-Windows systems, you will probably be able to perform a similar trick, but\nthe icons, file explorer, navigation schemes, and more may differ slightly. On some\nUnix systems, for instance, you may need to register the .py extension with your file\nexplorer GUI, make your script executable using the #! trick discussed in the previous\nsection, or associate the file MIME type with an application or command by editing\nfiles, installing programs, or using other tools. See your file explorer’s documentation\nfor more details if clicks do not work correctly right off the bat.",
    "Clicking Icons on Windows\nTo illustrate, let’s keep using the script we wrote earlier, script1.py, repeated here to\nminimize page flipping:\nClicking File Icons | 47\n\n\f# A first Python script\nimport sys\nprint(sys.platform)\nprint(2 ** 100)\nx = 'Spam!'\nprint(x * 8)\n\n# Load a library module\n# Raise 2 to a power\n# String repetition\n\nAs we’ve seen, you can always run this file from a system command line:\nC:\\misc> c:\\python30\\python script1.py\nwin32\n1267650600228229401496703205376",
    "# A first Python script\nimport sys\nprint(sys.platform)\nprint(2 ** 100)\nx = 'Spam!'\nprint(x * 8)\n\n# Load a library module\n# Raise 2 to a power\n# String repetition\n\nAs we’ve seen, you can always run this file from a system command line:\nC:\\misc> c:\\python30\\python script1.py\nwin32\n1267650600228229401496703205376\n\nHowever, icon clicks allow you to run the file without any typing at all. If you find this\nfile’s icon—for instance, by selecting Computer (or My Computer in XP) in your Start\nmenu and working your way down on the C drive on Windows—you will get the file\nexplorer picture captured in Figure 3-1 (Windows Vista is being used here). Python\nsource files show up with white backgrounds on Windows, and byte code files show\nup with black backgrounds. You will normally want to click (or otherwise run) the\nsource code file, in order to pick up your most recent changes. To launch the file here,\nsimply click on the icon for script1.py.",
    "Figure 3-1. On Windows, Python program files show up as icons in file explorer windows and can\nautomatically be run with a double-click of the mouse (though you might not see printed output or\nerror messages this way).\n\n48 | Chapter 3: How You Run Programs",
    "The input Trick\nUnfortunately, on Windows, the result of clicking on a file icon may not be incredibly\nsatisfying. In fact, as it is, this example script generates a perplexing “flash” when\nclicked—not exactly the sort of feedback that budding Python programmers usually\nhope for! This is not a bug, but has to do with the way the Windows version of Python\nhandles printed output.\nBy default, Python generates a pop-up black DOS console window to serve as a clicked\nfile’s input and output. If a script just prints and exits, well, it just prints and exits—\nthe console window appears, and text is printed there, but the console window closes\nand disappears on program exit. Unless you are very fast, or your machine is very slow,\nyou won’t get to see your output at all. Although this is normal behavior, it’s probably\nnot what you had in mind.\nLuckily, it’s easy to work around this. If you need your script’s output to stick around",
    "the console window appears, and text is printed there, but the console window closes\nand disappears on program exit. Unless you are very fast, or your machine is very slow,\nyou won’t get to see your output at all. Although this is normal behavior, it’s probably\nnot what you had in mind.\nLuckily, it’s easy to work around this. If you need your script’s output to stick around\nwhen you launch it with an icon click, simply put a call to the built-in input function\nat the very bottom of the script (raw_input in 2.6: see the note ahead). For example:\n# A first Python script\nimport sys\nprint(sys.platform)\nprint(2 ** 100)\nx = 'Spam!'\nprint(x * 8)\ninput()",
    "# Load a library module\n# Raise 2 to a power\n# String repetition\n# <== ADDED\n\nIn general, input reads the next line of standard input, waiting if there is none yet\navailable. The net effect in this context will be to pause the script, thereby keeping the\noutput window shown in Figure 3-2 open until you press the Enter key.\n\nFigure 3-2. When you click a program’s icon on Windows, you will be able to see its printed output\nif you include an input call at the very end of the script. But you only need to do so in this context!\n\nClicking File Icons | 49",
    "Now that I’ve shown you this trick, keep in mind that it is usually only required for\nWindows, and then only if your script prints text and exits and only if you will launch\nthe script by clicking its file icon. You should add this call to the bottom of your toplevel files if and only if all of these three conditions apply. There is no reason to add\nthis call in any other contexts (unless you’re unreasonably fond of pressing your computer’s Enter key!).† That may sound obvious, but it’s another common mistake in live\nclasses.\nBefore we move ahead, note that the input call applied here is the input counterpart of\nusing the print statement for outputs. It is the simplest way to read user input, and it\nis more general than this example implies. For instance, input:\n• Optionally accepts a string that will be printed as a prompt (e.g., input('Press\nEnter to exit'))\n• Returns to your script a line of text read as a string (e.g., nextinput = input())",
    "using the print statement for outputs. It is the simplest way to read user input, and it\nis more general than this example implies. For instance, input:\n• Optionally accepts a string that will be printed as a prompt (e.g., input('Press\nEnter to exit'))\n• Returns to your script a line of text read as a string (e.g., nextinput = input())\n• Supports input stream redirections at the system shell level (e.g., python spam.py\n< input.txt), just as the print statement does for output\nWe’ll use input in more advanced ways later in this text; for instance, Chapter 10 will\napply it in an interactive loop.\nVersion skew note: If you are working in Python 2.6 or earlier, use\nraw_input() instead of input() in this code. The former was renamed to\nthe latter in Python 3.0. Technically, 2.6 has an input too, but it also\nevaluates strings as though they are program code typed into a script,\nand so will not work in this context (an empty string is an error). Python",
    "apply it in an interactive loop.\nVersion skew note: If you are working in Python 2.6 or earlier, use\nraw_input() instead of input() in this code. The former was renamed to\nthe latter in Python 3.0. Technically, 2.6 has an input too, but it also\nevaluates strings as though they are program code typed into a script,\nand so will not work in this context (an empty string is an error). Python\n3.0’s input (and 2.6’s raw_input) simply returns the entered text as a\nstring, unevaluated. To simulate 2.6’s input in 3.0, use eval(input()).",
    "Other Icon-Click Limitations\nEven with the input trick, clicking file icons is not without its perils. You also may not\nget to see Python error messages. If your script generates an error, the error message\ntext is written to the pop-up console window—which then immediately disappears!\nWorse, adding an input call to your file will not help this time because your script will\nlikely abort long before it reaches this call. In other words, you won’t be able to tell\nwhat went wrong.\n\n† It is also possible to completely suppress the pop-up DOS console window for clicked files on Windows.\nFiles whose names end in a .pyw extension will display only windows constructed by your script, not the\ndefault DOS console window. .pyw files are simply .py source files that have this special operational behavior\non Windows. They are mostly used for Python-coded user interfaces that build windows of their own, often\nin conjunction with various techniques for saving printed output and errors to files.",
    "50 | Chapter 3: How You Run Programs\n\n\fBecause of these limitations, it is probably best to view icon clicks as a way to launch\nprograms after they have been debugged or have been instrumented to write their output to a file. Especially when starting out, use other techniques—such as system\ncommand lines and IDLE (discussed further in the section “The IDLE User Interface” on page 58)—so that you can see generated error messages and view your\nnormal output without resorting to coding tricks. When we discuss exceptions later in\nthis book, you’ll also learn that it is possible to intercept and recover from errors so\nthat they do not terminate your programs. Watch for the discussion of the try statement\nlater in this book for an alternative way to keep the console window from closing on\nerrors.",
    "Module Imports and Reloads\nSo far, I’ve been talking about “importing modules” without really explaining what this\nterm means. We’ll study modules and larger program architecture in depth in Part V,\nbut because imports are also a way to launch programs, this section will introduce\nenough module basics to get you started.\nIn simple terms, every file of Python source code whose name ends in a .py extension\nis a module. Other files can access the items a module defines by importing that module;\nimport operations essentially load another file and grant access to that file’s contents.\nThe contents of a module are made available to the outside world through its attributes\n(a term I’ll define in the next section).\nThis module-based services model turns out to be the core idea behind program architecture in Python. Larger programs usually take the form of multiple module files,\nwhich import tools from other module files. One of the modules is designated as the",
    "The contents of a module are made available to the outside world through its attributes\n(a term I’ll define in the next section).\nThis module-based services model turns out to be the core idea behind program architecture in Python. Larger programs usually take the form of multiple module files,\nwhich import tools from other module files. One of the modules is designated as the\nmain or top-level file, and this is the one launched to start the entire program.\nWe’ll delve into such architectural issues in more detail later in this book. This chapter\nis mostly interested in the fact that import operations run the code in a file that is being\nloaded as a final step. Because of this, importing a file is yet another way to launch it.\nFor instance, if you start an interactive session (from a system command line, from the\nStart menu, from IDLE, or otherwise), you can run the script1.py file you created earlier",
    "is mostly interested in the fact that import operations run the code in a file that is being\nloaded as a final step. Because of this, importing a file is yet another way to launch it.\nFor instance, if you start an interactive session (from a system command line, from the\nStart menu, from IDLE, or otherwise), you can run the script1.py file you created earlier\nwith a simple import (be sure to delete the input line you added in the prior section\nfirst, or you’ll need to press Enter for no reason):\nC:\\misc> c:\\python30\\python\n>>> import script1\nwin32\n1267650600228229401496703205376\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!",
    "Module Imports and Reloads | 51\n\n\fThis works, but only once per session (really, process) by default. After the first import,\nlater imports do nothing, even if you change and save the module’s source file again in\nanother window:\n>>> import script1\n>>> import script1\n\nThis is by design; imports are too expensive an operation to repeat more than once per\nfile, per program run. As you’ll learn in Chapter 21, imports must find files, compile\nthem to byte code, and run the code.\nIf you really want to force Python to run the file again in the same session without\nstopping and restarting the session, you need to instead call the reload function available in the imp standard library module (this function is also a simple built-in in Python\n2.6, but not in 3.0):\n>>> from imp import reload\n# Must load from module in 3.0\n>>> reload(script1)\nwin32\n65536\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!\n<module 'script1' from 'script1.py'>\n>>>",
    "The from statement here simply copies a name out of a module (more on this soon).\nThe reload function itself loads and runs the current version of your file’s code, picking\nup changes if you’ve changed and saved it in another window.\nThis allows you to edit and pick up new code on the fly within the current Python\ninteractive session. In this session, for example, the second print statement in\nscript1.py was changed in another window to print 2 ** 16 between the time of the\nfirst import and the reload call.\nThe reload function expects the name of an already loaded module object, so you have\nto have successfully imported a module once before you reload it. Notice that reload\nalso expects parentheses around the module object name, whereas import does not.\nreload is a function that is called, and import is a statement.\nThat’s why you must pass the module name to reload as an argument in parentheses,\nand that’s why you get back an extra output line when reloading. The last output line",
    "to have successfully imported a module once before you reload it. Notice that reload\nalso expects parentheses around the module object name, whereas import does not.\nreload is a function that is called, and import is a statement.\nThat’s why you must pass the module name to reload as an argument in parentheses,\nand that’s why you get back an extra output line when reloading. The last output line\nis just the display representation of the reload call’s return value, a Python module\nobject. We’ll learn more about using functions in general in Chapter 16.",
    "52 | Chapter 3: How You Run Programs",
    "Version skew note: Python 3.0 moved the reload built-in function to the\nimp standard library module. It still reloads files as before, but you must\nimport it in order to use it. In 3.0, run an import imp and use\nimp.reload(M), or run a from imp import reload and use reload(M), as\nshown here. We’ll discuss import and from statements in the next section, and more formally later in this book.\nIf you are working in Python 2.6 (or 2.X in general), reload is available\nas a built-in function, so no import is required. In Python 2.6, reload is\navailable in both forms—built-in and module function—to aid the transition to 3.0. In other words, reloading is still available in 3.0, but an\nextra line of code is required to fetch the reload call.\nThe move in 3.0 was likely motivated in part by some well-known issues\ninvolving reload and from statements that we’ll encounter in the next\nsection. In short, names loaded with a from are not directly updated by",
    "extra line of code is required to fetch the reload call.\nThe move in 3.0 was likely motivated in part by some well-known issues\ninvolving reload and from statements that we’ll encounter in the next\nsection. In short, names loaded with a from are not directly updated by\na reload, but names accessed with an import statement are. If your\nnames don’t seem to change after a reload, try using import and\nmodule.attribute name references instead.",
    "The Grander Module Story: Attributes\nImports and reloads provide a natural program launch option because import operations execute files as a last step. In the broader scheme of things, though, modules serve\nthe role of libraries of tools, as you’ll learn in Part V. More generally, a module is mostly\njust a package of variable names, known as a namespace. The names within that package\nare called attributes—an attribute is simply a variable name that is attached to a specific\nobject (like a module).\nIn typical use, importers gain access to all the names assigned at the top level of a\nmodule’s file. These names are usually assigned to tools exported by the module—\nfunctions, classes, variables, and so on—that are intended to be used in other files and\nother programs. Externally, a module file’s names can be fetched with two Python\nstatements, import and from, as well as the reload call.\nTo illustrate, use a text editor to create a one-line Python module file called myfile.py",
    "module’s file. These names are usually assigned to tools exported by the module—\nfunctions, classes, variables, and so on—that are intended to be used in other files and\nother programs. Externally, a module file’s names can be fetched with two Python\nstatements, import and from, as well as the reload call.\nTo illustrate, use a text editor to create a one-line Python module file called myfile.py\nwith the following contents:\ntitle = \"The Meaning of Life\"",
    "This may be one of the world’s simplest Python modules (it contains a single assignment\nstatement), but it’s enough to illustrate the point. When this file is imported, its code\nis run to generate the module’s attribute. The assignment statement creates a module\nattribute named title.\n\nModule Imports and Reloads | 53\n\n\fYou can access this module’s title attribute in other components in two different ways.\nFirst, you can load the module as a whole with an import statement, and then qualify\nthe module name with the attribute name to fetch it:\n% python\n>>> import myfile\n>>> print(myfile.title)\nThe Meaning of Life\n\n# Start Python\n# Run file; load module as a whole\n# Use its attribute names: '.' to qualify",
    "You can access this module’s title attribute in other components in two different ways.\nFirst, you can load the module as a whole with an import statement, and then qualify\nthe module name with the attribute name to fetch it:\n% python\n>>> import myfile\n>>> print(myfile.title)\nThe Meaning of Life\n\n# Start Python\n# Run file; load module as a whole\n# Use its attribute names: '.' to qualify\n\nIn general, the dot expression syntax object.attribute lets you fetch any attribute\nattached to any object, and this is a very common operation in Python code. Here,\nwe’ve used it to access the string variable title inside the module myfile—in other\nwords, myfile.title.\nAlternatively, you can fetch (really, copy) names out of a module with from statements:\n% python\n>>> from myfile import title\n>>> print(title)\nThe Meaning of Life\n\n# Start Python\n# Run file; copy its names\n# Use name directly: no need to qualify",
    "As you’ll see in more detail later, from is just like an import, with an extra assignment\nto names in the importing component. Technically, from copies a module’s attributes,\nsuch that they become simple variables in the recipient—thus, you can simply refer to\nthe imported string this time as title (a variable) instead of myfile.title (an attribute\nreference).‡\nWhether you use import or from to invoke an import operation, the statements in the\nmodule file myfile.py are executed, and the importing component (here, the interactive\nprompt) gains access to names assigned at the top level of the file. There’s only one\nsuch name in this simple example—the variable title, assigned to a string—but the\nconcept will be more useful when you start defining objects such as functions and\nclasses in your modules: such objects become reusable software components that can\nbe accessed by name from one or more client modules.",
    "prompt) gains access to names assigned at the top level of the file. There’s only one\nsuch name in this simple example—the variable title, assigned to a string—but the\nconcept will be more useful when you start defining objects such as functions and\nclasses in your modules: such objects become reusable software components that can\nbe accessed by name from one or more client modules.\nIn practice, module files usually define more than one name to be used in and outside\nthe files. Here’s an example that defines three:\na = 'dead'\nb = 'parrot'\nc = 'sketch'\nprint(a, b, c)",
    "# Define three attributes\n# Exported to other files\n# Also used in this file\n\nThis file, threenames.py, assigns three variables, and so generates three attributes for\nthe outside world. It also uses its own three variables in a print statement, as we see\nwhen we run this as a top-level file:\n\n‡ Notice that import and from both list the name of the module file as simply myfile without its .py suffix. As\nyou’ll learn in Part V, when Python looks for the actual file, it knows to include the suffix in its search\nprocedure. Again, you must include the .py suffix in system shell command lines, but not in import statements.\n\n54 | Chapter 3: How You Run Programs\n\n\f% python threenames.py\ndead parrot sketch",
    "54 | Chapter 3: How You Run Programs\n\n\f% python threenames.py\ndead parrot sketch\n\nAll of this file’s code runs as usual the first time it is imported elsewhere (by either an\nimport or from). Clients of this file that use import get a module with attributes, while\nclients that use from get copies of the file’s names:\n% python\n>>> import threenames\ndead parrot sketch\n>>>\n>>> threenames.b, threenames.c\n('parrot', 'sketch')\n>>>\n>>> from threenames import a, b, c\n>>> b, c\n('parrot', 'sketch')\n\n# Grab the whole module\n\n# Copy multiple names",
    "# Grab the whole module\n\n# Copy multiple names\n\nThe results here are printed in parentheses because they are really tuples (a kind of\nobject covered in the next part of this book); you can safely ignore them for now.\nOnce you start coding modules with multiple names like this, the built-in dir function\nstarts to come in handy—you can use it to fetch a list of the names available inside a\nmodule. The following returns a Python list of strings (we’ll start studying lists in the\nnext chapter):\n>>> dir(threenames)\n['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'a', 'b', 'c']",
    "I ran this on Python 3.0 and 2.6; older Pythons may return fewer names. When the\ndir function is called with the name of an imported module passed in parentheses like\nthis, it returns all the attributes inside that module. Some of the names it returns are\nnames you get “for free”: names with leading and trailing double underscores are builtin names that are always predefined by Python and that have special meaning to the\ninterpreter. The variables our code defined by assignment—a, b, and c—show up last\nin the dir result.",
    "Modules and namespaces\nModule imports are a way to run files of code, but, as we’ll discuss later in the book,\nmodules are also the largest program structure in Python programs.\nIn general, Python programs are composed of multiple module files, linked together by\nimport statements. Each module file is a self-contained package of variables—that is,\na namespace. One module file cannot see the names defined in another file unless it\nexplicitly imports that other file, so modules serve to minimize name collisions in your\ncode—because each file is a self-contained namespace, the names in one file cannot\nclash with those in another, even if they are spelled the same way.\n\nModule Imports and Reloads | 55",
    "In fact, as you’ll see, modules are one of a handful of ways that Python goes to great\nlengths to package your variables into compartments to avoid name clashes. We’ll\ndiscuss modules and other namespace constructs (including classes and function\nscopes) further later in the book. For now, modules will come in handy as a way to run\nyour code many times without having to retype it.\nimport versus from: I should point out that the from statement in a sense\ndefeats the namespace partitioning purpose of modules—because the\nfrom copies variables from one file to another, it can cause same-named\nvariables in the importing file to be overwritten (and won’t warn you if\nit does). This essentially collapses namespaces together, at least in terms\nof the copied variables.\nBecause of this, some recommend using import instead of from. I won’t\ngo that far, though; not only does from involve less typing, but its purported problem is rarely an issue in practice. Besides, this is something",
    "variables in the importing file to be overwritten (and won’t warn you if\nit does). This essentially collapses namespaces together, at least in terms\nof the copied variables.\nBecause of this, some recommend using import instead of from. I won’t\ngo that far, though; not only does from involve less typing, but its purported problem is rarely an issue in practice. Besides, this is something\nyou control by listing the variables you want in the from; as long as you\nunderstand that they’ll be assigned values, this is no more dangerous\nthan coding assignment statements—another feature you’ll probably\nwant to use!",
    "import and reload Usage Notes\nFor some reason, once people find out about running files using import and reload,\nmany tend to focus on this alone and forget about other launch options that always\nrun the current version of the code (e.g., icon clicks, IDLE menu options, and system\ncommand lines). This approach can quickly lead to confusion, though—you need to\nremember when you’ve imported to know if you can reload, you need to remember to\nuse parentheses when you call reload (only), and you need to remember to use\nreload in the first place to get the current version of your code to run. Moreover, reloads\naren’t transitive—reloading a module reloads that module only, not any modules it\nmay import—so you sometimes have to reload multiple files.\nBecause of these complications (and others we’ll explore later, including the reload/\nfrom issue mentioned in a prior note in this chapter), it’s generally a good idea to avoid",
    "aren’t transitive—reloading a module reloads that module only, not any modules it\nmay import—so you sometimes have to reload multiple files.\nBecause of these complications (and others we’ll explore later, including the reload/\nfrom issue mentioned in a prior note in this chapter), it’s generally a good idea to avoid\nthe temptation to launch by imports and reloads for now. The IDLE Run→Run Module\nmenu option described in the next section, for example, provides a simpler and less\nerror-prone way to run your files, and always runs the current version of your code.\nSystem shell command lines offer similar benefits. You don’t need to use reload if you\nuse these techniques.\nIn addition, you may run into trouble if you use modules in unusual ways at this point\nin the book. For instance, if you want to import a module file that is stored in a directory\nother than the one you’re working in, you’ll have to skip ahead to Chapter 21 and learn\nabout the module search path.",
    "56 | Chapter 3: How You Run Programs\n\n\fFor now, if you must import, try to keep all your files in the directory you are working\nin to avoid complications.§\nThat said, imports and reloads have proven to be a popular testing technique in Python\nclasses, and you may prefer using this approach too. As usual, though, if you find\nyourself running into a wall, stop running into a wall!",
    "Using exec to Run Module Files\nIn fact, there are more ways to run code stored in module files than have yet been\nexposed here. For instance, the exec(open('module.py').read()) built-in function call\nis another way to launch files from the interactive prompt without having to import\nand later reload. Each exec runs the current version of the file, without requiring later\nreloads (script1.py is as we left it after a reload in the prior section):\nC:\\misc> c:\\python30\\python\n>>> exec(open('script1.py').read())\nwin32\n65536\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!\n...change script1.py in a text edit window...\n>>> exec(open('script1.py').read())\nwin32\n4294967296\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!",
    "The exec call has an effect similar to an import, but it doesn’t technically import the\nmodule—by default, each time you call exec this way it runs the file anew, as though\nyou had pasted it in at the place where exec is called. Because of that, exec does not\nrequire module reloads after file changes—it skips the normal module import logic.\nOn the downside, because it works as if pasting code into the place where it is called,\nexec, like the from statement mentioned earlier, has the potential to silently overwrite\nvariables you may currently be using. For example, our script1.py assigns to a variable\nnamed x. If that name is also being used in the place where exec is called, the name’s\nvalue is replaced:\n>>> x = 999\n>>> exec(open('script1.py').read())\n...same outout...\n>>> x\n'Spam!'\n\n# Code run in this namespace by default\n# Its assignments can overwrite names here",
    "# Code run in this namespace by default\n# Its assignments can overwrite names here\n\n§ If you’re burning with curiosity, the short story is that Python searches for imported modules in every directory\nlisted in sys.path—a Python list of directory name strings in the sys module, which is initialized from a\nPYTHONPATH environment variable, plus a set of standard directories. If you want to import from a directory\nother than the one you are working in, that directory must generally be listed in your PYTHONPATH setting. For\nmore details, see Chapter 21.\n\nUsing exec to Run Module Files | 57",
    "By contrast, the basic import statement runs the file only once per process, and it makes\nthe file a separate module namespace so that its assignments will not change variables\nin your scope. The price you pay for the namespace partitioning of modules is the need\nto reload after changes.\nVersion skew note: Python 2.6 also includes an execfile('module.py')\nbuilt-in function, in addition to allowing the form\nexec(open('module.py')), which both automatically read the file’s\ncontent.\nBoth\nof\nthese\nare\nequivalent\nto\nthe\nexec(open('module.py').read()) form, which is more complex but\nruns in both 2.6 and 3.0.\nUnfortunately, neither of these two simpler 2.6 forms is available in 3.0,\nwhich means you must understand both files and their read methods to\nfully understand this technique today (alas, this seems to be a case of\naesthetics trouncing practicality in 3.0). In fact, the exec form in 3.0\ninvolves so much typing that the best advice may simply be not to do",
    "runs in both 2.6 and 3.0.\nUnfortunately, neither of these two simpler 2.6 forms is available in 3.0,\nwhich means you must understand both files and their read methods to\nfully understand this technique today (alas, this seems to be a case of\naesthetics trouncing practicality in 3.0). In fact, the exec form in 3.0\ninvolves so much typing that the best advice may simply be not to do\nit—it’s usually best to launch files by typing system shell command lines\nor by using the IDLE menu options described in the next section. For\nmore on the 3.0 exec form, see Chapter 9.",
    "The IDLE User Interface\nSo far, we’ve seen how to run Python code with the interactive prompt, system command lines, icon clicks, and module imports and exec calls. If you’re looking for something a bit more visual, IDLE provides a graphical user interface for doing Python\ndevelopment, and it’s a standard and free part of the Python system. It is usually referred\nto as an integrated development environment (IDE), because it binds together various\ndevelopment tasks into a single view.‖\nIn short, IDLE is a GUI that lets you edit, run, browse, and debug Python programs,\nall from a single interface. Moreover, because IDLE is a Python program that uses the\ntkinter GUI toolkit (known as Tkinter in 2.6), it runs portably on most Python platforms, including Microsoft Windows, X Windows (for Linux, Unix, and Unix-like\nplatforms), and the Mac OS (both Classic and OS X). For many, IDLE represents an\neasy-to-use alternative to typing command lines, and a less problem-prone alternative",
    "tkinter GUI toolkit (known as Tkinter in 2.6), it runs portably on most Python platforms, including Microsoft Windows, X Windows (for Linux, Unix, and Unix-like\nplatforms), and the Mac OS (both Classic and OS X). For many, IDLE represents an\neasy-to-use alternative to typing command lines, and a less problem-prone alternative\nto clicking on icons.",
    "IDLE Basics\nLet’s jump right into an example. IDLE is easy to start under Windows—it has an entry\nin the Start button menu for Python (see Figure 2-1, shown previously), and it can also\nbe selected by right-clicking on a Python program icon. On some Unix-like systems,\n‖ IDLE is officially a corruption of IDE, but it’s really named in honor of Monty Python member Eric Idle.\n\n58 | Chapter 3: How You Run Programs",
    "58 | Chapter 3: How You Run Programs\n\n\fyou may need to launch IDLE’s top-level script from a command line, or by clicking\non the icon for the idle.pyw or idle.py file located in the idlelib subdirectory of Python’s\nLib directory. On Windows, IDLE is a Python script that currently lives in C:\\Python30\\Lib\\idlelib (or C:Python26\\Lib\\idlelib in Python 2.6).#\nFigure 3-3 shows the scene after starting IDLE on Windows. The Python shell window\nthat opens initially is the main window, which runs an interactive session (notice the\n>>> prompt). This works like all interactive sessions—code you type here is run immediately after you type it—and serves as a testing tool.\n\nFigure 3-3. The main Python shell window of the IDLE development GUI, shown here running on\nWindows. Use the File menu to begin (New Window) or change (Open...) a source file; use the text\nedit window’s Run menu to run the code in that window (Run Module).",
    "Figure 3-3. The main Python shell window of the IDLE development GUI, shown here running on\nWindows. Use the File menu to begin (New Window) or change (Open...) a source file; use the text\nedit window’s Run menu to run the code in that window (Run Module).\n\n#IDLE is a Python program that uses the standard library’s tkinter GUI toolkit (a.k.a. Tkinter in Python 2.6)\nto build the IDLE GUI. This makes IDLE portable, but it also means that you’ll need to have tkinter support\nin your Python to use IDLE. The Windows version of Python has this by default, but some Linux and Unix\nusers may need to install the appropriate tkinter support (a yum tkinter command may suffice on some Linux\ndistributions, but see the installation hints in Appendix A for details). Mac OS X may have everything you\nneed preinstalled, too; look for an idle command or script on your machine.\n\nThe IDLE User Interface | 59",
    "IDLE uses familiar menus with keyboard shortcuts for most of its operations. To make\n(or edit) a source code file under IDLE, open a text edit window: in the main window,\nselect the File pull-down menu, and pick New Window (or Open... to open a text edit\nwindow displaying an existing file for editing).\nAlthough it may not show up fully in this book’s graphics, IDLE uses syntax-directed\ncolorization for the code typed in both the main window and all text edit windows—\nkeywords are one color, literals are another, and so on. This helps give you a better\npicture of the components in your code (and can even help you spot mistakes—\nrun-on strings are all one color, for example).\nTo run a file of code that you are editing in IDLE, select the file’s text edit window,\nopen that window’s Run pull-down menu, and choose the Run Module option listed\nthere (or use the equivalent keyboard shortcut, given in the menu). Python will let you",
    "picture of the components in your code (and can even help you spot mistakes—\nrun-on strings are all one color, for example).\nTo run a file of code that you are editing in IDLE, select the file’s text edit window,\nopen that window’s Run pull-down menu, and choose the Run Module option listed\nthere (or use the equivalent keyboard shortcut, given in the menu). Python will let you\nknow that you need to save your file first if you’ve changed it since it was opened or\nlast saved and forgot to save your changes—a common mistake when you’re knee deep\nin coding.\nWhen run this way, the output of your script and any error messages it may generate\nshow up back in the main interactive window (the Python shell window). In Figure 3-3, for example, the three lines after the “RESTART” line near the middle of the\nwindow reflect an execution of our script1.py file opened in a separate edit window.\nThe “RESTART” message tells us that the user-code process was restarted to run the",
    "show up back in the main interactive window (the Python shell window). In Figure 3-3, for example, the three lines after the “RESTART” line near the middle of the\nwindow reflect an execution of our script1.py file opened in a separate edit window.\nThe “RESTART” message tells us that the user-code process was restarted to run the\nedited script and serves to separate script output (it does not appear if IDLE is started\nwithout a user-code subprocess—more on this mode in a moment).\nIDLE hint of the day: If you want to repeat prior commands in IDLE’s\nmain interactive window, you can use the Alt-P key combination to\nscroll backward through the command history, and Alt-N to scroll forward (on some Macs, try Ctrl-P and Ctrl-N instead). Your prior commands will be recalled and displayed, and may be edited and rerun. You\ncan also recall commands by positioning the cursor on them, or use\ncut-and-paste operations, but these techniques tend to involve more",
    "scroll backward through the command history, and Alt-N to scroll forward (on some Macs, try Ctrl-P and Ctrl-N instead). Your prior commands will be recalled and displayed, and may be edited and rerun. You\ncan also recall commands by positioning the cursor on them, or use\ncut-and-paste operations, but these techniques tend to involve more\nwork. Outside IDLE, you may be able to recall commands in an interactive session with the arrow keys on Windows.",
    "Using IDLE\nIDLE is free, easy to use, portable, and automatically available on most platforms. I\ngenerally recommend it to Python newcomers because it sugarcoats some of the details\nand does not assume prior experience with system command lines. However, it is\nsomewhat limited compared to more advanced commercial IDEs. To help you avoid\nsome common pitfalls, here is a list of issues that IDLE beginners should bear in mind:\n• You must add “.py” explicitly when saving your files. I mentioned this when\ntalking about files in general, but it’s a common IDLE stumbling block, especially\n\n60 | Chapter 3: How You Run Programs",
    "for Windows users. IDLE does not automatically add a .py extension to filenames\nwhen files are saved. Be careful to type the .py extension yourself when saving a\nfile for the first time. If you don’t, while you will be able to run your file from IDLE\n(and system command lines), you will not be able to import it either interactively\nor from other modules.\n• Run scripts by selecting Run→Run Module in text edit windows, not by interactive imports and reloads. Earlier in this chapter, we saw that it’s possible\nto run a file by importing it interactively. However, this scheme can grow complex\nbecause it requires you to manually reload files after changes. By contrast, using\nthe Run→Run Module menu option in IDLE always runs the most current version\nof your file, just like running it using a system shell command line. IDLE also\nprompts you to save your file first, if needed (another common mistake outside\nIDLE).",
    "because it requires you to manually reload files after changes. By contrast, using\nthe Run→Run Module menu option in IDLE always runs the most current version\nof your file, just like running it using a system shell command line. IDLE also\nprompts you to save your file first, if needed (another common mistake outside\nIDLE).\n• You need to reload only modules being tested interactively. Like system shell\ncommand lines, IDLE’s Run→Run Module menu option always runs the current\nversion of both the top-level file and any modules it imports. Because of this,\nRun→Run Module eliminates common confusions surrounding imports. You only\nneed to reload modules that you are importing and testing interactively in IDLE.\nIf you choose to use the import and reload technique instead of Run→Run Module,\nremember that you can use the Alt-P/Alt-N key combinations to recall prior\ncommands.\n• You can customize IDLE. To change the text fonts and colors in IDLE, select the",
    "need to reload modules that you are importing and testing interactively in IDLE.\nIf you choose to use the import and reload technique instead of Run→Run Module,\nremember that you can use the Alt-P/Alt-N key combinations to recall prior\ncommands.\n• You can customize IDLE. To change the text fonts and colors in IDLE, select the\nConfigure option in the Options menu of any IDLE window. You can also customize key combination actions, indentation settings, and more; see IDLE’s Help\npull-down menu for more hints.\n• There is currently no clear-screen option in IDLE. This seems to be a frequent\nrequest (perhaps because it’s an option available in similar IDEs), and it might be\nadded eventually. Today, though, there is no way to clear the interactive window’s\ntext. If you want the window’s text to go away, you can either press and hold the\nEnter key, or type a Python loop to print a series of blank lines (nobody really uses",
    "request (perhaps because it’s an option available in similar IDEs), and it might be\nadded eventually. Today, though, there is no way to clear the interactive window’s\ntext. If you want the window’s text to go away, you can either press and hold the\nEnter key, or type a Python loop to print a series of blank lines (nobody really uses\nthe latter technique, of course, but it sounds more high-tech than pressing the Enter\nkey!).\n• tkinter GUI and threaded programs may not work well with IDLE. Because\nIDLE is a Python/tkinter program, it can hang if you use it to run certain types of\nadvanced Python/tkinter programs. This has become less of an issue in more recent\nversions of IDLE that run user code in one process and the IDLE GUI itself in\nanother, but some programs (especially those that use multithreading) might still\nhang the GUI. Your code may not exhibit such problems, but as a rule of thumb,\nit’s always safe to use IDLE to edit GUI programs but launch them using other",
    "advanced Python/tkinter programs. This has become less of an issue in more recent\nversions of IDLE that run user code in one process and the IDLE GUI itself in\nanother, but some programs (especially those that use multithreading) might still\nhang the GUI. Your code may not exhibit such problems, but as a rule of thumb,\nit’s always safe to use IDLE to edit GUI programs but launch them using other\noptions, such as icon clicks or system command lines. When in doubt, if your code\nfails in IDLE, try it outside the GUI.",
    "The IDLE User Interface | 61",
    "• If connection errors arise, try starting IDLE in single-process mode. Because\nIDLE requires communication between its separate user and GUI processes, it can\nsometimes have trouble starting up on certain platforms (notably, it fails to start\noccasionally on some Windows machines, due to firewall software that blocks\nconnections). If you run into such connection errors, it’s always possible to start\nIDLE with a system command line that forces it to run in single-process mode\nwithout a user-code subprocess and therefore avoids communication issues: its\n-n command-line flag forces this mode. On Windows, for example, start a Command Prompt window and run the system command line idle.py -n from within\nthe directory C:\\Python30\\Lib\\idlelib (cd there first if needed).\n• Beware of some IDLE usability features. IDLE does much to make life easier",
    "without a user-code subprocess and therefore avoids communication issues: its\n-n command-line flag forces this mode. On Windows, for example, start a Command Prompt window and run the system command line idle.py -n from within\nthe directory C:\\Python30\\Lib\\idlelib (cd there first if needed).\n• Beware of some IDLE usability features. IDLE does much to make life easier\nfor beginners, but some of its tricks won’t apply outside the IDLE GUI. For instance, IDLE runs your scripts in its own interactive namespace, so variables in\nyour code show up automatically in the IDLE interactive session—you don’t always need to run import commands to access names at the top level of files you’ve\nalready run. This can be handy, but it can also be confusing, because outside the\nIDLE environment names must always be imported from files to be used.\nIDLE also automatically changes both to the directory of a file just run and adds\nits directory to the module import search path—a handy feature that allows you",
    "already run. This can be handy, but it can also be confusing, because outside the\nIDLE environment names must always be imported from files to be used.\nIDLE also automatically changes both to the directory of a file just run and adds\nits directory to the module import search path—a handy feature that allows you\nto import files there without search path settings, but also something that won’t\nwork the same when you run files outside IDLE. It’s OK to use such features, but\ndon’t forget that they are IDLE behavior, not Python behavior.",
    "Advanced IDLE Tools\nBesides the basic edit and run functions, IDLE provides more advanced features, including a point-and-click program debugger and an object browser. The IDLE debugger\nis enabled via the Debug menu and the object browser via the File menu. The browser\nallows you to navigate through the module search path to files and objects in files;\nclicking on a file or object opens the corresponding source in a text edit window.\nIDLE debugging is initiated by selecting the Debug→Debugger menu option in the main\nwindow and then starting your script by selecting the Run→Run Module option in the\ntext edit window; once the debugger is enabled, you can set breakpoints in your code\nthat stop its execution by right-clicking on lines in the text edit windows, show variable\nvalues, and so on. You can also watch program execution when debugging—the current\nline of code is noted as you step through your code.",
    "window and then starting your script by selecting the Run→Run Module option in the\ntext edit window; once the debugger is enabled, you can set breakpoints in your code\nthat stop its execution by right-clicking on lines in the text edit windows, show variable\nvalues, and so on. You can also watch program execution when debugging—the current\nline of code is noted as you step through your code.\nFor simpler debugging operations, you can also right-click with your mouse on the text\nof an error message to quickly jump to the line of code where the error occurred—a\ntrick that makes it simple and fast to repair and run again. In addition, IDLE’s text\neditor offers a large collection of programmer-friendly tools, including automatic indentation, advanced text and file search operations, and more. Because IDLE uses",
    "62 | Chapter 3: How You Run Programs\n\n\fintuitive GUI interactions, you should experiment with the system live to get a feel for\nits other tools.",
    "Other IDEs\nBecause IDLE is free, portable, and a standard part of Python, it’s a nice first development tool to become familiar with if you want to use an IDE at all. Again, I recommend\nthat you use IDLE for this book’s exercises if you’re just starting out, unless you are\nalready familiar with and prefer a command-line-based development mode. There are,\nhowever, a handful of alternative IDEs for Python developers, some of which are substantially more powerful and robust than IDLE. Here are some of the most commonly\nused IDEs:\nEclipse and PyDev\nEclipse is an advanced open source IDE GUI. Originally developed as a Java IDE,\nEclipse also supports Python development when you install the PyDev (or a similar)\nplug-in. Eclipse is a popular and powerful option for Python development, and it\ngoes well beyond IDLE’s feature set. It includes support for code completion, syntax highlighting, syntax analysis, refactoring, debugging, and more. Its downsides",
    "Eclipse also supports Python development when you install the PyDev (or a similar)\nplug-in. Eclipse is a popular and powerful option for Python development, and it\ngoes well beyond IDLE’s feature set. It includes support for code completion, syntax highlighting, syntax analysis, refactoring, debugging, and more. Its downsides\nare that it is a large system to install and may require shareware extensions for some\nfeatures (this may vary over time). Still, when you are ready to graduate from IDLE,\nthe Eclipse/PyDev combination is worth your attention.\nKomodo\nA full-featured development environment GUI for Python (and other languages),\nKomodo includes standard syntax-coloring, text-editing, debugging, and other\nfeatures. In addition, Komodo offers many advanced features that IDLE does not,\nincluding project files, source-control integration, regular-expression debugging,\nand a drag-and-drop GUI builder that generates Python/tkinter code to implement",
    "A full-featured development environment GUI for Python (and other languages),\nKomodo includes standard syntax-coloring, text-editing, debugging, and other\nfeatures. In addition, Komodo offers many advanced features that IDLE does not,\nincluding project files, source-control integration, regular-expression debugging,\nand a drag-and-drop GUI builder that generates Python/tkinter code to implement\nthe GUIs you design interactively. At this writing, Komodo is not free; it is available\nat http://www.activestate.com.\nNetBeans IDE for Python\nNetBeans is a powerful open-source development environment GUI with support\nfor many advanced features for Python developers: code completion, automatic\nindentation and code colorization, editor hints, code folding, refactoring, debugging, code coverage and testing, projects, and more. It may be used to develop both",
    "at http://www.activestate.com.\nNetBeans IDE for Python\nNetBeans is a powerful open-source development environment GUI with support\nfor many advanced features for Python developers: code completion, automatic\nindentation and code colorization, editor hints, code folding, refactoring, debugging, code coverage and testing, projects, and more. It may be used to develop both\nCPython and Jython code. Like Eclipse, NetBeans requires installation steps beyond those of the included IDLE GUI, but it is seen by many as more than worth\nthe effort. Search the Web for the latest information and links.\nPythonWin\nPythonWin is a free Windows-only IDE for Python that ships as part of ActiveState’s ActivePython distribution (and may also be fetched separately from http://\nwww.python.org resources). It is roughly like IDLE, with a handful of useful\nWindows-specific extensions added; for example, PythonWin has support for\nOther IDEs | 63",
    "COM objects. Today, IDLE is probably more advanced than PythonWin (for instance, IDLE’s dual-process architecture often prevents it from hanging). However,\nPythonWin still offers tools for Windows developers that IDLE does not. See http:\n//www.activestate.com for more information.\nOthers\nThere are roughly half a dozen other widely used IDEs that I’m aware of (including\nthe commercial Wing IDE and PythonCard) but do not have space to do justice to\nhere, and more will probably appear over time. In fact, almost every programmerfriendly text editor has some sort of support for Python development these days,\nwhether it be preinstalled or fetched separately. Emacs and Vim, for instance, have\nsubstantial Python support.\nI won’t try to document all such options here; for more information, see the resources available at http://www.python.org or search the Web for “Python IDE.”\nYou might also try running a web search for “Python editors”—today, this leads",
    "whether it be preinstalled or fetched separately. Emacs and Vim, for instance, have\nsubstantial Python support.\nI won’t try to document all such options here; for more information, see the resources available at http://www.python.org or search the Web for “Python IDE.”\nYou might also try running a web search for “Python editors”—today, this leads\nyou to a wiki page that maintains information about many IDE and text-editor\noptions for Python programming.",
    "Other Launch Options\nAt this point, we’ve seen how to run code typed interactively, and how to launch code\nsaved in files in a variety of ways—system command lines, imports and execs, GUIs\nlike IDLE, and more. That covers most of the cases you’ll see in this book. There are\nadditional ways to run Python code, though, most of which have special or narrow\nroles. The next few sections take a quick look at some of these.",
    "Embedding Calls\nIn some specialized domains, Python code may be run automatically by an enclosing\nsystem. In such cases, we say that the Python programs are embedded in (i.e., run by)\nanother program. The Python code itself may be entered into a text file, stored in a\ndatabase, fetched from an HTML page, parsed from an XML document, and so on.\nBut from an operational perspective, another system—not you—may tell Python to\nrun the code you’ve created.\nSuch an embedded execution mode is commonly used to support end-user customization—a game program, for instance, might allow for play modifications by running\nuser-accessible embedded Python code at strategic points in time. Users can modify\nthis type of system by providing or changing Python code. Because Python code is\ninterpreted, there is no need to recompile the entire system to incorporate the change\n(see Chapter 2 for more on how Python code is run).\n\n64 | Chapter 3: How You Run Programs",
    "64 | Chapter 3: How You Run Programs\n\n\fIn this mode, the enclosing system that runs your code might be written in C, C++, or\neven Java when the Jython system is used. As an example, it’s possible to create and\nrun strings of Python code from a C program by calling functions in the Python runtime\nAPI (a set of services exported by the libraries created when Python is compiled on your\nmachine):\n#include <Python.h>\n...\nPy_Initialize();\nPyRun_SimpleString(\"x = 'brave ' + 'sir robin'\");\n\n// This is C, not Python\n// But it runs Python code",
    "// This is C, not Python\n// But it runs Python code\n\nIn this C code snippet, a program coded in the C language embeds the Python interpreter by linking in its libraries, and passes it a Python assignment statement string to\nrun. C programs may also gain access to Python modules and objects and process or\nexecute them using other Python API tools.\nThis book isn’t about Python/C integration, but you should be aware that, depending\non how your organization plans to use Python, you may or may not be the one who\nactually starts the Python programs you create. Regardless, you can usually still use the\ninteractive and file-based launching techniques described here to test code in isolation\nfrom those enclosing systems that may eventually use it.*",
    "Frozen Binary Executables\nFrozen binary executables, described in Chapter 2, are packages that combine your\nprogram’s byte code and the Python interpreter into a single executable program. This\napproach enables Python programs to be launched in the same ways that you would\nlaunch any other executable program (icon clicks, command lines, etc.). While this\noption works well for delivery of products, it is not really intended for use during program development; you normally freeze just before shipping (after development is\nfinished). See the prior chapter for more on this option.",
    "Text Editor Launch Options\nAs mentioned previously, although they’re not full-blown IDE GUIs, most programmer-friendly text editors have support for editing, and possibly running, Python\nprograms. Such support may be built in or fetchable on the Web. For instance, if you\nare familiar with the Emacs text editor, you can do all your Python editing and launching from inside that text editor. See the text editor resources page at http://www.python\n.org/editors for more details, or search the Web for the phrase “Python editors.”\n\n* See Programming Python (O’Reilly) for more details on embedding Python in C/C++. The embedding API\ncan call Python functions directly, load modules, and more. Also, note that the Jython system allows Java\nprograms to invoke Python code using a Java-based API (a Python interpreter class).\n\nOther Launch Options | 65",
    "Other Launch Options | 65\n\n\fStill Other Launch Options\nDepending on your platform, there may be additional ways that you can start Python\nprograms. For instance, on some Macintosh systems you may be able to drag Python\nprogram file icons onto the Python interpreter icon to make them execute, and on\nWindows you can always start Python scripts with the Run... option in the Start menu.\nAdditionally, the Python standard library has utilities that allow Python programs to\nbe started by other Python programs in separate processes (e.g., os.popen, os.system),\nand Python scripts might also be spawned in larger contexts like the Web (for instance,\na web page might invoke a script on a server); however, these are beyond the scope of\nthe present chapter.",
    "Future Possibilities?\nThis chapter reflects current practice, but much of the material is both platform- and\ntime-specific. Indeed, many of the execution and launch details presented arose during\nthe shelf life of this book’s various editions. As with program execution options, it’s\nnot impossible that new program launch options may arise over time.\nNew operating systems, and new versions of existing systems, may also provide execution techniques beyond those outlined here. In general, because Python keeps pace\nwith such changes, you should be able to launch Python programs in whatever way\nmakes sense for the machines you use, both now and in the future—be that by drawing\non tablet PCs or PDAs, grabbing icons in a virtual reality, or shouting a script’s name\nover your coworkers’ conversations.\nImplementation changes may also impact launch schemes somewhat (e.g., a full compiler could produce normal executables that are launched much like frozen binaries",
    "makes sense for the machines you use, both now and in the future—be that by drawing\non tablet PCs or PDAs, grabbing icons in a virtual reality, or shouting a script’s name\nover your coworkers’ conversations.\nImplementation changes may also impact launch schemes somewhat (e.g., a full compiler could produce normal executables that are launched much like frozen binaries\ntoday). If I knew what the future truly held, though, I would probably be talking to a\nstockbroker instead of writing these words!",
    "Which Option Should I Use?\nWith all these options, one question naturally arises: which one is best for me? In\ngeneral, you should give the IDLE interface a try if you are just getting started with\nPython. It provides a user-friendly GUI environment and hides some of the underlying\nconfiguration details. It also comes with a platform-neutral text editor for coding your\nscripts, and it’s a standard and free part of the Python system.\nIf, on the other hand, you are an experienced programmer, you might be more comfortable with simply the text editor of your choice in one window, and another window\nfor launching the programs you edit via system command lines and icon clicks (in fact,\nthis is how I develop Python programs, but I have a Unix-biased past). Because the\nchoice of development environments is very subjective, I can’t offer much more in the\n\n66 | Chapter 3: How You Run Programs",
    "66 | Chapter 3: How You Run Programs\n\n\fway of universal guidelines; in general, whatever environment you like to use will be\nthe best for you to use.",
    "Debugging Python Code\nNaturally, none of my readers or students ever have bugs in their code (insert smiley\nhere), but for less fortunate friends of yours who may, here’s a quick look at the strategies commonly used by real-world Python programmers to debug code:\n• Do nothing. By this, I don’t mean that Python programmers don’t debug their\ncode—but when you make a mistake in a Python program, you get a very useful\nand readable error message (you’ll get to see some soon, if you haven’t already).\nIf you already know Python, and especially for your own code, this is often\nenough—read the error message, and go fix the tagged line and file. For many, this\nis debugging in Python. It may not always be ideal for larger system you didn’t\nwrite, though.\n• Insert print statements. Probably the main way that Python programmers debug\ntheir code (and the way that I debug Python code) is to insert print statements and\nrun again. Because Python runs immediately after changes, this is usually the",
    "is debugging in Python. It may not always be ideal for larger system you didn’t\nwrite, though.\n• Insert print statements. Probably the main way that Python programmers debug\ntheir code (and the way that I debug Python code) is to insert print statements and\nrun again. Because Python runs immediately after changes, this is usually the\nquickest way to get more information than error messages provide. The print\nstatements don’t have to be sophisticated—a simple “I am here” or display of\nvariable values is usually enough to provide the context you need. Just remember\nto delete or comment out (i.e., add a # before) the debugging prints before you\nship your code!\n• Use IDE GUI debuggers. For larger systems you didn’t write, and for beginners\nwho want to trace code in more detail, most Python development GUIs have some\nsort of point-and-click debugging support. IDLE has a debugger too, but it doesn’t\nappear to be used very often in practice—perhaps because it has no command line,",
    "ship your code!\n• Use IDE GUI debuggers. For larger systems you didn’t write, and for beginners\nwho want to trace code in more detail, most Python development GUIs have some\nsort of point-and-click debugging support. IDLE has a debugger too, but it doesn’t\nappear to be used very often in practice—perhaps because it has no command line,\nor perhaps because adding print statements is usually quicker than setting up a\nGUI debugging session. To learn more, see IDLE’s Help, or simply try it on your\nown; its basic interface is described in the section “Advanced IDLE\nTools” on page 62. Other IDEs, such as Eclipse, NetBeans, Komodo, and Wing\nIDE, offer advanced point-and-click debuggers as well; see their documentation if\nyou use them.\n• Use the pdb command-line debugger. For ultimate control, Python comes with\na source-code debugger named pdb, available as a module in Python’s standard\nlibrary. In pdb, you type commands to step line by line, display variables, set and",
    "IDE, offer advanced point-and-click debuggers as well; see their documentation if\nyou use them.\n• Use the pdb command-line debugger. For ultimate control, Python comes with\na source-code debugger named pdb, available as a module in Python’s standard\nlibrary. In pdb, you type commands to step line by line, display variables, set and\nclear breakpoints, continue to a breakpoint or error, and so on. pdb can be\nlaunched interactively by importing it, or as a top-level script. Either way, because\nyou can type commands to control the session, it provides a powerful debugging\ntool. pdb also includes a postmortem function you can run after an exception\noccurs, to get information from the time of the error. See the Python library manual\nand Chapter 35 for more details on pdb.\n• Other options. For more specific debugging requirements, you can find additional\ntools in the open source domain, including support for multithreaded programs,",
    "tool. pdb also includes a postmortem function you can run after an exception\noccurs, to get information from the time of the error. See the Python library manual\nand Chapter 35 for more details on pdb.\n• Other options. For more specific debugging requirements, you can find additional\ntools in the open source domain, including support for multithreaded programs,\nembedded code, and process attachment. The Winpdb system, for example, is a\nWhich Option Should I Use? | 67",
    "standalone debugger with advanced debugging support and cross-platform GUI\nand console interfaces.\nThese options will become more important as we start writing larger scripts. Probably the best news on the debugging front, though, is that errors are detected and\nreported in Python, rather than passing silently or crashing the system altogether.\nIn fact, errors themselves are a well-defined mechanism known as exceptions,\nwhich you can catch and process (more on exceptions in Part VII). Making mistakes is never fun, of course, but speaking as someone who recalls when debugging\nmeant getting out a hex calculator and poring over piles of memory dump printouts, Python’s debugging support makes errors much less painful than they might\notherwise be.",
    "Chapter Summary\nIn this chapter, we’ve looked at common ways to launch Python programs: by running\ncode typed interactively, and by running code stored in files with system command\nlines, file-icon clicks, module imports, exec calls, and IDE GUIs such as IDLE. We’ve\ncovered a lot of pragmatic startup territory here. This chapter’s goal was to equip you\nwith enough information to enable you to start writing some code, which you’ll do in\nthe next part of the book. There, we will start exploring the Python language itself,\nbeginning with its core data types.\nFirst, though, take the usual chapter quiz to exercise what you’ve learned here. Because\nthis is the last chapter in this part of the book, it’s followed with a set of more complete\nexercises that test your mastery of this entire part’s topics. For help with the latter set\nof problems, or just for a refresher, be sure to turn to Appendix B after you’ve given\nthe exercises a try.",
    "Test Your Knowledge: Quiz\n1. How can you start an interactive interpreter session?\n2. Where do you type a system command line to launch a script file?\n3. Name four or more ways to run the code saved in a script file.\n4. Name two pitfalls related to clicking file icons on Windows.\n5. Why might you need to reload a module?\n6. How do you run a script from within IDLE?\n7. Name two pitfalls related to using IDLE.\n8. What is a namespace, and how does it relate to module files?\n\n68 | Chapter 3: How You Run Programs",
    "Test Your Knowledge: Answers\n1. You can start an interactive session on Windows by clicking your Start button,\npicking the All Programs option, clicking the Python entry, and selecting the “Python (command line)” menu option. You can also achieve the same effect on Windows and other platforms by typing python as a system command line in your\nsystem’s console window (a Command Prompt window on Windows). Another\nalternative is to launch IDLE, as its main Python shell window is an interactive\nsession. If you have not set your system’s PATH variable to find Python, you may\nneed to cd to where Python is installed, or type its full directory path instead of just\npython (e.g., C:\\Python30\\python on Windows).\n2. You type system command lines in whatever your platform provides as a system\nconsole: a Command Prompt window on Windows; an xterm or terminal window\non Unix, Linux, and Mac OS X; and so on.\n3. Code in a script (really, module) file can be run with system command lines, file",
    "python (e.g., C:\\Python30\\python on Windows).\n2. You type system command lines in whatever your platform provides as a system\nconsole: a Command Prompt window on Windows; an xterm or terminal window\non Unix, Linux, and Mac OS X; and so on.\n3. Code in a script (really, module) file can be run with system command lines, file\nicon clicks, imports and reloads, the exec built-in function, and IDE GUI selections\nsuch as IDLE’s Run→Run Module menu option. On Unix, they can also be run as\nexecutables with the #! trick, and some platforms support more specialized launching techniques (e.g., drag-and-drop). In addition, some text editors have unique\nways to run Python code, some Python programs are provided as standalone “frozen binary” executables, and some systems use Python code in embedded mode,\nwhere it is run automatically by an enclosing program written in a language like\nC, C++, or Java. The latter technique is usually done to provide a user customization layer.",
    "ways to run Python code, some Python programs are provided as standalone “frozen binary” executables, and some systems use Python code in embedded mode,\nwhere it is run automatically by an enclosing program written in a language like\nC, C++, or Java. The latter technique is usually done to provide a user customization layer.\n4. Scripts that print and then exit cause the output file to disappear immediately,\nbefore you can view the output (which is why the input trick comes in handy);\nerror messages generated by your script also appear in an output window that\ncloses before you can examine its contents (which is one reason that system command lines and IDEs such as IDLE are better for most development).\n5. Python only imports (loads) a module once per process, by default, so if you’ve\nchanged its source code and want to run the new version without stopping and\nrestarting Python, you’ll have to reload it. You must import a module at least once",
    "closes before you can examine its contents (which is one reason that system command lines and IDEs such as IDLE are better for most development).\n5. Python only imports (loads) a module once per process, by default, so if you’ve\nchanged its source code and want to run the new version without stopping and\nrestarting Python, you’ll have to reload it. You must import a module at least once\nbefore you can reload it. Running files of code from a system shell command line,\nvia an icon click, or via an IDE such as IDLE generally makes this a nonissue, as\nthose launch schemes usually run the current version of the source code file each\ntime.\n6. Within the text edit window of the file you wish to run, select the window’s\nRun→Run Module menu option. This runs the window’s source code as a top-level\nscript file and displays its output back in the interactive Python shell window.\n7. IDLE can still be hung by some types of programs—especially GUI programs that",
    "time.\n6. Within the text edit window of the file you wish to run, select the window’s\nRun→Run Module menu option. This runs the window’s source code as a top-level\nscript file and displays its output back in the interactive Python shell window.\n7. IDLE can still be hung by some types of programs—especially GUI programs that\nperform multithreading (an advanced technique beyond this book’s scope). Also,\nIDLE has some usability features that can burn you once you leave the IDLE GUI:\nTest Your Knowledge: Answers | 69",
    "a script’s variables are automatically imported to the interactive scope in IDLE, for\ninstance, but not by Python in general.\n8. A namespace is just a package of variables (i.e., names). It takes the form of an\nobject with attributes in Python. Each module file is automatically a namespace—\nthat is, a package of variables reflecting the assignments made at the top level of\nthe file. Namespaces help avoid name collisions in Python programs: because each\nmodule file is a self-contained namespace, files must explicitly import other files\nin order to use their names.",
    "Test Your Knowledge: Part I Exercises\nIt’s time to start doing a little coding on your own. This first exercise session is fairly\nsimple, but a few of these questions hint at topics to come in later chapters. Be sure to\ncheck “Part I, Getting Started” on page 1101 in the solutions appendix (Appendix B)\nfor the answers; the exercises and their solutions sometimes contain supplemental information not discussed in the main text, so you should take a peek at the solutions\neven if you manage to answer all the questions on your own.\n1. Interaction. Using a system command line, IDLE, or another method, start the\nPython interactive command line (>>> prompt), and type the expression \"Hello\nWorld!\" (including the quotes). The string should be echoed back to you. The\npurpose of this exercise is to get your environment configured to run Python. In\nsome scenarios, you may need to first run a cd shell command, type the full path",
    "1. Interaction. Using a system command line, IDLE, or another method, start the\nPython interactive command line (>>> prompt), and type the expression \"Hello\nWorld!\" (including the quotes). The string should be echoed back to you. The\npurpose of this exercise is to get your environment configured to run Python. In\nsome scenarios, you may need to first run a cd shell command, type the full path\nto the Python executable, or add its path to your PATH environment variable. If\ndesired, you can set PATH in your .cshrc or .kshrc file to make Python permanently\navailable on Unix systems; on Windows, use a setup.bat, autoexec.bat, or the environment variable GUI. See Appendix A for help with environment variable\nsettings.\n2. Programs. With the text editor of your choice, write a simple module file containing\nthe single statement print('Hello module world!') and store it as module1.py.\nNow, run this file by using any launch option you like: running it in IDLE, clicking",
    "settings.\n2. Programs. With the text editor of your choice, write a simple module file containing\nthe single statement print('Hello module world!') and store it as module1.py.\nNow, run this file by using any launch option you like: running it in IDLE, clicking\non its file icon, passing it to the Python interpreter on the system shell’s command\nline (e.g., python module1.py), built-in exec calls, imports and reloads, and so on.\nIn fact, experiment by running your file with as many of the launch techniques\ndiscussed in this chapter as you can. Which technique seems easiest? (There is no\nright answer to this, of course.)\n3. Modules. Start the Python interactive command line (>>> prompt) and import the\nmodule you wrote in exercise 2. Try moving the file to a different directory and\nimporting it again from its original directory (i.e., run Python in the original directory when you import). What happens? (Hint: is there still a module1.pyc byte\ncode file in the original directory?)",
    "70 | Chapter 3: How You Run Programs",
    "4. Scripts. If your platform supports it, add the #! line to the top of your\nmodule1.py module file, give the file executable privileges, and run it directly as an\nexecutable. What does the first line need to contain? #! usually only has meaning\non Unix, Linux, and Unix-like platforms such as Mac OS X; if you’re working on\nWindows, instead try running your file by listing just its name in a DOS console\nwindow without the word “python” before it (this works on recent versions of\nWindows), or via the Start→Run... dialog box.\n5. Errors and debugging. Experiment with typing mathematical expressions and assignments at the Python interactive command line. Along the way, type the expressions 2 ** 500 and 1 / 0, and reference an undefined variable name as we did\nin this chapter. What happens?\nYou may not know it yet, but when you make a mistake, you’re doing exception\nprocessing (a topic we’ll explore in depth in Part VII). As you’ll learn there, you",
    "in this chapter. What happens?\nYou may not know it yet, but when you make a mistake, you’re doing exception\nprocessing (a topic we’ll explore in depth in Part VII). As you’ll learn there, you\nare technically triggering what’s known as the default exception handler—logic that\nprints a standard error message. If you do not catch an error, the default handler\ndoes and prints the standard error message in response.\nExceptions are also bound up with the notion of debugging in Python. When you’re\nfirst starting out, Python’s default error messages on exceptions will probably provide as much error-handling support as you need—they give the cause of the error,\nas well as showing the lines in your code that were active when the error occurred.\nFor more about debugging, see the sidebar “Debugging Python Code”\non page 67.\n6. Breaks and cycles. At the Python command line, type:\nL = [1, 2]\nL.append(L)\nL",
    "# Make a 2-item list\n# Append L as a single item to itself\n# Print L\n\nWhat happens? In all recent versions of Python, you’ll see a strange output that\nwe’ll describe in the solutions appendix, and which will make more sense when\nwe study references in the next part of the book. If you’re using a Python version\nolder than 1.5.1, a Ctrl-C key combination will probably help on most platforms.\nWhy do you think your version of Python responds the way it does for this code?\nIf you do have a Python older than Release 1.5.1 (a hopefully rare\nscenario today!), make sure your machine can stop a program with\na Ctrl-C key combination of some sort before running this test, or\nyou may be waiting a long time.",
    "7. Documentation. Spend at least 17 minutes browsing the Python library and language manuals before moving on to get a feel for the available tools in the standard\nlibrary and the structure of the documentation set. It takes at least this long to\nbecome familiar with the locations of major topics in the manual set; once you’ve\ndone this, it’s easy to find what you need. You can find this manual via the Python\n\nTest Your Knowledge: Part I Exercises | 71\n\n\fStart button entry on Windows, in the Python Docs option on the Help pull-down\nmenu in IDLE, or online at http://www.python.org/doc. I’ll also have a few more\nwords to say about the manuals and other documentation sources available (including PyDoc and the help function) in Chapter 15. If you still have time, go\nexplore the Python website, as well as its PyPy third-party extension repository.\nEspecially check out the Python.org documentation and search pages; they can be\ncrucial resources.\n\n72 | Chapter 3: How You Run Programs",
    "72 | Chapter 3: How You Run Programs\n\n\fPART II\n\nTypes and Operations\n\n\f\fCHAPTER 4\n\nIntroducing Python Object Types",
    "This chapter begins our tour of the Python language. In an informal sense, in Python,\nwe do things with stuff. “Things” take the form of operations like addition and concatenation, and “stuff” refers to the objects on which we perform those operations. In\nthis part of the book, our focus is on that stuff, and the things our programs can do\nwith it.\nSomewhat more formally, in Python, data takes the form of objects—either built-in\nobjects that Python provides, or objects we create using Python or external language\ntools such as C extension libraries. Although we’ll firm up this definition later, objects\nare essentially just pieces of memory, with values and sets of associated operations.\nBecause objects are the most fundamental notion in Python programming, we’ll start\nthis chapter with a survey of Python’s built-in object types.\nBy way of introduction, however, let’s first establish a clear picture of how this chapter",
    "are essentially just pieces of memory, with values and sets of associated operations.\nBecause objects are the most fundamental notion in Python programming, we’ll start\nthis chapter with a survey of Python’s built-in object types.\nBy way of introduction, however, let’s first establish a clear picture of how this chapter\nfits into the overall Python picture. From a more concrete perspective, Python programs\ncan be decomposed into modules, statements, expressions, and objects, as follows:\n1. Programs are composed of modules.\n2. Modules contain statements.\n3. Statements contain expressions.\n4. Expressions create and process objects.\nThe discussion of modules in Chapter 3 introduced the highest level of this hierarchy.\nThis part’s chapters begin at the bottom, exploring both built-in objects and the expressions you can code to use them.",
    "75",
    "Why Use Built-in Types?\nIf you’ve used lower-level languages such as C or C++, you know that much of your\nwork centers on implementing objects—also known as data structures—to represent\nthe components in your application’s domain. You need to lay out memory structures,\nmanage memory allocation, implement search and access routines, and so on. These\nchores are about as tedious (and error-prone) as they sound, and they usually distract\nfrom your program’s real goals.\nIn typical Python programs, most of this grunt work goes away. Because Python provides powerful object types as an intrinsic part of the language, there’s usually no need\nto code object implementations before you start solving problems. In fact, unless you\nhave a need for special processing that built-in types don’t provide, you’re almost always better off using a built-in object instead of implementing your own. Here are some\nreasons why:\n• Built-in objects make programs easy to write. For simple tasks, built-in types",
    "to code object implementations before you start solving problems. In fact, unless you\nhave a need for special processing that built-in types don’t provide, you’re almost always better off using a built-in object instead of implementing your own. Here are some\nreasons why:\n• Built-in objects make programs easy to write. For simple tasks, built-in types\nare often all you need to represent the structure of problem domains. Because you\nget powerful tools such as collections (lists) and search tables (dictionaries) for free,\nyou can use them immediately. You can get a lot of work done with Python’s builtin object types alone.\n• Built-in objects are components of extensions. For more complex tasks, you\nmay need to provide your own objects using Python classes or C language interfaces. But as you’ll see in later parts of this book, objects implemented manually\nare often built on top of built-in types such as lists and dictionaries. For instance,",
    "• Built-in objects are components of extensions. For more complex tasks, you\nmay need to provide your own objects using Python classes or C language interfaces. But as you’ll see in later parts of this book, objects implemented manually\nare often built on top of built-in types such as lists and dictionaries. For instance,\na stack data structure may be implemented as a class that manages or customizes\na built-in list.\n• Built-in objects are often more efficient than custom data structures. Python’s built-in types employ already optimized data structure algorithms that are\nimplemented in C for speed. Although you can write similar object types on your\nown, you’ll usually be hard-pressed to get the level of performance built-in object\ntypes provide.\n• Built-in objects are a standard part of the language. In some ways, Python\nborrows both from languages that rely on built-in tools (e.g., LISP) and languages\nthat rely on the programmer to provide tool implementations or frameworks of",
    "own, you’ll usually be hard-pressed to get the level of performance built-in object\ntypes provide.\n• Built-in objects are a standard part of the language. In some ways, Python\nborrows both from languages that rely on built-in tools (e.g., LISP) and languages\nthat rely on the programmer to provide tool implementations or frameworks of\ntheir own (e.g., C++). Although you can implement unique object types in Python,\nyou don’t need to do so just to get started. Moreover, because Python’s built-ins\nare standard, they’re always the same; proprietary frameworks, on the other hand,\ntend to differ from site to site.\nIn other words, not only do built-in object types make programming easier, but they’re\nalso more powerful and efficient than most of what can be created from scratch. Regardless of whether you implement new object types, built-in objects form the core of\nevery Python program.",
    "76 | Chapter 4: Introducing Python Object Types\n\n\fPython’s Core Data Types\nTable 4-1 previews Python’s built-in object types and some of the syntax used to code\ntheir literals—that is, the expressions that generate these objects.* Some of these types\nwill probably seem familiar if you’ve used other languages; for instance, numbers and\nstrings represent numeric and textual values, respectively, and files provide an interface\nfor processing files stored on your computer.\nTable 4-1. Built-in objects preview\nObject type\n\nExample literals/creation\n\nNumbers\n\n1234, 3.1415, 3+4j, Decimal, Fraction\n\nStrings\n\n'spam', \"guido's\", b'a\\x01c'\n\nLists\n\n[1, [2, 'three'], 4]\n\nDictionaries\n\n{'food': 'spam', 'taste': 'yum'}\n\nTuples\n\n(1, 'spam', 4, 'U')\n\nFiles\n\nmyfile = open('eggs', 'r')\n\nSets\n\nset('abc'), {'a', 'b', 'c'}\n\nOther core types\n\nBooleans, types, None\n\nProgram unit types\n\nFunctions, modules, classes (Part IV, Part V, Part VI)\n\nImplementation-related types",
    "Strings\n\n'spam', \"guido's\", b'a\\x01c'\n\nLists\n\n[1, [2, 'three'], 4]\n\nDictionaries\n\n{'food': 'spam', 'taste': 'yum'}\n\nTuples\n\n(1, 'spam', 4, 'U')\n\nFiles\n\nmyfile = open('eggs', 'r')\n\nSets\n\nset('abc'), {'a', 'b', 'c'}\n\nOther core types\n\nBooleans, types, None\n\nProgram unit types\n\nFunctions, modules, classes (Part IV, Part V, Part VI)\n\nImplementation-related types\n\nCompiled code, stack tracebacks (Part IV, Part VII)",
    "Table 4-1 isn’t really complete, because everything we process in Python programs is a\nkind of object. For instance, when we perform text pattern matching in Python, we\ncreate pattern objects, and when we perform network scripting, we use socket objects.\nThese other kinds of objects are generally created by importing and using modules and\nhave behavior all their own.\nAs we’ll see in later parts of the book, program units such as functions, modules, and\nclasses are objects in Python too—they are created with statements and expressions\nsuch as def, class, import, and lambda and may be passed around scripts freely, stored\nwithin other objects, and so on. Python also provides a set of implementation-related\ntypes such as compiled code objects, which are generally of interest to tool builders\nmore than application developers; these are also discussed in later parts of this text.\nWe usually call the other object types in Table 4-1 core data types, though, because",
    "within other objects, and so on. Python also provides a set of implementation-related\ntypes such as compiled code objects, which are generally of interest to tool builders\nmore than application developers; these are also discussed in later parts of this text.\nWe usually call the other object types in Table 4-1 core data types, though, because\nthey are effectively built into the Python language—that is, there is specific expression\nsyntax for generating most of them. For instance, when you run the following code:\n>>> 'spam'",
    "* In this book, the term literal simply means an expression whose syntax generates an object—sometimes also\ncalled a constant. Note that the term “constant” does not imply objects or variables that can never be changed\n(i.e., this term is unrelated to C++’s const or Python’s “immutable”—a topic explored in the section\n“Immutability” on page 82).\n\nWhy Use Built-in Types? | 77",
    "you are, technically speaking, running a literal expression that generates and returns a\nnew string object. There is specific Python language syntax to make this object. Similarly, an expression wrapped in square brackets makes a list, one in curly braces makes\na dictionary, and so on. Even though, as we’ll see, there are no type declarations in\nPython, the syntax of the expressions you run determines the types of objects you create\nand use. In fact, object-generation expressions like those in Table 4-1 are generally\nwhere types originate in the Python language.\nJust as importantly, once you create an object, you bind its operation set for all time—\nyou can perform only string operations on a string and list operations on a list. As you’ll\nlearn, Python is dynamically typed (it keeps track of types for you automatically instead\nof requiring declaration code), but it is also strongly typed (you can perform on an object\nonly operations that are valid for its type).",
    "you can perform only string operations on a string and list operations on a list. As you’ll\nlearn, Python is dynamically typed (it keeps track of types for you automatically instead\nof requiring declaration code), but it is also strongly typed (you can perform on an object\nonly operations that are valid for its type).\nFunctionally, the object types in Table 4-1 are more general and powerful than what\nyou may be accustomed to. For instance, you’ll find that lists and dictionaries alone\nare powerful data representation tools that obviate most of the work you do to support\ncollections and searching in lower-level languages. In short, lists provide ordered collections of other objects, while dictionaries store objects by key; both lists and dictionaries may be nested, can grow and shrink on demand, and may contain objects of\nany type.\nWe’ll study each of the object types in Table 4-1 in detail in upcoming chapters. Before",
    "collections and searching in lower-level languages. In short, lists provide ordered collections of other objects, while dictionaries store objects by key; both lists and dictionaries may be nested, can grow and shrink on demand, and may contain objects of\nany type.\nWe’ll study each of the object types in Table 4-1 in detail in upcoming chapters. Before\ndigging into the details, though, let’s begin by taking a quick look at Python’s core\nobjects in action. The rest of this chapter provides a preview of the operations we’ll\nexplore in more depth in the chapters that follow. Don’t expect to find the full story\nhere—the goal of this chapter is just to whet your appetite and introduce some key\nideas. Still, the best way to get started is to get started, so let’s jump right into some\nreal code.",
    "Numbers\nIf you’ve done any programming or scripting in the past, some of the object types in\nTable 4-1 will probably seem familiar. Even if you haven’t, numbers are fairly straightforward. Python’s core objects set includes the usual suspects: integers (numbers without a fractional part), floating-point numbers (roughly, numbers with a decimal point\nin them), and more exotic numeric types (complex numbers with imaginary parts,\nfixed-precision decimals, rational fractions with numerator and denominator, and fullfeatured sets).\nAlthough it offers some fancier options, Python’s basic number types are, well, basic.\nNumbers in Python support the normal mathematical operations. For instance, the\nplus sign (+) performs addition, a star (*) is used for multiplication, and two stars (**)\nare used for exponentiation:\n\n78 | Chapter 4: Introducing Python Object Types\n\n\f>>> 123 + 222\n345\n>>> 1.5 * 4\n6.0\n>>> 2 ** 100\n1267650600228229401496703205376",
    "78 | Chapter 4: Introducing Python Object Types\n\n\f>>> 123 + 222\n345\n>>> 1.5 * 4\n6.0\n>>> 2 ** 100\n1267650600228229401496703205376\n\n# Integer addition\n# Floating-point multiplication\n# 2 to the power 100\n\nNotice the last result here: Python 3.0’s integer type automatically provides extra precision for large numbers like this when needed (in 2.6, a separate long integer type\nhandles numbers too large for the normal integer type in similar ways). You can, for\ninstance, compute 2 to the power 1,000,000 as an integer in Python, but you probably\nshouldn’t try to print the result—with more than 300,000 digits, you may be waiting\nawhile!\n>>> len(str(2 ** 1000000))\n301030\n\n# How many digits in a really BIG number?\n\nOnce you start experimenting with floating-point numbers, you’re likely to stumble\nacross something that may look a bit odd on first glance:\n>>> 3.1415 * 2\n6.2830000000000004\n>>> print(3.1415 * 2)\n6.283\n\n# repr: as code\n# str: user-friendly",
    "# How many digits in a really BIG number?\n\nOnce you start experimenting with floating-point numbers, you’re likely to stumble\nacross something that may look a bit odd on first glance:\n>>> 3.1415 * 2\n6.2830000000000004\n>>> print(3.1415 * 2)\n6.283\n\n# repr: as code\n# str: user-friendly\n\nThe first result isn’t a bug; it’s a display issue. It turns out that there are two ways to\nprint every object: with full precision (as in the first result shown here), and in a userfriendly form (as in the second). Formally, the first form is known as an object’s ascode repr, and the second is its user-friendly str. The difference can matter when we\nstep up to using classes; for now, if something looks odd, try showing it with a print\nbuilt-in call statement.\nBesides expressions, there are a handful of useful numeric modules that ship with\nPython—modules are just packages of additional tools that we import to use:\n>>> import math\n>>> math.pi\n3.1415926535897931\n>>> math.sqrt(85)\n9.2195444572928871",
    "The math module contains more advanced numeric tools as functions, while the\nrandom module performs random number generation and random selections (here, from\na Python list, introduced later in this chapter):\n>>> import random\n>>> random.random()\n0.59268735266273953\n>>> random.choice([1, 2, 3, 4])\n1\n\nPython also includes more exotic numeric objects—such as complex, fixed-precision,\nand rational numbers, as well as sets and Booleans—and the third-party open source\n\nNumbers | 79\n\n\fextension domain has even more (e.g., matrixes and vectors). We’ll defer discussion of\nthese types until later in the book.\nSo far, we’ve been using Python much like a simple calculator; to do better justice to\nits built-in types, let’s move on to explore strings.",
    "Numbers | 79\n\n\fextension domain has even more (e.g., matrixes and vectors). We’ll defer discussion of\nthese types until later in the book.\nSo far, we’ve been using Python much like a simple calculator; to do better justice to\nits built-in types, let’s move on to explore strings.\n\nStrings\nStrings are used to record textual information as well as arbitrary collections of bytes.\nThey are our first example of what we call a sequence in Python—that is, a positionally\nordered collection of other objects. Sequences maintain a left-to-right order among the\nitems they contain: their items are stored and fetched by their relative position. Strictly\nspeaking, strings are sequences of one-character strings; other types of sequences include lists and tuples, covered later.",
    "Sequence Operations\nAs sequences, strings support operations that assume a positional ordering among\nitems. For example, if we have a four-character string, we can verify its length with the\nbuilt-in len function and fetch its components with indexing expressions:\n>>> S = 'Spam'\n>>> len(S)\n4\n>>> S[0]\n'S'\n>>> S[1]\n'p'\n\n# Length\n# The first item in S, indexing by zero-based position\n# The second item from the left",
    "# Length\n# The first item in S, indexing by zero-based position\n# The second item from the left\n\nIn Python, indexes are coded as offsets from the front, and so start from 0: the first item\nis at index 0, the second is at index 1, and so on.\nNotice how we assign the string to a variable named S here. We’ll go into detail on how\nthis works later (especially in Chapter 6), but Python variables never need to be declared\nahead of time. A variable is created when you assign it a value, may be assigned any\ntype of object, and is replaced with its value when it shows up in an expression. It must\nalso have been previously assigned by the time you use its value. For the purposes of\nthis chapter, it’s enough to know that we need to assign an object to a variable in order\nto save it for later use.\nIn Python, we can also index backward, from the end—positive indexes count from\nthe left, and negative indexes count back from the right:\n>>> S[-1]\n'm'\n>>> S[-2]\n'a'",
    "# The last item from the end in S\n# The second to last item from the end\n\n80 | Chapter 4: Introducing Python Object Types\n\n\fFormally, a negative index is simply added to the string’s size, so the following two\noperations are equivalent (though the first is easier to code and less easy to get wrong):\n>>> S[-1]\n'm'\n>>> S[len(S)-1]\n'm'\n\n# The last item in S\n# Negative indexing, the hard way\n\nNotice that we can use an arbitrary expression in the square brackets, not just a hardcoded number literal—anywhere that Python expects a value, we can use a literal, a\nvariable, or any expression. Python’s syntax is completely general this way.\nIn addition to simple positional indexing, sequences also support a more general form\nof indexing known as slicing, which is a way to extract an entire section (slice) in a single\nstep. For example:\n>>> S\n'Spam'\n>>> S[1:3]\n'pa'\n\n# A 4-character string\n# Slice of S from offsets 1 through 2 (not 3)",
    "# A 4-character string\n# Slice of S from offsets 1 through 2 (not 3)\n\nProbably the easiest way to think of slices is that they are a way to extract an entire\ncolumn from a string in a single step. Their general form, X[I:J], means “give me everything in X from offset I up to but not including offset J.” The result is returned in a\nnew object. The second of the preceding operations, for instance, gives us all the characters in string S from offsets 1 through 2 (that is, 3 – 1) as a new string. The effect is\nto slice or “parse out” the two characters in the middle.\nIn a slice, the left bound defaults to zero, and the right bound defaults to the length of\nthe sequence being sliced. This leads to some common usage variations:\n>>> S[1:]\n'pam'\n>>> S\n'Spam'\n>>> S[0:3]\n'Spa'\n>>> S[:3]\n'Spa'\n>>> S[:-1]\n'Spa'\n>>> S[:]\n'Spam'",
    "# Everything past the first (1:len(S))\n# S itself hasn't changed\n# Everything but the last\n# Same as S[0:3]\n# Everything but the last again, but simpler (0:-1)\n# All of S as a top-level copy (0:len(S))\n\nNote how negative offsets can be used to give bounds for slices, too, and how the last\noperation effectively copies the entire string. As you’ll learn later, there is no reason to\ncopy a string, but this form can be useful for sequences like lists.\nFinally, as sequences, strings also support concatenation with the plus sign (joining two\nstrings into a new string) and repetition (making a new string by repeating another):\n>>> S\nSpam'\n>>> S + 'xyz'\n\n# Concatenation\n\nStrings | 81\n\n\f'Spamxyz'\n>>> S\n# S is unchanged\n'Spam'\n>>> S * 8\n# Repetition\n'SpamSpamSpamSpamSpamSpamSpamSpam'",
    "# Concatenation\n\nStrings | 81\n\n\f'Spamxyz'\n>>> S\n# S is unchanged\n'Spam'\n>>> S * 8\n# Repetition\n'SpamSpamSpamSpamSpamSpamSpamSpam'\n\nNotice that the plus sign (+) means different things for different objects: addition for\nnumbers, and concatenation for strings. This is a general property of Python that we’ll\ncall polymorphism later in the book—in sum, the meaning of an operation depends on\nthe objects being operated on. As you’ll see when we study dynamic typing, this polymorphism property accounts for much of the conciseness and flexibility of Python code.\nBecause types aren’t constrained, a Python-coded operation can normally work on\nmany different types of objects automatically, as long as they support a compatible\ninterface (like the + operation here). This turns out to be a huge idea in Python; you’ll\nlearn more about it later on our tour.",
    "Immutability\nNotice that in the prior examples, we were not changing the original string with any of\nthe operations we ran on it. Every string operation is defined to produce a new string\nas its result, because strings are immutable in Python—they cannot be changed in-place\nafter they are created. For example, you can’t change a string by assigning to one of its\npositions, but you can always build a new one and assign it to the same name. Because\nPython cleans up old objects as you go (as you’ll see later), this isn’t as inefficient as it\nmay sound:\n>>> S\n'Spam'\n>>> S[0] = 'z'\n# Immutable objects cannot be changed\n...error text omitted...\nTypeError: 'str' object does not support item assignment\n>>> S = 'z' + S[1:]\n>>> S\n'zpam'\n\n# But we can run expressions to make new objects",
    "# But we can run expressions to make new objects\n\nEvery object in Python is classified as either immutable (unchangeable) or not. In terms\nof the core types, numbers, strings, and tuples are immutable; lists and dictionaries are\nnot (they can be changed in-place freely). Among other things, immutability can be\nused to guarantee that an object remains constant throughout your program.\n\nType-Specific Methods\nEvery string operation we’ve studied so far is really a sequence operation—that is, these\noperations will work on other sequences in Python as well, including lists and tuples.\nIn addition to generic sequence operations, though, strings also have operations all\ntheir own, available as methods—functions attached to the object, which are triggered\nwith a call expression.\n\n82 | Chapter 4: Introducing Python Object Types",
    "82 | Chapter 4: Introducing Python Object Types\n\n\fFor example, the string find method is the basic substring search operation (it returns\nthe offset of the passed-in substring, or −1 if it is not present), and the string replace\nmethod performs global searches and replacements:\n>>> S.find('pa')\n1\n>>> S\n'Spam'\n>>> S.replace('pa', 'XYZ')\n'SXYZm'\n>>> S\n'Spam'\n\n# Find the offset of a substring\n\n# Replace occurrences of a substring with another",
    "# Find the offset of a substring\n\n# Replace occurrences of a substring with another\n\nAgain, despite the names of these string methods, we are not changing the original\nstrings here, but creating new strings as the results—because strings are immutable,\nwe have to do it this way. String methods are the first line of text-processing tools in\nPython. Other methods split a string into substrings on a delimiter (handy as a simple\nform of parsing), perform case conversions, test the content of the string (digits, letters,\nand so on), and strip whitespace characters off the ends of the string:\n>>> line = 'aaa,bbb,ccccc,dd'\n>>> line.split(',')\n# Split on a delimiter into a list of substrings\n['aaa', 'bbb', 'ccccc', 'dd']\n>>> S = 'spam'\n>>> S.upper()\n# Upper- and lowercase conversions\n'SPAM'\n>>> S.isalpha()\nTrue\n\n# Content tests: isalpha, isdigit, etc.\n\n>>> line = 'aaa,bbb,ccccc,dd\\n'\n>>> line = line.rstrip()\n# Remove whitespace characters on the right side\n>>> line\n'aaa,bbb,ccccc,dd'",
    "# Content tests: isalpha, isdigit, etc.\n\n>>> line = 'aaa,bbb,ccccc,dd\\n'\n>>> line = line.rstrip()\n# Remove whitespace characters on the right side\n>>> line\n'aaa,bbb,ccccc,dd'\n\nStrings also support an advanced substitution operation known as formatting, available\nas both an expression (the original) and a string method call (new in 2.6 and 3.0):\n>>> '%s, eggs, and %s' % ('spam', 'SPAM!')\n'spam, eggs, and SPAM!'\n\n# Formatting expression (all)\n\n>>> '{0}, eggs, and {1}'.format('spam', 'SPAM!')\n'spam, eggs, and SPAM!'\n\n# Formatting method (2.6, 3.0)",
    "Strings also support an advanced substitution operation known as formatting, available\nas both an expression (the original) and a string method call (new in 2.6 and 3.0):\n>>> '%s, eggs, and %s' % ('spam', 'SPAM!')\n'spam, eggs, and SPAM!'\n\n# Formatting expression (all)\n\n>>> '{0}, eggs, and {1}'.format('spam', 'SPAM!')\n'spam, eggs, and SPAM!'\n\n# Formatting method (2.6, 3.0)\n\nOne note here: although sequence operations are generic, methods are not—although\nsome types share some method names, string method operations generally work only\non strings, and nothing else. As a rule of thumb, Python’s toolset is layered: generic\noperations that span multiple types show up as built-in functions or expressions (e.g.,\nlen(X), X[0]), but type-specific operations are method calls (e.g., aString.upper()).\nFinding the tools you need among all these categories will become more natural as you\nuse Python more, but the next section gives a few tips you can use right now.\n\nStrings | 83",
    "Getting Help\nThe methods introduced in the prior section are a representative, but small, sample of\nwhat is available for string objects. In general, this book is not exhaustive in its look at\nobject methods. For more details, you can always call the built-in dir function, which\nreturns a list of all the attributes available for a given object. Because methods are\nfunction attributes, they will show up in this list. Assuming S is still the string, here are\nits attributes on Python 3.0 (Python 2.6 varies slightly):\n>>> dir(S)\n['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__',\n'__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__',\n'__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__',\n'__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',\n'__subclasshook__', '_formatter_field_name_split', '_formatter_parser',",
    "'__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__',\n'__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__',\n'__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',\n'__subclasshook__', '_formatter_field_name_split', '_formatter_parser',\n'capitalize', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find',\n'format', 'index', 'isalnum','isalpha', 'isdecimal', 'isdigit', 'isidentifier',\n'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join',\n'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind',\n'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines',\n'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']",
    "You probably won’t care about the names with underscores in this list until later in the\nbook, when we study operator overloading in classes—they represent the implementation of the string object and are available to support customization. In general, leading\nand trailing double underscores is the naming pattern Python uses for implementation\ndetails. The names without the underscores in this list are the callable methods on string\nobjects.\nThe dir function simply gives the methods’ names. To ask what they do, you can pass\nthem to the help function:\n>>> help(S.replace)\nHelp on built-in function replace:\nreplace(...)\nS.replace (old, new[, count]) -> str\nReturn a copy of S with all occurrences of substring\nold replaced by new. If the optional argument count is\ngiven, only the first count occurrences are replaced.\n\nhelp is one of a handful of interfaces to a system of code that ships with Python known",
    "help is one of a handful of interfaces to a system of code that ships with Python known\n\nas PyDoc—a tool for extracting documentation from objects. Later in the book, you’ll\nsee that PyDoc can also render its reports in HTML format.\nYou can also ask for help on an entire string (e.g., help(S)), but you may get more help\nthan you want to see—i.e., information about every string method. It’s generally better\nto ask about a specific method.\n\n84 | Chapter 4: Introducing Python Object Types\n\n\fFor more details, you can also consult Python’s standard library reference manual or\ncommercially published reference books, but dir and help are the first line of documentation in Python.",
    "84 | Chapter 4: Introducing Python Object Types\n\n\fFor more details, you can also consult Python’s standard library reference manual or\ncommercially published reference books, but dir and help are the first line of documentation in Python.\n\nOther Ways to Code Strings\nSo far, we’ve looked at the string object’s sequence operations and type-specific methods. Python also provides a variety of ways for us to code strings, which we’ll explore\nin greater depth later. For instance, special characters can be represented as backslash\nescape sequences:\n>>> S = 'A\\nB\\tC'\n>>> len(S)\n5\n\n# \\n is end-of-line, \\t is tab\n# Each stands for just one character\n\n>>> ord('\\n')\n10\n\n# \\n is a byte with the binary value 10 in ASCII\n\n>>> S = 'A\\0B\\0C'\n>>> len(S)\n5\n\n# \\0, a binary zero byte, does not terminate string",
    "# \\n is end-of-line, \\t is tab\n# Each stands for just one character\n\n>>> ord('\\n')\n10\n\n# \\n is a byte with the binary value 10 in ASCII\n\n>>> S = 'A\\0B\\0C'\n>>> len(S)\n5\n\n# \\0, a binary zero byte, does not terminate string\n\nPython allows strings to be enclosed in single or double quote characters (they mean\nthe same thing). It also allows multiline string literals enclosed in triple quotes (single\nor double)—when this form is used, all the lines are concatenated together, and endof-line characters are added where line breaks appear. This is a minor syntactic convenience, but it’s useful for embedding things like HTML and XML code in a Python\nscript:\n>>> msg = \"\"\" aaaaaaaaaaaaa\nbbb'''bbbbbbbbbb\"\"bbbbbbb'bbbb\ncccccccccccccc\"\"\"\n>>> msg\n'\\naaaaaaaaaaaaa\\nbbb\\'\\'\\'bbbbbbbbbb\"\"bbbbbbb\\'bbbb\\ncccccccccccccc'",
    "Python also supports a raw string literal that turns off the backslash escape mechanism\n(such string literals start with the letter r), as well as Unicode string support that supports internationalization. In 3.0, the basic str string type handles Unicode too (which\nmakes sense, given that ASCII text is a simple kind of Unicode), and a bytes type\nrepresents raw byte strings; in 2.6, Unicode is a separate type, and str handles both 8bit strings and binary data. Files are also changed in 3.0 to return and accept str for\ntext and bytes for binary data. We’ll meet all these special string forms in later chapters.\n\nPattern Matching\nOne point worth noting before we move on is that none of the string object’s methods\nsupport pattern-based text processing. Text pattern matching is an advanced tool outside this book’s scope, but readers with backgrounds in other scripting languages may\nbe interested to know that to do pattern matching in Python, we import a module called\nStrings | 85",
    "Pattern Matching\nOne point worth noting before we move on is that none of the string object’s methods\nsupport pattern-based text processing. Text pattern matching is an advanced tool outside this book’s scope, but readers with backgrounds in other scripting languages may\nbe interested to know that to do pattern matching in Python, we import a module called\nStrings | 85\n\n\fre. This module has analogous calls for searching, splitting, and replacement, but be-\n\ncause we can use patterns to specify substrings, we can be much more general:\n>>> import re\n>>> match = re.match('Hello[ \\t]*(.*)world', 'Hello\n>>> match.group(1)\n'Python '\n\nPython world')",
    "re. This module has analogous calls for searching, splitting, and replacement, but be-\n\ncause we can use patterns to specify substrings, we can be much more general:\n>>> import re\n>>> match = re.match('Hello[ \\t]*(.*)world', 'Hello\n>>> match.group(1)\n'Python '\n\nPython world')\n\nThis example searches for a substring that begins with the word “Hello,” followed by\nzero or more tabs or spaces, followed by arbitrary characters to be saved as a matched\ngroup, terminated by the word “world.” If such a substring is found, portions of the\nsubstring matched by parts of the pattern enclosed in parentheses are available as\ngroups. The following pattern, for example, picks out three groups separated by\nslashes:\n>>> match = re.match('/(.*)/(.*)/(.*)', '/usr/home/lumberjack')\n>>> match.groups()\n('usr', 'home', 'lumberjack')",
    "Pattern matching is a fairly advanced text-processing tool by itself, but there is also\nsupport in Python for even more advanced language processing, including natural language processing. I’ve already said enough about strings for this tutorial, though, so\nlet’s move on to the next type.\n\nLists\nThe Python list object is the most general sequence provided by the language. Lists are\npositionally ordered collections of arbitrarily typed objects, and they have no fixed size.\nThey are also mutable—unlike strings, lists can be modified in-place by assignment to\noffsets as well as a variety of list method calls.\n\nSequence Operations\nBecause they are sequences, lists support all the sequence operations we discussed for\nstrings; the only difference is that the results are usually lists instead of strings. For\ninstance, given a three-item list:\n>>> L = [123, 'spam', 1.23]\n>>> len(L)\n3\n\n# A list of three different-type objects\n# Number of items in the list",
    "Sequence Operations\nBecause they are sequences, lists support all the sequence operations we discussed for\nstrings; the only difference is that the results are usually lists instead of strings. For\ninstance, given a three-item list:\n>>> L = [123, 'spam', 1.23]\n>>> len(L)\n3\n\n# A list of three different-type objects\n# Number of items in the list\n\nwe can index, slice, and so on, just as for strings:\n>>> L[0]\n123\n\n# Indexing by position\n\n>>> L[:-1]\n[123, 'spam']\n\n# Slicing a list returns a new list\n\n>>> L + [4, 5, 6]\n[123, 'spam', 1.23, 4, 5, 6]\n\n# Concatenation makes a new list too\n\n86 | Chapter 4: Introducing Python Object Types\n\n\f>>> L\n[123, 'spam', 1.23]\n\n# We're not changing the original list",
    "we can index, slice, and so on, just as for strings:\n>>> L[0]\n123\n\n# Indexing by position\n\n>>> L[:-1]\n[123, 'spam']\n\n# Slicing a list returns a new list\n\n>>> L + [4, 5, 6]\n[123, 'spam', 1.23, 4, 5, 6]\n\n# Concatenation makes a new list too\n\n86 | Chapter 4: Introducing Python Object Types\n\n\f>>> L\n[123, 'spam', 1.23]\n\n# We're not changing the original list\n\nType-Specific Operations\nPython’s lists are related to arrays in other languages, but they tend to be more powerful.\nFor one thing, they have no fixed type constraint—the list we just looked at, for example, contains three objects of completely different types (an integer, a string, and a\nfloating-point number). Further, lists have no fixed size. That is, they can grow and\nshrink on demand, in response to list-specific operations:\n>>> L.append('NI')\n>>> L\n[123, 'spam', 1.23, 'NI']\n\n# Growing: add object at end of list\n\n>>> L.pop(2)\n1.23\n\n# Shrinking: delete an item in the middle\n\n>>> L\n[123, 'spam', 'NI']",
    "# Growing: add object at end of list\n\n>>> L.pop(2)\n1.23\n\n# Shrinking: delete an item in the middle\n\n>>> L\n[123, 'spam', 'NI']\n\n# \"del L[2]\" deletes from a list too\n\nHere, the list append method expands the list’s size and inserts an item at the end; the\npop method (or an equivalent del statement) then removes an item at a given offset,\ncausing the list to shrink. Other list methods insert an item at an arbitrary position\n(insert), remove a given item by value (remove), and so on. Because lists are mutable,\nmost list methods also change the list object in-place, instead of creating a new one:\n>>> M = ['bb', 'aa', 'cc']\n>>> M.sort()\n>>> M\n['aa', 'bb', 'cc']\n>>> M.reverse()\n>>> M\n['cc', 'bb', 'aa']\n\nThe list sort method here, for example, orders the list in ascending fashion by default,\nand reverse reverses it—in both cases, the methods modify the list directly.",
    "The list sort method here, for example, orders the list in ascending fashion by default,\nand reverse reverses it—in both cases, the methods modify the list directly.\n\nBounds Checking\nAlthough lists have no fixed size, Python still doesn’t allow us to reference items that\nare not present. Indexing off the end of a list is always a mistake, but so is assigning off\nthe end:\n>>> L\n[123, 'spam', 'NI']\n>>> L[99]\n...error text omitted...\nIndexError: list index out of range\n\nLists | 87\n\n\f>>> L[99] = 1\n...error text omitted...\nIndexError: list assignment index out of range\n\nThis is intentional, as it’s usually an error to try to assign off the end of a list (and a\nparticularly nasty one in the C language, which doesn’t do as much error checking as\nPython). Rather than silently growing the list in response, Python reports an error. To\ngrow a list, we call list methods such as append instead.",
    "This is intentional, as it’s usually an error to try to assign off the end of a list (and a\nparticularly nasty one in the C language, which doesn’t do as much error checking as\nPython). Rather than silently growing the list in response, Python reports an error. To\ngrow a list, we call list methods such as append instead.\n\nNesting\nOne nice feature of Python’s core data types is that they support arbitrary nesting—we\ncan nest them in any combination, and as deeply as we like (for example, we can have\na list that contains a dictionary, which contains another list, and so on). One immediate\napplication of this feature is to represent matrixes, or “multidimensional arrays” in\nPython. A list with nested lists will do the job for basic applications:\n>>> M = [[1, 2, 3],\n# A 3 × 3 matrix, as nested lists\n[4, 5, 6],\n# Code can span lines if bracketed\n[7, 8, 9]]\n>>> M\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
    "Here, we’ve coded a list that contains three other lists. The effect is to represent a\n3 × 3 matrix of numbers. Such a structure can be accessed in a variety of ways:\n>>> M[1]\n[4, 5, 6]\n\n# Get row 2\n\n>>> M[1][2]\n6\n\n# Get row 2, then get item 3 within the row\n\nThe first operation here fetches the entire second row, and the second grabs the third\nitem within that row. Stringing together index operations takes us deeper and deeper\ninto our nested-object structure.†\n\nComprehensions\nIn addition to sequence operations and list methods, Python includes a more advanced\noperation known as a list comprehension expression, which turns out to be a powerful\nway to process structures like our matrix. Suppose, for instance, that we need to extract\nthe second column of our sample matrix. It’s easy to grab rows by simple indexing",
    "Comprehensions\nIn addition to sequence operations and list methods, Python includes a more advanced\noperation known as a list comprehension expression, which turns out to be a powerful\nway to process structures like our matrix. Suppose, for instance, that we need to extract\nthe second column of our sample matrix. It’s easy to grab rows by simple indexing\n\n† This matrix structure works for small-scale tasks, but for more serious number crunching you will probably\nwant to use one of the numeric extensions to Python, such as the open source NumPy system. Such tools can\nstore and process large matrixes much more efficiently than our nested list structure. NumPy has been said\nto turn Python into the equivalent of a free and more powerful version of the Matlab system, and organizations\nsuch as NASA, Los Alamos, and JPMorgan Chase use this tool for scientific and financial tasks. Search the\nWeb for more details.\n\n88 | Chapter 4: Introducing Python Object Types",
    "88 | Chapter 4: Introducing Python Object Types\n\n\fbecause the matrix is stored by rows, but it’s almost as easy to get a column with a list\ncomprehension:\n>>> col2 = [row[1] for row in M]\n>>> col2\n[2, 5, 8]\n\n# Collect the items in column 2\n\n>>> M\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n# The matrix is unchanged\n\nList comprehensions derive from set notation; they are a way to build a new list by\nrunning an expression on each item in a sequence, one at a time, from left to right. List\ncomprehensions are coded in square brackets (to tip you off to the fact that they make\na list) and are composed of an expression and a looping construct that share a variable\nname (row, here). The preceding list comprehension means basically what it says: “Give\nme row[1] for each row in matrix M, in a new list.” The result is a new list containing\ncolumn 2 of the matrix.\nList comprehensions can be more complex in practice:\n>>> [row[1] + 1 for row in M]\n[3, 6, 9]\n\n# Add 1 to each item in column 2",
    "# Add 1 to each item in column 2\n\n>>> [row[1] for row in M if row[1] % 2 == 0] # Filter out odd items\n[2, 8]\n\nThe first operation here, for instance, adds 1 to each item as it is collected, and the\nsecond uses an if clause to filter odd numbers out of the result using the % modulus\nexpression (remainder of division). List comprehensions make new lists of results, but\nthey can be used to iterate over any iterable object. Here, for instance, we use list comprehensions to step over a hardcoded list of coordinates and a string:\n>>> diag = [M[i][i] for i in [0, 1, 2]]\n>>> diag\n[1, 5, 9]\n\n# Collect a diagonal from matrix\n\n>>> doubles = [c * 2 for c in 'spam']\n>>> doubles\n['ss', 'pp', 'aa', 'mm']\n\n# Repeat characters in a string",
    "# Collect a diagonal from matrix\n\n>>> doubles = [c * 2 for c in 'spam']\n>>> doubles\n['ss', 'pp', 'aa', 'mm']\n\n# Repeat characters in a string\n\nList comprehensions, and relatives like the map and filter built-in functions, are a bit\ntoo involved for me to say more about them here. The main point of this brief introduction is to illustrate that Python includes both simple and advanced tools in its arsenal. List comprehensions are an optional feature, but they tend to be handy in practice\nand often provide a substantial processing speed advantage. They also work on any\ntype that is a sequence in Python, as well as some types that are not. You’ll hear much\nmore about them later in this book.\nAs a preview, though, you’ll find that in recent Pythons, comprehension syntax in\nparentheses can also be used to create generators that produce results on demand (the\nsum built-in, for instance, sums items in a sequence):\n\nLists | 89\n\n\f>>> G = (sum(row) for row in M)\n>>> next(G)\n6\n>>> next(G)\n15",
    "Lists | 89\n\n\f>>> G = (sum(row) for row in M)\n>>> next(G)\n6\n>>> next(G)\n15\n\n# Create a generator of row sums\n# Run the iteration protocol\n\nThe map built-in can do similar work, by generating the results of running items through\na function. Wrapping it in list forces it to return all its values in Python 3.0:\n>>> list(map(sum, M))\n[6, 15, 24]\n\n# Map sum over items in M\n\nIn Python 3.0, comprehension syntax can also be used to create sets and dictionaries:\n>>> {sum(row) for row in M}\n{24, 6, 15}\n\n# Create a set of row sums\n\n>>> {i : sum(M[i]) for i in range(3)}\n{0: 6, 1: 15, 2: 24}\n\n# Creates key/value table of row sums\n\nIn fact, lists, sets, and dictionaries can all be built with comprehensions in 3.0:\n>>> [ord(x) for x in 'spaam']\n[115, 112, 97, 97, 109]\n>>> {ord(x) for x in 'spaam'}\n{112, 97, 115, 109}\n>>> {x: ord(x) for x in 'spaam'}\n{'a': 97, 'p': 112, 's': 115, 'm': 109}\n\n# List of character ordinals\n# Sets remove duplicates\n# Dictionary keys are unique",
    "# Creates key/value table of row sums\n\nIn fact, lists, sets, and dictionaries can all be built with comprehensions in 3.0:\n>>> [ord(x) for x in 'spaam']\n[115, 112, 97, 97, 109]\n>>> {ord(x) for x in 'spaam'}\n{112, 97, 115, 109}\n>>> {x: ord(x) for x in 'spaam'}\n{'a': 97, 'p': 112, 's': 115, 'm': 109}\n\n# List of character ordinals\n# Sets remove duplicates\n# Dictionary keys are unique\n\nTo understand objects like generators, sets, and dictionaries, though, we must move\nahead.",
    "# List of character ordinals\n# Sets remove duplicates\n# Dictionary keys are unique\n\nTo understand objects like generators, sets, and dictionaries, though, we must move\nahead.\n\nDictionaries\nPython dictionaries are something completely different (Monty Python reference\nintended)—they are not sequences at all, but are instead known as mappings. Mappings\nare also collections of other objects, but they store objects by key instead of by relative\nposition. In fact, mappings don’t maintain any reliable left-to-right order; they simply\nmap keys to associated values. Dictionaries, the only mapping type in Python’s core\nobjects set, are also mutable: they may be changed in-place and can grow and shrink\non demand, like lists.",
    "Mapping Operations\nWhen written as literals, dictionaries are coded in curly braces and consist of a series\nof “key: value” pairs. Dictionaries are useful anytime we need to associate a set of values\nwith keys—to describe the properties of something, for instance. As an example, consider the following three-item dictionary (with keys “food,” “quantity,” and “color”):\n>>> D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}\n\n90 | Chapter 4: Introducing Python Object Types\n\n\fWe can index this dictionary by key to fetch and change the keys’ associated values.\nThe dictionary index operation uses the same syntax as that used for sequences, but\nthe item in the square brackets is a key, not a relative position:\n>>> D['food']\n'Spam'\n\n# Fetch value of key 'food'\n\n>>> D['quantity'] += 1\n# Add 1 to 'quantity' value\n>>> D\n{'food': 'Spam', 'color': 'pink', 'quantity': 5}",
    "We can index this dictionary by key to fetch and change the keys’ associated values.\nThe dictionary index operation uses the same syntax as that used for sequences, but\nthe item in the square brackets is a key, not a relative position:\n>>> D['food']\n'Spam'\n\n# Fetch value of key 'food'\n\n>>> D['quantity'] += 1\n# Add 1 to 'quantity' value\n>>> D\n{'food': 'Spam', 'color': 'pink', 'quantity': 5}\n\nAlthough the curly-braces literal form does see use, it is perhaps more common to see\ndictionaries built up in different ways. The following code, for example, starts with an\nempty dictionary and fills it out one key at a time. Unlike out-of-bounds assignments\nin lists, which are forbidden, assignments to new dictionary keys create those keys:\n>>> D = {}\n>>> D['name'] = 'Bob'\n>>> D['job'] = 'dev'\n>>> D['age'] = 40\n\n# Create keys by assignment\n\n>>> D\n{'age': 40, 'job': 'dev', 'name': 'Bob'}\n>>> print(D['name'])\nBob",
    "# Create keys by assignment\n\n>>> D\n{'age': 40, 'job': 'dev', 'name': 'Bob'}\n>>> print(D['name'])\nBob\n\nHere, we’re effectively using dictionary keys as field names in a record that describes\nsomeone. In other applications, dictionaries can also be used to replace searching\noperations—indexing a dictionary by key is often the fastest way to code a search in\nPython.\n\nNesting Revisited\nIn the prior example, we used a dictionary to describe a hypothetical person, with three\nkeys. Suppose, though, that the information is more complex. Perhaps we need to\nrecord a first name and a last name, along with multiple job titles. This leads to another\napplication of Python’s object nesting in action. The following dictionary, coded all at\nonce as a literal, captures more structured information:\n>>> rec = {'name': {'first': 'Bob', 'last': 'Smith'},\n'job': ['dev', 'mgr'],\n'age': 40.5}",
    "Here, we again have a three-key dictionary at the top (keys “name,” “job,” and “age”),\nbut the values have become more complex: a nested dictionary for the name to support\nmultiple parts, and a nested list for the job to support multiple roles and future expansion. We can access the components of this structure much as we did for our matrix\nearlier, but this time some of our indexes are dictionary keys, not list offsets:\n\nDictionaries | 91\n\n\f>>> rec['name']\n{'last': 'Smith', 'first': 'Bob'}\n\n# 'name' is a nested dictionary\n\n>>> rec['name']['last']\n'Smith'\n\n# Index the nested dictionary\n\n>>> rec['job']\n['dev', 'mgr']\n>>> rec['job'][-1]\n'mgr'\n\n# 'job' is a nested list\n# Index the nested list\n\n>>> rec['job'].append('janitor')\n# Expand Bob's job description in-place\n>>> rec\n{'age': 40.5, 'job': ['dev', 'mgr', 'janitor'], 'name': {'last': 'Smith',\n'first': 'Bob'}}",
    "Notice how the last operation here expands the nested job list—because the job list is\na separate piece of memory from the dictionary that contains it, it can grow and shrink\nfreely (object memory layout will be discussed further later in this book).\nThe real reason for showing you this example is to demonstrate the flexibility of Python’s core data types. As you can see, nesting allows us to build up complex information structures directly and easily. Building a similar structure in a low-level language\nlike C would be tedious and require much more code: we would have to lay out and\ndeclare structures and arrays, fill out values, link everything together, and so on. In\nPython, this is all automatic—running the expression creates the entire nested object\nstructure for us. In fact, this is one of the main benefits of scripting languages like\nPython.\nJust as importantly, in a lower-level language we would have to be careful to clean up",
    "declare structures and arrays, fill out values, link everything together, and so on. In\nPython, this is all automatic—running the expression creates the entire nested object\nstructure for us. In fact, this is one of the main benefits of scripting languages like\nPython.\nJust as importantly, in a lower-level language we would have to be careful to clean up\nall of the object’s space when we no longer need it. In Python, when we lose the last\nreference to the object—by assigning its variable to something else, for example—all\nof the memory space occupied by that object’s structure is automatically cleaned up\nfor us:\n>>> rec = 0",
    "# Now the object's space is reclaimed\n\nTechnically speaking, Python has a feature known as garbage collection that cleans up\nunused memory as your program runs and frees you from having to manage such details\nin your code. In Python, the space is reclaimed immediately, as soon as the last reference\nto an object is removed. We’ll study how this works later in this book; for now, it’s\nenough to know that you can use objects freely, without worrying about creating their\nspace or cleaning up as you go.‡\n\n‡ Keep in mind that the rec record we just created really could be a database record, when we employ Python’s\nobject persistence system—an easy way to store native Python objects in files or access-by-key databases. We\nwon’t go into details here, but watch for discussion of Python’s pickle and shelve modules later in this book.\n\n92 | Chapter 4: Introducing Python Object Types",
    "‡ Keep in mind that the rec record we just created really could be a database record, when we employ Python’s\nobject persistence system—an easy way to store native Python objects in files or access-by-key databases. We\nwon’t go into details here, but watch for discussion of Python’s pickle and shelve modules later in this book.\n\n92 | Chapter 4: Introducing Python Object Types\n\n\fSorting Keys: for Loops\nAs mappings, as we’ve already seen, dictionaries only support accessing items by key.\nHowever, they also support type-specific operations with method calls that are useful\nin a variety of common use cases.\nAs mentioned earlier, because dictionaries are not sequences, they don’t maintain any\ndependable left-to-right order. This means that if we make a dictionary and print it\nback, its keys may come back in a different order than that in which we typed them:\n>>> D = {'a': 1, 'b': 2, 'c': 3}\n>>> D\n{'a': 1, 'c': 3, 'b': 2}",
    "What do we do, though, if we do need to impose an ordering on a dictionary’s items?\nOne common solution is to grab a list of keys with the dictionary keys method, sort\nthat with the list sort method, and then step through the result with a Python for loop\n(be sure to press the Enter key twice after coding the for loop below—as explained in\nChapter 3, an empty line means “go” at the interactive prompt, and the prompt changes\nto “...” on some interfaces):\n>>> Ks = list(D.keys())\n>>> Ks\n['a', 'c', 'b']\n\n# Unordered keys list\n# A list in 2.6, \"view\" in 3.0: use list()\n\n>>> Ks.sort()\n>>> Ks\n['a', 'b', 'c']\n\n# Sorted keys list\n\n>>> for key in Ks:\nprint(key, '=>', D[key])\n\n# Iterate though sorted keys\n# <== press Enter twice here\n\na => 1\nb => 2\nc => 3",
    "# Unordered keys list\n# A list in 2.6, \"view\" in 3.0: use list()\n\n>>> Ks.sort()\n>>> Ks\n['a', 'b', 'c']\n\n# Sorted keys list\n\n>>> for key in Ks:\nprint(key, '=>', D[key])\n\n# Iterate though sorted keys\n# <== press Enter twice here\n\na => 1\nb => 2\nc => 3\n\nThis is a three-step process, although, as we’ll see in later chapters, in recent versions\nof Python it can be done in one step with the newer sorted built-in function. The\nsorted call returns the result and sorts a variety of object types, in this case sorting\ndictionary keys automatically:\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> for key in sorted(D):\nprint(key, '=>', D[key])\na => 1\nb => 2\nc => 3\n\nBesides showcasing dictionaries, this use case serves to introduce the Python for loop.\nThe for loop is a simple and efficient way to step through all the items in a sequence\n\nDictionaries | 93",
    "Besides showcasing dictionaries, this use case serves to introduce the Python for loop.\nThe for loop is a simple and efficient way to step through all the items in a sequence\n\nDictionaries | 93\n\n\fand run a block of code for each item in turn. A user-defined loop variable (key, here)\nis used to reference the current item each time through. The net effect in our example\nis to print the unordered dictionary’s keys and values, in sorted-key order.\nThe for loop, and its more general cousin the while loop, are the main ways we code\nrepetitive tasks as statements in our scripts. Really, though, the for loop (like its relative\nthe list comprehension, which we met earlier) is a sequence operation. It works on any\nobject that is a sequence and, like the list comprehension, even on some things that are\nnot. Here, for example, it is stepping across the characters in a string, printing the\nuppercase version of each as it goes:\n>>> for c in 'spam':\nprint(c.upper())\nS\nP\nA\nM",
    "Python’s while loop is a more general sort of looping tool, not limited to stepping across\nsequences:\n>>> x = 4\n>>> while x > 0:\nprint('spam!' * x)\nx -= 1\nspam!spam!spam!spam!\nspam!spam!spam!\nspam!spam!\nspam!\n\nWe’ll discuss looping statements, syntax, and tools in depth later in the book.",
    "Iteration and Optimization\nIf the last section’s for loop looks like the list comprehension expression introduced\nearlier, it should: both are really general iteration tools. In fact, both will work on any\nobject that follows the iteration protocol—a pervasive idea in Python that essentially\nmeans a physically stored sequence in memory, or an object that generates one item at\na time in the context of an iteration operation. An object falls into the latter category\nif it responds to the iter built-in with an object that advances in response to next. The\ngenerator comprehension expression we saw earlier is such an object.\nI’ll have more to say about the iteration protocol later in this book. For now, keep in\nmind that every Python tool that scans an object from left to right uses the iteration\nprotocol. This is why the sorted call used in the prior section works on the dictionary\ndirectly—we don’t have to call the keys method to get a sequence because dictionaries",
    "I’ll have more to say about the iteration protocol later in this book. For now, keep in\nmind that every Python tool that scans an object from left to right uses the iteration\nprotocol. This is why the sorted call used in the prior section works on the dictionary\ndirectly—we don’t have to call the keys method to get a sequence because dictionaries\nare iterable objects, with a next that returns successive keys.",
    "94 | Chapter 4: Introducing Python Object Types\n\n\fThis also means that any list comprehension expression, such as this one, which computes the squares of a list of numbers:\n>>> squares = [x ** 2 for x in [1, 2, 3, 4, 5]]\n>>> squares\n[1, 4, 9, 16, 25]\n\ncan always be coded as an equivalent for loop that builds the result list manually by\nappending as it goes:\n>>> squares = []\n>>> for x in [1, 2, 3, 4, 5]:\nsquares.append(x ** 2)\n\n# This is what a list comprehension does\n# Both run the iteration protocol internally\n\n>>> squares\n[1, 4, 9, 16, 25]",
    ">>> squares\n[1, 4, 9, 16, 25]\n\nThe list comprehension, though, and related functional programming tools like map\nand filter, will generally run faster than a for loop today (perhaps even twice as fast)—\na property that could matter in your programs for large data sets. Having said that,\nthough, I should point out that performance measures are tricky business in Python\nbecause it optimizes so much, and performance can vary from release to release.\nA major rule of thumb in Python is to code for simplicity and readability first and worry\nabout performance later, after your program is working, and after you’ve proved that\nthere is a genuine performance concern. More often than not, your code will be quick\nenough as it is. If you do need to tweak code for performance, though, Python includes\ntools to help you out, including the time and timeit modules and the profile module.\nYou’ll find more on these later in this book, and in the Python manuals.",
    "Missing Keys: if Tests\nOne other note about dictionaries before we move on. Although we can assign to a new\nkey to expand a dictionary, fetching a nonexistent key is still a mistake:\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> D['e'] = 99\n>>> D\n{'a': 1, 'c': 3, 'b': 2, 'e': 99}\n\n# Assigning new keys grows dictionaries\n\n>>> D['f']\n...error text omitted...\nKeyError: 'f'\n\n# Referencing a nonexistent key is an error\n\nThis is what we want—it’s usually a programming error to fetch something that isn’t\nreally there. But in some generic programs, we can’t always know what keys will be\npresent when we write our code. How do we handle such cases and avoid errors? One\ntrick is to test ahead of time. The dictionary in membership expression allows us to\n\nDictionaries | 95\n\n\fquery the existence of a key and branch on the result with a Python if statement (as\nwith the for, be sure to press Enter twice to run the if interactively here):\n>>> 'f' in D\nFalse\n>>> if not 'f' in D:\nprint('missing')\nmissing",
    "I’ll have much more to say about the if statement and statement syntax in general later\nin this book, but the form we’re using here is straightforward: it consists of the word\nif, followed by an expression that is interpreted as a true or false result, followed by a\nblock of code to run if the test is true. In its full form, the if statement can also have\nan else clause for a default case, and one or more elif (else if) clauses for other tests.\nIt’s the main selection tool in Python, and it’s the way we code logic in our scripts.\nStill, there are other ways to create dictionaries and avoid accessing nonexistent keys:\nthe get method (a conditional index with a default); the Python 2.X has_key method\n(which is no longer available in 3.0); the try statement (a tool we’ll first meet in Chapter 10 that catches and recovers from exceptions altogether); and the if/else expression\n(essentially, an if statement squeezed onto a single line). Here are a few examples:\n>>> value = D.get('x', 0)",
    "the get method (a conditional index with a default); the Python 2.X has_key method\n(which is no longer available in 3.0); the try statement (a tool we’ll first meet in Chapter 10 that catches and recovers from exceptions altogether); and the if/else expression\n(essentially, an if statement squeezed onto a single line). Here are a few examples:\n>>> value = D.get('x', 0)\n>>> value\n0\n>>> value = D['x'] if 'x' in D else 0\n>>> value\n0",
    "# Index but with a default\n# if/else expression form\n\nWe’ll save the details on such alternatives until a later chapter. For now, let’s move on\nto tuples.\n\nTuples\nThe tuple object (pronounced “toople” or “tuhple,” depending on who you ask) is\nroughly like a list that cannot be changed—tuples are sequences, like lists, but they are\nimmutable, like strings. Syntactically, they are coded in parentheses instead of square\nbrackets, and they support arbitrary types, arbitrary nesting, and the usual sequence\noperations:\n>>> T = (1, 2, 3, 4)\n>>> len(T)\n4\n\n# A 4-item tuple\n# Length\n\n>> T + (5, 6)\n(1, 2, 3, 4, 5, 6)\n\n# Concatenation\n\n>>> T[0]\n1\n\n# Indexing, slicing, and more\n\n96 | Chapter 4: Introducing Python Object Types\n\n\fTuples also have two type-specific callable methods in Python 3.0, but not nearly as\nmany as lists:\n>>> T.index(4)\n3\n>>> T.count(4)\n1\n\n# Tuple methods: 4 appears at offset 3\n# 4 appears once",
    "# A 4-item tuple\n# Length\n\n>> T + (5, 6)\n(1, 2, 3, 4, 5, 6)\n\n# Concatenation\n\n>>> T[0]\n1\n\n# Indexing, slicing, and more\n\n96 | Chapter 4: Introducing Python Object Types\n\n\fTuples also have two type-specific callable methods in Python 3.0, but not nearly as\nmany as lists:\n>>> T.index(4)\n3\n>>> T.count(4)\n1\n\n# Tuple methods: 4 appears at offset 3\n# 4 appears once\n\nThe primary distinction for tuples is that they cannot be changed once created. That\nis, they are immutable sequences:\n>>> T[0] = 2\n# Tuples are immutable\n...error text omitted...\nTypeError: 'tuple' object does not support item assignment\n\nLike lists and dictionaries, tuples support mixed types and nesting, but they don’t grow\nand shrink because they are immutable:\n>>> T = ('spam', 3.0, [11, 22, 33])\n>>> T[1]\n3.0\n>>> T[2][1]\n22\n>>> T.append(4)\nAttributeError: 'tuple' object has no attribute 'append'",
    "Like lists and dictionaries, tuples support mixed types and nesting, but they don’t grow\nand shrink because they are immutable:\n>>> T = ('spam', 3.0, [11, 22, 33])\n>>> T[1]\n3.0\n>>> T[2][1]\n22\n>>> T.append(4)\nAttributeError: 'tuple' object has no attribute 'append'\n\nWhy Tuples?\nSo, why have a type that is like a list, but supports fewer operations? Frankly, tuples\nare not generally used as often as lists in practice, but their immutability is the whole\npoint. If you pass a collection of objects around your program as a list, it can be changed\nanywhere; if you use a tuple, it cannot. That is, tuples provide a sort of integrity constraint that is convenient in programs larger than those we’ll write here. We’ll talk more\nabout tuples later in the book. For now, though, let’s jump ahead to our last major core\ntype: the file.",
    "Files\nFile objects are Python code’s main interface to external files on your computer. Files\nare a core type, but they’re something of an oddball—there is no specific literal syntax\nfor creating them. Rather, to create a file object, you call the built-in open function,\npassing in an external filename and a processing mode as strings. For example, to create\na text output file, you would pass in its name and the 'w' processing mode string to\nwrite data:\n>>> f = open('data.txt', 'w')\n>>> f.write('Hello\\n')\n6\n>>> f.write('world\\n')\n6\n>>> f.close()\n\n# Make a new file in output mode\n# Write strings of bytes to it\n# Returns number of bytes written in Python 3.0\n# Close to flush output buffers to disk\n\nFiles | 97",
    "# Make a new file in output mode\n# Write strings of bytes to it\n# Returns number of bytes written in Python 3.0\n# Close to flush output buffers to disk\n\nFiles | 97\n\n\fThis creates a file in the current directory and writes text to it (the filename can be a\nfull directory path if you need to access a file elsewhere on your computer). To read\nback what you just wrote, reopen the file in 'r' processing mode, for reading text\ninput—this is the default if you omit the mode in the call. Then read the file’s content\ninto a string, and display it. A file’s contents are always a string in your script, regardless\nof the type of data the file contains:\n>>> f = open('data.txt')\n>>> text = f.read()\n>>> text\n'Hello\\nworld\\n'\n\n# 'r' is the default processing mode\n# Read entire file into a string\n\n>>> print(text)\nHello\nworld\n\n# print interprets control characters\n\n>>> text.split()\n['Hello', 'world']\n\n# File content is always a string",
    "Other file object methods support additional features we don’t have time to cover here.\nFor instance, file objects provide more ways of reading and writing (read accepts an\noptional byte size, readline reads one line at a time, and so on), as well as other tools\n(seek moves to a new file position). As we’ll see later, though, the best way to read a\nfile today is to not read it at all—files provide an iterator that automatically reads line\nby line in for loops and other contexts.\nWe’ll meet the full set of file methods later in this book, but if you want a quick preview\nnow, run a dir call on any open file and a help on any of the method names that come\nback:\n>>> dir(f)\n[ ...many names omitted...\n'buffer', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty',\n'line_buffering', 'mode', 'name', 'newlines', 'read', 'readable', 'readline',\n'readlines', 'seek', 'seekable', 'tell', 'truncate', 'writable', 'write',\n'writelines']\n>>>help(f.seek)\n...try it and see...",
    "Later in the book, we’ll also see that files in Python 3.0 draw a sharp distinction between\ntext and binary data. Text files represent content as strings and perform Unicode encoding and decoding automatically, while binary files represent content as a special\nbytes string type and allow you to access file content unaltered:\n>>> data = open('data.bin', 'rb').read()\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> data[4:8]\nb'spam'\n\n98 | Chapter 4: Introducing Python Object Types\n\n# Open binary file\n# bytes string holds binary data\n\n\fAlthough you won’t generally need to care about this distinction if you deal only with\nASCII text, Python 3.0’s strings and files are an asset if you deal with internationalized\napplications or byte-oriented data.",
    "98 | Chapter 4: Introducing Python Object Types\n\n# Open binary file\n# bytes string holds binary data\n\n\fAlthough you won’t generally need to care about this distinction if you deal only with\nASCII text, Python 3.0’s strings and files are an asset if you deal with internationalized\napplications or byte-oriented data.\n\nOther File-Like Tools\nThe open function is the workhorse for most file processing you will do in Python. For\nmore advanced tasks, though, Python comes with additional file-like tools: pipes,\nFIFOs, sockets, keyed-access files, persistent object shelves, descriptor-based files, relational and object-oriented database interfaces, and more. Descriptor files, for\ninstance, support file locking and other low-level tools, and sockets provide an interface\nfor networking and interprocess communication. We won’t cover many of these topics\nin this book, but you’ll find them useful once you start programming Python in earnest.",
    "Other Core Types\nBeyond the core types we’ve seen so far, there are others that may or may not qualify\nfor membership in the set, depending on how broadly it is defined. Sets, for example,\nare a recent addition to the language that are neither mappings nor sequences; rather,\nthey are unordered collections of unique and immutable objects. Sets are created by\ncalling the built-in set function or using new set literals and expressions in 3.0, and\nthey support the usual mathematical set operations (the choice of new {...} syntax for\nset literals in 3.0 makes sense, since sets are much like the keys of a valueless dictionary):\n>>> X = set('spam')\n# Make a set out of a sequence in 2.6 and 3.0\n>>> Y = {'h', 'a', 'm'}\n# Make a set with new 3.0 set literals\n>>> X, Y\n({'a', 'p', 's', 'm'}, {'a', 'h', 'm'})\n>>> X & Y\n{'a', 'm'}\n\n# Intersection\n\n>>> X | Y\n{'a', 'p', 's', 'h', 'm'}\n\n# Union\n\n>>> X – Y\n{'p', 's'}\n\n# Difference\n\n>>> {x ** 2 for x in [1, 2, 3, 4]}\n{16, 1, 4, 9}",
    "# Intersection\n\n>>> X | Y\n{'a', 'p', 's', 'h', 'm'}\n\n# Union\n\n>>> X – Y\n{'p', 's'}\n\n# Difference\n\n>>> {x ** 2 for x in [1, 2, 3, 4]}\n{16, 1, 4, 9}\n\n# Set comprehensions in 3.0\n\nIn addition, Python recently grew a few new numeric types: decimal numbers (fixedprecision floating-point numbers) and fraction numbers (rational numbers with both\na numerator and a denominator). Both can be used to work around the limitations and\ninherent inaccuracies of floating-point math:\n>>> 1 / 3\n0.33333333333333331\n>>> (2/3) + (1/2)\n\n# Floating-point (use .0 in Python 2.6)\n\nOther Core Types | 99\n\n\f1.1666666666666665\n>>> import decimal\n>>> d = decimal.Decimal('3.141')\n>>> d + 1\nDecimal('4.141')\n\n# Decimals: fixed precision\n\n>>> decimal.getcontext().prec = 2\n>>> decimal.Decimal('1.00') / decimal.Decimal('3.00')\nDecimal('0.33')\n>>> from fractions import Fraction\n>>> f = Fraction(2, 3)\n>>> f + 1\nFraction(5, 3)\n>>> f + Fraction(1, 2)\nFraction(7, 6)\n\n# Fractions: numerator+denominator",
    "1.1666666666666665\n>>> import decimal\n>>> d = decimal.Decimal('3.141')\n>>> d + 1\nDecimal('4.141')\n\n# Decimals: fixed precision\n\n>>> decimal.getcontext().prec = 2\n>>> decimal.Decimal('1.00') / decimal.Decimal('3.00')\nDecimal('0.33')\n>>> from fractions import Fraction\n>>> f = Fraction(2, 3)\n>>> f + 1\nFraction(5, 3)\n>>> f + Fraction(1, 2)\nFraction(7, 6)\n\n# Fractions: numerator+denominator\n\nPython also comes with Booleans (with predefined True and False objects that are essentially just the integers 1 and 0 with custom display logic), and it has long supported\na special placeholder object called None commonly used to initialize names and objects:\n>>> 1 > 2, 1 < 2\n(False, True)\n>>> bool('spam')\nTrue\n\n# Booleans\n\n>>> X = None\n# None placeholder\n>>> print(X)\nNone\n>>> L = [None] * 100\n# Initialize a list of 100 Nones\n>>> L\n[None, None, None, None, None, None, None, None, None, None, None, None,\nNone, None, None, None, None, None, None, None, ...a list of 100 Nones...]",
    "# Booleans\n\n>>> X = None\n# None placeholder\n>>> print(X)\nNone\n>>> L = [None] * 100\n# Initialize a list of 100 Nones\n>>> L\n[None, None, None, None, None, None, None, None, None, None, None, None,\nNone, None, None, None, None, None, None, None, ...a list of 100 Nones...]\n\nHow to Break Your Code’s Flexibility\nI’ll have more to say about all of Python’s object types later, but one merits special\ntreatment here. The type object, returned by the type built-in function, is an object that\ngives the type of another object; its result differs slightly in 3.0, because types have\nmerged with classes completely (something we’ll explore in the context of “new-style”\nclasses in Part VI). Assuming L is still the list of the prior section:\n# In Python 2.6:\n>>> type(L)\n<type 'list'>\n>>> type(type(L))\n<type 'type'>\n\n# Types: type of L is list type object\n# Even types are objects\n\n# In Python 3.0:\n>>> type(L)\n<class 'list'>\n\n100 | Chapter 4: Introducing Python Object Types",
    "# Types: type of L is list type object\n# Even types are objects\n\n# In Python 3.0:\n>>> type(L)\n<class 'list'>\n\n100 | Chapter 4: Introducing Python Object Types\n\n# 3.0: types are classes, and vice versa\n\n\f>>> type(type(L))\n<class 'type'>\n\n# See Chapter 31 for more on class types\n\nBesides allowing you to explore your objects interactively, the practical application of\nthis is that it allows code to check the types of the objects it processes. In fact, there are\nat least three ways to do so in a Python script:\n>>> if type(L) == type([]):\nprint('yes')\n\n# Type testing, if you must...\n\nyes\n>>> if type(L) == list:\nprint('yes')\n\n# Using the type name\n\nyes\n>>> if isinstance(L, list):\nprint('yes')\n\n# Object-oriented tests\n\nyes",
    "Now that I’ve shown you all these ways to do type testing, however, I am required by\nlaw to tell you that doing so is almost always the wrong thing to do in a Python program\n(and often a sign of an ex-C programmer first starting to use Python!). The reason why\nwon’t become completely clear until later in the book, when we start writing larger\ncode units such as functions, but it’s a (perhaps the) core Python concept. By checking\nfor specific types in your code, you effectively break its flexibility—you limit it to\nworking on just one type. Without such tests, your code may be able to work on a\nwhole range of types.\nThis is related to the idea of polymorphism mentioned earlier, and it stems from\nPython’s lack of type declarations. As you’ll learn, in Python, we code to object interfaces (operations supported), not to types. Not caring about specific types means that",
    "working on just one type. Without such tests, your code may be able to work on a\nwhole range of types.\nThis is related to the idea of polymorphism mentioned earlier, and it stems from\nPython’s lack of type declarations. As you’ll learn, in Python, we code to object interfaces (operations supported), not to types. Not caring about specific types means that\ncode is automatically applicable to many of them—any object with a compatible interface will work, regardless of its specific type. Although type checking is supported—\nand even required, in some rare cases—you’ll see that it’s not usually the “Pythonic”\nway of thinking. In fact, you’ll find that polymorphism is probably the key idea behind\nusing Python well.",
    "User-Defined Classes\nWe’ll study object-oriented programming in Python—an optional but powerful feature\nof the language that cuts development time by supporting programming by customization—in depth later in this book. In abstract terms, though, classes define new types\nof objects that extend the core set, so they merit a passing glance here. Say, for example,\nthat you wish to have a type of object that models employees. Although there is no such\nspecific core type in Python, the following user-defined class might fit the bill:\n>>> class Worker:\ndef __init__(self, name, pay):\nself.name = name\n\n# Initialize when created\n# self is the new object\n\nOther Core Types | 101\n\n\fself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\n\n# Split string on blanks\n# Update pay in-place",
    "# Initialize when created\n# self is the new object\n\nOther Core Types | 101\n\n\fself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\n\n# Split string on blanks\n# Update pay in-place\n\nThis class defines a new kind of object that will have name and pay attributes (sometimes\ncalled state information), as well as two bits of behavior coded as functions (normally\ncalled methods). Calling the class like a function generates instances of our new type,\nand the class’s methods automatically receive the instance being processed by a given\nmethod call (in the self argument):\n>>> bob = Worker('Bob Smith', 50000)\n>>> sue = Worker('Sue Jones', 60000)\n>>> bob.lastName()\n'Smith'\n>>> sue.lastName()\n'Jones'\n>>> sue.giveRaise(.10)\n>>> sue.pay\n66000.0\n\n# Make two instances\n# Each has name and pay attrs\n# Call method: bob is self\n# sue is the self subject\n# Updates sue's pay",
    "The implied “self” object is why we call this an object-oriented model: there is always\nan implied subject in functions within a class. In a sense, though, the class-based type\nsimply builds on and uses core types—a user-defined Worker object here, for example,\nis just a collection of a string and a number (name and pay, respectively), plus functions\nfor processing those two built-in objects.\nThe larger story of classes is that their inheritance mechanism supports software hierarchies that lend themselves to customization by extension. We extend software by\nwriting new classes, not by changing what already works. You should also know that\nclasses are an optional feature of Python, and simpler built-in types such as lists and\ndictionaries are often better tools than user-coded classes. This is all well beyond the\nbounds of our introductory object-type tutorial, though, so consider this just a preview;",
    "writing new classes, not by changing what already works. You should also know that\nclasses are an optional feature of Python, and simpler built-in types such as lists and\ndictionaries are often better tools than user-coded classes. This is all well beyond the\nbounds of our introductory object-type tutorial, though, so consider this just a preview;\nfor full disclosure on user-defined types coded with classes, you’ll have to read on to\nPart VI.",
    "And Everything Else\nAs mentioned earlier, everything you can process in a Python script is a type of object,\nso our object type tour is necessarily incomplete. However, even though everything in\nPython is an “object,” only those types of objects we’ve met so far are considered part\nof Python’s core type set. Other types in Python either are objects related to program\nexecution (like functions, modules, classes, and compiled code), which we will study\nlater, or are implemented by imported module functions, not language syntax. The\nlatter of these also tend to have application-specific roles—text patterns, database interfaces, network connections, and so on.\n\n102 | Chapter 4: Introducing Python Object Types",
    "102 | Chapter 4: Introducing Python Object Types\n\n\fMoreover, keep in mind that the objects we’ve met here are objects, but not necessarily\nobject-oriented—a concept that usually requires inheritance and the Python class\nstatement, which we’ll meet again later in this book. Still, Python’s core objects are the\nworkhorses of almost every Python script you’re likely to meet, and they usually are\nthe basis of larger noncore types.",
    "Chapter Summary\nAnd that’s a wrap for our concise data type tour. This chapter has offered a brief introduction to Python’s core object types and the sorts of operations we can apply to\nthem. We’ve studied generic operations that work on many object types (sequence\noperations such as indexing and slicing, for example), as well as type-specific operations\navailable as method calls (for instance, string splits and list appends). We’ve also defined some key terms, such as immutability, sequences, and polymorphism.\nAlong the way, we’ve seen that Python’s core object types are more flexible and powerful than what is available in lower-level languages such as C. For instance, Python’s\nlists and dictionaries obviate most of the work you do to support collections and\nsearching in lower-level languages. Lists are ordered collections of other objects, and",
    "Along the way, we’ve seen that Python’s core object types are more flexible and powerful than what is available in lower-level languages such as C. For instance, Python’s\nlists and dictionaries obviate most of the work you do to support collections and\nsearching in lower-level languages. Lists are ordered collections of other objects, and\ndictionaries are collections of other objects that are indexed by key instead of by position. Both dictionaries and lists may be nested, can grow and shrink on demand, and\nmay contain objects of any type. Moreover, their space is automatically cleaned up as\nyou go.\nI’ve skipped most of the details here in order to provide a quick tour, so you shouldn’t\nexpect all of this chapter to have made sense yet. In the next few chapters, we’ll start\nto dig deeper, filling in details of Python’s core object types that were omitted here so\nyou can gain a more complete understanding. We’ll start off in the next chapter with",
    "you go.\nI’ve skipped most of the details here in order to provide a quick tour, so you shouldn’t\nexpect all of this chapter to have made sense yet. In the next few chapters, we’ll start\nto dig deeper, filling in details of Python’s core object types that were omitted here so\nyou can gain a more complete understanding. We’ll start off in the next chapter with\nan in-depth look at Python numbers. First, though, another quiz to review.",
    "Test Your Knowledge: Quiz\nWe’ll explore the concepts introduced in this chapter in more detail in upcoming\nchapters, so we’ll just cover the big ideas here:\n1. Name four of Python’s core data types.\n2. Why are they called “core” data types?\n3. What does “immutable” mean, and which three of Python’s core types are considered immutable?\n4. What does “sequence” mean, and which three types fall into that category?\n\nTest Your Knowledge: Quiz | 103\n\n\f5. What does “mapping” mean, and which core type is a mapping?\n6. What is “polymorphism,” and why should you care?",
    "Test Your Knowledge: Answers\n1. Numbers, strings, lists, dictionaries, tuples, files, and sets are generally considered\nto be the core object (data) types. Types, None, and Booleans are sometimes classified this way as well. There are multiple number types (integer, floating point,\ncomplex, fraction, and decimal) and multiple string types (simple strings and Unicode strings in Python 2.X, and text strings and byte strings in Python 3.X).\n2. They are known as “core” types because they are part of the Python language itself\nand are always available; to create other objects, you generally must call functions\nin imported modules. Most of the core types have specific syntax for generating\nthe objects: 'spam', for example, is an expression that makes a string and determines the set of operations that can be applied to it. Because of this, core types are\nhardwired into Python’s syntax. In contrast, you must call the built-in open function\nto create a file object.",
    "in imported modules. Most of the core types have specific syntax for generating\nthe objects: 'spam', for example, is an expression that makes a string and determines the set of operations that can be applied to it. Because of this, core types are\nhardwired into Python’s syntax. In contrast, you must call the built-in open function\nto create a file object.\n3. An “immutable” object is an object that cannot be changed after it is created.\nNumbers, strings, and tuples in Python fall into this category. While you cannot\nchange an immutable object in-place, you can always make a new one by running\nan expression.\n4. A “sequence” is a positionally ordered collection of objects. Strings, lists, and tuples\nare all sequences in Python. They share common sequence operations, such as\nindexing, concatenation, and slicing, but also have type-specific method calls.",
    "change an immutable object in-place, you can always make a new one by running\nan expression.\n4. A “sequence” is a positionally ordered collection of objects. Strings, lists, and tuples\nare all sequences in Python. They share common sequence operations, such as\nindexing, concatenation, and slicing, but also have type-specific method calls.\n5. The term “mapping” denotes an object that maps keys to associated values. Python’s dictionary is the only mapping type in the core type set. Mappings do not\nmaintain any left-to-right positional ordering; they support access to data stored\nby key, plus type-specific method calls.\n6. “Polymorphism” means that the meaning of an operation (like a +) depends on the\nobjects being operated on. This turns out to be a key idea (perhaps the key idea)\nbehind using Python well—not constraining code to specific types makes that code\nautomatically applicable to many types.",
    "104 | Chapter 4: Introducing Python Object Types\n\n\fCHAPTER 5\n\nNumeric Types\n\nThis chapter begins our in-depth tour of the Python language. In Python, data takes\nthe form of objects—either built-in objects that Python provides, or objects we create\nusing Python tools and other languages such as C. In fact, objects are the basis of every\nPython program you will ever write. Because they are the most fundamental notion in\nPython programming, objects are also our first focus in this book.\nIn the preceding chapter, we took a quick pass over Python’s core object types. Although essential terms were introduced in that chapter, we avoided covering too many\nspecifics in the interest of space. Here, we’ll begin a more careful second look at data\ntype concepts, to fill in details we glossed over earlier. Let’s get started by exploring\nour first data type category: Python’s numeric types.",
    "Numeric Type Basics\nMost of Python’s number types are fairly typical and will probably seem familiar if\nyou’ve used almost any other programming language in the past. They can be used to\nkeep track of your bank balance, the distance to Mars, the number of visitors to your\nwebsite, and just about any other numeric quantity.\nIn Python, numbers are not really a single object type, but a category of similar types.\nPython supports the usual numeric types (integers and floating points), as well as literals\nfor creating numbers and expressions for processing them. In addition, Python provides\nmore advanced numeric programming support and objects for more advanced work.\nA complete inventory of Python’s numeric toolbox includes:\n• Integers and floating-point numbers\n• Complex numbers\n• Fixed-precision decimal numbers\n\n105",
    "105\n\n\f• Rational fraction numbers\n• Sets\n• Booleans\n• Unlimited integer precision\n• A variety of numeric built-ins and modules\nThis chapter starts with basic numbers and fundamentals, then moves on to explore\nthe other tools in this list. Before we jump into code, though, the next few sections get\nus started with a brief overview of how we write and process numbers in our scripts.\n\nNumeric Literals\nAmong its basic types, Python provides integers (positive and negative whole numbers)\nand floating-point numbers (numbers with a fractional part, sometimes called “floats”\nfor economy). Python also allows us to write integers using hexadecimal, octal, and\nbinary literals; offers a complex number type; and allows integers to have unlimited\nprecision (they can grow to have as many digits as your memory space allows). Table 5-1 shows what Python’s numeric types look like when written out in a program,\nas literals.\nTable 5-1. Basic numeric literals\nLiteral\n\nInterpretation",
    "Interpretation\n\n1234, −24, 0, 99999999999999\n\nIntegers (unlimited size)\n\n1.23, 1., 3.14e-10, 4E210, 4.0e+210\n\nFloating-point numbers\n\n0177, 0x9ff, 0b101010\n\nOctal, hex, and binary literals in 2.6\n\n0o177, 0x9ff, 0b101010\n\nOctal, hex, and binary literals in 3.0\n\n3+4j, 3.0+4.0j, 3J\n\nComplex number literals",
    "1234, −24, 0, 99999999999999\n\nIntegers (unlimited size)\n\n1.23, 1., 3.14e-10, 4E210, 4.0e+210\n\nFloating-point numbers\n\n0177, 0x9ff, 0b101010\n\nOctal, hex, and binary literals in 2.6\n\n0o177, 0x9ff, 0b101010\n\nOctal, hex, and binary literals in 3.0\n\n3+4j, 3.0+4.0j, 3J\n\nComplex number literals\n\nIn general, Python’s numeric type literals are straightforward to write, but a few coding\nconcepts are worth highlighting here:\nInteger and floating-point literals\nIntegers are written as strings of decimal digits. Floating-point numbers have a\ndecimal point and/or an optional signed exponent introduced by an e or E and\nfollowed by an optional sign. If you write a number with a decimal point or exponent, Python makes it a floating-point object and uses floating-point (not integer)\nmath when the object is used in an expression. Floating-point numbers are implemented as C “doubles,” and therefore get as much precision as the C compiler used\nto build the Python interpreter gives to doubles.",
    "106 | Chapter 5: Numeric Types",
    "Integers in Python 2.6: normal and long\nIn Python 2.6 there are two integer types, normal (32 bits) and long (unlimited\nprecision), and an integer may end in an l or L to force it to become a long integer.\nBecause integers are automatically converted to long integers when their values\noverflow 32 bits, you never need to type the letter L yourself—Python automatically\nconverts up to long integer when extra precision is needed.\nIntegers in Python 3.0: a single type\nIn Python 3.0, the normal and long integer types have been merged—there is only\ninteger, which automatically supports the unlimited precision of Python 2.6’s separate long integer type. Because of this, integers can no longer be coded with a\ntrailing l or L, and integers never print with this character either. Apart from this,\nmost programs are unaffected by this change, unless they do type testing that\nchecks for 2.6 long integers.\nHexadecimal, octal, and binary literals",
    "integer, which automatically supports the unlimited precision of Python 2.6’s separate long integer type. Because of this, integers can no longer be coded with a\ntrailing l or L, and integers never print with this character either. Apart from this,\nmost programs are unaffected by this change, unless they do type testing that\nchecks for 2.6 long integers.\nHexadecimal, octal, and binary literals\nIntegers may be coded in decimal (base 10), hexadecimal (base 16), octal (base 8),\nor binary (base 2). Hexadecimals start with a leading 0x or 0X, followed by a string\nof hexadecimal digits (0–9 and A–F). Hex digits may be coded in lower- or uppercase. Octal literals start with a leading 0o or 0O (zero and lower- or uppercase letter\n“o”), followed by a string of digits (0–7). In 2.6 and earlier, octal literals can also\nbe coded with just a leading 0, but not in 3.0 (this original octal form is too easily\nconfused with decimal, and is replaced by the new 0o format). Binary literals, new",
    "“o”), followed by a string of digits (0–7). In 2.6 and earlier, octal literals can also\nbe coded with just a leading 0, but not in 3.0 (this original octal form is too easily\nconfused with decimal, and is replaced by the new 0o format). Binary literals, new\nin 2.6 and 3.0, begin with a leading 0b or 0B, followed by binary digits (0–1).\nNote that all of these literals produce integer objects in program code; they are just\nalternative syntaxes for specifying values. The built-in calls hex(I), oct(I), and\nbin(I) convert an integer to its representation string in these three bases, and\nint(str, base) converts a runtime string to an integer per a given base.\nComplex numbers\nPython complex literals are written as realpart+imaginarypart, where the\nimaginarypart is terminated with a j or J. The realpart is technically optional, so\nthe imaginarypart may appear on its own. Internally, complex numbers are implemented as pairs of floating-point numbers, but all numeric operations perform",
    "Complex numbers\nPython complex literals are written as realpart+imaginarypart, where the\nimaginarypart is terminated with a j or J. The realpart is technically optional, so\nthe imaginarypart may appear on its own. Internally, complex numbers are implemented as pairs of floating-point numbers, but all numeric operations perform\ncomplex math when applied to complex numbers. Complex numbers may also be\ncreated with the complex(real, imag) built-in call.\nCoding other numeric types\nAs we’ll see later in this chapter, there are additional, more advanced number types\nnot included in Table 5-1. Some of these are created by calling functions in imported modules (e.g., decimals and fractions), and others have literal syntax all\ntheir own (e.g., sets).",
    "Numeric Type Basics | 107",
    "Built-in Numeric Tools\nBesides the built-in number literals shown in Table 5-1, Python provides a set of tools\nfor processing number objects:\nExpression operators\n+, -, *, /, >>, **, &, etc.\nBuilt-in mathematical functions\npow, abs, round, int, hex, bin, etc.\nUtility modules\nrandom, math, etc.\nWe’ll meet all of these as we go along.\nAlthough numbers are primarily processed with expressions, built-ins, and modules,\nthey also have a handful of type-specific methods today, which we’ll meet in this chapter\nas well. Floating-point numbers, for example, have an as_integer_ratio method that\nis useful for the fraction number type, and an is_integer method to test if the number\nis an integer. Integers have various attributes, including a new bit_length method in\nthe upcoming Python 3.1 release that gives the number of bits necessary to represent\nthe object’s value. Moreover, as part collection and part number, sets also support both\nmethods and expressions.",
    "is useful for the fraction number type, and an is_integer method to test if the number\nis an integer. Integers have various attributes, including a new bit_length method in\nthe upcoming Python 3.1 release that gives the number of bits necessary to represent\nthe object’s value. Moreover, as part collection and part number, sets also support both\nmethods and expressions.\nSince expressions are the most essential tool for most number types, though, let’s turn\nto them next.",
    "Python Expression Operators\nPerhaps the most fundamental tool that processes numbers is the expression: a combination of numbers (or other objects) and operators that computes a value when executed by Python. In Python, expressions are written using the usual mathematical\nnotation and operator symbols. For instance, to add two numbers X and Y you would\nsay X + Y, which tells Python to apply the + operator to the values named by X and Y.\nThe result of the expression is the sum of X and Y, another number object.\nTable 5-2 lists all the operator expressions available in Python. Many are\nself-explanatory; for instance, the usual mathematical operators (+, −, *, /, and so on)\nare supported. A few will be familiar if you’ve used other languages in the past: % computes a division remainder, << performs a bitwise left-shift, & computes a bitwise AND\nresult, and so on. Others are more Python-specific, and not all are numeric in nature:",
    "self-explanatory; for instance, the usual mathematical operators (+, −, *, /, and so on)\nare supported. A few will be familiar if you’ve used other languages in the past: % computes a division remainder, << performs a bitwise left-shift, & computes a bitwise AND\nresult, and so on. Others are more Python-specific, and not all are numeric in nature:\nfor example, the is operator tests object identity (i.e., address in memory, a strict form\nof equality), and lambda creates unnamed functions.",
    "108 | Chapter 5: Numeric Types\n\n\fTable 5-2. Python expression operators and precedence\nOperators\n\nDescription\n\nyield x\n\nGenerator function send protocol\n\nlambda args: expression\n\nAnonymous function generation\n\nx if y else z\n\nTernary selection (x is evaluated only if y is true)\n\nx or y\n\nLogical OR (y is evaluated only if x is false)\n\nx and y\n\nLogical AND (y is evaluated only if x is true)\n\nnot x\n\nLogical negation\n\nx in y, x not in y\n\nMembership (iterables, sets)\n\nx is y, x is not y\n\nObject identity tests\n\nx < y, x <= y, x > y, x >= y\n\nMagnitude comparison, set subset and superset;\n\nx == y, x != y\n\nValue equality operators\n\nx | y\n\nBitwise OR, set union\n\nx ^ y\n\nBitwise XOR, set symmetric difference\n\nx & y\n\nBitwise AND, set intersection\n\nx << y, x >> y\n\nShift x left or right by y bits\n\nx + y\n\nAddition, concatenation;\n\nx – y\n\nSubtraction, set difference\n\nx * y\n\nMultiplication, repetition;\n\nx % y\n\nRemainder, format;\n\nx / y, x // y\n\nDivision: true and floor\n\n−x, +x\n\nNegation, identity\n\n˜x",
    "Value equality operators\n\nx | y\n\nBitwise OR, set union\n\nx ^ y\n\nBitwise XOR, set symmetric difference\n\nx & y\n\nBitwise AND, set intersection\n\nx << y, x >> y\n\nShift x left or right by y bits\n\nx + y\n\nAddition, concatenation;\n\nx – y\n\nSubtraction, set difference\n\nx * y\n\nMultiplication, repetition;\n\nx % y\n\nRemainder, format;\n\nx / y, x // y\n\nDivision: true and floor\n\n−x, +x\n\nNegation, identity\n\n˜x\n\nBitwise NOT (inversion)\n\nx ** y\n\nPower (exponentiation)\n\nx[i]\n\nIndexing (sequence, mapping, others)\n\nx[i:j:k]\n\nSlicing\n\nx(...)\n\nCall (function, method, class, other callable)\n\nx.attr\n\nAttribute reference\n\n(...)\n\nTuple, expression, generator expression\n\n[...]\n\nList, list comprehension\n\n{...}\n\nDictionary, set, set and dictionary comprehensions\n\nNumeric Type Basics | 109",
    "Since this book addresses both Python 2.6 and 3.0, here are some notes about version\ndifferences and recent additions related to the operators in Table 5-2:\n• In Python 2.6, value inequality can be written as either X != Y or X <> Y. In Python\n3.0, the latter of these options is removed because it is redundant. In either version,\nbest practice is to use X != Y for all value inequality tests.\n• In Python 2.6, a backquotes expression `X` works the same as repr(X) and converts\nobjects to display strings. Due to its obscurity, this expression is removed in Python\n3.0; use the more readable str and repr built-in functions, described in “Numeric\nDisplay Formats” on page 115.\n• The X // Y floor division expression always truncates fractional remainders in both\nPython 2.6 and 3.0. The X / Y expression performs true division in 3.0 (retaining\nremainders) and classic division in 2.6 (truncating for integers). See “Division:\nClassic, Floor, and True” on page 117.",
    "Display Formats” on page 115.\n• The X // Y floor division expression always truncates fractional remainders in both\nPython 2.6 and 3.0. The X / Y expression performs true division in 3.0 (retaining\nremainders) and classic division in 2.6 (truncating for integers). See “Division:\nClassic, Floor, and True” on page 117.\n• The syntax [...] is used for both list literals and list comprehension expressions.\nThe latter of these performs an implied loop and collects expression results in a\nnew list. See Chapters 4, 14, and 20 for examples.\n• The syntax (...) is used for tuples and expressions, as well as generator\nexpressions—a form of list comprehension that produces results on demand, instead of building a result list. See Chapters 4 and 20 for examples. The parentheses\nmay sometimes be omitted in all three constructs.\n• The syntax {...} is used for dictionary literals, and in Python 3.0 for set literals\nand both dictionary and set comprehensions. See the set coverage in this chapter",
    "expressions—a form of list comprehension that produces results on demand, instead of building a result list. See Chapters 4 and 20 for examples. The parentheses\nmay sometimes be omitted in all three constructs.\n• The syntax {...} is used for dictionary literals, and in Python 3.0 for set literals\nand both dictionary and set comprehensions. See the set coverage in this chapter\nand Chapters 4, 8, 14, and 20 for examples.\n• The yield and ternary if/else selection expressions are available in Python 2.5 and\nlater. The former returns send(...) arguments in generators; the latter is shorthand\nfor a multiline if statement. yield requires parentheses if not alone on the right\nside of an assignment statement.\n• Comparison operators may be chained: X < Y < Z produces the same result as\nX < Y and Y < X. See “Comparisons: Normal and Chained” on page 116 for details.\n• In recent Pythons, the slice expression X[I:J:K] is equivalent to indexing with a\nslice object: X[slice(I, J, K)].",
    "for a multiline if statement. yield requires parentheses if not alone on the right\nside of an assignment statement.\n• Comparison operators may be chained: X < Y < Z produces the same result as\nX < Y and Y < X. See “Comparisons: Normal and Chained” on page 116 for details.\n• In recent Pythons, the slice expression X[I:J:K] is equivalent to indexing with a\nslice object: X[slice(I, J, K)].\n• In Python 2.X, magnitude comparisons of mixed types—converting numbers to a\ncommon type, and ordering other mixed types according to the type name—are\nallowed. In Python 3.0, nonnumeric mixed-type magnitude comparisons are not\nallowed and raise exceptions; this includes sorts by proxy.\n• Magnitude comparisons for dictionaries are also no longer supported in Python\n3.0 (though equality tests are); comparing sorted(dict.items()) is one possible\nreplacement.\nWe’ll see most of the operators in Table 5-2 in action later; first, though, we need to",
    "allowed. In Python 3.0, nonnumeric mixed-type magnitude comparisons are not\nallowed and raise exceptions; this includes sorts by proxy.\n• Magnitude comparisons for dictionaries are also no longer supported in Python\n3.0 (though equality tests are); comparing sorted(dict.items()) is one possible\nreplacement.\nWe’ll see most of the operators in Table 5-2 in action later; first, though, we need to\ntake a quick look at the ways these operators may be combined in expressions.\n110 | Chapter 5: Numeric Types",
    "Mixed operators follow operator precedence\nAs in most languages, in Python, more complex expressions are coded by stringing\ntogether the operator expressions in Table 5-2. For instance, the sum of two multiplications might be written as a mix of variables and operators:\nA * B + C * D",
    "So, how does Python know which operation to perform first? The answer to this question lies in operator precedence. When you write an expression with more than one\noperator, Python groups its parts according to what are called precedence rules, and\nthis grouping determines the order in which the expression’s parts are computed.\nTable 5-2 is ordered by operator precedence:\n• Operators lower in the table have higher precedence, and so bind more tightly in\nmixed expressions.\n• Operators in the same row in Table 5-2 generally group from left to right when\ncombined (except for exponentiation, which groups right to left, and comparisons,\nwhich chain left to right).\nFor example, if you write X + Y * Z, Python evaluates the multiplication first\n(Y * Z), then adds that result to X because * has higher precedence (is lower in the\ntable) than +. Similarly, in this section’s original example, both multiplications (A * B\nand C * D) will happen before their results are added.",
    "Parentheses group subexpressions\nYou can forget about precedence completely if you’re careful to group parts of expressions with parentheses. When you enclose subexpressions in parentheses, you override\nPython’s precedence rules; Python always evaluates expressions in parentheses first\nbefore using their results in the enclosing expressions.\nFor instance, instead of coding X + Y * Z, you could write one of the following to force\nPython to evaluate the expression in the desired order:\n(X + Y) * Z\nX + (Y * Z)\n\nIn the first case, + is applied to X and Y first, because this subexpression is wrapped in\nparentheses. In the second case, the * is performed first (just as if there were no parentheses at all). Generally speaking, adding parentheses in large expressions is a good\nidea—it not only forces the evaluation order you want, but also aids readability.",
    "In the first case, + is applied to X and Y first, because this subexpression is wrapped in\nparentheses. In the second case, the * is performed first (just as if there were no parentheses at all). Generally speaking, adding parentheses in large expressions is a good\nidea—it not only forces the evaluation order you want, but also aids readability.\n\nMixed types are converted up\nBesides mixing operators in expressions, you can also mix numeric types. For instance,\nyou can add an integer to a floating-point number:\n40 + 3.14\n\nNumeric Type Basics | 111",
    "But this leads to another question: what type is the result—integer or floating-point?\nThe answer is simple, especially if you’ve used almost any other language before: in\nmixed-type numeric expressions, Python first converts operands up to the type of the\nmost complicated operand, and then performs the math on same-type operands. This\nbehavior is similar to type conversions in the C language.\nPython ranks the complexity of numeric types like so: integers are simpler than floatingpoint numbers, which are simpler than complex numbers. So, when an integer is mixed\nwith a floating point, as in the preceding example, the integer is converted up to a\nfloating-point value first, and floating-point math yields the floating-point result. Similarly, any mixed-type expression where one operand is a complex number results in\nthe other operand being converted up to a complex number, and the expression yields\na complex result. (In Python 2.6, normal integers are also converted to long integers",
    "floating-point value first, and floating-point math yields the floating-point result. Similarly, any mixed-type expression where one operand is a complex number results in\nthe other operand being converted up to a complex number, and the expression yields\na complex result. (In Python 2.6, normal integers are also converted to long integers\nwhenever their values are too large to fit in a normal integer; in 3.0, integers subsume\nlongs entirely.)\nYou can force the issue by calling built-in functions to convert types manually:\n>>> int(3.1415)\n3\n>>> float(3)\n3.0",
    "# Truncates float to integer\n# Converts integer to float\n\nHowever, you won’t usually need to do this: because Python automatically converts\nup to the more complex type within an expression, the results are normally what you\nwant.\nAlso, keep in mind that all these mixed-type conversions apply only when mixing\nnumeric types (e.g., an integer and a floating-point) in an expression, including those\nusing numeric and comparison operators. In general, Python does not convert across\nany other type boundaries automatically. Adding a string to an integer, for example,\nresults in an error, unless you manually convert one or the other; watch for an example\nwhen we meet strings in Chapter 7.\nIn Python 2.6, nonnumeric mixed types can be compared, but no conversions are performed (mixed types compare according to a fixed but\narbitrary rule). In 3.0, nonnumeric mixed-type comparisons are not allowed and raise exceptions.",
    "Preview: Operator overloading and polymorphism\nAlthough we’re focusing on built-in numbers right now, all Python operators may be\noverloaded (i.e., implemented) by Python classes and C extension types to work on\nobjects you create. For instance, you’ll see later that objects coded with classes may be\nadded or concatenated with + expressions, indexed with [i] expressions, and so on.\nFurthermore, Python itself automatically overloads some operators, such that they\nperform different actions depending on the type of built-in objects being processed.\n112 | Chapter 5: Numeric Types",
    "For example, the + operator performs addition when applied to numbers but performs\nconcatenation when applied to sequence objects such as strings and lists. In fact, + can\nmean anything at all when applied to objects you define with classes.\nAs we saw in the prior chapter, this property is usually called polymorphism—a term\nindicating that the meaning of an operation depends on the type of the objects being\noperated on. We’ll revisit this concept when we explore functions in Chapter 16, because it becomes a much more obvious feature in that context.\n\nNumbers in Action\nOn to the code! Probably the best way to understand numeric objects and expressions\nis to see them in action, so let’s start up the interactive command line and try some\nbasic but illustrative operations (see Chapter 3 for pointers if you need help starting an\ninteractive session).",
    "Variables and Basic Expressions\nFirst of all, let’s exercise some basic math. In the following interaction, we first assign\ntwo variables (a and b) to integers so we can use them later in a larger expression.\nVariables are simply names—created by you or Python—that are used to keep track of\ninformation in your program. We’ll say more about this in the next chapter, but in\nPython:\n• Variables are created when they are first assigned values.\n• Variables are replaced with their values when used in expressions.\n• Variables must be assigned before they can be used in expressions.\n• Variables refer to objects and are never declared ahead of time.\nIn other words, these assignments cause the variables a and b to spring into existence\nautomatically:\n% python\n>>> a = 3\n>>> b = 4\n\n# Name created",
    "# Name created\n\nI’ve also used a comment here. Recall that in Python code, text after a # mark and\ncontinuing to the end of the line is considered to be a comment and is ignored. Comments are a way to write human-readable documentation for your code. Because code\nyou type interactively is temporary, you won’t normally write comments in this context,\nbut I’ve added them to some of this book’s examples to help explain the code.* In the\nnext part of the book, we’ll meet a related feature—documentation strings—that attaches the text of your comments to objects.\n* If you’re working along, you don’t need to type any of the comment text from the # through to the end of\nthe line; comments are simply ignored by Python and not required parts of the statements we’re running.\n\nNumbers in Action | 113",
    "Numbers in Action | 113\n\n\fNow, let’s use our new integer objects in some expressions. At this point, the values of\na and b are still 3 and 4, respectively. Variables like these are replaced with their values\nwhenever they’re used inside an expression, and the expression results are echoed back\nimmediately when working interactively:\n>>> a + 1, a – 1\n(4, 2)\n>>> b * 3, b / 2\n(12, 2.0)\n>>> a % 2, b ** 2\n(1, 16)\n>>> 2 + 4.0, 2.0 ** b\n(6.0, 16.0)\n\n# Addition (3 + 1), subtraction (3 - 1)\n# Multiplication (4 * 3), division (4 / 2)\n# Modulus (remainder), power (4 ** 2)\n# Mixed-type conversions",
    "# Addition (3 + 1), subtraction (3 - 1)\n# Multiplication (4 * 3), division (4 / 2)\n# Modulus (remainder), power (4 ** 2)\n# Mixed-type conversions\n\nTechnically, the results being echoed back here are tuples of two values because the\nlines typed at the prompt contain two expressions separated by commas; that’s why\nthe results are displayed in parentheses (more on tuples later). Note that the expressions\nwork because the variables a and b within them have been assigned values. If you use\na different variable that has never been assigned, Python reports an error rather than\nfilling in some default value:\n>>> c * 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nNameError: name 'c' is not defined",
    "You don’t need to predeclare variables in Python, but they must have been assigned at\nleast once before you can use them. In practice, this means you have to initialize counters to zero before you can add to them, initialize lists to an empty list before you can\nappend to them, and so on.\nHere are two slightly larger expressions to illustrate operator grouping and more about\nconversions:\n>>> b / 2 + a\n5.0\n>>> print(b / (2.0 + a))\n0.8\n\n# Same as ((4 / 2) + 3)\n# Same as (4 / (2.0 + 3))",
    "In the first expression, there are no parentheses, so Python automatically groups the\ncomponents according to its precedence rules—because / is lower in Table 5-2 than\n+, it binds more tightly and so is evaluated first. The result is as if the expression had\nbeen organized with parentheses as shown in the comment to the right of the code.\nAlso, notice that all the numbers are integers in the first expression. Because of that,\nPython 2.6 performs integer division and addition and will give a result of 5, whereas\nPython 3.0 performs true division with remainders and gives the result shown. If you\nwant integer division in 3.0, code this as b // 2 + a (more on division in a moment).\nIn the second expression, parentheses are added around the + part to force Python to\nevaluate it first (i.e., before the /). We also made one of the operands floating-point by\nadding a decimal point: 2.0. Because of the mixed types, Python converts the integer\n114 | Chapter 5: Numeric Types",
    "referenced by a to a floating-point value (3.0) before performing the +. If all the numbers\nin this expression were integers, integer division (4 / 5) would yield the truncated\ninteger 0 in Python 2.6 but the floating-point 0.8 in Python 3.0 (again, stay tuned for\ndivision details).\n\nNumeric Display Formats\nNotice that we used a print operation in the last of the preceding examples. Without\nthe print, you’ll see something that may look a bit odd at first glance:\n>>> b / (2.0 + a)\n0.80000000000000004\n\n# Auto echo output: more digits\n\n>>> print(b / (2.0 + a))\n0.8\n\n# print rounds off digits",
    "# Auto echo output: more digits\n\n>>> print(b / (2.0 + a))\n0.8\n\n# print rounds off digits\n\nThe full story behind this odd result has to do with the limitations of floating-point\nhardware and its inability to exactly represent some values in a limited number of bits.\nBecause computer architecture is well beyond this book’s scope, though, we’ll finesse\nthis by saying that all of the digits in the first output are really there in your computer’s\nfloating-point hardware—it’s just that you’re not accustomed to seeing them. In fact,\nthis is really just a display issue—the interactive prompt’s automatic result echo shows\nmore digits than the print statement. If you don’t want to see all the digits, use print;\nas the sidebar “str and repr Display Formats” on page 116 will explain, you’ll get a\nuser-friendly display.\nNote, however, that not all values have so many digits to display:\n>>> 1 / 2.0\n0.5",
    "and that there are more ways to display the bits of a number inside your computer than\nusing print and automatic echoes:\n>>> num = 1 / 3.0\n>>> num\n0.33333333333333331\n>>> print(num)\n0.333333333333\n>>> '%e' % num\n'3.333333e-001'\n>>> '%4.2f' % num\n'0.33'\n>>> '{0:4.2f}'.format(num)\n'0.33'\n\n# Echoes\n# print rounds\n# String formatting expression\n# Alternative floating-point format\n# String formatting method (Python 2.6 and 3.0)\n\nThe last three of these expressions employ string formatting, a tool that allows for format flexibility, which we will explore in the upcoming chapter on strings (Chapter 7).\nIts results are strings that are typically printed to displays or reports.\n\nNumbers in Action | 115\n\n\fstr and repr Display Formats\nTechnically, the difference between default interactive echoes and print corresponds\nto the difference between the built-in repr and str functions:\n>>> num = 1 / 3\n>>> repr(num)\n'0.33333333333333331'\n>>> str(num)\n'0.333333333333'",
    "Numbers in Action | 115\n\n\fstr and repr Display Formats\nTechnically, the difference between default interactive echoes and print corresponds\nto the difference between the built-in repr and str functions:\n>>> num = 1 / 3\n>>> repr(num)\n'0.33333333333333331'\n>>> str(num)\n'0.333333333333'\n\n# Used by echoes: as-code form\n# Used by print: user-friendly form",
    "# Used by echoes: as-code form\n# Used by print: user-friendly form\n\nBoth of these convert arbitrary objects to their string representations: repr (and the\ndefault interactive echo) produces results that look as though they were code; str (and\nthe print operation) converts to a typically more user-friendly format if available. Some\nobjects have both—a str for general use, and a repr with extra details. This notion will\nresurface when we study both strings and operator overloading in classes, and you’ll\nfind more on these built-ins in general later in the book.\nBesides providing print strings for arbitrary objects, the str built-in is also the name of\nthe string data type and may be called with an encoding name to decode a Unicode\nstring from a byte string. We’ll study the latter advanced role in Chapter 36 of this book.",
    "Comparisons: Normal and Chained\nSo far, we’ve been dealing with standard numeric operations (addition and multiplication), but numbers can also be compared. Normal comparisons work for numbers\nexactly as you’d expect—they compare the relative magnitudes of their operands and\nreturn a Boolean result (which we would normally test in a larger statement):\n>>> 1 < 2\nTrue\n>>> 2.0 >= 1\nTrue\n>>> 2.0 == 2.0\nTrue\n>>> 2.0 != 2.0\nFalse\n\n# Less than\n# Greater than or equal: mixed-type 1 converted to 1.0\n# Equal value\n# Not equal value",
    "# Less than\n# Greater than or equal: mixed-type 1 converted to 1.0\n# Equal value\n# Not equal value\n\nNotice again how mixed types are allowed in numeric expressions (only); in the second\ntest here, Python compares values in terms of the more complex type, float.\nInterestingly, Python also allows us to chain multiple comparisons together to perform\nrange tests. Chained comparisons are a sort of shorthand for larger Boolean expressions. In short, Python lets us string together magnitude comparison tests to code\nchained comparisons such as range tests. The expression (A < B < C), for instance,\ntests whether B is between A and C; it is equivalent to the Boolean test (A < B and B <\nC) but is easier on the eyes (and the keyboard). For example, assume the following\nassignments:\n\n116 | Chapter 5: Numeric Types\n\n\f>>> X = 2\n>>> Y = 4\n>>> Z = 6",
    "116 | Chapter 5: Numeric Types\n\n\f>>> X = 2\n>>> Y = 4\n>>> Z = 6\n\nThe following two expressions have identical effects, but the first is shorter to type, and\nit may run slightly faster since Python needs to evaluate Y only once:\n>>> X < Y < Z\nTrue\n>>> X < Y and Y < Z\nTrue\n\n# Chained comparisons: range tests\n\nThe same equivalence holds for false results, and arbitrary chain lengths are allowed:\n>>> X < Y > Z\nFalse\n>>> X < Y and Y > Z\nFalse\n>>> 1 < 2 < 3.0 < 4\nTrue\n>>> 1 > 2 > 3.0 > 4\nFalse\n\nYou can use other comparisons in chained tests, but the resulting expressions can become nonintuitive unless you evaluate them the way Python does. The following, for\ninstance, is false just because 1 is not equal to 2:\n>>> 1 == 2 < 3\nFalse\n\n# Same as: 1 == 2 and 2 < 3\n# Not same as: False < 3 (which means 0 < 3, which is true)",
    "You can use other comparisons in chained tests, but the resulting expressions can become nonintuitive unless you evaluate them the way Python does. The following, for\ninstance, is false just because 1 is not equal to 2:\n>>> 1 == 2 < 3\nFalse\n\n# Same as: 1 == 2 and 2 < 3\n# Not same as: False < 3 (which means 0 < 3, which is true)\n\nPython does not compare the 1 == 2 False result to 3—this would technically mean\nthe same as 0 < 3, which would be True (as we’ll see later in this chapter, True and\nFalse are just customized 1 and 0).\n\nDivision: Classic, Floor, and True\nYou’ve seen how division works in the previous sections, so you should know that it\nbehaves slightly differently in Python 3.0 and 2.6. In fact, there are actually three flavors\nof division, and two different division operators, one of which changes in 3.0:\nX / Y",
    "Division: Classic, Floor, and True\nYou’ve seen how division works in the previous sections, so you should know that it\nbehaves slightly differently in Python 3.0 and 2.6. In fact, there are actually three flavors\nof division, and two different division operators, one of which changes in 3.0:\nX / Y\n\nClassic and true division. In Python 2.6 and earlier, this operator performs classic\ndivision, truncating results for integers and keeping remainders for floating-point\nnumbers. In Python 3.0, it performs true division, always keeping remainders regardless of types.\nX // Y\n\nFloor division. Added in Python 2.2 and available in both Python 2.6 and 3.0, this\noperator always truncates fractional remainders down to their floor, regardless of\ntypes.\n\nNumbers in Action | 117",
    "True division was added to address the fact that the results of the original classic division\nmodel are dependent on operand types, and so can be difficult to anticipate in a dynamically typed language like Python. Classic division was removed in 3.0 because of\nthis constraint—the / and // operators implement true and floor division in 3.0.\nIn sum:\n• In 3.0, the / now always performs true division, returning a float result that includes\nany remainder, regardless of operand types. The // performs floor division, which\ntruncates the remainder and returns an integer for integer operands or a float if any\noperand is a float.\n• In 2.6, the / does classic division, performing truncating integer division if both\noperands are integers and float division (keeping remainders) otherwise. The //\ndoes floor division and works as it does in 3.0, performing truncating division for\nintegers and floor division for floats.\nHere are the two operators at work in 3.0 and 2.6:\nC:\\misc> C:\\Python30\\python",
    "operand is a float.\n• In 2.6, the / does classic division, performing truncating integer division if both\noperands are integers and float division (keeping remainders) otherwise. The //\ndoes floor division and works as it does in 3.0, performing truncating division for\nintegers and floor division for floats.\nHere are the two operators at work in 3.0 and 2.6:\nC:\\misc> C:\\Python30\\python\n>>>\n>>> 10 / 4\n# Differs in 3.0: keeps remainder\n2.5\n>>> 10 // 4\n# Same in 3.0: truncates remainder\n2\n>>> 10 / 4.0\n# Same in 3.0: keeps remainder\n2.5\n>>> 10 // 4.0\n# Same in 3.0: truncates to floor\n2.0\nC:\\misc> C:\\Python26\\python\n>>>\n>>> 10 / 4\n2\n>>> 10 // 4\n2\n>>> 10 / 4.0\n2.5\n>>> 10 // 4.0\n2.0",
    "Notice that the data type of the result for // is still dependent on the operand types in\n3.0: if either is a float, the result is a float; otherwise, it is an integer. Although this may\nseem similar to the type-dependent behavior of / in 2.X that motivated its change in\n3.0, the type of the return value is much less critical than differences in the return value\nitself. Moreover, because // was provided in part as a backward-compatibility tool for\nprograms that rely on truncating integer division (and this is more common than you\nmight expect), it must return integers for integers.\n\n118 | Chapter 5: Numeric Types\n\n\fSupporting either Python\nAlthough / behavior differs in 2.6 and 3.0, you can still support both versions in your\ncode. If your programs depend on truncating integer division, use // in both 2.6 and\n3.0. If your programs require floating-point results with remainders for integers, use\nfloat to guarantee that one operand is a float around a / when run in 2.6:\nX = Y // Z",
    "Supporting either Python\nAlthough / behavior differs in 2.6 and 3.0, you can still support both versions in your\ncode. If your programs depend on truncating integer division, use // in both 2.6 and\n3.0. If your programs require floating-point results with remainders for integers, use\nfloat to guarantee that one operand is a float around a / when run in 2.6:\nX = Y // Z\n\n# Always truncates, always an int result for ints in 2.6 and 3.0\n\nX = Y / float(Z)\n\n# Guarantees float division with remainder in either 2.6 or 3.0\n\nAlternatively, you can enable 3.0 / division in 2.6 with a __future__ import, rather than\nforcing it with float conversions:\nC:\\misc> C:\\Python26\\python\n>>> from __future__ import division\n>>> 10 / 4\n2.5\n>>> 10 // 4\n2\n\n# Enable 3.0 \"/\" behavior",
    "X = Y / float(Z)\n\n# Guarantees float division with remainder in either 2.6 or 3.0\n\nAlternatively, you can enable 3.0 / division in 2.6 with a __future__ import, rather than\nforcing it with float conversions:\nC:\\misc> C:\\Python26\\python\n>>> from __future__ import division\n>>> 10 / 4\n2.5\n>>> 10 // 4\n2\n\n# Enable 3.0 \"/\" behavior\n\nFloor versus truncation\nOne subtlety: the // operator is generally referred to as truncating division, but it’s more\naccurate to refer to it as floor division—it truncates the result down to its floor, which\nmeans the closest whole number below the true result. The net effect is to round down,\nnot strictly truncate, and this matters for negatives. You can see the difference for\nyourself with the Python math module (modules must be imported before you can use\ntheir contents; more on this later):\n>>> import math\n>>> math.floor(2.5)\n2\n>>> math.floor(-2.5)\n-3\n>>> math.trunc(2.5)\n2\n>>> math.trunc(-2.5)\n-2",
    "When running division operators, you only really truncate for positive results, since\ntruncation is the same as floor; for negatives, it’s a floor result (really, they are both\nfloor, but floor is the same as truncation for positives). Here’s the case for 3.0:\nC:\\misc> c:\\python30\\python\n>>> 5 / 2, 5 / −2\n(2.5, −2.5)\n>>> 5 // 2, 5 // −2\n(2, −3)\n\n# Truncates to floor: rounds to first lower integer\n# 2.5 becomes 2, −2.5 becomes −3\n\n>>> 5 / 2.0, 5 / −2.0\n(2.5, −2.5)\n\nNumbers in Action | 119\n\n\f>>> 5 // 2.0, 5 // −2.0\n(2.0, −3.0)\n\n# Ditto for floats, though result is float too\n\nThe 2.6 case is similar, but / results differ again:\nC:\\misc> c:\\python26\\python\n>>> 5 / 2, 5 / −2\n(2, −3)\n>>> 5 // 2, 5 // −2\n(2, −3)\n\n# Differs in 3.0\n# This and the rest are the same in 2.6 and 3.0\n\n>>> 5 / 2.0, 5 / −2.0\n(2.5, −2.5)\n>>> 5 // 2.0, 5 // −2.0\n(2.0, −3.0)",
    "Numbers in Action | 119\n\n\f>>> 5 // 2.0, 5 // −2.0\n(2.0, −3.0)\n\n# Ditto for floats, though result is float too\n\nThe 2.6 case is similar, but / results differ again:\nC:\\misc> c:\\python26\\python\n>>> 5 / 2, 5 / −2\n(2, −3)\n>>> 5 // 2, 5 // −2\n(2, −3)\n\n# Differs in 3.0\n# This and the rest are the same in 2.6 and 3.0\n\n>>> 5 / 2.0, 5 / −2.0\n(2.5, −2.5)\n>>> 5 // 2.0, 5 // −2.0\n(2.0, −3.0)\n\nIf you really want truncation regardless of sign, you can always run a float division\nresult through math.trunc, regardless of Python version (also see the round built-in for\nrelated functionality):\nC:\\misc> c:\\python30\\python\n>>> import math\n>>> 5 / −2\n−2.5\n>>> 5 // −2\n-3\n>>> math.trunc(5 / −2)\n−2\nC:\\misc> c:\\python26\\python\n>>> import math\n>>> 5 / float(−2)\n−2.5\n>>> 5 / −2, 5 // −2\n(−3, −3)\n>>> math.trunc(5 / float(−2))\n−2\n\n# Keep remainder\n# Floor below result\n# Truncate instead of floor\n\n# Remainder in 2.6\n# Floor in 2.6\n# Truncate in 2.6",
    "# Keep remainder\n# Floor below result\n# Truncate instead of floor\n\n# Remainder in 2.6\n# Floor in 2.6\n# Truncate in 2.6\n\nWhy does truncation matter?\nIf you are using 3.0, here is the short story on division operators for reference:\n>>> (5 / 2), (5 / 2.0), (5 / −2.0), (5 / −2)\n(2.5, 2.5, −2.5, −2.5)\n\n# 3.0 true division\n\n>>> (5 // 2), (5 // 2.0), (5 // −2.0), (5 // −2)\n(2, 2.0, −3.0, −3)\n\n# 3.0 floor division\n\n>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)\n(3.0, 3.0, 3, 3.0)\n\n# Both\n\nFor 2.6 readers, division works as follows:\n>>> (5 / 2), (5 / 2.0), (5 / −2.0), (5 / −2)\n(2, 2.5, −2.5, −3)\n\n120 | Chapter 5: Numeric Types\n\n# 2.6 classic division\n\n\f>>> (5 // 2), (5 // 2.0), (5 // −2.0), (5 // −2)\n(2, 2.0, −3.0, −3)\n\n# 2.6 floor division (same)\n\n>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)\n(3, 3.0, 3, 3.0)\n\n# Both",
    "# Both\n\nFor 2.6 readers, division works as follows:\n>>> (5 / 2), (5 / 2.0), (5 / −2.0), (5 / −2)\n(2, 2.5, −2.5, −3)\n\n120 | Chapter 5: Numeric Types\n\n# 2.6 classic division\n\n\f>>> (5 // 2), (5 // 2.0), (5 // −2.0), (5 // −2)\n(2, 2.0, −3.0, −3)\n\n# 2.6 floor division (same)\n\n>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)\n(3, 3.0, 3, 3.0)\n\n# Both\n\nAlthough results have yet to come in, it’s possible that the nontruncating behavior\nof / in 3.0 may break a significant number of programs. Perhaps because of a C language\nlegacy, many programmers rely on division truncation for integers and will have to\nlearn to use // in such contexts instead. Watch for a simple prime number while loop\nexample in Chapter 13, and a corresponding exercise at the end of Part IV that illustrates\nthe sort of code that may be impacted by this / change. Also stay tuned for more on\nthe special from command used in this section; it’s discussed further in Chapter 24.",
    "Integer Precision\nDivision may differ slightly across Python releases, but it’s still fairly standard. Here’s\nsomething a bit more exotic. As mentioned earlier, Python 3.0 integers support unlimited size:\n>>> 999999999999999999999999999999 + 1\n1000000000000000000000000000000\n\nPython 2.6 has a separate type for long integers, but it automatically converts any\nnumber too large to store in a normal integer to this type. Hence, you don’t need to\ncode any special syntax to use longs, and the only way you can tell that you’re using\n2.6 longs is that they print with a trailing “L”:\n>>> 999999999999999999999999999999 + 1\n1000000000000000000000000000000L",
    "Python 2.6 has a separate type for long integers, but it automatically converts any\nnumber too large to store in a normal integer to this type. Hence, you don’t need to\ncode any special syntax to use longs, and the only way you can tell that you’re using\n2.6 longs is that they print with a trailing “L”:\n>>> 999999999999999999999999999999 + 1\n1000000000000000000000000000000L\n\nUnlimited-precision integers are a convenient built-in tool. For instance, you can use\nthem to count the U.S. national debt in pennies in Python directly (if you are so inclined,\nand have enough memory on your computer for this year’s budget!). They are also why\nwe were able to raise 2 to such large powers in the examples in Chapter 3. Here are the\n3.0 and 2.6 cases:\n>>> 2 ** 200\n1606938044258990275541962092341162602522202993782792835301376\n>>> 2 ** 200\n1606938044258990275541962092341162602522202993782792835301376L",
    "Because Python must do extra work to support their extended precision, integer math\nis usually substantially slower than normal when numbers grow large. However, if you\nneed the precision, the fact that it’s built in for you to use will likely outweigh its\nperformance penalty.\n\nNumbers in Action | 121",
    "Numbers in Action | 121\n\n\fComplex Numbers\nAlthough less widely used than the types we’ve been exploring thus far, complex numbers are a distinct core object type in Python. If you know what they are, you know\nwhy they are useful; if not, consider this section optional reading.\nComplex numbers are represented as two floating-point numbers—the real and imaginary parts—and are coded by adding a j or J suffix to the imaginary part. We can also\nwrite complex numbers with a nonzero real part by adding the two parts with a +. For\nexample, the complex number with a real part of 2 and an imaginary part of −3 is written\n2 + −3j. Here are some examples of complex math at work:\n>>> 1j * 1J\n(-1+0j)\n>>> 2 + 1j * 3\n(2+3j)\n>>> (2 + 1j) * 3\n(6+3j)",
    "Complex numbers also allow us to extract their parts as attributes, support all the usual\nmathematical expressions, and may be processed with tools in the standard cmath\nmodule (the complex version of the standard math module). Complex numbers typically\nfind roles in engineering-oriented programs. Because they are advanced tools, check\nPython’s language reference manual for additional details.",
    "Hexadecimal, Octal, and Binary Notation\nAs described earlier in this chapter, Python integers can be coded in hexadecimal, octal,\nand binary notation, in addition to the normal base 10 decimal coding. The coding\nrules were laid out at the start of this chapter; let’s look at some live examples here.\nKeep in mind that these literals are simply an alternative syntax for specifying the value\nof an integer object. For example, the following literals coded in Python 3.0 or 2.6\nproduce normal integers with the specified values in all three bases:\n>>> 0o1, 0o20, 0o377\n(1, 16, 255)\n>>> 0x01, 0x10, 0xFF\n(1, 16, 255)\n>>> 0b1, 0b10000, 0b11111111\n(1, 16, 255)\n\n# Octal literals\n# Hex literals\n# Binary literals",
    "# Octal literals\n# Hex literals\n# Binary literals\n\nHere, the octal value 0o377, the hex value 0xFF, and the binary value 0b11111111 are all\ndecimal 255. Python prints in decimal (base 10) by default but provides built-in functions that allow you to convert integers to other bases’ digit strings:\n>>> oct(64), hex(64), bin(64)\n('0100', '0x40', '0b1000000')\n\n122 | Chapter 5: Numeric Types\n\n\fThe oct function converts decimal to octal, hex to hexadecimal, and bin to binary. To\ngo the other way, the built-in int function converts a string of digits to an integer, and\nan optional second argument lets you specify the numeric base:\n>>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)\n(64, 64, 64, 64)\n# Literals okay too\n\n>>> int('0x40', 16), int('0b1000000', 2)\n(64, 64)",
    "The oct function converts decimal to octal, hex to hexadecimal, and bin to binary. To\ngo the other way, the built-in int function converts a string of digits to an integer, and\nan optional second argument lets you specify the numeric base:\n>>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)\n(64, 64, 64, 64)\n# Literals okay too\n\n>>> int('0x40', 16), int('0b1000000', 2)\n(64, 64)\n\nThe eval function, which you’ll meet later in this book, treats strings as though they\nwere Python code. Therefore, it has a similar effect (but usually runs more slowly—it\nactually compiles and runs the string as a piece of a program, and it assumes you can\ntrust the source of the string being run; a clever user might be able to submit a string\nthat deletes files on your machine!):\n>>> eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')\n(64, 64, 64, 64)",
    "Finally, you can also convert integers to octal and hexadecimal strings with string formatting method calls and expressions:\n>>> '{0:o}, {1:x}, {2:b}'.format(64, 64, 64)\n'100, 40, 1000000'\n>>> '%o, %x, %X' % (64, 255, 255)\n'100, ff, FF'\n\nString formatting is covered in more detail in Chapter 7.\nTwo notes before moving on. First, Python 2.6 users should remember that you can\ncode octals with simply a leading zero, the original octal format in Python:\n>>> 0o1, 0o20, 0o377\n(1, 16, 255)\n>>> 01, 020, 0377\n(1, 16, 255)\n\n# New octal format in 2.6 (same as 3.0)\n# Old octal literals in 2.6 (and earlier)",
    "# New octal format in 2.6 (same as 3.0)\n# Old octal literals in 2.6 (and earlier)\n\nIn 3.0, the syntax in the second of these examples generates an error. Even though it’s\nnot an error in 2.6, be careful not to begin a string of digits with a leading zero unless\nyou really mean to code an octal value. Python 2.6 will treat it as base 8, which may\nnot work as you’d expect—010 is always decimal 8 in 2.6, not decimal 10 (despite what\nyou may or may not think!). This, along with symmetry with the hex and binary forms,\nis why the octal format was changed in 3.0—you must use 0o010 in 3.0, and probably\nshould in 2.6.\nSecondly, note that these literals can produce arbitrarily long integers. The following,\nfor instance, creates an integer with hex notation and then displays it first in decimal\nand then in octal and binary with converters:\n>>> X = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n>>> X\n5192296858534827628530496329220095L\n>>> oct(X)\n\nNumbers in Action | 123",
    "Numbers in Action | 123\n\n\f'017777777777777777777777777777777777777L'\n>>> bin(X)\n'0b1111111111111111111111111111111111111111111111111111111111 ...and so on...\n\nSpeaking of binary digits, the next section shows tools for processing individual bits.\n\nBitwise Operations\nBesides the normal numeric operations (addition, subtraction, and so on), Python supports most of the numeric expressions available in the C language. This includes\noperators that treat integers as strings of binary bits. For instance, here it is at work\nperforming bitwise shift and Boolean operations:\n>>> x = 1\n>>> x << 2\n4\n>>> x | 2\n3\n>>> x & 1\n1\n\n# 0001\n# Shift left 2 bits: 0100\n# Bitwise OR: 0011\n# Bitwise AND: 0001",
    "# 0001\n# Shift left 2 bits: 0100\n# Bitwise OR: 0011\n# Bitwise AND: 0001\n\nIn the first expression, a binary 1 (in base 2, 0001) is shifted left two slots to create a\nbinary 4 (0100). The last two operations perform a binary OR (0001|0010 = 0011) and a\nbinary AND (0001&0001 = 0001). Such bit-masking operations allow us to encode multiple flags and other values within a single integer.\nThis is one area where the binary and hexadecimal number support in Python 2.6 and\n3.0 become especially useful—they allow us to code and inspect numbers by bit-strings:\n>>> X = 0b0001\n>>> X << 2\n4\n>>> bin(X << 2)\n'0b100'\n\n# Binary literals\n# Shift left\n\n>>> bin(X | 0b010)\n'0b11'\n>>> bin(X & 0b1)\n'0b1'\n\n# Bitwise OR\n\n# Binary digits string\n\n# Bitwise AND\n\n>>> X = 0xFF\n# Hex literals\n>>> bin(X)\n'0b11111111'\n>>> X ^ 0b10101010\n# Bitwise XOR\n85\n>>> bin(X ^ 0b10101010)\n'0b1010101'\n>>> int('1010101', 2)\n85\n>>> hex(85)\n'0x55'\n\n124 | Chapter 5: Numeric Types\n\n# String to int per base\n# Hex digit string",
    "We won’t go into much more detail on “bit-twiddling” here. It’s supported if you need\nit, and it comes in handy if your Python code must deal with things like network packets\nor packed binary data produced by a C program. Be aware, though, that bitwise operations are often not as important in a high-level language such as Python as they are in\na low-level language such as C. As a rule of thumb, if you find yourself wanting to flip\nbits in Python, you should think about which language you’re really coding. In general,\nthere are often better ways to encode information in Python than bit strings.\nIn the upcoming Python 3.1 release, the integer bit_length method also\nallows you to query the number of bits required to represent a number’s\nvalue in binary. The same effect can often be achieved by subtracting 2\nfrom the length of the bin string using the len built-in function we met\nin Chapter 4, though it may be less efficient:\n>>> X = 99\n>>> bin(X), X.bit_length()\n('0b1100011', 7)",
    "In the upcoming Python 3.1 release, the integer bit_length method also\nallows you to query the number of bits required to represent a number’s\nvalue in binary. The same effect can often be achieved by subtracting 2\nfrom the length of the bin string using the len built-in function we met\nin Chapter 4, though it may be less efficient:\n>>> X = 99\n>>> bin(X), X.bit_length()\n('0b1100011', 7)\n>>> bin(256), (256).bit_length()\n('0b100000000', 9)\n>>> len(bin(256)) - 2\n9",
    "Other Built-in Numeric Tools\nIn addition to its core object types, Python also provides both built-in functions and\nstandard library modules for numeric processing. The pow and abs built-in functions,\nfor instance, compute powers and absolute values, respectively. Here are some examples of the built-in math module (which contains most of the tools in the C language’s\nmath library) and a few built-in functions at work:\n>>> import math\n>>> math.pi, math.e\n(3.1415926535897931, 2.7182818284590451)\n\n# Common constants\n\n>>> math.sin(2 * math.pi / 180)\n0.034899496702500969\n\n# Sine, tangent, cosine\n\n>>> math.sqrt(144), math.sqrt(2)\n(12.0, 1.4142135623730951)\n\n# Square root\n\n>>> pow(2, 4), 2 ** 4\n(16, 16)\n\n# Exponentiation (power)\n\n>>> abs(-42.0), sum((1, 2, 3, 4))\n(42.0, 10)\n\n# Absolute value, summation\n\n>>> min(3, 1, 2, 4), max(3, 1, 2, 4)\n(1, 4)\n\n# Minimum, maximum",
    "# Common constants\n\n>>> math.sin(2 * math.pi / 180)\n0.034899496702500969\n\n# Sine, tangent, cosine\n\n>>> math.sqrt(144), math.sqrt(2)\n(12.0, 1.4142135623730951)\n\n# Square root\n\n>>> pow(2, 4), 2 ** 4\n(16, 16)\n\n# Exponentiation (power)\n\n>>> abs(-42.0), sum((1, 2, 3, 4))\n(42.0, 10)\n\n# Absolute value, summation\n\n>>> min(3, 1, 2, 4), max(3, 1, 2, 4)\n(1, 4)\n\n# Minimum, maximum\n\nThe sum function shown here works on a sequence of numbers, and min and max accept\neither a sequence or individual arguments. There are a variety of ways to drop the\nNumbers in Action | 125\n\n\fdecimal digits of floating-point numbers. We met truncation and floor earlier; we can\nalso round, both numerically and for display purposes:\n>>> math.floor(2.567), math.floor(-2.567)\n(2, −3)\n\n# Floor (next-lower integer)\n\n>>> math.trunc(2.567), math.trunc(−2.567)\n(2, −2)\n\n# Truncate (drop decimal digits)\n\n>>> int(2.567), int(−2.567)\n(2, −2)\n\n# Truncate (integer conversion)",
    "decimal digits of floating-point numbers. We met truncation and floor earlier; we can\nalso round, both numerically and for display purposes:\n>>> math.floor(2.567), math.floor(-2.567)\n(2, −3)\n\n# Floor (next-lower integer)\n\n>>> math.trunc(2.567), math.trunc(−2.567)\n(2, −2)\n\n# Truncate (drop decimal digits)\n\n>>> int(2.567), int(−2.567)\n(2, −2)\n\n# Truncate (integer conversion)\n\n>>> round(2.567), round(2.467), round(2.567, 2)\n(3, 2, 2.5699999999999998)\n\n# Round (Python 3.0 version)\n\n>>> '%.1f' % 2.567, '{0:.2f}'.format(2.567)\n('2.6', '2.57')\n\n# Round for display (Chapter 7)",
    "# Floor (next-lower integer)\n\n>>> math.trunc(2.567), math.trunc(−2.567)\n(2, −2)\n\n# Truncate (drop decimal digits)\n\n>>> int(2.567), int(−2.567)\n(2, −2)\n\n# Truncate (integer conversion)\n\n>>> round(2.567), round(2.467), round(2.567, 2)\n(3, 2, 2.5699999999999998)\n\n# Round (Python 3.0 version)\n\n>>> '%.1f' % 2.567, '{0:.2f}'.format(2.567)\n('2.6', '2.57')\n\n# Round for display (Chapter 7)\n\nAs we saw earlier, the last of these produces strings that we would usually print and\nsupports a variety of formatting options. As also described earlier, the second to last\ntest here will output (3, 2, 2.57) if we wrap it in a print call to request a more userfriendly display. The last two lines still differ, though—round rounds a floating-point\nnumber but still yields a floating-point number in memory, whereas string formatting\nproduces a string and doesn’t yield a modified number:\n>>> (1 / 3), round(1 / 3, 2), ('%.2f' % (1 / 3))\n(0.33333333333333331, 0.33000000000000002, '0.33')",
    "Interestingly, there are three ways to compute square roots in Python: using a module\nfunction, an expression, or a built-in function (if you’re interested in performance, we\nwill revisit these in an exercise and its solution at the end of Part IV, to see which runs\nquicker):\n>>> import math\n>>> math.sqrt(144)\n12.0\n>>> 144 ** .5\n12.0\n>>> pow(144, .5)\n12.0\n>>> math.sqrt(1234567890)\n35136.418286444619\n>>> 1234567890 ** .5\n35136.418286444619\n>>> pow(1234567890, .5)\n35136.418286444619\n\n# Module\n# Expression\n# Built-in\n# Larger numbers\n\nNotice that standard library modules such as math must be imported, but built-in functions such as abs and round are always available without imports. In other words, modules are external components, but built-in functions live in an implied namespace that\nPython automatically searches to find names used in your program. This namespace\ncorresponds to the module called builtins in Python 3.0 (__builtin__ in 2.6). There\n\n126 | Chapter 5: Numeric Types",
    "126 | Chapter 5: Numeric Types\n\n\fis much more about name resolution in the function and module parts of this book;\nfor now, when you hear “module,” think “import.”\nThe standard library random module must be imported as well. This module provides\ntools for picking a random floating-point number between 0 and 1, selecting a random\ninteger between two numbers, choosing an item at random from a sequence, and more:\n>>> import random\n>>> random.random()\n0.44694718823781876\n>>> random.random()\n0.28970426439292829\n>>> random.randint(1, 10)\n5\n>>> random.randint(1, 10)\n4\n>>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])\n'Life of Brian'\n>>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])\n'Holy Grail'\n\nThe random module can be useful for shuffling cards in games, picking images at random\nin a slideshow GUI, performing statistical simulations, and much more. For more details, see Python’s library manual.",
    "The random module can be useful for shuffling cards in games, picking images at random\nin a slideshow GUI, performing statistical simulations, and much more. For more details, see Python’s library manual.\n\nOther Numeric Types\nSo far in this chapter, we’ve been using Python’s core numeric types—integer, floating\npoint, and complex. These will suffice for most of the number crunching that most\nprogrammers will ever need to do. Python comes with a handful of more exotic numeric\ntypes, though, that merit a quick look here.",
    "Decimal Type\nPython 2.4 introduced a new core numeric type: the decimal object, formally known\nas Decimal. Syntactically, decimals are created by calling a function within an imported\nmodule, rather than running a literal expression. Functionally, decimals are like\nfloating-point numbers, but they have a fixed number of decimal points. Hence, decimals are fixed-precision floating-point values.\nFor example, with decimals, we can have a floating-point value that always retains just\ntwo decimal digits. Furthermore, we can specify how to round or truncate the extra\ndecimal digits beyond the object’s cutoff. Although it generally incurs a small performance penalty compared to the normal floating-point type, the decimal type is well suited\nto representing fixed-precision quantities like sums of money and can help you achieve\nbetter numeric accuracy.\n\nOther Numeric Types | 127",
    "Other Numeric Types | 127\n\n\fThe basics\nThe last point merits elaboration. As you may or may not already know, floating-point\nmath is less than exact, because of the limited space used to store values. For example,\nthe following should yield zero, but it does not. The result is close to zero, but there\nare not enough bits to be precise here:\n>>> 0.1 + 0.1 + 0.1 - 0.3\n5.5511151231257827e-17\n\nPrinting the result to produce the user-friendly display format doesn’t completely help\neither, because the hardware related to floating-point math is inherently limited in\nterms of accuracy:\n>>> print(0.1 + 0.1 + 0.1 - 0.3)\n5.55111512313e-17\n\nHowever, with decimals, the result can be dead-on:\n>>> from decimal import Decimal\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')\nDecimal('0.0')",
    "However, with decimals, the result can be dead-on:\n>>> from decimal import Decimal\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')\nDecimal('0.0')\n\nAs shown here, we can make decimal objects by calling the Decimal constructor function\nin the decimal module and passing in strings that have the desired number of decimal\ndigits for the resulting object (we can use the str function to convert floating-point\nvalues to strings if needed). When decimals of different precision are mixed in expressions, Python converts up to the largest number of decimal digits automatically:\n>>> Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30')\nDecimal('0.00')\n\nIn Python 3.1 (to be released after this book’s publication), it’s also\npossible to create a decimal object from a floating-point object, with a\ncall of the form decimal.Decimal.from_float(1.25). The conversion is\nexact but can sometimes yield a large number of digits.",
    "In Python 3.1 (to be released after this book’s publication), it’s also\npossible to create a decimal object from a floating-point object, with a\ncall of the form decimal.Decimal.from_float(1.25). The conversion is\nexact but can sometimes yield a large number of digits.\n\nSetting precision globally\nOther tools in the decimal module can be used to set the precision of all decimal numbers, set up error handling, and more. For instance, a context object in this module\nallows for specifying precision (number of decimal digits) and rounding modes (down,\nceiling, etc.). The precision is applied globally for all decimals created in the calling\nthread:\n>>> import decimal\n>>> decimal.Decimal(1) / decimal.Decimal(7)\nDecimal('0.1428571428571428571428571429')\n>>> decimal.getcontext().prec = 4\n>>> decimal.Decimal(1) / decimal.Decimal(7)\nDecimal('0.1429')\n\n128 | Chapter 5: Numeric Types",
    "128 | Chapter 5: Numeric Types\n\n\fThis is especially useful for monetary applications, where cents are represented as two\ndecimal digits. Decimals are essentially an alternative to manual rounding and string\nformatting in this context:\n>>> 1999 + 1.33\n2000.3299999999999\n>>>\n>>> decimal.getcontext().prec = 2\n>>> pay = decimal.Decimal(str(1999 + 1.33))\n>>> pay\nDecimal('2000.33')\n\nDecimal context manager\nIn Python 2.6 and 3.0 (and later), it’s also possible to reset precision temporarily by\nusing the with context manager statement. The precision is reset to its original value\non statement exit:\nC:\\misc> C:\\Python30\\python\n>>> import decimal\n>>> decimal.Decimal('1.00') / decimal.Decimal('3.00')\nDecimal('0.3333333333333333333333333333')\n>>>\n>>> with decimal.localcontext() as ctx:\n...\nctx.prec = 2\n...\ndecimal.Decimal('1.00') / decimal.Decimal('3.00')\n...\nDecimal('0.33')\n>>>\n>>> decimal.Decimal('1.00') / decimal.Decimal('3.00')\nDecimal('0.3333333333333333333333333333')",
    "Though useful, this statement requires much more background knowledge than you’ve\nobtained at this point; watch for coverage of the with statement in Chapter 33.\nBecause use of the decimal type is still relatively rare in practice, I’ll defer to Python’s\nstandard library manuals and interactive help for more details. And because decimals\naddress some of the same floating-point accuracy issues as the fraction type, let’s move\non to the next section to see how the two compare.\n\nFraction Type\nPython 2.6 and 3.0 debut a new numeric type, Fraction, which implements a rational\nnumber object. It essentially keeps both a numerator and a denominator explicitly, so\nas to avoid some of the inaccuracies and limitations of floating-point math.\n\nThe basics\nFraction is a sort of cousin to the existing Decimal fixed-precision type described in the",
    "Fraction Type\nPython 2.6 and 3.0 debut a new numeric type, Fraction, which implements a rational\nnumber object. It essentially keeps both a numerator and a denominator explicitly, so\nas to avoid some of the inaccuracies and limitations of floating-point math.\n\nThe basics\nFraction is a sort of cousin to the existing Decimal fixed-precision type described in the\n\nprior section, as both can be used to control numerical accuracy by fixing decimal digits\nand specifying rounding or truncation policies. It’s also used in similar ways—like\n\nOther Numeric Types | 129\n\n\fDecimal, Fraction resides in a module; import its constructor and pass in a numerator\n\nand a denominator to make one. The following interaction shows how:\n>>> from fractions import Fraction\n>>> x = Fraction(1, 3)\n>>> y = Fraction(4, 6)\n\n# Numerator, denominator\n# Simplified to 2, 3 by gcd\n\n>>> x\nFraction(1, 3)\n>>> y\nFraction(2, 3)\n>>> print(y)\n2/3",
    "Other Numeric Types | 129\n\n\fDecimal, Fraction resides in a module; import its constructor and pass in a numerator\n\nand a denominator to make one. The following interaction shows how:\n>>> from fractions import Fraction\n>>> x = Fraction(1, 3)\n>>> y = Fraction(4, 6)\n\n# Numerator, denominator\n# Simplified to 2, 3 by gcd\n\n>>> x\nFraction(1, 3)\n>>> y\nFraction(2, 3)\n>>> print(y)\n2/3\n\nOnce created, Fractions can be used in mathematical expressions as usual:\n>>> x + y\nFraction(1, 1)\n>>> x – y\nFraction(-1, 3)\n>>> x * y\nFraction(2, 9)\n\n# Results are exact: numerator, denominator\n\nFraction objects can also be created from floating-point number strings, much like\n\ndecimals:\n>>> Fraction('.25')\nFraction(1, 4)\n>>> Fraction('1.25')\nFraction(5, 4)\n>>>\n>>> Fraction('.25') + Fraction('1.25')\nFraction(3, 2)",
    "# Results are exact: numerator, denominator\n\nFraction objects can also be created from floating-point number strings, much like\n\ndecimals:\n>>> Fraction('.25')\nFraction(1, 4)\n>>> Fraction('1.25')\nFraction(5, 4)\n>>>\n>>> Fraction('.25') + Fraction('1.25')\nFraction(3, 2)\n\nNumeric accuracy\nNotice that this is different from floating-point-type math, which is constrained by the\nunderlying limitations of floating-point hardware. To compare, here are the same operations run with floating-point objects, and notes on their limited accuracy:\n>>> a = 1 / 3.0\n>>> b = 4 / 6.0\n>>> a\n0.33333333333333331\n>>> b\n0.66666666666666663\n\n# Only as accurate as floating-point hardware\n# Can lose precision over calculations\n\n>>> a + b\n1.0\n>>> a - b\n-0.33333333333333331\n>>> a * b\n0.22222222222222221\n\nThis floating-point limitation is especially apparent for values that cannot be represented accurately given their limited number of bits in memory. Both Fraction and\n130 | Chapter 5: Numeric Types",
    "# Only as accurate as floating-point hardware\n# Can lose precision over calculations\n\n>>> a + b\n1.0\n>>> a - b\n-0.33333333333333331\n>>> a * b\n0.22222222222222221\n\nThis floating-point limitation is especially apparent for values that cannot be represented accurately given their limited number of bits in memory. Both Fraction and\n130 | Chapter 5: Numeric Types\n\n\fDecimal provide ways to get exact results, albeit at the cost of some speed. For instance,\n\nin the following example (repeated from the prior section), floating-point numbers do\nnot accurately give the zero answer expected, but both of the other types do:\n# This should be zero (close, but not exact)\n\n>>> 0.1 + 0.1 + 0.1 - 0.3\n5.5511151231257827e-17\n\n>>> from fractions import Fraction\n>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)\nFraction(0, 1)\n>>> from decimal import Decimal\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')\nDecimal('0.0')",
    ">>> 0.1 + 0.1 + 0.1 - 0.3\n5.5511151231257827e-17\n\n>>> from fractions import Fraction\n>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)\nFraction(0, 1)\n>>> from decimal import Decimal\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')\nDecimal('0.0')\n\nMoreover, fractions and decimals both allow more intuitive and accurate results than\nfloating points sometimes can, in different ways (by using rational representation and\nby limiting precision):\n>>> 1 / 3\n0.33333333333333331\n\n# Use 3.0 in Python 2.6 for true \"/\"\n\n>>> Fraction(1, 3)\nFraction(1, 3)\n\n# Numeric accuracy\n\n>>> import decimal\n>>> decimal.getcontext().prec = 2\n>>> decimal.Decimal(1) / decimal.Decimal(3)\nDecimal('0.33')\n\nIn fact, fractions both retain accuracy and automatically simplify results. Continuing\nthe preceding interaction:\n>>> (1 / 3) + (6 / 12)\n0.83333333333333326\n\n# Use \".0\" in Python 2.6 for true \"/\"\n\n>>> Fraction(6, 12)\nFraction(1, 2)\n\n# Automatically simplified",
    "# Numeric accuracy\n\n>>> import decimal\n>>> decimal.getcontext().prec = 2\n>>> decimal.Decimal(1) / decimal.Decimal(3)\nDecimal('0.33')\n\nIn fact, fractions both retain accuracy and automatically simplify results. Continuing\nthe preceding interaction:\n>>> (1 / 3) + (6 / 12)\n0.83333333333333326\n\n# Use \".0\" in Python 2.6 for true \"/\"\n\n>>> Fraction(6, 12)\nFraction(1, 2)\n\n# Automatically simplified\n\n>>> Fraction(1, 3) + Fraction(6, 12)\nFraction(5, 6)\n>>> decimal.Decimal(str(1/3)) + decimal.Decimal(str(6/12))\nDecimal('0.83')\n>>> 1000.0 / 1234567890\n8.1000000737100011e-07\n>>> Fraction(1000, 1234567890)\nFraction(100, 123456789)\n\nConversions and mixed types\nTo support fraction conversions, floating-point objects now have a method that yields\ntheir numerator and denominator ratio, fractions have a from_float method, and\n\nOther Numeric Types | 131",
    "Conversions and mixed types\nTo support fraction conversions, floating-point objects now have a method that yields\ntheir numerator and denominator ratio, fractions have a from_float method, and\n\nOther Numeric Types | 131\n\n\ffloat accepts a Fraction as an argument. Trace through the following interaction to\nsee how this pans out (the * in the second test is special syntax that expands a tuple\n\ninto individual arguments; more on this when we study function argument passing in\nChapter 18):\n>>> (2.5).as_integer_ratio()\n(5, 2)\n>>> f = 2.5\n>>> z = Fraction(*f.as_integer_ratio())\n>>> z\nFraction(5, 2)\n\n# float object method\n\n# Convert float -> fraction: two args\n# Same as Fraction(5, 2)\n\n>>> x\nFraction(1, 3)\n>>> x + z\nFraction(17, 6)\n\n# x from prior interaction\n\n>>> float(x)\n0.33333333333333331\n>>> float(z)\n2.5\n>>> float(x + z)\n2.8333333333333335\n>>> 17 / 6\n2.8333333333333335\n\n# Convert fraction -> float",
    "# float object method\n\n# Convert float -> fraction: two args\n# Same as Fraction(5, 2)\n\n>>> x\nFraction(1, 3)\n>>> x + z\nFraction(17, 6)\n\n# x from prior interaction\n\n>>> float(x)\n0.33333333333333331\n>>> float(z)\n2.5\n>>> float(x + z)\n2.8333333333333335\n>>> 17 / 6\n2.8333333333333335\n\n# Convert fraction -> float\n\n>>> Fraction.from_float(1.75)\nFraction(7, 4)\n>>> Fraction(*(1.75).as_integer_ratio())\nFraction(7, 4)\n\n# Convert float -> fraction: other way\n\n# 5/2 + 1/3 = 15/6 + 2/6\n\nFinally, some type mixing is allowed in expressions, though Fraction must sometimes\nbe manually propagated to retain accuracy. Study the following interaction to see how\nthis works:\n>>> x\nFraction(1, 3)\n>>> x + 2\nFraction(7, 3)\n>>> x + 2.0\n2.3333333333333335\n>>> x + (1./3)\n0.66666666666666663\n>>> x + (4./3)\n1.6666666666666665\n>>> x + Fraction(4, 3)\nFraction(5, 3)\n\n# Fraction + int -> Fraction\n# Fraction + float -> float\n# Fraction + float -> float\n\n# Fraction + Fraction -> Fraction",
    "# Fraction + int -> Fraction\n# Fraction + float -> float\n# Fraction + float -> float\n\n# Fraction + Fraction -> Fraction\n\nCaveat: although you can convert from floating-point to fraction, in some cases there\nis an unavoidable precision loss when you do so, because the number is inaccurate in\nits original floating-point form. When needed, you can simplify such results by limiting\nthe maximum denominator value:\n132 | Chapter 5: Numeric Types\n\n\f>>> 4.0 / 3\n1.3333333333333333\n>>> (4.0 / 3).as_integer_ratio()\n(6004799503160661, 4503599627370496)\n\n# Precision loss from float\n\n>>> x\nFraction(1, 3)\n>>> a = x + Fraction(*(4.0 / 3).as_integer_ratio())\n>>> a\nFraction(22517998136852479, 13510798882111488)\n>>> 22517998136852479 / 13510798882111488.\n1.6666666666666667\n\n# 5 / 3 (or close to it!)\n\n>>> a.limit_denominator(10)\nFraction(5, 3)\n\n# Simplify to closest fraction",
    "# Precision loss from float\n\n>>> x\nFraction(1, 3)\n>>> a = x + Fraction(*(4.0 / 3).as_integer_ratio())\n>>> a\nFraction(22517998136852479, 13510798882111488)\n>>> 22517998136852479 / 13510798882111488.\n1.6666666666666667\n\n# 5 / 3 (or close to it!)\n\n>>> a.limit_denominator(10)\nFraction(5, 3)\n\n# Simplify to closest fraction\n\nFor more details on the Fraction type, experiment further on your own and consult the\nPython 2.6 and 3.0 library manuals and other documentation.",
    "Sets\nPython 2.4 also introduced a new collection type, the set—an unordered collection of\nunique and immutable objects that supports operations corresponding to mathematical set theory. By definition, an item appears only once in a set, no matter how many\ntimes it is added. As such, sets have a variety of applications, especially in numeric and\ndatabase-focused work.\nBecause sets are collections of other objects, they share some behavior with objects\nsuch as lists and dictionaries that are outside the scope of this chapter. For example,\nsets are iterable, can grow and shrink on demand, and may contain a variety of object\ntypes. As we’ll see, a set acts much like the keys of a valueless dictionary, but it supports\nextra operations.\nHowever, because sets are unordered and do not map keys to values, they are neither\nsequence nor mapping types; they are a type category unto themselves. Moreover, because sets are fundamentally mathematical in nature (and for many readers, may seem",
    "types. As we’ll see, a set acts much like the keys of a valueless dictionary, but it supports\nextra operations.\nHowever, because sets are unordered and do not map keys to values, they are neither\nsequence nor mapping types; they are a type category unto themselves. Moreover, because sets are fundamentally mathematical in nature (and for many readers, may seem\nmore academic and be used much less often than more pervasive objects like dictionaries), we’ll explore the basic utility of Python’s set objects here.",
    "Set basics in Python 2.6\nThere are a few ways to make sets today, depending on whether you are using Python\n2.6 or 3.0. Since this book covers both, let’s begin with the 2.6 case, which also is\navailable (and sometimes still required) in 3.0; we’ll refine this for 3.0 extensions in a\nmoment. To make a set object, pass in a sequence or other iterable object to the builtin set function:\n>>> x = set('abcde')\n>>> y = set('bdxyz')\n\nOther Numeric Types | 133\n\n\fYou get back a set object, which contains all the items in the object passed in (notice\nthat sets do not have a positional ordering, and so are not sequences):\n>>> x\nset(['a', 'c', 'b', 'e', 'd'])\n\n# 2.6 display format\n\nSets made this way support the common mathematical set operations with expression operators. Note that we can’t perform these expressions on plain sequences—we\nmust create sets from them in order to apply these tools:\n>>> 'e' in x\nTrue\n\n# Membership\n\n>>> x – y\nset(['a', 'c', 'e'])\n\n# Difference",
    "# 2.6 display format\n\nSets made this way support the common mathematical set operations with expression operators. Note that we can’t perform these expressions on plain sequences—we\nmust create sets from them in order to apply these tools:\n>>> 'e' in x\nTrue\n\n# Membership\n\n>>> x – y\nset(['a', 'c', 'e'])\n\n# Difference\n\n>>> x | y\nset(['a', 'c', 'b', 'e', 'd', 'y', 'x', 'z'])\n\n# Union\n\n>>> x & y\nset(['b', 'd'])\n\n# Intersection\n\n>>> x ^ y\nset(['a', 'c', 'e', 'y', 'x', 'z'])\n\n# Symmetric difference (XOR)\n\n>>> x > y, x < y\n(False, False)\n\n# Superset, subset",
    "# Membership\n\n>>> x – y\nset(['a', 'c', 'e'])\n\n# Difference\n\n>>> x | y\nset(['a', 'c', 'b', 'e', 'd', 'y', 'x', 'z'])\n\n# Union\n\n>>> x & y\nset(['b', 'd'])\n\n# Intersection\n\n>>> x ^ y\nset(['a', 'c', 'e', 'y', 'x', 'z'])\n\n# Symmetric difference (XOR)\n\n>>> x > y, x < y\n(False, False)\n\n# Superset, subset\n\nIn addition to expressions, the set object provides methods that correspond to these\noperations and more, and that support set changes—the set add method inserts one\nitem, update is an in-place union, and remove deletes an item by value (run a dir call on\nany set instance or the set type name to see all the available methods). Assuming x and\ny are still as they were in the prior interaction:\n>>> z = x.intersection(y)\n>>> z\nset(['b', 'd'])\n>>> z.add('SPAM')\n>>> z\nset(['b', 'd', 'SPAM'])\n>>> z.update(set(['X', 'Y']))\n>>> z\nset(['Y', 'X', 'b', 'd', 'SPAM'])\n>>> z.remove('b')\n>>> z\nset(['Y', 'X', 'd', 'SPAM'])\n\n# Same as x & y\n# Insert one item\n# Merge: in-place union\n# Delete one item",
    "# Same as x & y\n# Insert one item\n# Merge: in-place union\n# Delete one item\n\nAs iterable containers, sets can also be used in operations such as len, for loops, and\nlist comprehensions. Because they are unordered, though, they don’t support sequence\noperations like indexing and slicing:\n>>> for item in set('abc'): print(item * 3)\n...\naaa\n\n134 | Chapter 5: Numeric Types\n\n\fccc\nbbb\n\nFinally, although the set expressions shown earlier generally require two sets, their\nmethod-based counterparts can often work with any iterable type as well:\n>>> S = set([1, 2, 3])\n>>> S | set([3, 4])\n# Expressions require both to be sets\nset([1, 2, 3, 4])\n>>> S | [3, 4]\nTypeError: unsupported operand type(s) for |: 'set' and 'list'\n>>> S.union([3, 4])\n# But their methods allow any iterable\nset([1, 2, 3, 4])\n>>> S.intersection((1, 3, 5))\nset([1, 3])\n>>> S.issubset(range(-5, 5))\nTrue",
    "For more details on set operations, see Python’s library reference manual or a reference\nbook. Although set operations can be coded manually in Python with other types, like\nlists and dictionaries (and often were in the past), Python’s built-in sets use efficient\nalgorithms and implementation techniques to provide quick and standard operation.\n\nSet literals in Python 3.0\nIf you think sets are “cool,” they recently became noticeably cooler. In Python 3.0 we\ncan still use the set built-in to make set objects, but 3.0 also adds a new set literal form,\nusing the curly braces formerly reserved for dictionaries. In 3.0, the following are\nequivalent:\nset([1, 2, 3, 4])\n{1, 2, 3, 4}\n\n# Built-in call\n# 3.0 set literals",
    "# Built-in call\n# 3.0 set literals\n\nThis syntax makes sense, given that sets are essentially like valueless dictionaries—\nbecause they are unordered, unique, and immutable, a set’s items behave much like a\ndictionary’s keys. This operational similarity is even more striking given that dictionary\nkey lists in 3.0 are view objects, which support set-like behavior such as intersections\nand unions (see Chapter 8 for more on dictionary view objects).\nIn fact, regardless of how a set is made, 3.0 displays it using the new literal format. The\nset built-in is still required in 3.0 to create empty sets and to build sets from existing\niterable objects (short of using set comprehensions, discussed later in this chapter), but\nthe new literal is convenient for initializing sets of known structure:\nC:\\Misc> c:\\python30\\python\n>>> set([1, 2, 3, 4])\n{1, 2, 3, 4}\n>>> set('spam')\n{'a', 'p', 's', 'm'}\n>>> {1, 2, 3, 4}\n\n# Built-in: same as in 2.6\n# Add all items in an iterable\n# Set literals: new in 3.0",
    "# Built-in: same as in 2.6\n# Add all items in an iterable\n# Set literals: new in 3.0\n\nOther Numeric Types | 135\n\n\f{1, 2, 3, 4}\n>>> S = {'s', 'p', 'a', 'm'}\n>>> S.add('alot')\n>>> S\n{'a', 'p', 's', 'm', 'alot'}\n\nAll the set processing operations discussed in the prior section work the same in 3.0,\nbut the result sets print differently:\n>>> S1 = {1, 2, 3, 4}\n>>> S1 & {1, 3}\n{1, 3}\n>>> {1, 5, 3, 6} | S1\n{1, 2, 3, 4, 5, 6}\n>>> S1 - {1, 3, 4}\n{2}\n>>> S1 > {1, 3}\nTrue\n\n# Intersection\n# Union\n# Difference\n# Superset\n\nNote that {} is still a dictionary in Python. Empty sets must be created with the set\nbuilt-in, and print the same way:\n>>> S1 - {1, 2, 3, 4}\nset()\n>>> type({})\n<class 'dict'>\n\n# Empty sets print differently\n\n>>> S = set()\n>>> S.add(1.23)\n>>> S\n{1.23}\n\n# Initialize an empty set\n\n# Because {} is an empty dictionary",
    "# Intersection\n# Union\n# Difference\n# Superset\n\nNote that {} is still a dictionary in Python. Empty sets must be created with the set\nbuilt-in, and print the same way:\n>>> S1 - {1, 2, 3, 4}\nset()\n>>> type({})\n<class 'dict'>\n\n# Empty sets print differently\n\n>>> S = set()\n>>> S.add(1.23)\n>>> S\n{1.23}\n\n# Initialize an empty set\n\n# Because {} is an empty dictionary\n\nAs in Python 2.6, sets created with 3.0 literals support the same methods, some of which\nallow general iterable operands that expressions do not:\n>>> {1, 2, 3} | {3, 4}\n{1, 2, 3, 4}\n>>> {1, 2, 3} | [3, 4]\nTypeError: unsupported operand type(s) for |: 'set' and 'list'\n>>> {1, 2, 3}.union([3, 4])\n{1, 2, 3, 4}\n>>> {1, 2, 3}.union({3, 4})\n{1, 2, 3, 4}\n>>> {1, 2, 3}.union(set([3, 4]))\n{1, 2, 3, 4}\n>>> {1, 2, 3}.intersection((1, 3, 5))\n{1, 3}\n>>> {1, 2, 3}.issubset(range(-5, 5))\nTrue",
    "Immutable constraints and frozen sets\nSets are powerful and flexible objects, but they do have one constraint in both 3.0 and\n2.6 that you should keep in mind—largely because of their implementation, sets can\n136 | Chapter 5: Numeric Types\n\n\fonly contain immutable (a.k.a “hashable”) object types. Hence, lists and dictionaries\ncannot be embedded in sets, but tuples can if you need to store compound values.\nTuples compare by their full values when used in set operations:\n>>> S\n{1.23}\n>>> S.add([1, 2, 3])\nTypeError: unhashable type: 'list'\n>>> S.add({'a':1})\nTypeError: unhashable type: 'dict'\n>>> S.add((1, 2, 3))\n>>> S\n{1.23, (1, 2, 3)}\n>>> S | {(4, 5, 6), (1, 2, 3)}\n{1.23, (4, 5, 6), (1, 2, 3)}\n>>> (1, 2, 3) in S\nTrue\n>>> (1, 4, 3) in S\nFalse\n\n# Only mutable objects work in a set\n\n# No list or dict, but tuple okay\n# Union: same as S.union(...)\n# Membership: by complete values",
    "# Only mutable objects work in a set\n\n# No list or dict, but tuple okay\n# Union: same as S.union(...)\n# Membership: by complete values\n\nTuples in a set, for instance, might be used to represent dates, records, IP addresses,\nand so on (more on tuples later in this part of the book). Sets themselves are mutable\ntoo, and so cannot be nested in other sets directly; if you need to store a set inside\nanother set, the frozenset built-in call works just like set but creates an immutable set\nthat cannot change and thus can be embedded in other sets.",
    "Set comprehensions in Python 3.0\nIn addition to literals, 3.0 introduces a set comprehension construct; it is similar in\nform to the list comprehension we previewed in Chapter 4, but is coded in curly braces\ninstead of square brackets and run to make a set instead of a list. Set comprehensions\nrun a loop and collect the result of an expression on each iteration; a loop variable gives\naccess to the current iteration value for use in the collection expression. The result is a\nnew set created by running the code, with all the normal set behavior:\n>>> {x ** 2 for x in [1, 2, 3, 4]}\n{16, 1, 4, 9}\n\n# 3.0 set comprehension",
    "# 3.0 set comprehension\n\nIn this expression, the loop is coded on the right, and the collection expression is coded\non the left (x ** 2). As for list comprehensions, we get back pretty much what this\nexpression says: “Give me a new set containing X squared, for every X in a list.” Comprehensions can also iterate across other kinds of objects, such as strings (the first of\nthe following examples illustrates the comprehension-based way to make a set from an\nexisting iterable):\n>>> {x for x in 'spam'}\n{'a', 'p', 's', 'm'}\n\n# Same as: set('spam')\n\n>>> {c * 4 for c in 'spam'}\n{'ssss', 'aaaa', 'pppp', 'mmmm'}\n>>> {c * 4 for c in 'spamham'}\n\n# Set of collected expression results\n\nOther Numeric Types | 137\n\n\f{'ssss', 'aaaa', 'hhhh', 'pppp', 'mmmm'}\n>>> S = {c * 4 for c in 'spam'}\n>>> S | {'mmmm', 'xxxx'}\n{'ssss', 'aaaa', 'pppp', 'mmmm', 'xxxx'}\n>>> S & {'mmmm', 'xxxx'}\n{'mmmm'}",
    "# Same as: set('spam')\n\n>>> {c * 4 for c in 'spam'}\n{'ssss', 'aaaa', 'pppp', 'mmmm'}\n>>> {c * 4 for c in 'spamham'}\n\n# Set of collected expression results\n\nOther Numeric Types | 137\n\n\f{'ssss', 'aaaa', 'hhhh', 'pppp', 'mmmm'}\n>>> S = {c * 4 for c in 'spam'}\n>>> S | {'mmmm', 'xxxx'}\n{'ssss', 'aaaa', 'pppp', 'mmmm', 'xxxx'}\n>>> S & {'mmmm', 'xxxx'}\n{'mmmm'}\n\nBecause the rest of the comprehensions story relies upon underlying concepts we’re\nnot yet prepared to address, we’ll postpone further details until later in this book. In\nChapter 8, we’ll meet a first cousin in 3.0, the dictionary comprehension, and I’ll have\nmuch more to say about all comprehensions (list, set, dictionary, and generator) later,\nespecially in Chapters14 and 20. As we’ll learn later, all comprehensions, including\nsets, support additional syntax not shown here, including nested loops and if tests,\nwhich can be difficult to understand until you’ve had a chance to study larger\nstatements.",
    "Why sets?\nSet operations have a variety of common uses, some more practical than mathematical.\nFor example, because items are stored only once in a set, sets can be used to filter\nduplicates out of other collections. Simply convert the collection to a set, and then\nconvert it back again (because sets are iterable, they work in the list call here):\n>>> L = [1, 2, 1, 3, 2, 4, 5]\n>>> set(L)\n{1, 2, 3, 4, 5}\n>>> L = list(set(L))\n>>> L\n[1, 2, 3, 4, 5]\n\n# Remove duplicates",
    "Sets can also be used to keep track of where you’ve already been when traversing a\ngraph or other cyclic structure. For example, the transitive module reloader and inheritance tree lister examples we’ll study in Chapters 24 and 30, respectively, must keep\ntrack of items visited to avoid loops. Although recording states visited as keys in a\ndictionary is efficient, sets offer an alternative that’s essentially equivalent (and may be\nmore or less intuitive, depending on who you ask).\nFinally, sets are also convenient when dealing with large data sets (database query\nresults, for example)—the intersection of two sets contains objects in common to both\ncategories, and the union contains all items in either set. To illustrate, here’s a somewhat more realistic example of set operations at work, applied to lists of people in a\nhypothetical company, using 3.0 set literals (use set in 2.6):\n>>> engineers = {'bob', 'sue', 'ann', 'vic'}\n>>> managers = {'tom', 'sue'}\n>>> 'bob' in engineers\nTrue",
    "# Is bob an engineer?\n\n>>> engineers & managers\n\n# Who is both engineer and manager?\n\n138 | Chapter 5: Numeric Types\n\n\f{'sue'}\n>>> engineers | managers\n{'vic', 'sue', 'tom', 'bob', 'ann'}\n\n# All people in either category\n\n>>> engineers – managers\n{'vic', 'bob', 'ann'}\n\n# Engineers who are not managers\n\n>>> managers – engineers\n{'tom'}\n\n# Managers who are not engineers\n\n>>> engineers > managers\nFalse\n\n# Are all managers engineers? (superset)\n\n>>> {'bob', 'sue'} < engineers\nTrue\n\n# Are both engineers? (subset)\n\n>>> (managers | engineers) > managers\nTrue\n\n# All people is a superset of managers\n\n>>> managers ^ engineers\n{'vic', 'bob', 'ann', 'tom'}\n\n# Who is in one but not both?\n\n>>> (managers | engineers) - (managers ^ engineers)\n{'sue'}\n\n# Intersection!",
    ">>> engineers > managers\nFalse\n\n# Are all managers engineers? (superset)\n\n>>> {'bob', 'sue'} < engineers\nTrue\n\n# Are both engineers? (subset)\n\n>>> (managers | engineers) > managers\nTrue\n\n# All people is a superset of managers\n\n>>> managers ^ engineers\n{'vic', 'bob', 'ann', 'tom'}\n\n# Who is in one but not both?\n\n>>> (managers | engineers) - (managers ^ engineers)\n{'sue'}\n\n# Intersection!\n\nYou can find more details on set operations in the Python library manual and some\nmathematical and relational database theory texts. Also stay tuned for Chapter 8’s\nrevival of some of the set operations we’ve seen here, in the context of dictionary view\nobjects in Python 3.0.",
    "Booleans\nSome argue that the Python Boolean type, bool, is numeric in nature because its two\nvalues, True and False, are just customized versions of the integers 1 and 0 that print\nthemselves differently. Although that’s all most programmers need to know, let’s explore this type in a bit more detail.\nMore formally, Python today has an explicit Boolean data type called bool, with the\nvalues True and False available as new preassigned built-in names. Internally, the names\nTrue and False are instances of bool, which is in turn just a subclass (in the objectoriented sense) of the built-in integer type int. True and False behave exactly like the\nintegers 1 and 0, except that they have customized printing logic—they print themselves as the words True and False, instead of the digits 1 and 0. bool accomplishes this\nby redefining str and repr string formats for its two objects.",
    "integers 1 and 0, except that they have customized printing logic—they print themselves as the words True and False, instead of the digits 1 and 0. bool accomplishes this\nby redefining str and repr string formats for its two objects.\nBecause of this customization, the output of Boolean expressions typed at the interactive prompt prints as the words True and False instead of the older and less obvious 1\nand 0. In addition, Booleans make truth values more explicit. For instance, an infinite\nloop can now be coded as while True: instead of the less intuitive while 1:. Similarly,",
    "Other Numeric Types | 139\n\n\fflags can be initialized more clearly with flag = False. We’ll discuss these statements\nfurther in Part III.\nAgain, though, for all other practical purposes, you can treat True and False as though\nthey are predefined variables set to integer 1 and 0. Most programmers used to preassign\nTrue and False to 1 and 0 anyway; the bool type simply makes this standard. Its implementation can lead to curious results, though. Because True is just the integer 1 with\na custom display format, True + 4 yields 5 in Python:\n>>> type(True)\n<class 'bool'>\n>>> isinstance(True, int)\nTrue\n>>> True == 1\nTrue\n>>> True is 1\nFalse\n>>> True or False\nTrue\n>>> True + 4\n5\n\n# Same value\n# But different object: see the next chapter\n# Same as: 1 or 0\n# (Hmmm)",
    "# Same value\n# But different object: see the next chapter\n# Same as: 1 or 0\n# (Hmmm)\n\nSince you probably won’t come across an expression like the last of these in real Python\ncode, you can safely ignore its deeper metaphysical implications....\nWe’ll revisit Booleans in Chapter 9 (to define Python’s notion of truth) and again in\nChapter 12 (to see how Boolean operators like and and or work).",
    "Numeric Extensions\nFinally, although Python core numeric types offer plenty of power for most applications, there is a large library of third-party open source extensions available to address\nmore focused needs. Because numeric programming is a popular domain for Python,\nyou’ll find a wealth of advanced tools.\nFor example, if you need to do serious number crunching, an optional extension for\nPython called NumPy (Numeric Python) provides advanced numeric programming\ntools, such as a matrix data type, vector processing, and sophisticated computation\nlibraries. Hardcore scientific programming groups at places like Los Alamos and NASA\nuse Python with NumPy to implement the sorts of tasks they previously coded in\nC++, FORTRAN, or Matlab. The combination of Python and NumPy is often compared to a free, more flexible version of Matlab—you get NumPy’s performance, plus\nthe Python language and its libraries.\nBecause it’s so advanced, we won’t talk further about NumPy in this book. You can",
    "use Python with NumPy to implement the sorts of tasks they previously coded in\nC++, FORTRAN, or Matlab. The combination of Python and NumPy is often compared to a free, more flexible version of Matlab—you get NumPy’s performance, plus\nthe Python language and its libraries.\nBecause it’s so advanced, we won’t talk further about NumPy in this book. You can\nfind additional support for advanced numeric programming in Python, including\ngraphics and plotting tools, statistics libraries, and the popular SciPy package at Python’s PyPI site, or by searching the Web. Also note that NumPy is currently an optional\nextension; it doesn’t come with Python and must be installed separately.",
    "140 | Chapter 5: Numeric Types\n\n\fChapter Summary\nThis chapter has taken a tour of Python’s numeric object types and the operations we\ncan apply to them. Along the way, we met the standard integer and floating-point types,\nas well as some more exotic and less commonly used types such as complex numbers,\nfractions, and sets. We also explored Python’s expression syntax, type conversions,\nbitwise operations, and various literal forms for coding numbers in scripts.\nLater in this part of the book, I’ll fill in some details about the next object type, the\nstring. In the next chapter, however, we’ll take some time to explore the mechanics of\nvariable assignment in more detail than we have here. This turns out to be perhaps the\nmost fundamental idea in Python, so make sure you check out the next chapter before\nmoving on. First, though, it’s time to take the usual chapter quiz.",
    "Test Your Knowledge: Quiz\n1. What is the value of the expression 2 * (3 + 4) in Python?\n2. What is the value of the expression 2 * 3 + 4 in Python?\n3. What is the value of the expression 2 + 3 * 4 in Python?\n4. What tools can you use to find a number’s square root, as well as its square?\n5. What is the type of the result of the expression 1 + 2.0 + 3?\n6. How can you truncate and round a floating-point number?\n7. How can you convert an integer to a floating-point number?\n8. How would you display an integer in octal, hexadecimal, or binary notation?\n9. How might you convert an octal, hexadecimal, or binary string to a plain integer?",
    "Test Your Knowledge: Answers\n1. The value will be 14, the result of 2 * 7, because the parentheses force the addition\nto happen before the multiplication.\n2. The value will be 10, the result of 6 + 4. Python’s operator precedence rules are\napplied in the absence of parentheses, and multiplication has higher precedence\nthan (i.e., happens before) addition, per Table 5-2.\n3. This expression yields 14, the result of 2 + 12, for the same precedence reasons as\nin the prior question.\n4. Functions for obtaining the square root, as well as pi, tangents, and more, are\navailable in the imported math module. To find a number’s square root, import\nmath and call math.sqrt(N). To get a number’s square, use either the exponent\n\nTest Your Knowledge: Answers | 141",
    "expression X ** 2 or the built-in function pow(X, 2). Either of these last two can\nalso compute the square root when given a power of 0.5 (e.g., X ** .5).\n5. The result will be a floating-point number: the integers are converted up to floating\npoint, the most complex type in the expression, and floating-point math is used to\nevaluate it.\n6. The int(N) and math.trunc(N) functions truncate, and the round(N, digits) function rounds. We can also compute the floor with math.floor(N) and round for\ndisplay with string formatting operations.\n7. The float(I) function converts an integer to a floating point; mixing an integer\nwith a floating point within an expression will result in a conversion as well. In\nsome sense, Python 3.0 / division converts too—it always returns a floating-point\nresult that includes the remainder, even if both operands are integers.\n8. The oct(I) and hex(I) built-in functions return the octal and hexadecimal string",
    "with a floating point within an expression will result in a conversion as well. In\nsome sense, Python 3.0 / division converts too—it always returns a floating-point\nresult that includes the remainder, even if both operands are integers.\n8. The oct(I) and hex(I) built-in functions return the octal and hexadecimal string\nforms for an integer. The bin(I) call also returns a number’s binary digits string in\nPython 2.6 and 3.0. The % string formatting expression and format string method\nalso provide targets for some such conversions.\n9. The int(S, base) function can be used to convert from octal and hexadecimal\nstrings to normal integers (pass in 8, 16, or 2 for the base). The eval(S) function\ncan be used for this purpose too, but it’s more expensive to run and can have\nsecurity issues. Note that integers are always stored in binary in computer memory;\nthese are just display string format conversions.",
    "142 | Chapter 5: Numeric Types\n\n\fCHAPTER 6\n\nThe Dynamic Typing Interlude\n\nIn the prior chapter, we began exploring Python’s core object types in depth with a\nlook at Python numbers. We’ll resume our object type tour in the next chapter, but\nbefore we move on, it’s important that you get a handle on what may be the most\nfundamental idea in Python programming and is certainly the basis of much of both\nthe conciseness and flexibility of the Python language—dynamic typing, and the polymorphism it yields.\nAs you’ll see here and later in this book, in Python, we do not declare the specific types\nof the objects our scripts use. In fact, programs should not even care about specific\ntypes; in exchange, they are naturally applicable in more contexts than we can sometimes even plan ahead for. Because dynamic typing is the root of this flexibility, let’s\ntake a brief look at the model here.",
    "The Case of the Missing Declaration Statements\nIf you have a background in compiled or statically typed languages like C, C++, or Java,\nyou might find yourself a bit perplexed at this point in the book. So far, we’ve been\nusing variables without declaring their existence or their types, and it somehow works.\nWhen we type a = 3 in an interactive session or program file, for instance, how does\nPython know that a should stand for an integer? For that matter, how does Python\nknow what a is at all?\nOnce you start asking such questions, you’ve crossed over into the domain of Python’s\ndynamic typing model. In Python, types are determined automatically at runtime, not\nin response to declarations in your code. This means that you never declare variables\nahead of time (a concept that is perhaps simpler to grasp if you keep in mind that it all\nboils down to variables, objects, and the links between them).\n\n143",
    "Variables, Objects, and References\nAs you’ve seen in many of the examples used so far in this book, when you run an\nassignment statement such as a = 3 in Python, it works even if you’ve never told Python\nto use the name a as a variable, or that a should stand for an integer-type object. In the\nPython language, this all pans out in a very natural way, as follows:\nVariable creation\nA variable (i.e., name), like a, is created when your code first assigns it a value.\nFuture assignments change the value of the already created name. Technically,\nPython detects some names before your code runs, but you can think of it as though\ninitial assignments make variables.\nVariable types\nA variable never has any type information or constraints associated with it. The\nnotion of type lives with objects, not names. Variables are generic in nature; they\nalways simply refer to a particular object at a particular point in time.\nVariable use",
    "Python detects some names before your code runs, but you can think of it as though\ninitial assignments make variables.\nVariable types\nA variable never has any type information or constraints associated with it. The\nnotion of type lives with objects, not names. Variables are generic in nature; they\nalways simply refer to a particular object at a particular point in time.\nVariable use\nWhen a variable appears in an expression, it is immediately replaced with the object\nthat it currently refers to, whatever that may be. Further, all variables must be\nexplicitly assigned before they can be used; referencing unassigned variables results\nin errors.\nIn sum, variables are created when assigned, can reference any type of object, and must\nbe assigned before they are referenced. This means that you never need to declare names\nused by your script, but you must initialize names before you can update them; counters, for example, must be initialized to zero before you can add to them.",
    "in errors.\nIn sum, variables are created when assigned, can reference any type of object, and must\nbe assigned before they are referenced. This means that you never need to declare names\nused by your script, but you must initialize names before you can update them; counters, for example, must be initialized to zero before you can add to them.\nThis dynamic typing model is strikingly different from the typing model of traditional\nlanguages. When you are first starting out, the model is usually easier to understand if\nyou keep clear the distinction between names and objects. For example, when we say\nthis:\n>>> a = 3",
    "at least conceptually, Python will perform three distinct steps to carry out the request.\nThese steps reflect the operation of all assignments in the Python language:\n1. Create an object to represent the value 3.\n2. Create the variable a, if it does not yet exist.\n3. Link the variable a to the new object 3.\nThe net result will be a structure inside Python that resembles Figure 6-1. As sketched,\nvariables and objects are stored in different parts of memory and are associated by links\n(the link is shown as a pointer in the figure). Variables always link to objects and never\nto other variables, but larger objects may link to other objects (for instance, a list object\nhas links to the objects it contains).\n\n144 | Chapter 6: The Dynamic Typing Interlude\n\n\fFigure 6-1. Names and objects after running the assignment a = 3. Variable a becomes a reference to\nthe object 3. Internally, the variable is really a pointer to the object’s memory space created by running\nthe literal expression 3.",
    "These links from variables to objects are called references in Python—that is, a reference\nis a kind of association, implemented as a pointer in memory.* Whenever the variables\nare later used (i.e., referenced), Python automatically follows the variable-to-object\nlinks. This is all simpler than the terminology may imply. In concrete terms:\n• Variables are entries in a system table, with spaces for links to objects.\n• Objects are pieces of allocated memory, with enough space to represent the values\nfor which they stand.\n• References are automatically followed pointers from variables to objects.\nAt least conceptually, each time you generate a new value in your script by running an\nexpression, Python creates a new object (i.e., a chunk of memory) to represent that\nvalue. Internally, as an optimization, Python caches and reuses certain kinds of unchangeable objects, such as small integers and strings (each 0 is not really a new piece",
    "At least conceptually, each time you generate a new value in your script by running an\nexpression, Python creates a new object (i.e., a chunk of memory) to represent that\nvalue. Internally, as an optimization, Python caches and reuses certain kinds of unchangeable objects, such as small integers and strings (each 0 is not really a new piece\nof memory—more on this caching behavior later). But, from a logical perspective, it\nworks as though each expression’s result value is a distinct object and each object is a\ndistinct piece of memory.\nTechnically speaking, objects have more structure than just enough space to represent\ntheir values. Each object also has two standard header fields: a type designator used to\nmark the type of the object, and a reference counter used to determine when it’s OK to\nreclaim the object. To understand how these two header fields factor into the model,\nwe need to move on.",
    "Types Live with Objects, Not Variables\nTo see how object types come into play, watch what happens if we assign a variable\nmultiple times:\n\n* Readers with a background in C may find Python references similar to C pointers (memory addresses). In\nfact, references are implemented as pointers, and they often serve the same roles, especially with objects that\ncan be changed in-place (more on this later). However, because references are always automatically\ndereferenced when used, you can never actually do anything useful with a reference itself; this is a feature\nthat eliminates a vast category of C bugs. You can think of Python references as C “void*” pointers, which\nare automatically followed whenever used.\n\nThe Case of the Missing Declaration Statements | 145\n\n\f>>> a = 3\n>>> a = 'spam'\n>>> a = 1.23\n\n# It's an integer\n# Now it's a string\n# Now it's a floating point",
    "This isn’t typical Python code, but it does work—a starts out as an integer, then becomes a string, and finally becomes a floating-point number. This example tends to\nlook especially odd to ex-C programmers, as it appears as though the type of a changes\nfrom integer to string when we say a = 'spam'.\nHowever, that’s not really what’s happening. In Python, things work more simply.\nNames have no types; as stated earlier, types live with objects, not names. In the preceding listing, we’ve simply changed a to reference different objects. Because variables\nhave no type, we haven’t actually changed the type of the variable a; we’ve simply made\nthe variable reference a different type of object. In fact, again, all we can ever say about\na variable in Python is that it references a particular object at a particular point in time.\nObjects, on the other hand, know what type they are—each object contains a header",
    "have no type, we haven’t actually changed the type of the variable a; we’ve simply made\nthe variable reference a different type of object. In fact, again, all we can ever say about\na variable in Python is that it references a particular object at a particular point in time.\nObjects, on the other hand, know what type they are—each object contains a header\nfield that tags the object with its type. The integer object 3, for example, will contain\nthe value 3, plus a designator that tells Python that the object is an integer (strictly\nspeaking, a pointer to an object called int, the name of the integer type). The type\ndesignator of the 'spam' string object points to the string type (called str) instead.\nBecause objects know their types, variables don’t have to.\nTo recap, types are associated with objects in Python, not with variables. In typical\ncode, a given variable usually will reference just one kind of object. Because this isn’t",
    "designator of the 'spam' string object points to the string type (called str) instead.\nBecause objects know their types, variables don’t have to.\nTo recap, types are associated with objects in Python, not with variables. In typical\ncode, a given variable usually will reference just one kind of object. Because this isn’t\na requirement, though, you’ll find that Python code tends to be much more flexible\nthan you may be accustomed to—if you use Python well, your code might work on\nmany types automatically.\nI mentioned that objects have two header fields, a type designator and a reference\ncounter. To understand the latter of these, we need to move on and take a brief look\nat what happens at the end of an object’s life.",
    "Objects Are Garbage-Collected\nIn the prior section’s listings, we assigned the variable a to different types of objects in\neach assignment. But when we reassign a variable, what happens to the value it was\npreviously referencing? For example, after the following statements, what happens to\nthe object 3?\n>>> a = 3\n>>> a = 'spam'\n\nThe answer is that in Python, whenever a name is assigned to a new object, the space\nheld by the prior object is reclaimed (if it is not referenced by any other name or object).\nThis automatic reclamation of objects’ space is known as garbage collection.\nTo illustrate, consider the following example, which sets the name x to a different object\non each assignment:\n\n146 | Chapter 6: The Dynamic Typing Interlude\n\n\f>>> x = 42\n>>> x = 'shrubbery'\n>>> x = 3.1415\n>>> x = [1, 2, 3]\n\n# Reclaim 42 now (unless referenced elsewhere)\n# Reclaim 'shrubbery' now\n# Reclaim 3.1415 now",
    "First, notice that x is set to a different type of object each time. Again, though this is\nnot really the case, the effect is as though the type of x is changing over time. Remember,\nin Python types live with objects, not names. Because names are just generic references\nto objects, this sort of code works naturally.\nSecond, notice that references to objects are discarded along the way. Each time x is\nassigned to a new object, Python reclaims the prior object’s space. For instance, when\nit is assigned the string 'shrubbery', the object 42 is immediately reclaimed (assuming\nit is not referenced anywhere else)—that is, the object’s space is automatically thrown\nback into the free space pool, to be reused for a future object.\nInternally, Python accomplishes this feat by keeping a counter in every object that keeps\ntrack of the number of references currently pointing to that object. As soon as (and\nexactly when) this counter drops to zero, the object’s memory space is automatically",
    "back into the free space pool, to be reused for a future object.\nInternally, Python accomplishes this feat by keeping a counter in every object that keeps\ntrack of the number of references currently pointing to that object. As soon as (and\nexactly when) this counter drops to zero, the object’s memory space is automatically\nreclaimed. In the preceding listing, we’re assuming that each time x is assigned to a new\nobject, the prior object’s reference counter drops to zero, causing it to be reclaimed.\nThe most immediately tangible benefit of garbage collection is that it means you can\nuse objects liberally without ever needing to free up space in your script. Python will\nclean up unused space for you as your program runs. In practice, this eliminates a\nsubstantial amount of bookkeeping code required in lower-level languages such as C\nand C++.\nTechnically speaking, Python’s garbage collection is based mainly upon\nreference counters, as described here; however, it also has a component",
    "clean up unused space for you as your program runs. In practice, this eliminates a\nsubstantial amount of bookkeeping code required in lower-level languages such as C\nand C++.\nTechnically speaking, Python’s garbage collection is based mainly upon\nreference counters, as described here; however, it also has a component\nthat detects and reclaims objects with cyclic references in time. This\ncomponent can be disabled if you’re sure that your code doesn’t create\ncycles, but it is enabled by default.\nBecause references are implemented as pointers, it’s possible for an object to reference itself, or reference another object that does. For example, exercise 3 at the end of Part I and its solution in Appendix B show\nhow to create a cycle by embedding a reference to a list within itself.\nThe same phenomenon can occur for assignments to attributes of objects created from user-defined classes. Though relatively rare, because\nthe reference counts for such objects never drop to zero, they must be",
    "how to create a cycle by embedding a reference to a list within itself.\nThe same phenomenon can occur for assignments to attributes of objects created from user-defined classes. Though relatively rare, because\nthe reference counts for such objects never drop to zero, they must be\ntreated specially.\nFor more details on Python’s cycle detector, see the documentation for\nthe gc module in Python’s library manual. Also note that this description\nof Python’s garbage collector applies to the standard CPython only; Jython and IronPython may use different schemes, though the net effect\nin all is similar—unused space is reclaimed for you automatically.",
    "The Case of the Missing Declaration Statements | 147\n\n\fShared References\nSo far, we’ve seen what happens as a single variable is assigned references to objects.\nNow let’s introduce another variable into our interaction and watch what happens to\nits names and objects:\n>>> a = 3\n>>> b = a\n\nTyping these two statements generates the scene captured in Figure 6-2. The second\nline causes Python to create the variable b; the variable a is being used and not assigned\nhere, so it is replaced with the object it references (3), and b is made to reference that\nobject. The net effect is that the variables a and b wind up referencing the same object\n(that is, pointing to the same chunk of memory). This scenario, with multiple names\nreferencing the same object, is called a shared reference in Python.",
    "Figure 6-2. Names and objects after next running the assignment b = a. Variable b becomes a reference\nto the object 3. Internally, the variable is really a pointer to the object’s memory space created by\nrunning the literal expression 3.\n\nNext, suppose we extend the session with one more statement:\n>>> a = 3\n>>> b = a\n>>> a = 'spam'\n\nAs with all Python assignments, this statement simply makes a new object to represent\nthe string value 'spam' and sets a to reference this new object. It does not, however,\nchange the value of b; b still references the original object, the integer 3. The resulting\nreference structure is shown in Figure 6-3.\nThe same sort of thing would happen if we changed b to 'spam' instead—the assignment\nwould change only b, not a. This behavior also occurs if there are no type differences\nat all. For example, consider these three statements:\n>>> a = 3\n>>> b = a\n>>> a = a + 2\n\n148 | Chapter 6: The Dynamic Typing Interlude",
    "148 | Chapter 6: The Dynamic Typing Interlude\n\n\fFigure 6-3. Names and objects after finally running the assignment a = ‘spam’. Variable a references\nthe new object (i.e., piece of memory) created by running the literal expression ‘spam’, but variable b\nstill refers to the original object 3. Because this assignment is not an in-place change to the object 3,\nit changes only variable a, not b.",
    "In this sequence, the same events transpire. Python makes the variable a reference the\nobject 3 and makes b reference the same object as a, as in Figure 6-2; as before, the last\nassignment then sets a to a completely different object (in this case, the integer 5, which\nis the result of the + expression). It does not change b as a side effect. In fact, there is\nno way to ever overwrite the value of the object 3—as introduced in Chapter 4, integers\nare immutable and thus can never be changed in-place.\nOne way to think of this is that, unlike in some languages, in Python variables are always\npointers to objects, not labels of changeable memory areas: setting a variable to a new\nvalue does not alter the original object, but rather causes the variable to reference an\nentirely different object. The net effect is that assignment to a variable can impact only\nthe single variable being assigned. When mutable objects and in-place changes enter",
    "pointers to objects, not labels of changeable memory areas: setting a variable to a new\nvalue does not alter the original object, but rather causes the variable to reference an\nentirely different object. The net effect is that assignment to a variable can impact only\nthe single variable being assigned. When mutable objects and in-place changes enter\nthe equation, though, the picture changes somewhat; to see how, let’s move on.",
    "Shared References and In-Place Changes\nAs you’ll see later in this part’s chapters, there are objects and operations that perform\nin-place object changes. For instance, an assignment to an offset in a list actually\nchanges the list object itself in-place, rather than generating a brand new list object.\nFor objects that support such in-place changes, you need to be more aware of shared\nreferences, since a change from one name may impact others.\nTo further illustrate, let’s take another look at the list objects introduced in Chapter 4. Recall that lists, which do support in-place assignments to positions, are simply\ncollections of other objects, coded in square brackets:\n>>> L1 = [2, 3, 4]\n>>> L2 = L1\n\nShared References | 149\n\n\fL1 here is a list containing the objects 2, 3, and 4. Items inside a list are accessed by their\npositions, so L1[0] refers to object 2, the first item in the list L1. Of course, lists are also",
    "Shared References | 149\n\n\fL1 here is a list containing the objects 2, 3, and 4. Items inside a list are accessed by their\npositions, so L1[0] refers to object 2, the first item in the list L1. Of course, lists are also\n\nobjects in their own right, just like integers and strings. After running the two prior\nassignments, L1 and L2 reference the same object, just like a and b in the prior example\n(see Figure 6-2). Now say that, as before, we extend this interaction to say the following:\n>>> L1 = 24\n\nThis assignment simply sets L1 is to a different object; L2 still references the original\nlist. If we change this statement’s syntax slightly, however, it has a radically different\neffect:\n>>> L1 = [2, 3, 4]\n>>> L2 = L1\n>>> L1[0] = 24\n\n# A mutable object\n# Make a reference to the same object\n# An in-place change\n\n>>> L1\n[24, 3, 4]\n>>> L2\n[24, 3, 4]\n\n# L1 is different\n# But so is L2!",
    "Really, we haven’t changed L1 itself here; we’ve changed a component of the object that\nL1 references. This sort of change overwrites part of the list object in-place. Because the\nlist object is shared by (referenced from) other variables, though, an in-place change\nlike this doesn’t only affect L1—that is, you must be aware that when you make such\nchanges, they can impact other parts of your program. In this example, the effect shows\nup in L2 as well because it references the same object as L1. Again, we haven’t actually\nchanged L2, either, but its value will appear different because it has been overwritten.\nThis behavior is usually what you want, but you should be aware of how it works, so\nthat it’s expected. It’s also just the default: if you don’t want such behavior, you can\nrequest that Python copy objects instead of making references. There are a variety of\nways to copy a list, including using the built-in list function and the standard library",
    "This behavior is usually what you want, but you should be aware of how it works, so\nthat it’s expected. It’s also just the default: if you don’t want such behavior, you can\nrequest that Python copy objects instead of making references. There are a variety of\nways to copy a list, including using the built-in list function and the standard library\ncopy module. Perhaps the most common way is to slice from start to finish (see Chapters\n4 and 7 for more on slicing):\n>>> L1 = [2, 3, 4]\n>>> L2 = L1[:]\n>>> L1[0] = 24\n>>> L1\n[24, 3, 4]\n>>> L2\n[2, 3, 4]",
    "# Make a copy of L1\n\n# L2 is not changed\n\nHere, the change made through L1 is not reflected in L2 because L2 references a copy\nof the object L1 references; that is, the two variables point to different pieces of memory.\n\n150 | Chapter 6: The Dynamic Typing Interlude\n\n\fNote that this slicing technique won’t work on the other major mutable core types,\ndictionaries and sets, because they are not sequences—to copy a dictionary or set,\ninstead use their X.copy() method call. Also, note that the standard library copy module\nhas a call for copying any object type generically, as well as a call for copying nested\nobject structures (a dictionary with nested lists, for example):\nimport copy\nX = copy.copy(Y)\nX = copy.deepcopy(Y)\n\n# Make top-level \"shallow\" copy of any object Y\n# Make deep copy of any object Y: copy all nested parts",
    "# Make top-level \"shallow\" copy of any object Y\n# Make deep copy of any object Y: copy all nested parts\n\nWe’ll explore lists and dictionaries in more depth, and revisit the concept of shared\nreferences and copies, in Chapters 8 and 9. For now, keep in mind that objects that can\nbe changed in-place (that is, mutable objects) are always open to these kinds of effects.\nIn Python, this includes lists, dictionaries, and some objects defined with class statements. If this is not the desired behavior, you can simply copy your objects as needed.\n\nShared References and Equality\nIn the interest of full disclosure, I should point out that the garbage-collection behavior\ndescribed earlier in this chapter may be more conceptual than literal for certain types.\nConsider these statements:\n>>> x = 42\n>>> x = 'shrubbery'\n\n# Reclaim 42 now?",
    "Shared References and Equality\nIn the interest of full disclosure, I should point out that the garbage-collection behavior\ndescribed earlier in this chapter may be more conceptual than literal for certain types.\nConsider these statements:\n>>> x = 42\n>>> x = 'shrubbery'\n\n# Reclaim 42 now?\n\nBecause Python caches and reuses small integers and small strings, as mentioned earlier,\nthe object 42 here is probably not literally reclaimed; instead, it will likely remain in a\nsystem table to be reused the next time you generate a 42 in your code. Most kinds of\nobjects, though, are reclaimed immediately when they are no longer referenced; for\nthose that are not, the caching mechanism is irrelevant to your code.\nFor instance, because of Python’s reference model, there are two different ways to check\nfor equality in a Python program. Let’s create a shared reference to demonstrate:\n>>> L = [1, 2, 3]\n>>> M = L\n>>> L == M\nTrue\n>>> L is M\nTrue",
    "# M and L reference the same object\n# Same value\n# Same object\n\nThe first technique here, the == operator, tests whether the two referenced objects have\nthe same values; this is the method almost always used for equality checks in Python.\nThe second method, the is operator, instead tests for object identity—it returns True\nonly if both names point to the exact same object, so it is a much stronger form of\nequality testing.\n\nShared References | 151\n\n\fReally, is simply compares the pointers that implement references, and it serves as a\nway to detect shared references in your code if needed. It returns False if the names\npoint to equivalent but different objects, as is the case when we run two different literal\nexpressions:\n>>> L = [1, 2, 3]\n>>> M = [1, 2, 3]\n>>> L == M\nTrue\n>>> L is M\nFalse\n\n# M and L reference different objects\n# Same values\n# Different objects",
    "# M and L reference different objects\n# Same values\n# Different objects\n\nNow, watch what happens when we perform the same operations on small numbers:\n>>> X = 42\n>>> Y = 42\n>>> X == Y\nTrue\n>>> X is Y\nTrue\n\n# Should be two different objects\n# Same object anyhow: caching at work!\n\nIn this interaction, X and Y should be == (same value), but not is (same object) because\nwe ran two different literal expressions. Because small integers and strings are cached\nand reused, though, is tells us they reference the same single object.\nIn fact, if you really want to look under the hood, you can always ask Python how many\nreferences there are to an object: the getrefcount function in the standard sys module\nreturns the object’s reference count. When I ask about the integer object 1 in the IDLE\nGUI, for instance, it reports 837 reuses of this same object (most of which are in IDLE’s\nsystem code, not mine):\n>>> import sys\n>>> sys.getrefcount(1)\n837\n\n# 837 pointers to this shared piece of memory",
    "# 837 pointers to this shared piece of memory\n\nThis object caching and reuse is irrelevant to your code (unless you run the is check!).\nBecause you cannot change numbers or strings in-place, it doesn’t matter how many\nreferences there are to the same object. Still, this behavior reflects one of the many ways\nPython optimizes its model for execution speed.",
    "Dynamic Typing Is Everywhere\nOf course, you don’t really need to draw name/object diagrams with circles and arrows\nto use Python. When you’re starting out, though, it sometimes helps you understand\nunusual cases if you can trace their reference structures. If a mutable object changes\nout from under you when passed around your program, for example, chances are you\nare witnessing some of this chapter’s subject matter firsthand.\nMoreover, even if dynamic typing seems a little abstract at this point, you probably will\ncare about it eventually. Because everything seems to work by assignment and\nreferences in Python, a basic understanding of this model is useful in many different\n152 | Chapter 6: The Dynamic Typing Interlude",
    "contexts. As you’ll see, it works the same in assignment statements, function arguments, for loop variables, module imports, class attributes, and more. The good news\nis that there is just one assignment model in Python; once you get a handle on dynamic\ntyping, you’ll find that it works the same everywhere in the language.\nAt the most practical level, dynamic typing means there is less code for you to write.\nJust as importantly, though, dynamic typing is also the root of Python’s polymorphism, a concept we introduced in Chapter 4 and will revisit again later in this book.\nBecause we do not constrain types in Python code, it is highly flexible. As you’ll see,\nwhen used well, dynamic typing and the polymorphism it provides produce code that\nautomatically adapts to new requirements as your systems evolve.",
    "Chapter Summary\nThis chapter took a deeper look at Python’s dynamic typing model—that is, the way\nthat Python keeps track of object types for us automatically, rather than requiring us\nto code declaration statements in our scripts. Along the way, we learned how variables\nand objects are associated by references in Python; we also explored the idea of garbage\ncollection, learned how shared references to objects can affect multiple variables, and\nsaw how references impact the notion of equality in Python.\nBecause there is just one assignment model in Python, and because assignment pops\nup everywhere in the language, it’s important that you have a handle on the model\nbefore moving on. The following quiz should help you review some of this chapter’s\nideas. After that, we’ll resume our object tour in the next chapter, with strings.\n\nTest Your Knowledge: Quiz\n1. Consider the following three statements. Do they change the value printed for A?\nA = \"spam\"\nB = A\nB = \"shrubbery\"",
    "Test Your Knowledge: Quiz\n1. Consider the following three statements. Do they change the value printed for A?\nA = \"spam\"\nB = A\nB = \"shrubbery\"\n\n2. Consider these three statements. Do they change the printed value of A?\nA = [\"spam\"]\nB = A\nB[0] = \"shrubbery\"\n\n3. How about these—is A changed now?\nA = [\"spam\"]\nB = A[:]\nB[0] = \"shrubbery\"\n\nTest Your Knowledge: Quiz | 153",
    "Test Your Knowledge: Answers\n1. No: A still prints as \"spam\". When B is assigned to the string \"shrubbery\", all that\nhappens is that the variable B is reset to point to the new string object. A and B\ninitially share (i.e., reference/point to) the same single string object \"spam\", but two\nnames are never linked together in Python. Thus, setting B to a different object has\nno effect on A. The same would be true if the last statement here was B = B +\n'shrubbery', by the way—the concatenation would make a new object for its result,\nwhich would then be assigned to B only. We can never overwrite a string (or number, or tuple) in-place, because strings are immutable.\n2. Yes: A now prints as [\"shrubbery\"]. Technically, we haven’t really changed either\nA or B; instead, we’ve changed part of the object they both reference (point to) by\noverwriting that object in-place through the variable B. Because A references the\nsame object as B, the update is reflected in A as well.",
    "2. Yes: A now prints as [\"shrubbery\"]. Technically, we haven’t really changed either\nA or B; instead, we’ve changed part of the object they both reference (point to) by\noverwriting that object in-place through the variable B. Because A references the\nsame object as B, the update is reflected in A as well.\n3. No: A still prints as [\"spam\"]. The in-place assignment through B has no effect this\ntime because the slice expression made a copy of the list object before it was assigned to B. After the second assignment statement, there are two different list\nobjects that have the same value (in Python, we say they are ==, but not is). The\nthird statement changes the value of the list object pointed to by B, but not that\npointed to by A.",
    "154 | Chapter 6: The Dynamic Typing Interlude\n\n\fCHAPTER 7\n\nStrings",
    "The next major type on our built-in object tour is the Python string—an ordered collection of characters used to store and represent text-based information. We looked\nbriefly at strings in Chapter 4. Here, we will revisit them in more depth, filling in some\nof the details we skipped then.\nFrom a functional perspective, strings can be used to represent just about anything that\ncan be encoded as text: symbols and words (e.g., your name), contents of text files\nloaded into memory, Internet addresses, Python programs, and so on. They can also\nbe used to hold the absolute binary values of bytes, and multibyte Unicode text used\nin internationalized programs.\nYou may have used strings in other languages, too. Python’s strings serve the same role\nas character arrays in languages such as C, but they are a somewhat higher-level tool\nthan arrays. Unlike in C, in Python, strings come with a powerful set of processing",
    "be used to hold the absolute binary values of bytes, and multibyte Unicode text used\nin internationalized programs.\nYou may have used strings in other languages, too. Python’s strings serve the same role\nas character arrays in languages such as C, but they are a somewhat higher-level tool\nthan arrays. Unlike in C, in Python, strings come with a powerful set of processing\ntools. Also unlike languages such as C, Python has no distinct type for individual characters; instead, you just use one-character strings.\nStrictly speaking, Python strings are categorized as immutable sequences, meaning that\nthe characters they contain have a left-to-right positional order and that they cannot\nbe changed in-place. In fact, strings are the first representative of the larger class of\nobjects called sequences that we will study here. Pay special attention to the sequence",
    "Strictly speaking, Python strings are categorized as immutable sequences, meaning that\nthe characters they contain have a left-to-right positional order and that they cannot\nbe changed in-place. In fact, strings are the first representative of the larger class of\nobjects called sequences that we will study here. Pay special attention to the sequence\noperations introduced in this chapter, because they will work the same on other sequence types we’ll explore later, such as lists and tuples.\nTable 7-1 previews common string literals and operations we will discuss in this chapter. Empty strings are written as a pair of quotation marks (single or double) with\nnothing in between, and there are a variety of ways to code strings. For processing,\nstrings support expression operations such as concatenation (combining strings), slicing (extracting sections), indexing (fetching by offset), and so on. Besides expressions,",
    "nothing in between, and there are a variety of ways to code strings. For processing,\nstrings support expression operations such as concatenation (combining strings), slicing (extracting sections), indexing (fetching by offset), and so on. Besides expressions,\nPython also provides a set of string methods that implement common string-specific\ntasks, as well as modules for more advanced text-processing tasks such as pattern\nmatching. We’ll explore all of these later in the chapter.",
    "155\n\n\fTable 7-1. Common string literals and operations\nOperation\n\nInterpretation\n\nS = ''\n\nEmpty string\n\nS = \"spam's\"\n\nDouble quotes, same as single\n\nS = 's\\np\\ta\\x00m'\n\nEscape sequences\n\nS = \"\"\"...\"\"\"\n\nTriple-quoted block strings\n\nS = r'\\temp\\spam'\n\nRaw strings\n\nS = b'spam'\n\nByte strings in 3.0 (Chapter 36)\n\nS = u'spam'\n\nUnicode strings in 2.6 only (Chapter 36)\n\nS1 + S2\n\nConcatenate, repeat\n\nS * 3\nS[i]\n\nIndex, slice, length\n\nS[i:j]\nlen(S)\n\"a %s parrot\" % kind\n\nString formatting expression\n\n\"a {0} parrot\".format(kind)\n\nString formatting method in 2.6 and 3.0\n\nS.find('pa')\n\nString method calls: search,\n\nS.rstrip()\n\nremove whitespace,\n\nS.replace('pa', 'xx')\n\nreplacement,\n\nS.split(',')\n\nsplit on delimiter,\n\nS.isdigit()\n\ncontent test,\n\nS.lower()\n\ncase conversion,\n\nS.endswith('spam')\n\nend test,\n\n'spam'.join(strlist)\n\ndelimiter join,\n\nS.encode('latin-1')\n\nUnicode encoding, etc.\n\nfor x in S: print(x)\n\nIteration, membership\n\n'spam' in S\n[c * 2 for c in S]\nmap(ord, S)",
    "String method calls: search,\n\nS.rstrip()\n\nremove whitespace,\n\nS.replace('pa', 'xx')\n\nreplacement,\n\nS.split(',')\n\nsplit on delimiter,\n\nS.isdigit()\n\ncontent test,\n\nS.lower()\n\ncase conversion,\n\nS.endswith('spam')\n\nend test,\n\n'spam'.join(strlist)\n\ndelimiter join,\n\nS.encode('latin-1')\n\nUnicode encoding, etc.\n\nfor x in S: print(x)\n\nIteration, membership\n\n'spam' in S\n[c * 2 for c in S]\nmap(ord, S)\n\nBeyond the core set of string tools in Table 7-1, Python also supports more advanced\npattern-based string processing with the standard library’s re (regular expression)\nmodule, introduced in Chapter 4, and even higher-level text processing tools such as\nXML parsers, discussed briefly in Chapter 36. This book’s scope, though, is focused\non the fundamentals represented by Table 7-1.\n\n156 | Chapter 7: Strings",
    "To cover the basics, this chapter begins with an overview of string literal forms and\nstring expressions, then moves on to look at more advanced tools such as string methods and formatting. Python comes with many string tools, and we won’t look at them\nall here; the complete story is chronicled in the Python library manual. Our goal here\nis to explore enough commonly used tools to give you a representative sample; methods\nwe won’t see in action here, for example, are largely analogous to those we will.\nContent note: Technically speaking, this chapter tells only part of the\nstring story in Python—the part most programmers need to know. It\npresents the basic str string type, which handles ASCII text and works\nthe same regardless of which version of Python you use. That is, this\nchapter intentionally limits its scope to the string processing essentials\nthat are used in most Python scripts.\nFrom a more formal perspective, ASCII is a simple form of Unicode text.",
    "string story in Python—the part most programmers need to know. It\npresents the basic str string type, which handles ASCII text and works\nthe same regardless of which version of Python you use. That is, this\nchapter intentionally limits its scope to the string processing essentials\nthat are used in most Python scripts.\nFrom a more formal perspective, ASCII is a simple form of Unicode text.\nPython addresses the distinction between text and binary data by including distinct object types:\n• In Python 3.0 there are three string types: str is used for Unicode\ntext (ASCII or otherwise), bytes is used for binary data (including\nencoded text), and bytearray is a mutable variant of bytes.\n• In Python 2.6, unicode strings represent wide Unicode text, and\nstr strings handle both 8-bit text and binary data.\nThe bytearray type is also available as a back-port in 2.6, but not earlier,\nand it’s not as closely bound to binary data as it is in 3.0. Because most",
    "text (ASCII or otherwise), bytes is used for binary data (including\nencoded text), and bytearray is a mutable variant of bytes.\n• In Python 2.6, unicode strings represent wide Unicode text, and\nstr strings handle both 8-bit text and binary data.\nThe bytearray type is also available as a back-port in 2.6, but not earlier,\nand it’s not as closely bound to binary data as it is in 3.0. Because most\nprogrammers don’t need to dig into the details of Unicode encodings or\nbinary data formats, though, I’ve moved all such details to the Advanced\nTopics part of this book, in Chapter 36.\nIf you do need to deal with more advanced string concepts such as alternative character sets or packed binary data and files, see Chapter 36 after reading the material here. For now, we’ll focus on the basic\nstring type and its operations. As you’ll find, the basics we’ll study here\nalso apply directly to the more advanced string types in Python’s toolset.",
    "String Literals\nBy and large, strings are fairly easy to use in Python. Perhaps the most complicated\nthing about them is that there are so many ways to write them in your code:\n• Single quotes: 'spa\"m'\n• Double quotes: \"spa'm\"\n• Triple quotes: '''... spam ...''', \"\"\"... spam ...\"\"\"\n• Escape sequences: \"s\\tp\\na\\0m\"\n• Raw strings: r\"C:\\new\\test.spm\"\n\nString Literals | 157\n\n\f• Byte strings in 3.0 (see Chapter 36): b'sp\\x01am'\n• Unicode strings in 2.6 only (see Chapter 36): u'eggs\\u0020spam'\nThe single- and double-quoted forms are by far the most common; the others serve\nspecialized roles, and we’re postponing discussion of the last two advanced forms until\nChapter 36. Let’s take a quick look at all the other options in turn.",
    "String Literals | 157\n\n\f• Byte strings in 3.0 (see Chapter 36): b'sp\\x01am'\n• Unicode strings in 2.6 only (see Chapter 36): u'eggs\\u0020spam'\nThe single- and double-quoted forms are by far the most common; the others serve\nspecialized roles, and we’re postponing discussion of the last two advanced forms until\nChapter 36. Let’s take a quick look at all the other options in turn.\n\nSingle- and Double-Quoted Strings Are the Same\nAround Python strings, single and double quote characters are interchangeable. That\nis, string literals can be written enclosed in either two single or two double quotes—\nthe two forms work the same and return the same type of object. For example, the\nfollowing two strings are identical, once coded:\n>>> 'shrubbery', \"shrubbery\"\n('shrubbery', 'shrubbery')",
    "The reason for supporting both is that it allows you to embed a quote character of the\nother variety inside a string without escaping it with a backslash. You may embed a\nsingle quote character in a string enclosed in double quote characters, and vice versa:\n>>> 'knight\"s', \"knight's\"\n('knight\"s', \"knight's\")\n\nIncidentally, Python automatically concatenates adjacent string literals in any expression, although it is almost as simple to add a + operator between them to invoke concatenation explicitly (as we’ll see in Chapter 12, wrapping this form in parentheses also\nallows it to span multiple lines):\n>>> title = \"Meaning \" 'of' \" Life\"\n>>> title\n'Meaning of Life'\n\n# Implicit concatenation",
    "Incidentally, Python automatically concatenates adjacent string literals in any expression, although it is almost as simple to add a + operator between them to invoke concatenation explicitly (as we’ll see in Chapter 12, wrapping this form in parentheses also\nallows it to span multiple lines):\n>>> title = \"Meaning \" 'of' \" Life\"\n>>> title\n'Meaning of Life'\n\n# Implicit concatenation\n\nNotice that adding commas between these strings would result in a tuple, not a string.\nAlso notice in all of these outputs that Python prefers to print strings in single quotes,\nunless they embed one. You can also embed quotes by escaping them with backslashes:\n>>> 'knight\\'s', \"knight\\\"s\"\n(\"knight's\", 'knight\"s')\n\nTo understand why, you need to know how escapes work in general.",
    "Notice that adding commas between these strings would result in a tuple, not a string.\nAlso notice in all of these outputs that Python prefers to print strings in single quotes,\nunless they embed one. You can also embed quotes by escaping them with backslashes:\n>>> 'knight\\'s', \"knight\\\"s\"\n(\"knight's\", 'knight\"s')\n\nTo understand why, you need to know how escapes work in general.\n\nEscape Sequences Represent Special Bytes\nThe last example embedded a quote inside a string by preceding it with a backslash.\nThis is representative of a general pattern in strings: backslashes are used to introduce\nspecial byte codings known as escape sequences.\nEscape sequences let us embed byte codes in strings that cannot easily be typed on a\nkeyboard. The character \\, and one or more characters following it in the string literal,\nare replaced with a single character in the resulting string object, which has the binary\n158 | Chapter 7: Strings",
    "value specified by the escape sequence. For example, here is a five-character string that\nembeds a newline and a tab:\n>>> s = 'a\\nb\\tc'\n\nThe two characters \\n stand for a single character—the byte containing the binary value\nof the newline character in your character set (usually, ASCII code 10). Similarly, the\nsequence \\t is replaced with the tab character. The way this string looks when printed\ndepends on how you print it. The interactive echo shows the special characters as\nescapes, but print interprets them instead:\n>>> s\n'a\\nb\\tc'\n>>> print(s)\na\nb\nc\n\nTo be completely sure how many bytes are in this string, use the built-in len function—\nit returns the actual number of bytes in a string, regardless of how it is displayed:\n>>> len(s)\n5",
    "To be completely sure how many bytes are in this string, use the built-in len function—\nit returns the actual number of bytes in a string, regardless of how it is displayed:\n>>> len(s)\n5\n\nThis string is five bytes long: it contains an ASCII a byte, a newline byte, an ASCII b\nbyte, and so on. Note that the original backslash characters are not really stored with\nthe string in memory; they are used to tell Python to store special byte values in the\nstring. For coding such special bytes, Python recognizes a full set of escape code sequences, listed in Table 7-2.\nTable 7-2. String backslash characters\nEscape\n\nMeaning\n\n\\newline\n\nIgnored (continuation line)\n\n\\\\\n\nBackslash (stores one \\)\n\n\\'\n\nSingle quote (stores ')\n\n\\\"\n\nDouble quote (stores \")\n\n\\a\n\nBell\n\n\\b\n\nBackspace\n\n\\f\n\nFormfeed\n\n\\n\n\nNewline (linefeed)\n\n\\r\n\nCarriage return\n\n\\t\n\nHorizontal tab\n\n\\v\n\nVertical tab\n\n\\xhh\n\nCharacter with hex value hh (at most 2 digits)\n\n\\ooo\n\nCharacter with octal value ooo (up to 3 digits)\n\n\\0",
    "Meaning\n\n\\newline\n\nIgnored (continuation line)\n\n\\\\\n\nBackslash (stores one \\)\n\n\\'\n\nSingle quote (stores ')\n\n\\\"\n\nDouble quote (stores \")\n\n\\a\n\nBell\n\n\\b\n\nBackspace\n\n\\f\n\nFormfeed\n\n\\n\n\nNewline (linefeed)\n\n\\r\n\nCarriage return\n\n\\t\n\nHorizontal tab\n\n\\v\n\nVertical tab\n\n\\xhh\n\nCharacter with hex value hh (at most 2 digits)\n\n\\ooo\n\nCharacter with octal value ooo (up to 3 digits)\n\n\\0\n\nNull: binary 0 character (doesn’t end string)\n\nString Literals | 159\n\n\fEscape\n\nMeaning\n\n\\N{ id }\n\nUnicode database ID\n\n\\uhhhh\n\nUnicode 16-bit hex\n\n\\Uhhhhhhhh\n\nUnicode 32-bit hexa\n\n\\other\n\nNot an escape (keeps both \\ and other)\n\na The \\Uhhhh... escape sequence takes exactly eight hexadecimal digits (h); both \\u and \\U can be used only in Unicode string literals.\n\nSome escape sequences allow you to embed absolute binary values into the bytes of a\nstring. For instance, here’s a five-character string that embeds two binary zero bytes\n(coded as octal escapes of one digit):\n>>> s = 'a\\0b\\0c'\n>>> s\n'a\\x00b\\x00c'\n>>> len(s)\n5",
    "a The \\Uhhhh... escape sequence takes exactly eight hexadecimal digits (h); both \\u and \\U can be used only in Unicode string literals.\n\nSome escape sequences allow you to embed absolute binary values into the bytes of a\nstring. For instance, here’s a five-character string that embeds two binary zero bytes\n(coded as octal escapes of one digit):\n>>> s = 'a\\0b\\0c'\n>>> s\n'a\\x00b\\x00c'\n>>> len(s)\n5\n\nIn Python, the zero (null) byte does not terminate a string the way it typically does in\nC. Instead, Python keeps both the string’s length and text in memory. In fact, no character terminates a string in Python. Here’s a string that is all absolute binary escape\ncodes—a binary 1 and 2 (coded in octal), followed by a binary 3 (coded in hexadecimal):\n>>> s = '\\001\\002\\x03'\n>>> s\n'\\x01\\x02\\x03'\n>>> len(s)\n3",
    "Notice that Python displays nonprintable characters in hex, regardless of how they were\nspecified. You can freely combine absolute value escapes and the more symbolic escape\ntypes in Table 7-2. The following string contains the characters “spam”, a tab and\nnewline, and an absolute zero value byte coded in hex:\n>>> S = \"s\\tp\\na\\x00m\"\n>>> S\n's\\tp\\na\\x00m'\n>>> len(S)\n7\n>>> print(S)\ns\np\na m",
    "This becomes more important to know when you process binary data files in Python.\nBecause their contents are represented as strings in your scripts, it’s OK to process\nbinary files that contain any sorts of binary byte values (more on files in Chapter 9).*\n* If you need to care about binary data files, the chief distinction is that you open them in binary mode (using\nopen mode flags with a b, such as 'rb', 'wb', and so on). In Python 3.0, binary file content is a bytes string,\nwith an interface similar to that of normal strings; in 2.6, such content is a normal str string. See also the\nstandard struct module introduced in Chapter 9, which can parse binary data loaded from a file, and the\nextended coverage of binary files and byte strings in Chapter 36.\n\n160 | Chapter 7: Strings",
    "160 | Chapter 7: Strings\n\n\fFinally, as the last entry in Table 7-2 implies, if Python does not recognize the character\nafter a \\ as being a valid escape code, it simply keeps the backslash in the resulting string:\n>>> x = \"C:\\py\\code\"\n>>> x\n'C:\\\\py\\\\code'\n>>> len(x)\n10\n\n# Keeps \\ literally\n\nUnless you’re able to commit all of Table 7-2 to memory, though, you probably\nshouldn’t rely on this behavior.† To code literal backslashes explicitly such that they\nare retained in your strings, double them up (\\\\ is an escape for one \\) or use raw strings;\nthe next section shows how.\n\nRaw Strings Suppress Escapes\nAs we’ve seen, escape sequences are handy for embedding special byte codes within\nstrings. Sometimes, though, the special treatment of backslashes for introducing escapes can lead to trouble. It’s surprisingly common, for instance, to see Python newcomers in classes trying to open a file with a filename argument that looks something\nlike this:\nmyfile = open('C:\\new\\text.dat', 'w')",
    "thinking that they will open a file called text.dat in the directory C:\\new. The problem\nhere is that \\n is taken to stand for a newline character, and \\t is replaced with a tab.\nIn effect, the call tries to open a file named C:(newline)ew(tab)ext.dat, with usually less\nthan stellar results.\nThis is just the sort of thing that raw strings are useful for. If the letter r (uppercase or\nlowercase) appears just before the opening quote of a string, it turns off the escape\nmechanism. The result is that Python retains your backslashes literally, exactly as you\ntype them. Therefore, to fix the filename problem, just remember to add the letter r on\nWindows:\nmyfile = open(r'C:\\new\\text.dat', 'w')\n\nAlternatively, because two backslashes are really an escape sequence for one backslash,\nyou can keep your backslashes by simply doubling them up:\nmyfile = open('C:\\\\new\\\\text.dat', 'w')",
    "Alternatively, because two backslashes are really an escape sequence for one backslash,\nyou can keep your backslashes by simply doubling them up:\nmyfile = open('C:\\\\new\\\\text.dat', 'w')\n\nIn fact, Python itself sometimes uses this doubling scheme when it prints strings with\nembedded backslashes:\n>>> path = r'C:\\new\\text.dat'\n>>> path\n'C:\\\\new\\\\text.dat'\n>>> print(path)\n\n# Show as Python code\n# User-friendly format\n\n† In classes, I’ve met people who have indeed committed most or all of this table to memory; I’d probably think\nthat was really sick, but for the fact that I’m a member of the set, too.\n\nString Literals | 161\n\n\fC:\\new\\text.dat\n>>> len(path)\n15\n\n# String length",
    "As with numeric representation, the default format at the interactive prompt prints\nresults as if they were code, and therefore escapes backslashes in the output. The\nprint statement provides a more user-friendly format that shows that there is actually\nonly one backslash in each spot. To verify this is the case, you can check the result of\nthe built-in len function, which returns the number of bytes in the string, independent\nof display formats. If you count the characters in the print(path) output, you’ll see that\nthere really is just 1 character per backslash, for a total of 15.\nBesides directory paths on Windows, raw strings are also commonly used for regular\nexpressions (text pattern matching, supported with the re module introduced in Chapter 4). Also note that Python scripts can usually use forward slashes in directory paths\non Windows and Unix because Python tries to interpret paths portably (i.e., 'C:/new/",
    "Besides directory paths on Windows, raw strings are also commonly used for regular\nexpressions (text pattern matching, supported with the re module introduced in Chapter 4). Also note that Python scripts can usually use forward slashes in directory paths\non Windows and Unix because Python tries to interpret paths portably (i.e., 'C:/new/\ntext.dat' works when opening files, too). Raw strings are useful if you code paths using\nnative Windows backslashes, though.\nDespite its role, even a raw string cannot end in a single backslash, because the backslash escapes the following quote character—you still\nmust escape the surrounding quote character to embed it in the string.\nThat is, r\"...\\\" is not a valid string literal—a raw string cannot end in\nan odd number of backslashes. If you need to end a raw string with a\nsingle backslash, you can use two and slice off the second\n(r'1\\nb\\tc\\\\'[:-1]), tack one on manually (r'1\\nb\\tc' + '\\\\'), or skip",
    "must escape the surrounding quote character to embed it in the string.\nThat is, r\"...\\\" is not a valid string literal—a raw string cannot end in\nan odd number of backslashes. If you need to end a raw string with a\nsingle backslash, you can use two and slice off the second\n(r'1\\nb\\tc\\\\'[:-1]), tack one on manually (r'1\\nb\\tc' + '\\\\'), or skip\nthe raw string syntax and just double up the backslashes in a normal\nstring ('1\\\\nb\\\\tc\\\\'). All three of these forms create the same eightcharacter string containing three backslashes.",
    "Triple Quotes Code Multiline Block Strings\nSo far, you’ve seen single quotes, double quotes, escapes, and raw strings in action.\nPython also has a triple-quoted string literal format, sometimes called a block string,\nthat is a syntactic convenience for coding multiline text data. This form begins with\nthree quotes (of either the single or double variety), is followed by any number of lines\nof text, and is closed with the same triple-quote sequence that opened it. Single and\ndouble quotes embedded in the string’s text may be, but do not have to be, escaped—\nthe string does not end until Python sees three unescaped quotes of the same kind used\nto start the literal. For example:\n>>> mantra = \"\"\"Always look\n... on the bright\n... side of life.\"\"\"\n>>>\n>>> mantra\n'Always look\\n on the bright\\nside of life.'\n\n162 | Chapter 7: Strings",
    "162 | Chapter 7: Strings\n\n\fThis string spans three lines (in some interfaces, the interactive prompt changes\nto ... on continuation lines; IDLE simply drops down one line). Python collects all the\ntriple-quoted text into a single multiline string, with embedded newline characters\n(\\n) at the places where your code has line breaks. Notice that, as in the literal, the\nsecond line in the result has a leading space, but the third does not—what you type is\ntruly what you get. To see the string with the newlines interpreted, print it instead of\nechoing:\n>>> print(mantra)\nAlways look\non the bright\nside of life.",
    "Triple-quoted strings are useful any time you need multiline text in your program; for\nexample, to embed multiline error messages or HTML or XML code in your source\ncode files. You can embed such blocks directly in your scripts without resorting to\nexternal text files or explicit concatenation and newline characters.\nTriple-quoted strings are also commonly used for documentation strings, which are\nstring literals that are taken as comments when they appear at specific points in your\nfile (more on these later in the book). These don’t have to be triple-quoted blocks, but\nthey usually are to allow for multiline comments.\nFinally, triple-quoted strings are also sometimes used as a “horribly hackish” way to\ntemporarily disable lines of code during development (OK, it’s not really too horrible,\nand it’s actually a fairly common practice). If you wish to turn off a few lines of code\nand run your script again, simply put three quotes above and below them, like this:\nX = 1\n\"\"\"\nimport os",
    "Finally, triple-quoted strings are also sometimes used as a “horribly hackish” way to\ntemporarily disable lines of code during development (OK, it’s not really too horrible,\nand it’s actually a fairly common practice). If you wish to turn off a few lines of code\nand run your script again, simply put three quotes above and below them, like this:\nX = 1\n\"\"\"\nimport os\nprint(os.getcwd())\n\"\"\"\nY = 2",
    "# Disable this code temporarily\n\nI said this was hackish because Python really does make a string out of the lines of code\ndisabled this way, but this is probably not significant in terms of performance. For large\nsections of code, it’s also easier than manually adding hash marks before each line and\nlater removing them. This is especially true if you are using a text editor that does not\nhave support for editing Python code specifically. In Python, practicality often beats\naesthetics.\n\nStrings in Action\nOnce you’ve created a string with the literal expressions we just met, you will almost\ncertainly want to do things with it. This section and the next two demonstrate string\nexpressions, methods, and formatting—the first line of text-processing tools in the\nPython language.\n\nStrings in Action | 163",
    "Strings in Action\nOnce you’ve created a string with the literal expressions we just met, you will almost\ncertainly want to do things with it. This section and the next two demonstrate string\nexpressions, methods, and formatting—the first line of text-processing tools in the\nPython language.\n\nStrings in Action | 163\n\n\fBasic Operations\nLet’s begin by interacting with the Python interpreter to illustrate the basic string operations listed earlier in Table 7-1. Strings can be concatenated using the + operator\nand repeated using the * operator:\n% python\n>>> len('abc')\n3\n>>> 'abc' + 'def'\n'abcdef'\n>>> 'Ni!' * 4\n'Ni!Ni!Ni!Ni!'\n\n# Length: number of items\n# Concatenation: a new string\n# Repetition: like \"Ni!\" + \"Ni!\" + ...",
    "# Length: number of items\n# Concatenation: a new string\n# Repetition: like \"Ni!\" + \"Ni!\" + ...\n\nFormally, adding two string objects creates a new string object, with the contents of its\noperands joined. Repetition is like adding a string to itself a number of times. In both\ncases, Python lets you create arbitrarily sized strings; there’s no need to predeclare\nanything in Python, including the sizes of data structures.‡ The len built-in function\nreturns the length of a string (or any other object with a length).\nRepetition may seem a bit obscure at first, but it comes in handy in a surprising number\nof contexts. For example, to print a line of 80 dashes, you can count up to 80, or let\nPython count for you:\n>>> print('------- ...more... ---')\n>>> print('-' * 80)\n\n# 80 dashes, the hard way\n# 80 dashes, the easy way",
    "# 80 dashes, the hard way\n# 80 dashes, the easy way\n\nNotice that operator overloading is at work here already: we’re using the same + and\n* operators that perform addition and multiplication when using numbers. Python does\nthe correct operation because it knows the types of the objects being added and multiplied. But be careful: the rules aren’t quite as liberal as you might expect. For instance,\nPython doesn’t allow you to mix numbers and strings in + expressions: 'abc'+9 raises\nan error instead of automatically converting 9 to a string.\nAs shown in the last row in Table 7-1, you can also iterate over strings in loops using\nfor statements and test membership for both characters and substrings with the in\nexpression operator, which is essentially a search. For substrings, in is much like the\nstr.find() method covered later in this chapter, but it returns a Boolean result instead\nof the substring’s position:\n>>> myjob = \"hacker\"\n>>> for c in myjob: print(c, end=' ')\n...",
    "# Step through items\n\n‡ Unlike with C character arrays, you don’t need to allocate or manage storage arrays when using Python\nstrings; you can simply create string objects as needed and let Python manage the underlying memory space.\nAs discussed in Chapter 6, Python reclaims unused objects’ memory space automatically, using a referencecount garbage-collection strategy. Each object keeps track of the number of names, data structures, etc., that\nreference it; when the count reaches zero, Python frees the object’s space. This scheme means Python doesn’t\nhave to stop and scan all the memory to find unused space to free (an additional garbage component also\ncollects cyclic objects).\n\n164 | Chapter 7: Strings\n\n\fh a c k e r\n>>> \"k\" in myjob\nTrue\n>>> \"z\" in myjob\nFalse\n>>> 'spam' in 'abcspamdef'\nTrue\n\n# Found\n# Not found\n# Substring search, no position returned",
    "164 | Chapter 7: Strings\n\n\fh a c k e r\n>>> \"k\" in myjob\nTrue\n>>> \"z\" in myjob\nFalse\n>>> 'spam' in 'abcspamdef'\nTrue\n\n# Found\n# Not found\n# Substring search, no position returned\n\nThe for loop assigns a variable to successive items in a sequence (here, a string) and\nexecutes one or more statements for each item. In effect, the variable c becomes a cursor\nstepping across the string here. We will discuss iteration tools like these and others\nlisted in Table 7-1 in more detail later in this book (especially in Chapters 14 and 20).",
    "Indexing and Slicing\nBecause strings are defined as ordered collections of characters, we can access their\ncomponents by position. In Python, characters in a string are fetched by indexing—\nproviding the numeric offset of the desired component in square brackets after the\nstring. You get back the one-character string at the specified position.\nAs in the C language, Python offsets start at 0 and end at one less than the length of\nthe string. Unlike C, however, Python also lets you fetch items from sequences such\nas strings using negative offsets. Technically, a negative offset is added to the length of\na string to derive a positive offset. You can also think of negative offsets as counting\nbackward from the end. The following interaction demonstrates:\n>>> S = 'spam'\n>>> S[0], S[−2]\n('s', 'a')\n>>> S[1:3], S[1:], S[:−1]\n('pa', 'pam', 'spa')\n\n# Indexing from front or end\n# Slicing: extract a section",
    "The first line defines a four-character string and assigns it the name S. The next line\nindexes it in two ways: S[0] fetches the item at offset 0 from the left (the one-character\nstring 's'), and S[−2] gets the item at offset 2 back from the end (or equivalently, at\noffset (4 + (–2)) from the front). Offsets and slices map to cells as shown in Figure 7-1.§\nThe last line in the preceding example demonstrates slicing, a generalized form of indexing that returns an entire section, not a single item. Probably the best way to think\nof slicing is that it is a type of parsing (analyzing structure), especially when applied to\nstrings—it allows us to extract an entire section (substring) in a single step. Slices can\nbe used to extract columns of data, chop off leading and trailing text, and more. In fact,\nwe’ll explore slicing in the context of text parsing later in this chapter.\nThe basics of slicing are straightforward. When you index a sequence object such as a",
    "strings—it allows us to extract an entire section (substring) in a single step. Slices can\nbe used to extract columns of data, chop off leading and trailing text, and more. In fact,\nwe’ll explore slicing in the context of text parsing later in this chapter.\nThe basics of slicing are straightforward. When you index a sequence object such as a\nstring on a pair of offsets separated by a colon, Python returns a new object containing\n§ More mathematically minded readers (and students in my classes) sometimes detect a small asymmetry here:\nthe leftmost item is at offset 0, but the rightmost is at offset –1. Alas, there is no such thing as a distinct –0\nvalue in Python.",
    "Strings in Action | 165\n\n\fFigure 7-1. Offsets and slices: positive offsets start from the left end (offset 0 is the first item), and\nnegatives count back from the right end (offset −1 is the last item). Either kind of offset can be used\nto give positions in indexing and slicing operations.",
    "the contiguous section identified by the offset pair. The left offset is taken to be the\nlower bound (inclusive), and the right is the upper bound (noninclusive). That is, Python\nfetches all items from the lower bound up to but not including the upper bound, and\nreturns a new object containing the fetched items. If omitted, the left and right bounds\ndefault to 0 and the length of the object you are slicing, respectively.\nFor instance, in the example we just saw, S[1:3] extracts the items at offsets 1 and 2:\nit grabs the second and third items, and stops before the fourth item at offset 3. Next,\nS[1:] gets all items beyond the first—the upper bound, which is not specified, defaults\nto the length of the string. Finally, S[:−1] fetches all but the last item—the lower bound\ndefaults to 0, and −1 refers to the last item, noninclusive.",
    "it grabs the second and third items, and stops before the fourth item at offset 3. Next,\nS[1:] gets all items beyond the first—the upper bound, which is not specified, defaults\nto the length of the string. Finally, S[:−1] fetches all but the last item—the lower bound\ndefaults to 0, and −1 refers to the last item, noninclusive.\nThis may seem confusing at first glance, but indexing and slicing are simple and powerful tools to use, once you get the knack. Remember, if you’re unsure about the effects\nof a slice, try it out interactively. In the next chapter, you’ll see that it’s even possible\nto change an entire section of another object in one step by assigning to a slice (though\nnot for immutables like strings). Here’s a summary of the details for reference:\n• Indexing (S[i]) fetches components at offsets:\n— The first item is at offset 0.\n— Negative indexes mean to count backward from the end or right.\n— S[0] fetches the first item.",
    "to change an entire section of another object in one step by assigning to a slice (though\nnot for immutables like strings). Here’s a summary of the details for reference:\n• Indexing (S[i]) fetches components at offsets:\n— The first item is at offset 0.\n— Negative indexes mean to count backward from the end or right.\n— S[0] fetches the first item.\n— S[−2] fetches the second item from the end (like S[len(S)−2]).\n• Slicing (S[i:j]) extracts contiguous sections of sequences:\n— The upper bound is noninclusive.\n— Slice boundaries default to 0 and the sequence length, if omitted.\n— S[1:3] fetches items at offsets 1 up to but not including 3.\n— S[1:] fetches items at offset 1 through the end (the sequence length).",
    "166 | Chapter 7: Strings\n\n\f— S[:3] fetches items at offset 0 up to but not including 3.\n— S[:−1] fetches items at offset 0 up to but not including the last item.\n— S[:] fetches items at offsets 0 through the end—this effectively performs a toplevel copy of S.\nThe last item listed here turns out to be a very common trick: it makes a full top-level\ncopy of a sequence object—an object with the same value, but a distinct piece of memory (you’ll find more on copies in Chapter 9). This isn’t very useful for immutable\nobjects like strings, but it comes in handy for objects that may be changed in-place,\nsuch as lists.\nIn the next chapter, you’ll see that the syntax used to index by offset (square brackets)\nis used to index dictionaries by key as well; the operations look the same but have\ndifferent interpretations.",
    "Extended slicing: the third limit and slice objects\nIn Python 2.3 and later, slice expressions have support for an optional third index, used\nas a step (sometimes called a stride). The step is added to the index of each item extracted. The full-blown form of a slice is now X[I:J:K], which means “extract all the\nitems in X, from offset I through J−1, by K.” The third limit, K, defaults to 1, which is\nwhy normally all items in a slice are extracted from left to right. If you specify an explicit\nvalue, however, you can use the third limit to skip items or to reverse their order.\nFor instance, X[1:10:2] will fetch every other item in X from offsets 1–9; that is, it will\ncollect the items at offsets 1, 3, 5, 7, and 9. As usual, the first and second limits default\nto 0 and the length of the sequence, respectively, so X[::2] gets every other item from\nthe beginning to the end of the sequence:\n>>> S = 'abcdefghijklmnop'\n>>> S[1:10:2]\n'bdfhj'\n>>> S[::2]\n'acegikmo'",
    "You can also use a negative stride. For example, the slicing expression \"hello\"[::−1]\nreturns the new string \"olleh\"—the first two bounds default to 0 and the length of the\nsequence, as before, and a stride of −1 indicates that the slice should go from right to\nleft instead of the usual left to right. The effect, therefore, is to reverse the sequence:\n>>> S = 'hello'\n>>> S[::−1]\n'olleh'\n\nWith a negative stride, the meanings of the first two bounds are essentially reversed.\nThat is, the slice S[5:1:−1] fetches the items from 2 to 5, in reverse order (the result\ncontains items from offsets 5, 4, 3, and 2):\n\nStrings in Action | 167\n\n\f>>> S = 'abcedfg'\n>>> S[5:1:−1]\n'fdec'",
    "With a negative stride, the meanings of the first two bounds are essentially reversed.\nThat is, the slice S[5:1:−1] fetches the items from 2 to 5, in reverse order (the result\ncontains items from offsets 5, 4, 3, and 2):\n\nStrings in Action | 167\n\n\f>>> S = 'abcedfg'\n>>> S[5:1:−1]\n'fdec'\n\nSkipping and reversing like this are the most common use cases for three-limit slices,\nbut see Python’s standard library manual for more details (or run a few experiments\ninteractively). We’ll revisit three-limit slices again later in this book, in conjunction\nwith the for loop statement.\nLater in the book, we’ll also learn that slicing is equivalent to indexing with a slice\nobject, a finding of importance to class writers seeking to support both operations:\n>>> 'spam'[1:3]\n'pa'\n>>> 'spam'[slice(1, 3)]\n'pa'\n>>> 'spam'[::-1]\n'maps'\n>>> 'spam'[slice(None, None, −1)]\n'maps'\n\n# Slicing syntax\n# Slice objects",
    "# Slicing syntax\n# Slice objects\n\nWhy You Will Care: Slices\nThroughout this book, I will include common use case sidebars (such as this one) to\ngive you a peek at how some of the language features being introduced are typically\nused in real programs. Because you won’t be able to make much sense of real use cases\nuntil you’ve seen more of the Python picture, these sidebars necessarily contain many\nreferences to topics not introduced yet; at most, you should consider them previews of\nways that you may find these abstract language concepts useful for common programming tasks.\nFor instance, you’ll see later that the argument words listed on a system command line\nused to launch a Python program are made available in the argv attribute of the builtin sys module:\n# File echo.py\nimport sys\nprint(sys.argv)\n% python echo.py −a −b −c\n['echo.py', '−a', '−b', '−c']",
    "Usually, you’re only interested in inspecting the arguments that follow the program\nname. This leads to a very typical application of slices: a single slice expression can be\nused to return all but the first item of a list. Here, sys.argv[1:] returns the desired list,\n['−a', '−b', '−c']. You can then process this list without having to accommodate the\nprogram name at the front.\nSlices are also often used to clean up lines read from input files. If you know that a line\nwill have an end-of-line character at the end (a \\n newline marker), you can get rid of\nit with a single expression such as line[:−1], which extracts all but the last character\nin the line (the lower limit defaults to 0). In both cases, slices do the job of logic that\nmust be explicit in a lower-level language.\n168 | Chapter 7: Strings",
    "Note that calling the line.rstrip method is often preferred for stripping newline characters because this call leaves the line intact if it has no newline character at the end—\na common case for files created with some text-editing tools. Slicing works if you’re\nsure the line is properly terminated.\n\nString Conversion Tools\nOne of Python’s design mottos is that it refuses the temptation to guess. As a prime\nexample, you cannot add a number and a string together in Python, even if the string\nlooks like a number (i.e., is all digits):\n>>> \"42\" + 1\nTypeError: cannot concatenate 'str' and 'int' objects",
    "String Conversion Tools\nOne of Python’s design mottos is that it refuses the temptation to guess. As a prime\nexample, you cannot add a number and a string together in Python, even if the string\nlooks like a number (i.e., is all digits):\n>>> \"42\" + 1\nTypeError: cannot concatenate 'str' and 'int' objects\n\nThis is by design: because + can mean both addition and concatenation, the choice of\nconversion would be ambiguous. So, Python treats this as an error. In Python, magic\nis generally omitted if it will make your life more complex.\nWhat to do, then, if your script obtains a number as a text string from a file or user\ninterface? The trick is that you need to employ conversion tools before you can treat a\nstring like a number, or vice versa. For instance:\n>>> int(\"42\"), str(42)\n(42, '42')\n>>> repr(42)\n'42'\n\n# Convert from/to string\n# Convert to as-code string",
    "# Convert from/to string\n# Convert to as-code string\n\nThe int function converts a string to a number, and the str function converts a number\nto its string representation (essentially, what it looks like when printed). The repr\nfunction (and the older backquotes expression, removed in Python 3.0) also converts\nan object to its string representation, but returns the object as a string of code that can\nbe rerun to recreate the object. For strings, the result has quotes around it if displayed\nwith a print statement:\n>>> print(str('spam'), repr('spam'))\n('spam', \"'spam'\")\n\nSee the sidebar “str and repr Display Formats” on page 116 for more on this topic. Of\nthese, int and str are the generally prescribed conversion techniques.\nNow, although you can’t mix strings and number types around operators such as +,\nyou can manually convert operands before that operation if needed:\n>>> S = \"42\"\n>>> I = 1\n>>> S + I\nTypeError: cannot concatenate 'str' and 'int' objects\n>>> int(S) + I\n43",
    "# Force addition\n\nStrings in Action | 169\n\n\f>>> S + str(I)\n'421'\n\n# Force concatenation\n\nSimilar built-in functions handle floating-point number conversions to and from\nstrings:\n>>> str(3.1415), float(\"1.5\")\n('3.1415', 1.5)\n>>> text = \"1.234E-10\"\n>>> float(text)\n1.2340000000000001e-010\n\nLater, we’ll further study the built-in eval function; it runs a string containing Python\nexpression code and so can convert a string to any kind of object. The functions int\nand float convert only to numbers, but this restriction means they are usually faster\n(and more secure, because they do not accept arbitrary expression code). As we saw\nbriefly in Chapter 5, the string formatting expression also provides a way to convert\nnumbers to strings. We’ll discuss formatting further later in this chapter.",
    "Character code conversions\nOn the subject of conversions, it is also possible to convert a single character to its\nunderlying ASCII integer code by passing it to the built-in ord function—this returns\nthe actual binary value of the corresponding byte in memory. The chr function performs\nthe inverse operation, taking an ASCII integer code and converting it to the corresponding character:\n>>> ord('s')\n115\n>>> chr(115)\n's'\n\nYou can use a loop to apply these functions to all characters in a string. These tools can\nalso be used to perform a sort of string-based math. To advance to the next character,\nfor example, convert and do the math in integer:\n>>> S = '5'\n>>> S = chr(ord(S) + 1)\n>>> S\n'6'\n>>> S = chr(ord(S) + 1)\n>>> S\n'7'\n\nAt least for single-character strings, this provides an alternative to using the built-in\nint function to convert from string to integer:\n>>> int('5')\n5\n>>> ord('5') - ord('0')\n5\n\n170 | Chapter 7: Strings",
    "At least for single-character strings, this provides an alternative to using the built-in\nint function to convert from string to integer:\n>>> int('5')\n5\n>>> ord('5') - ord('0')\n5\n\n170 | Chapter 7: Strings\n\n\fSuch conversions can be used in conjunction with looping statements, introduced in\nChapter 4 and covered in depth in the next part of this book, to convert a string of\nbinary digits to their corresponding integer values. Each time through the loop, multiply\nthe current value by 2 and add the next digit’s integer value:\n>>> B = '1101'\n# Convert binary digits to integer with ord\n>>> I = 0\n>>> while B != '':\n...\nI = I * 2 + (ord(B[0]) - ord('0'))\n...\nB = B[1:]\n...\n>>> I\n13",
    "A left-shift operation (I << 1) would have the same effect as multiplying by 2 here.\nWe’ll leave this change as a suggested exercise, though, both because we haven’t studied loops in detail yet and because the int and bin built-ins we met in Chapter 5 handle\nbinary conversion tasks for us in Python 2.6 and 3.0:\n>>> int('1101', 2)\n13\n>>> bin(13)\n'0b1101'\n\n# Convert binary to integer: built-in\n# Convert integer to binary\n\nGiven enough time, Python tends to automate most common tasks!\n\nChanging Strings\nRemember the term “immutable sequence”? The immutable part means that you can’t\nchange a string in-place (e.g., by assigning to an index):\n>>> S = 'spam'\n>>> S[0] = \"x\"\nRaises an error!",
    "# Convert binary to integer: built-in\n# Convert integer to binary\n\nGiven enough time, Python tends to automate most common tasks!\n\nChanging Strings\nRemember the term “immutable sequence”? The immutable part means that you can’t\nchange a string in-place (e.g., by assigning to an index):\n>>> S = 'spam'\n>>> S[0] = \"x\"\nRaises an error!\n\nSo, how do you modify text information in Python? To change a string, you need to\nbuild and assign a new string using tools such as concatenation and slicing, and then,\nif desired, assign the result back to the string’s original name:\n>>> S = S + 'SPAM!'\n# To change a string, make a new one\n>>> S\n'spamSPAM!'\n>>> S = S[:4] + 'Burger' + S[−1]\n>>> S\n'spamBurger!'",
    "So, how do you modify text information in Python? To change a string, you need to\nbuild and assign a new string using tools such as concatenation and slicing, and then,\nif desired, assign the result back to the string’s original name:\n>>> S = S + 'SPAM!'\n# To change a string, make a new one\n>>> S\n'spamSPAM!'\n>>> S = S[:4] + 'Burger' + S[−1]\n>>> S\n'spamBurger!'\n\nThe first example adds a substring at the end of S, by concatenation (really, it makes a\nnew string and assigns it back to S, but you can think of this as “changing” the original\nstring). The second example replaces four characters with six by slicing, indexing, and\nconcatenating. As you’ll see in the next section, you can achieve similar effects with\nstring method calls like replace:\n\nStrings in Action | 171\n\n\f>>> S = 'splot'\n>>> S = S.replace('pl', 'pamal')\n>>> S\n'spamalot'",
    ">>> S = 'splot'\n>>> S = S.replace('pl', 'pamal')\n>>> S\n'spamalot'\n\nLike every operation that yields a new string value, string methods generate new string\nobjects. If you want to retain those objects, you can assign them to variable names.\nGenerating a new string object for each string change is not as inefficient as it may\nsound—remember, as discussed in the preceding chapter, Python automatically garbage collects (reclaims the space of) old unused string objects as you go, so newer\nobjects reuse the space held by prior values. Python is usually more efficient than you\nmight expect.\nFinally, it’s also possible to build up new text values with string formatting expressions.\nBoth of the following substitute objects into a string, in a sense converting the objects\nto strings and changing the original string according to a format specification:\n>>> 'That is %d %s bird!' % (1, 'dead')\nThat is 1 dead bird!\n>>> 'That is {0} {1} bird!'.format(1, 'dead')\n'That is 1 dead bird!'",
    "# Format expression\n# Format method in 2.6 and 3.0",
    "Despite the substitution metaphor, though, the result of formatting is a new string\nobject, not a modified one. We’ll study formatting later in this chapter; as we’ll find,\nformatting turns out to be more general and useful than this example implies. Because\nthe second of the preceding calls is provided as a method, though, let’s get a handle on\nstring method calls before we explore formatting further.\nAs we’ll see in Chapter 36, Python 3.0 and 2.6 introduce a new string\ntype known as bytearray, which is mutable and so may be changed in\nplace. bytearray objects aren’t really strings; they’re sequences of small,\n8-bit integers. However, they support most of the same operations as\nnormal strings and print as ASCII characters when displayed. As such,\nthey provide another option for large amounts of text that must be\nchanged frequently. In Chapter 36 we’ll also see that ord and chr handle\nUnicode characters, too, which might not be stored in single bytes.",
    "String Methods\nIn addition to expression operators, strings provide a set of methods that implement\nmore sophisticated text-processing tasks. Methods are simply functions that are associated with particular objects. Technically, they are attributes attached to objects that\nhappen to reference callable functions. In Python, expressions and built-in functions\nmay work across a range of types, but methods are generally specific to object types—\nstring methods, for example, work only on string objects. The method sets of some\ntypes intersect in Python 3.0 (e.g., many types have a count method), but they are still\nmore type-specific than other tools.\n\n172 | Chapter 7: Strings",
    "In finer-grained detail, functions are packages of code, and method calls combine two\noperations at once (an attribute fetch and a call):\nAttribute fetches\nAn expression of the form object.attribute means “fetch the value of attribute\nin object.”\nCall expressions\nAn expression of the form function(arguments) means “invoke the code of\nfunction, passing zero or more comma-separated argument objects to it, and return\nfunction’s result value.”\nPutting these two together allows us to call a method of an object. The method call\nexpression object.method(arguments) is evaluated from left to right—Python will first\nfetch the method of the object and then call it, passing in the arguments. If the method\ncomputes a result, it will come back as the result of the entire method-call expression.\nAs you’ll see throughout this part of the book, most objects have callable methods, and\nall are accessed using this same method-call syntax. To call an object method, as you’ll",
    "fetch the method of the object and then call it, passing in the arguments. If the method\ncomputes a result, it will come back as the result of the entire method-call expression.\nAs you’ll see throughout this part of the book, most objects have callable methods, and\nall are accessed using this same method-call syntax. To call an object method, as you’ll\nsee in the following sections, you have to go through an existing object.\nTable 7-3 summarizes the methods and call patterns for built-in string objects in Python\n3.0; these change frequently, so be sure to check Python’s standard library manual for\nthe most up-to-date list, or run a help call on any string interactively. Python 2.6’s string\nmethods vary slightly; it includes a decode, for example, because of its different handling\nof Unicode data (something we’ll discuss in Chapter 36). In this table, S is a string\nobject, and optional arguments are enclosed in square brackets. String methods in this",
    "the most up-to-date list, or run a help call on any string interactively. Python 2.6’s string\nmethods vary slightly; it includes a decode, for example, because of its different handling\nof Unicode data (something we’ll discuss in Chapter 36). In this table, S is a string\nobject, and optional arguments are enclosed in square brackets. String methods in this\ntable implement higher-level operations such as splitting and joining, case conversions,\ncontent tests, and substring searches and replacements.\nTable 7-3. String method calls in Python 3.0\nS.capitalize()",
    "S.ljust(width [, fill])\n\nS.center(width [, fill])\n\nS.lower()\n\nS.count(sub [, start [, end]])\n\nS.lstrip([chars])\n\nS.encode([encoding [,errors]])\n\nS.maketrans(x[, y[, z]])\n\nS.endswith(suffix [, start [, end]])\n\nS.partition(sep)\n\nS.expandtabs([tabsize])\n\nS.replace(old, new [, count])\n\nS.find(sub [, start [, end]])\n\nS.rfind(sub [,start [,end]])\n\nS.format(fmtstr, *args, **kwargs)\n\nS.rindex(sub [, start [, end]])\n\nS.index(sub [, start [, end]])\n\nS.rjust(width [, fill])\n\nS.isalnum()\n\nS.rpartition(sep)\n\nS.isalpha()\n\nS.rsplit([sep[, maxsplit]])\n\nS.isdecimal()\n\nS.rstrip([chars])\n\nS.isdigit()\n\nS.split([sep [,maxsplit]])\n\nString Methods | 173\n\n\fS.isidentifier()\n\nS.splitlines([keepends])\n\nS.islower()\n\nS.startswith(prefix [, start [, end]])\n\nS.isnumeric()\n\nS.strip([chars])\n\nS.isprintable()\n\nS.swapcase()\n\nS.isspace()\n\nS.title()\n\nS.istitle()\n\nS.translate(map)\n\nS.isupper()\n\nS.upper()\n\nS.join(iterable)\n\nS.zfill(width)",
    "S.isdecimal()\n\nS.rstrip([chars])\n\nS.isdigit()\n\nS.split([sep [,maxsplit]])\n\nString Methods | 173\n\n\fS.isidentifier()\n\nS.splitlines([keepends])\n\nS.islower()\n\nS.startswith(prefix [, start [, end]])\n\nS.isnumeric()\n\nS.strip([chars])\n\nS.isprintable()\n\nS.swapcase()\n\nS.isspace()\n\nS.title()\n\nS.istitle()\n\nS.translate(map)\n\nS.isupper()\n\nS.upper()\n\nS.join(iterable)\n\nS.zfill(width)\n\nAs you can see, there are quite a few string methods, and we don’t have space to cover\nthem all; see Python’s library manual or reference texts for all the fine points. To help\nyou get started, though, let’s work through some code that demonstrates some of the\nmost commonly used methods in action, and illustrates Python text-processing basics\nalong the way.",
    "S.join(iterable)\n\nS.zfill(width)\n\nAs you can see, there are quite a few string methods, and we don’t have space to cover\nthem all; see Python’s library manual or reference texts for all the fine points. To help\nyou get started, though, let’s work through some code that demonstrates some of the\nmost commonly used methods in action, and illustrates Python text-processing basics\nalong the way.\n\nString Method Examples: Changing Strings\nAs we’ve seen, because strings are immutable, they cannot be changed in-place directly.\nTo make a new text value from an existing string, you construct a new string with\noperations such as slicing and concatenation. For example, to replace two characters\nin the middle of a string, you can use code like this:\n>>> S = 'spammy'\n>>> S = S[:3] + 'xx' + S[5:]\n>>> S\n'spaxxy'\n\nBut, if you’re really just out to replace a substring, you can use the string replace method\ninstead:\n>>> S = 'spammy'\n>>> S = S.replace('mm', 'xx')\n>>> S\n'spaxxy'",
    "But, if you’re really just out to replace a substring, you can use the string replace method\ninstead:\n>>> S = 'spammy'\n>>> S = S.replace('mm', 'xx')\n>>> S\n'spaxxy'\n\nThe replace method is more general than this code implies. It takes as arguments the\noriginal substring (of any length) and the string (of any length) to replace it with, and\nperforms a global search and replace:\n>>> 'aa$bb$cc$dd'.replace('$', 'SPAM')\n'aaSPAMbbSPAMccSPAMdd'\n\nIn such a role, replace can be used as a tool to implement template replacements (e.g.,\nin form letters). Notice that this time we simply printed the result, instead of assigning\nit to a name—you need to assign results to names only if you want to retain them for\nlater use.\n\n174 | Chapter 7: Strings",
    "In such a role, replace can be used as a tool to implement template replacements (e.g.,\nin form letters). Notice that this time we simply printed the result, instead of assigning\nit to a name—you need to assign results to names only if you want to retain them for\nlater use.\n\n174 | Chapter 7: Strings\n\n\fIf you need to replace one fixed-size string that can occur at any offset, you can do a\nreplacement again, or search for the substring with the string find method and then\nslice:\n>>> S = 'xxxxSPAMxxxxSPAMxxxx'\n>>> where = S.find('SPAM')\n# Search for position\n>>> where\n# Occurs at offset 4\n4\n>>> S = S[:where] + 'EGGS' + S[(where+4):]\n>>> S\n'xxxxEGGSxxxxSPAMxxxx'",
    "174 | Chapter 7: Strings\n\n\fIf you need to replace one fixed-size string that can occur at any offset, you can do a\nreplacement again, or search for the substring with the string find method and then\nslice:\n>>> S = 'xxxxSPAMxxxxSPAMxxxx'\n>>> where = S.find('SPAM')\n# Search for position\n>>> where\n# Occurs at offset 4\n4\n>>> S = S[:where] + 'EGGS' + S[(where+4):]\n>>> S\n'xxxxEGGSxxxxSPAMxxxx'\n\nThe find method returns the offset where the substring appears (by default, searching\nfrom the front), or −1 if it is not found. As we saw earlier, it’s a substring search operation\njust like the in expression, but find returns the position of a located substring.\nAnother option is to use replace with a third argument to limit it to a single substitution:\n>>> S = 'xxxxSPAMxxxxSPAMxxxx'\n>>> S.replace('SPAM', 'EGGS')\n'xxxxEGGSxxxxEGGSxxxx'\n>>> S.replace('SPAM', 'EGGS', 1)\n'xxxxEGGSxxxxSPAMxxxx'\n\n# Replace all\n# Replace one",
    "# Replace all\n# Replace one\n\nNotice that replace returns a new string object each time. Because strings are immutable, methods never really change the subject strings in-place, even if they are called\n“replace”!\nThe fact that concatenation operations and the replace method generate new string\nobjects each time they are run is actually a potential downside of using them to change\nstrings. If you have to apply many changes to a very large string, you might be able to\nimprove your script’s performance by converting the string to an object that does support in-place changes:\n>>> S = 'spammy'\n>>> L = list(S)\n>>> L\n['s', 'p', 'a', 'm', 'm', 'y']",
    "The built-in list function (or an object construction call) builds a new list out of the\nitems in any sequence—in this case, “exploding” the characters of a string into a list.\nOnce the string is in this form, you can make multiple changes to it without generating\na new copy for each change:\n>>> L[3] = 'x'\n>>> L[4] = 'x'\n>>> L\n['s', 'p', 'a', 'x', 'x', 'y']\n\n# Works for lists, not strings\n\nIf, after your changes, you need to convert back to a string (e.g., to write to a file), use\nthe string join method to “implode” the list back into a string:\n\nString Methods | 175\n\n\f>>> S = ''.join(L)\n>>> S\n'spaxxy'",
    "# Works for lists, not strings\n\nIf, after your changes, you need to convert back to a string (e.g., to write to a file), use\nthe string join method to “implode” the list back into a string:\n\nString Methods | 175\n\n\f>>> S = ''.join(L)\n>>> S\n'spaxxy'\n\nThe join method may look a bit backward at first sight. Because it is a method of strings\n(not of lists), it is called through the desired delimiter. join puts the strings in a list (or\nother iterable) together, with the delimiter between list items; in this case, it uses an\nempty string delimiter to convert from a list back to a string. More generally, any string\ndelimiter and iterable of strings will do:\n>>> 'SPAM'.join(['eggs', 'sausage', 'ham', 'toast'])\n'eggsSPAMsausageSPAMhamSPAMtoast'",
    "In fact, joining substrings all at once this way often runs much faster than concatenating\nthem individually. Be sure to also see the earlier note about the mutable bytearray string\nin Python 3.0 and 2.6, described fully in Chapter 36; because it may be changed in\nplace, it offers an alternative to this list/join combination for some kinds of text that\nmust be changed often.\n\nString Method Examples: Parsing Text\nAnother common role for string methods is as a simple form of text parsing—that is,\nanalyzing structure and extracting substrings. To extract substrings at fixed offsets, we\ncan employ slicing techniques:\n>>> line = 'aaa bbb ccc'\n>>> col1 = line[0:3]\n>>> col3 = line[8:]\n>>> col1\n'aaa'\n>>> col3\n'ccc'",
    "String Method Examples: Parsing Text\nAnother common role for string methods is as a simple form of text parsing—that is,\nanalyzing structure and extracting substrings. To extract substrings at fixed offsets, we\ncan employ slicing techniques:\n>>> line = 'aaa bbb ccc'\n>>> col1 = line[0:3]\n>>> col3 = line[8:]\n>>> col1\n'aaa'\n>>> col3\n'ccc'\n\nHere, the columns of data appear at fixed offsets and so may be sliced out of the original\nstring. This technique passes for parsing, as long as the components of your data have\nfixed positions. If instead some sort of delimiter separates the data, you can pull out its\ncomponents by splitting. This will work even if the data may show up at arbitrary\npositions within the string:\n>>> line = 'aaa bbb ccc'\n>>> cols = line.split()\n>>> cols\n['aaa', 'bbb', 'ccc']",
    "The string split method chops up a string into a list of substrings, around a delimiter\nstring. We didn’t pass a delimiter in the prior example, so it defaults to whitespace—\nthe string is split at groups of one or more spaces, tabs, and newlines, and we get back\na list of the resulting substrings. In other applications, more tangible delimiters may\nseparate the data. This example splits (and hence parses) the string at commas, a separator common in data returned by some database tools:\n\n176 | Chapter 7: Strings\n\n\f>>> line = 'bob,hacker,40'\n>>> line.split(',')\n['bob', 'hacker', '40']\n\nDelimiters can be longer than a single character, too:\n>>> line = \"i'mSPAMaSPAMlumberjack\"\n>>> line.split(\"SPAM\")\n[\"i'm\", 'a', 'lumberjack']\n\nAlthough there are limits to the parsing potential of slicing and splitting, both run very\nfast and can handle basic text-extraction chores.",
    "176 | Chapter 7: Strings\n\n\f>>> line = 'bob,hacker,40'\n>>> line.split(',')\n['bob', 'hacker', '40']\n\nDelimiters can be longer than a single character, too:\n>>> line = \"i'mSPAMaSPAMlumberjack\"\n>>> line.split(\"SPAM\")\n[\"i'm\", 'a', 'lumberjack']\n\nAlthough there are limits to the parsing potential of slicing and splitting, both run very\nfast and can handle basic text-extraction chores.\n\nOther Common String Methods in Action\nOther string methods have more focused roles—for example, to strip off whitespace\nat the end of a line of text, perform case conversions, test content, and test for a substring\nat the end or front:\n>>> line = \"The knights who say Ni!\\n\"\n>>> line.rstrip()\n'The knights who say Ni!'\n>>> line.upper()\n'THE KNIGHTS WHO SAY NI!\\n'\n>>> line.isalpha()\nFalse\n>>> line.endswith('Ni!\\n')\nTrue\n>>> line.startswith('The')\nTrue",
    "Alternative techniques can also sometimes be used to achieve the same results as string\nmethods—the in membership operator can be used to test for the presence of a substring, for instance, and length and slicing operations can be used to mimic endswith:\n>>> line\n'The knights who say Ni!\\n'\n>>> line.find('Ni') != −1\nTrue\n>>> 'Ni' in line\nTrue\n>>> sub = 'Ni!\\n'\n>>> line.endswith(sub)\nTrue\n>>> line[-len(sub):] == sub\nTrue\n\n# Search via method call or expression\n\n# End test via method call or slice\n\nSee also the format string formatting method described later in this chapter; it provides\nmore advanced substitution tools that combine many operations in a single step.\nAgain, because there are so many methods available for strings, we won’t look at every\none here. You’ll see some additional string examples later in this book, but for more\n\nString Methods | 177",
    "String Methods | 177\n\n\fdetails you can also turn to the Python library manual and other documentation\nsources, or simply experiment interactively on your own. You can also check the\nhelp(S.method) results for a method of any string object S for more hints.\nNote that none of the string methods accepts patterns—for pattern-based text processing, you must use the Python re standard library module, an advanced tool that\nwas introduced in Chapter 4 but is mostly outside the scope of this text (one further\nexample appears at the end of Chapter 36). Because of this limitation, though, string\nmethods may sometimes run more quickly than the re module’s tools.",
    "The Original string Module (Gone in 3.0)\nThe history of Python’s string methods is somewhat convoluted. For roughly the first\ndecade of its existence, Python provided a standard library module called string that\ncontained functions that largely mirrored the current set of string object methods. In\nresponse to user requests, in Python 2.0 these functions were made available as methods\nof string objects. Because so many people had written so much code that relied on the\noriginal string module, however, it was retained for backward compatibility.\nToday, you should use only string methods, not the original string module. In fact, the\noriginal module-call forms of today’s string methods have been removed completely\nfrom Python in Release 3.0. However, because you may still see the module in use in\nolder Python code, a brief look is in order here.\nThe upshot of this legacy is that in Python 2.6, there technically are still two ways to",
    "Today, you should use only string methods, not the original string module. In fact, the\noriginal module-call forms of today’s string methods have been removed completely\nfrom Python in Release 3.0. However, because you may still see the module in use in\nolder Python code, a brief look is in order here.\nThe upshot of this legacy is that in Python 2.6, there technically are still two ways to\ninvoke advanced string operations: by calling object methods, or by calling string\nmodule functions and passing in the objects as arguments. For instance, given a variable\nX assigned to a string object, calling an object method:\nX.method(arguments)",
    "is usually equivalent to calling the same operation through the string module (provided\nthat you have already imported the module):\nstring.method(X, arguments)\n\nHere’s an example of the method scheme in action:\n>>> S = 'a+b+c+'\n>>> x = S.replace('+', 'spam')\n>>> x\n'aspambspamcspam'\n\nTo access the same operation through the string module in Python 2.6, you need to\nimport the module (at least once in your process) and pass in the object:\n>>> import string\n>>> y = string.replace(S, '+', 'spam')\n>>> y\n'aspambspamcspam'\n\n178 | Chapter 7: Strings",
    "Because the module approach was the standard for so long, and because strings are\nsuch a central component of most programs, you might see both call patterns in Python\n2.X code you come across.\nAgain, though, today you should always use method calls instead of the older module\ncalls. There are good reasons for this, besides the fact that the module calls have gone\naway in Release 3.0. For one thing, the module call scheme requires you to import the\nstring module (methods do not require imports). For another, the module makes calls\na few characters longer to type (when you load the module with import, that is, not\nusing from). And, finally, the module runs more slowly than methods (the module maps\nmost calls back to the methods and so incurs an extra call along the way).\nThe original string module itself, without its string method equivalents, is retained in\nPython 3.0 because it contains additional tools, including predefined string constants",
    "using from). And, finally, the module runs more slowly than methods (the module maps\nmost calls back to the methods and so incurs an extra call along the way).\nThe original string module itself, without its string method equivalents, is retained in\nPython 3.0 because it contains additional tools, including predefined string constants\nand a template object system (a relatively obscure tool omitted here—see the Python\nlibrary manual for details on template objects). Unless you really want to have to change\nyour 2.6 code to use 3.0, though, you should consider the basic string operation calls\nin it to be just ghosts from the past.",
    "String Formatting Expressions\nAlthough you can get a lot done with the string methods and sequence operations we’ve\nalready met, Python also provides a more advanced way to combine string processing\ntasks—string formatting allows us to perform multiple type-specific substitutions on a\nstring in a single step. It’s never strictly required, but it can be convenient, especially\nwhen formatting text to be displayed to a program’s users. Due to the wealth of new\nideas in the Python world, string formatting is available in two flavors in Python today:\nString formatting expressions\nThe original technique, available since Python’s inception; this is based upon the\nC language’s “printf” model and is used in much existing code.\nString formatting method calls\nA newer technique added in Python 2.6 and 3.0; this is more unique to Python and\nlargely overlaps with string formatting expression functionality.\nSince the method call flavor is new, there is some chance that one or the other of these",
    "C language’s “printf” model and is used in much existing code.\nString formatting method calls\nA newer technique added in Python 2.6 and 3.0; this is more unique to Python and\nlargely overlaps with string formatting expression functionality.\nSince the method call flavor is new, there is some chance that one or the other of these\nmay become deprecated over time. The expressions are more likely to be deprecated\nin later Python releases, though this should depend on the future practice of real Python\nprogrammers. As they are largely just variations on a theme, though, either technique\nis valid to use today. Since string formatting expressions are the original in this department, let’s start with them.\nPython defines the % binary operator to work on strings (you may recall that this is also\nthe remainder of division, or modulus, operator for numbers). When applied to strings,\nthe % operator provides a simple way to format values as strings according to a format",
    "String Formatting Expressions | 179\n\n\fdefinition. In short, the % operator provides a compact way to code multiple string\nsubstitutions all at once, instead of building and concatenating parts individually.\nTo format strings:\n1. On the left of the % operator, provide a format string containing one or more embedded conversion targets, each of which starts with a % (e.g., %d).\n2. On the right of the % operator, provide the object (or objects, embedded in a tuple)\nthat you want Python to insert into the format string on the left in place of the\nconversion target (or targets).\nFor instance, in the formatting example we saw earlier in this chapter, the integer 1\nreplaces the %d in the format string on the left, and the string 'dead' replaces the %s.\nThe result is a new string that reflects these two substitutions:\n>>> 'That is %d %s bird!' % (1, 'dead')\nThat is 1 dead bird!\n\n# Format expression",
    "# Format expression\n\nTechnically speaking, string formatting expressions are usually optional—you can\ngenerally do similar work with multiple concatenations and conversions. However,\nformatting allows us to combine many steps into a single operation. It’s powerful\nenough to warrant a few more examples:\n>>> exclamation = \"Ni\"\n>>> \"The knights who say %s!\" % exclamation\n'The knights who say Ni!'\n>>> \"%d %s %d you\" % (1, 'spam', 4)\n'1 spam 4 you'\n>>> \"%s -- %s -- %s\" % (42, 3.14159, [1, 2, 3])\n'42 -- 3.14159 -- [1, 2, 3]'",
    "The first example here plugs the string \"Ni\" into the target on the left, replacing the\n%s marker. In the second example, three values are inserted into the target string. Note\nthat when you’re inserting more than one value, you need to group the values on the\nright in parentheses (i.e., put them in a tuple). The % formatting expression operator\nexpects either a single item or a tuple of one or more items on its right side.\nThe third example again inserts three values—an integer, a floating-point object, and\na list object—but notice that all of the targets on the left are %s, which stands for conversion to string. As every type of object can be converted to a string (the one used\nwhen printing), every object type works with the %s conversion code. Because of this,\nunless you will be doing some special formatting, %s is often the only code you need to\nremember for the formatting expression.\nAgain, keep in mind that formatting always makes a new string, rather than changing",
    "when printing), every object type works with the %s conversion code. Because of this,\nunless you will be doing some special formatting, %s is often the only code you need to\nremember for the formatting expression.\nAgain, keep in mind that formatting always makes a new string, rather than changing\nthe string on the left; because strings are immutable, it must work this way. As before,\nassign the result to a variable name if you need to retain it.",
    "180 | Chapter 7: Strings\n\n\fAdvanced String Formatting Expressions\nFor more advanced type-specific formatting, you can use any of the conversion type\ncodes listed in Table 7-4 in formatting expressions; they appear after the % character in\nsubstitution targets. C programmers will recognize most of these because Python string\nformatting supports all the usual C printf format codes (but returns the result, instead\nof displaying it, like printf). Some of the format codes in the table provide alternative\nways to format the same type; for instance, %e, %f, and %g provide alternative ways to\nformat floating-point numbers.\nTable 7-4. String formatting type codes\nCode\n\nMeaning\n\ns\n\nString (or any object’s str(X) string)\n\nr\n\ns, but uses repr, not str\n\nc\n\nCharacter\n\nd\n\nDecimal (integer)\n\ni\n\nInteger\n\nu\n\nSame as d (obsolete: no longer unsigned)\n\no\n\nOctal integer\n\nx\n\nHex integer\n\nX\n\nx, but prints uppercase\n\ne\n\nFloating-point exponent, lowercase\n\nE\n\nSame as e, but prints uppercase\n\nf",
    "Meaning\n\ns\n\nString (or any object’s str(X) string)\n\nr\n\ns, but uses repr, not str\n\nc\n\nCharacter\n\nd\n\nDecimal (integer)\n\ni\n\nInteger\n\nu\n\nSame as d (obsolete: no longer unsigned)\n\no\n\nOctal integer\n\nx\n\nHex integer\n\nX\n\nx, but prints uppercase\n\ne\n\nFloating-point exponent, lowercase\n\nE\n\nSame as e, but prints uppercase\n\nf\n\nFloating-point decimal\n\nF\n\nFloating-point decimal\n\ng\n\nFloating-point e or f\n\nG\n\nFloating-point E or F\n\n%\n\nLiteral %\n\nIn fact, conversion targets in the format string on the expression’s left side support a\nvariety of conversion operations with a fairly sophisticated syntax all their own. The\ngeneral structure of conversion targets looks like this:\n%[(name)][flags][width][.precision]typecode",
    "f\n\nFloating-point decimal\n\nF\n\nFloating-point decimal\n\ng\n\nFloating-point e or f\n\nG\n\nFloating-point E or F\n\n%\n\nLiteral %\n\nIn fact, conversion targets in the format string on the expression’s left side support a\nvariety of conversion operations with a fairly sophisticated syntax all their own. The\ngeneral structure of conversion targets looks like this:\n%[(name)][flags][width][.precision]typecode\n\nThe character type codes in Table 7-4 show up at the end of the target string. Between\nthe % and the character code, you can do any of the following: provide a dictionary key;\nlist flags that specify things like left justification (−), numeric sign (+), and zero fills\n(0); give a total minimum field width and the number of digits after a decimal point;\nand more. Both width and precision can also be coded as a * to specify that they should\ntake their values from the next item in the input values.\n\nString Formatting Expressions | 181",
    "String Formatting Expressions | 181\n\n\fFormatting target syntax is documented in full in the Python standard manuals, but to\ndemonstrate common usage, let’s look at a few examples. This one formats integers by\ndefault, and then in a six-character field with left justification and zero padding:\n>>> x = 1234\n>>> res = \"integers: ...%d...%−6d...%06d\" % (x, x, x)\n>>> res\n'integers: ...1234...1234 ...001234'\n\nThe %e, %f, and %g formats display floating-point numbers in different ways, as the\nfollowing interaction demonstrates (%E is the same as %e but the exponent is uppercase):\n>>> x = 1.23456789\n>>> x\n1.2345678899999999\n>>> '%e | %f | %g' % (x, x, x)\n'1.234568e+00 | 1.234568 | 1.23457'\n>>> '%E' % x\n'1.234568E+00'",
    "The %e, %f, and %g formats display floating-point numbers in different ways, as the\nfollowing interaction demonstrates (%E is the same as %e but the exponent is uppercase):\n>>> x = 1.23456789\n>>> x\n1.2345678899999999\n>>> '%e | %f | %g' % (x, x, x)\n'1.234568e+00 | 1.234568 | 1.23457'\n>>> '%E' % x\n'1.234568E+00'\n\nFor floating-point numbers, you can achieve a variety of additional formatting effects\nby specifying left justification, zero padding, numeric signs, field width, and digits after\nthe decimal point. For simpler tasks, you might get by with simply converting to strings\nwith a format expression or the str built-in function shown earlier:\n>>> '%−6.2f | %05.2f | %+06.1f' % (x, x, x)\n'1.23\n| 01.23 | +001.2'\n>>> \"%s\" % x, str(x)\n('1.23456789', '1.23456789')",
    "When sizes are not known until runtime, you can have the width and precision computed by specifying them with a * in the format string to force their values to be taken\nfrom the next item in the inputs to the right of the % operator—the 4 in the tuple here\ngives precision:\n>>> '%f, %.2f, %.*f' % (1/3.0, 1/3.0, 4, 1/3.0)\n'0.333333, 0.33, 0.3333'\n\nIf you’re interested in this feature, experiment with some of these examples and operations on your own for more information.\n\nDictionary-Based String Formatting Expressions\nString formatting also allows conversion targets on the left to refer to the keys in a\ndictionary on the right and fetch the corresponding values. I haven’t told you much\nabout dictionaries yet, so here’s an example that demonstrates the basics:\n>>> \"%(n)d %(x)s\" % {\"n\":1, \"x\":\"spam\"}\n'1 spam'\n\n182 | Chapter 7: Strings",
    "Dictionary-Based String Formatting Expressions\nString formatting also allows conversion targets on the left to refer to the keys in a\ndictionary on the right and fetch the corresponding values. I haven’t told you much\nabout dictionaries yet, so here’s an example that demonstrates the basics:\n>>> \"%(n)d %(x)s\" % {\"n\":1, \"x\":\"spam\"}\n'1 spam'\n\n182 | Chapter 7: Strings\n\n\fHere, the (n) and (x) in the format string refer to keys in the dictionary literal on the\nright and fetch their associated values. Programs that generate text such as HTML or\nXML often use this technique—you can build up a dictionary of values and substitute\nthem all at once with a single formatting expression that uses key-based references:\n>>> reply = \"\"\"\nGreetings...\nHello %(name)s!\nYour age squared is %(age)s\n\"\"\"\n>>> values = {'name': 'Bob', 'age': 40}\n>>> print(reply % values)\n\n# Template with substitution targets\n\n# Build up values to substitute\n# Perform substitutions",
    "# Template with substitution targets\n\n# Build up values to substitute\n# Perform substitutions\n\nGreetings...\nHello Bob!\nYour age squared is 40\n\nThis trick is also used in conjunction with the vars built-in function, which returns a\ndictionary containing all the variables that exist in the place it is called:\n>>> food = 'spam'\n>>> age = 40\n>>> vars()\n{'food': 'spam', 'age': 40, ...many more... }\n\nWhen used on the right of a format operation, this allows the format string to refer to\nvariables by name (i.e., by dictionary key):\n>>> \"%(age)d %(food)s\" % vars()\n'40 spam'\n\nWe’ll study dictionaries in more depth in Chapter 8. See also Chapter 5 for examples\nthat convert to hexadecimal and octal number strings with the %x and %o formatting\ntarget codes.",
    "We’ll study dictionaries in more depth in Chapter 8. See also Chapter 5 for examples\nthat convert to hexadecimal and octal number strings with the %x and %o formatting\ntarget codes.\n\nString Formatting Method Calls\nAs mentioned earlier, Python 2.6 and 3.0 introduced a new way to format strings that\nis seen by some as a bit more Python-specific. Unlike formatting expressions, formatting\nmethod calls are not closely based upon the C language’s “printf” model, and they are\nmore verbose and explicit in intent. On the other hand, the new technique still relies\non some “printf” concepts, such as type codes and formatting specifications. Moreover,\nit largely overlaps with (and sometimes requires a bit more code than) formatting expressions, and it can be just as complex in advanced roles. Because of this, there is no\nbest-use recommendation between expressions and method calls today, so most programmers would be well served by a cursory understanding of both schemes.",
    "String Formatting Method Calls | 183\n\n\fThe Basics\nIn short, the new string object’s format method in 2.6 and 3.0 (and later) uses the subject\nstring as a template and takes any number of arguments that represent values to be\nsubstituted according to the template. Within the subject string, curly braces designate\nsubstitution targets and arguments to be inserted either by position (e.g., {1}) or keyword (e.g., {food}). As we’ll learn when we study argument passing in depth in Chapter 18, arguments to functions and methods may be passed by position or keyword\nname, and Python’s ability to collect arbitrarily many positional and keyword arguments allows for such general method call patterns. In Python 2.6 and 3.0, for example:\n>>> template = '{0}, {1} and {2}'\n>>> template.format('spam', 'ham', 'eggs')\n'spam, ham and eggs'\n\n# By position\n\n>>> template = '{motto}, {pork} and {food}'\n>>> template.format(motto='spam', pork='ham', food='eggs')\n'spam, ham and eggs'\n\n# By keyword",
    "# By position\n\n>>> template = '{motto}, {pork} and {food}'\n>>> template.format(motto='spam', pork='ham', food='eggs')\n'spam, ham and eggs'\n\n# By keyword\n\n>>> template = '{motto}, {0} and {food}'\n>>> template.format('ham', motto='spam', food='eggs')\n'spam, ham and eggs'\n\n# By both\n\nNaturally, the string can also be a literal that creates a temporary string, and arbitrary\nobject types can be substituted:\n>>> '{motto}, {0} and {food}'.format(42, motto=3.14, food=[1, 2])\n'3.14, 42 and [1, 2]'",
    "# By keyword\n\n>>> template = '{motto}, {0} and {food}'\n>>> template.format('ham', motto='spam', food='eggs')\n'spam, ham and eggs'\n\n# By both\n\nNaturally, the string can also be a literal that creates a temporary string, and arbitrary\nobject types can be substituted:\n>>> '{motto}, {0} and {food}'.format(42, motto=3.14, food=[1, 2])\n'3.14, 42 and [1, 2]'\n\nJust as with the % expression and other string methods, format creates and returns a\nnew string object, which can be printed immediately or saved for further work (recall\nthat strings are immutable, so format really must make a new object). String formatting\nis not just for display:\n>>> X = '{motto}, {0} and {food}'.format(42, motto=3.14, food=[1, 2])\n>>> X\n'3.14, 42 and [1, 2]'\n>>> X.split(' and ')\n['3.14, 42', '[1, 2]']\n>>> Y = X.replace('and', 'but under no circumstances')\n>>> Y\n'3.14, 42 but under no circumstances [1, 2]'",
    "Adding Keys, Attributes, and Offsets\nLike % formatting expressions, format calls can become more complex to support more\nadvanced usage. For instance, format strings can name object attributes and dictionary\nkeys—as in normal Python syntax, square brackets name dictionary keys and dots\ndenote object attributes of an item referenced by position or keyword. The first of the\n\n184 | Chapter 7: Strings\n\n\ffollowing examples indexes a dictionary on the key “spam” and then fetches the attribute “platform” from the already imported sys module object. The second does the\nsame, but names the objects by keyword instead of position:\n>>> import sys\n>>> 'My {1[spam]} runs {0.platform}'.format(sys, {'spam': 'laptop'})\n'My laptop runs win32'\n>>> 'My {config[spam]} runs {sys.platform}'.format(sys=sys,\nconfig={'spam': 'laptop'})\n'My laptop runs win32'",
    "Square brackets in format strings can name list (and other sequence) offsets to perform\nindexing, too, but only single positive offsets work syntactically within format strings,\nso this feature is not as general as you might think. As with % expressions, to name\nnegative offsets or slices, or to use arbitrary expression results in general, you must run\nexpressions outside the format string itself:\n>>> somelist = list('SPAM')\n>>> somelist\n['S', 'P', 'A', 'M']\n>>> 'first={0[0]}, third={0[2]}'.format(somelist)\n'first=S, third=A'\n>>> 'first={0}, last={1}'.format(somelist[0], somelist[-1])\n'first=S, last=M'\n\n# [-1] fails in fmt\n\n>>> parts = somelist[0], somelist[-1], somelist[1:3]\n>>> 'first={0}, last={1}, middle={2}'.format(*parts)\n\"first=S, last=M, middle=['P', 'A']\"\n\n# [1:3] fails in fmt",
    "# [-1] fails in fmt\n\n>>> parts = somelist[0], somelist[-1], somelist[1:3]\n>>> 'first={0}, last={1}, middle={2}'.format(*parts)\n\"first=S, last=M, middle=['P', 'A']\"\n\n# [1:3] fails in fmt\n\nAdding Specific Formatting\nAnother similarity with % expressions is that more specific layouts can be achieved by\nadding extra syntax in the format string. For the formatting method, we use a colon\nafter the substitution target’s identification, followed by a format specifier that can\nname the field size, justification, and a specific type code. Here’s the formal structure\nof what can appear as a substitution target in a format string:\n{fieldname!conversionflag:formatspec}\n\nIn this substitution target syntax:\n• fieldname is a number or keyword naming an argument, followed by optional\n“.name” attribute or “[index]” component references.\n• conversionflag can be r, s, or a to call repr, str, or ascii built-in functions on the\nvalue, respectively.\n\nString Formatting Method Calls | 185",
    "In this substitution target syntax:\n• fieldname is a number or keyword naming an argument, followed by optional\n“.name” attribute or “[index]” component references.\n• conversionflag can be r, s, or a to call repr, str, or ascii built-in functions on the\nvalue, respectively.\n\nString Formatting Method Calls | 185\n\n\f• formatspec specifies how the value should be presented, including details such as\nfield width, alignment, padding, decimal precision, and so on, and ends with an\noptional data type code.\nThe formatspec component after the colon character is formally described as follows\n(brackets denote optional components and are not coded literally):\n[[fill]align][sign][#][0][width][.precision][typecode]",
    "• formatspec specifies how the value should be presented, including details such as\nfield width, alignment, padding, decimal precision, and so on, and ends with an\noptional data type code.\nThe formatspec component after the colon character is formally described as follows\n(brackets denote optional components and are not coded literally):\n[[fill]align][sign][#][0][width][.precision][typecode]\n\nalign may be <, >, =, or ^, for left alignment, right alignment, padding after a sign\ncharacter, or centered alignment, respectively. The formatspec also contains nested\n{} format strings with field names only, to take values from the arguments list dynamically (much like the * in formatting expressions).",
    "See Python’s library manual for more on substitution syntax and a list of the available\ntype codes—they almost completely overlap with those used in % expressions and listed\npreviously in Table 7-4, but the format method also allows a “b” type code used to\ndisplay integers in binary format (it’s equivalent to using the bin built-in call), allows\na “%” type code to display percentages, and uses only “d” for base-10 integers (not “i”\nor “u”).\nAs an example, in the following {0:10} means the first positional argument in a field\n10 characters wide, {1:<10} means the second positional argument left-justified in a\n10-character-wide field, and {0.platform:>10} means the platform attribute of the first\nargument right-justified in a 10-character-wide field:\n>>> '{0:10} = {1:10}'.format('spam', 123.4567)\n'spam\n=\n123.457'\n>>> '{0:>10} = {1:<10}'.format('spam', 123.4567)\n'\nspam = 123.457\n'\n>>> '{0.platform:>10} = {1[item]:<10}'.format(sys, dict(item='laptop'))\n'\nwin32 = laptop\n'",
    "Floating-point numbers support the same type codes and formatting specificity in formatting method calls as in % expressions. For instance, in the following {2:g} means\nthe third argument formatted by default according to the “g” floating-point representation, {1:.2f} designates the “f” floating-point format with just 2 decimal digits, and\n{2:06.2f} adds a field with a width of 6 characters and zero padding on the left:\n>>> '{0:e}, {1:.3e}, {2:g}'.format(3.14159, 3.14159, 3.14159)\n'3.141590e+00, 3.142e+00, 3.14159'\n>>> '{0:f}, {1:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159)\n'3.141590, 3.14, 003.14'\n\nHex, octal, and binary formats are supported by the format method as well. In fact,\nstring formatting is an alternative to some of the built-in functions that format integers\nto a given base:\n\n186 | Chapter 7: Strings\n\n\f>>> '{0:X}, {1:o}, {2:b}'.format(255, 255, 255)\n'FF, 377, 11111111'\n\n# Hex, octal, binary\n\n>>> bin(255), int('11111111', 2), 0b11111111\n('0b11111111', 255, 255)",
    "Hex, octal, and binary formats are supported by the format method as well. In fact,\nstring formatting is an alternative to some of the built-in functions that format integers\nto a given base:\n\n186 | Chapter 7: Strings\n\n\f>>> '{0:X}, {1:o}, {2:b}'.format(255, 255, 255)\n'FF, 377, 11111111'\n\n# Hex, octal, binary\n\n>>> bin(255), int('11111111', 2), 0b11111111\n('0b11111111', 255, 255)\n\n# Other to/from binary\n\n>>> hex(255), int('FF', 16), 0xFF\n('0xff', 255, 255)\n\n# Other to/from hex\n\n>>> oct(255), int('377', 8), 0o377, 0377\n('0377', 255, 255, 255)\n\n# Other to/from octal\n# 0377 works in 2.6, not 3.0!\n\nFormatting parameters can either be hardcoded in format strings or taken from the\narguments list dynamically by nested format syntax, much like the star syntax in formatting expressions:\n>>> '{0:.2f}'.format(1 / 3.0)\n'0.33'\n>>> '%.2f' % (1 / 3.0)\n'0.33'\n\n# Parameters hardcoded\n\n>>> '{0:.{1}f}'.format(1 / 3.0, 4)\n'0.3333'\n>>> '%.*f' % (4, 1 / 3.0)\n'0.3333'",
    "Formatting parameters can either be hardcoded in format strings or taken from the\narguments list dynamically by nested format syntax, much like the star syntax in formatting expressions:\n>>> '{0:.2f}'.format(1 / 3.0)\n'0.33'\n>>> '%.2f' % (1 / 3.0)\n'0.33'\n\n# Parameters hardcoded\n\n>>> '{0:.{1}f}'.format(1 / 3.0, 4)\n'0.3333'\n>>> '%.*f' % (4, 1 / 3.0)\n'0.3333'\n\n# Take value from arguments\n# Ditto for expression\n\nFinally, Python 2.6 and 3.0 also provide a new built-in format function, which can be\nused to format a single item. It’s a more concise alternative to the string format method,\nand is roughly similar to formatting a single item with the % formatting expression:\n# String method\n\n>>> '{0:.2f}'.format(1.2345)\n'1.23'\n>>> format(1.2345, '.2f')\n'1.23'\n>>> '%.2f' % 1.2345\n'1.23'\n\n# Built-in function\n# Expression",
    ">>> '{0:.2f}'.format(1.2345)\n'1.23'\n>>> format(1.2345, '.2f')\n'1.23'\n>>> '%.2f' % 1.2345\n'1.23'\n\n# Built-in function\n# Expression\n\nTechnically, the format built-in runs the subject object’s __format__ method, which the\nstr.format method does internally for each formatted item. It’s still more verbose than\nthe original % expression’s equivalent, though—which leads us to the next section.\n\nComparison to the % Formatting Expression\nIf you study the prior sections closely, you’ll probably notice that at least for positional\nreferences and dictionary keys, the string format method looks very much like the %\nformatting expression, especially in advanced use with type codes and extra formatting\nsyntax. In fact, in common use cases formatting expressions may be easier to code than\nformatting method calls, especially when using the generic %s print-string substitution\ntarget:\nprint('%s=%s' % ('spam', 42))\n\n# 2.X+ format expression\n\nprint('{0}={1}'.format('spam', 42))",
    "# 2.X+ format expression\n\nprint('{0}={1}'.format('spam', 42))\n\n# 3.0 (and 2.6) format method\n\nString Formatting Method Calls | 187\n\n\fAs we’ll see in a moment, though, more complex formatting tends to be a draw in terms\nof complexity (difficult tasks are generally difficult, regardless of approach), and some\nsee the formatting method as largely redundant.\nOn the other hand, the formatting method also offers a few potential advantages. For\nexample, the original % expression can’t handle keywords, attribute references, and\nbinary type codes, although dictionary key references in % format strings can often\nachieve similar goals. To see how the two techniques overlap, compare the following\n% expressions to the equivalent format method calls shown earlier:\n# The basics: with % instead of format()\n>>> template = '%s, %s, %s'\n>>> template % ('spam', 'ham', 'eggs')\n'spam, ham, eggs'\n\n# By position",
    "# By position\n\n>>> template = '%(motto)s, %(pork)s and %(food)s'\n>>> template % dict(motto='spam', pork='ham', food='eggs')\n'spam, ham and eggs'\n\n# By key\n\n>>> '%s, %s and %s' % (3.14, 42, [1, 2])\n'3.14, 42 and [1, 2]'\n\n# Arbitrary types\n\n# Adding keys, attributes, and offsets\n>>> 'My %(spam)s runs %(platform)s' % {'spam': 'laptop', 'platform': sys.platform}\n'My laptop runs win32'\n>>> 'My %(spam)s runs %(platform)s' % dict(spam='laptop', platform=sys.platform)\n'My laptop runs win32'\n>>> somelist = list('SPAM')\n>>> parts = somelist[0], somelist[-1], somelist[1:3]\n>>> 'first=%s, last=%s, middle=%s' % parts\n\"first=S, last=M, middle=['P', 'A']\"",
    "When more complex formatting is applied the two techniques approach parity in terms\nof complexity, although if you compare the following with the format method call\nequivalents listed earlier you’ll again find that the % expressions tend to be a bit simpler\nand more concise:\n# Adding specific formatting\n>>> '%-10s = %10s' % ('spam', 123.4567)\n'spam\n=\n123.4567'\n>>> '%10s = %-10s' % ('spam', 123.4567)\n'\nspam = 123.4567 '\n>>> '%(plat)10s = %(item)-10s' % dict(plat=sys.platform, item='laptop')\n'\nwin32 = laptop\n'\n\n188 | Chapter 7: Strings\n\n\f# Floating-point numbers\n>>> '%e, %.3e, %g' % (3.14159, 3.14159, 3.14159)\n'3.141590e+00, 3.142e+00, 3.14159'\n>>> '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159)\n'3.141590, 3.14, 003.14'\n# Hex and octal, but not binary\n>>> '%x, %o' % (255, 255)\n'ff, 377'",
    "188 | Chapter 7: Strings\n\n\f# Floating-point numbers\n>>> '%e, %.3e, %g' % (3.14159, 3.14159, 3.14159)\n'3.141590e+00, 3.142e+00, 3.14159'\n>>> '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159)\n'3.141590, 3.14, 003.14'\n# Hex and octal, but not binary\n>>> '%x, %o' % (255, 255)\n'ff, 377'\n\nThe format method has a handful of advanced features that the % expression does not,\nbut even more involved formatting still seems to be essentially a draw in terms of complexity. For instance, the following shows the same result generated with both\ntechniques, with field sizes and justifications and various argument reference methods:\n# Hardcoded references in both\n>>> import sys\n>>> 'My {1[spam]:<8} runs {0.platform:>8}'.format(sys, {'spam': 'laptop'})\n'My laptop\nruns\nwin32'\n>>> 'My %(spam)-8s runs %(plat)8s' % dict(spam='laptop', plat=sys.platform)\n'My laptop\nruns\nwin32'",
    "In practice, programs are less likely to hardcode references like this than to execute\ncode that builds up a set of substitution data ahead of time (to collect data to substitute\ninto an HTML template all at once, for instance). When we account for common practice in examples like this, the comparison between the format method and the % expression is even more direct (as we’ll see in Chapter 18, the **data in the method call\nhere is special syntax that unpacks a dictionary of keys and values into individual\n“name=value” keyword arguments so they can be referenced by name in the format\nstring):\n# Building data ahead of time in both\n>>> data = dict(platform=sys.platform, spam='laptop')\n>>> 'My {spam:<8} runs {platform:>8}'.format(**data)\n'My laptop\nruns\nwin32'\n>>> 'My %(spam)-8s runs %(platform)8s' % data\n'My laptop\nruns\nwin32'",
    "As usual, the Python community will have to decide whether % expressions, format\nmethod calls, or a toolset with both techniques proves better over time. Experiment\nwith these techniques on your own to get a feel for what they offer, and be sure to see\nthe Python 2.6 and 3.0 library manuals for more details.\n\nString Formatting Method Calls | 189\n\n\fString format method enhancements in Python 3.1: The upcoming 3.1\nrelease (in alpha form as this chapter was being written) will add a\nthousand-separator syntax for numbers, which inserts commas between\nthree-digit groups. Add a comma before the type code to make this\nwork, as follows:\n>>> '{0:d}'.format(999999999999)\n'999999999999'\n>>> '{0:,d}'.format(999999999999)\n'999,999,999,999'",
    "String format method enhancements in Python 3.1: The upcoming 3.1\nrelease (in alpha form as this chapter was being written) will add a\nthousand-separator syntax for numbers, which inserts commas between\nthree-digit groups. Add a comma before the type code to make this\nwork, as follows:\n>>> '{0:d}'.format(999999999999)\n'999999999999'\n>>> '{0:,d}'.format(999999999999)\n'999,999,999,999'\n\nPython 3.1 also assigns relative numbers to substitution targets automatically if they are not included explicitly, though using this extension\nmay negate one of the main benefits of the formatting method, as the\nnext section describes:\n>>> '{:,d}'.format(999999999999)\n'999,999,999,999'\n>>> '{:,d} {:,d}'.format(9999999, 8888888)\n'9,999,999 8,888,888'\n>>> '{:,.2f}'.format(296999.2567)\n'296,999.26'",
    "This book doesn’t cover 3.1 officially, so you should take this as a preview. Python 3.1 will also address a major performance issue in\n3.0 related to the speed of file input/output operations, which made 3.0\nimpractical for many types of programs. See the 3.1 release notes for\nmore details. See also the formats.py comma-insertion and\nmoney-formatting function examples in Chapter 24 for a manual solution that can be imported and used prior to Python 3.1.",
    "Why the New Format Method?\nNow that I’ve gone to such lengths to compare and contrast the two formatting techniques, I need to explain why you might want to consider using the format method\nvariant at times. In short, although the formatting method can sometimes require more\ncode, it also:\n• Has a few extra features not found in the % expression\n• Can make substitution value references more explicit\n• Trades an operator for an arguably more mnemonic method name\n• Does not support different syntax for single and multiple substitution value cases\nAlthough both techniques are available today and the formatting expression is still\nwidely used, the format method might eventually subsume it. But because the choice\nis currently still yours to make, let’s briefly expand on some of the differences before\nmoving on.\n\n190 | Chapter 7: Strings",
    "190 | Chapter 7: Strings\n\n\fExtra features\nThe method call supports a few extras that the expression does not, such as binary type\ncodes and (coming in Python 3.1) thousands groupings. In addition, the method call\nsupports key and attribute references directly. As we’ve seen, though, the formatting\nexpression can usually achieve the same effects in other ways:\n>>> '{0:b}'.format((2 ** 16) −1)\n'1111111111111111'\n>>> '%b' % ((2 ** 16) −1)\nValueError: unsupported format character 'b' (0x62) at index 1\n>>> bin((2 ** 16) −1)\n'0b1111111111111111'\n>>> '%s' % bin((2 ** 16) −1)[2:]\n'1111111111111111'\n\nSee also the prior examples that compare dictionary-based formatting in the % expression to key and attribute references in the format method; especially in common practice, the two seem largely variations on a theme.",
    "See also the prior examples that compare dictionary-based formatting in the % expression to key and attribute references in the format method; especially in common practice, the two seem largely variations on a theme.\n\nExplicit value references\nOne use case where the format method is at least debatably clearer is when there are\nmany values to be substituted into the format string. The lister.py classes example we’ll\nmeet in Chapter 30, for example, substitutes six items into a single string, and in this\ncase the method’s {i} position labels seem easier to read than the expression’s %s:\n'\\n%s<Class %s, address %s:\\n%s%s%s>\\n' % (...)\n\n# Expression\n\n'\\n{0}<Class {1}, address {2}:\\n{3}{4}{5}>\\n'.format(...)\n\n# Method",
    "# Expression\n\n'\\n{0}<Class {1}, address {2}:\\n{3}{4}{5}>\\n'.format(...)\n\n# Method\n\nOn the other hand, using dictionary keys in % expressions can mitigate much of this\ndifference. This is also something of a worst-case scenario for formatting complexity,\nand not very common in practice; more typical use cases seem largely a tossup. Moreover, in Python 3.1 (still in alpha release form as I write these words), numbering substitution values will become optional, thereby subverting this purported benefit\naltogether:\nC:\\misc> C:\\Python31\\python\n>>> 'The {0} side {1} {2}'.format('bright', 'of', 'life')\n'The bright side of life'\n>>>\n>>> 'The {} side {} {}'.format('bright', 'of', 'life')\n'The bright side of life'\n>>>\n>>> 'The %s side %s %s' % ('bright', 'of', 'life')\n'The bright side of life'\n\n# Python 3.1+\n\nString Formatting Method Calls | 191",
    "# Python 3.1+\n\nString Formatting Method Calls | 191\n\n\fUsing 3.1’s automatic relative numbering like this seems to negate a large part of the\nmethod’s advantage. Compare the effect on floating-point formatting, for example—\nthe formatting expression is still more concise, and still seems less cluttered:\nC:\\misc> C:\\Python31\\python\n>>> '{0:f}, {1:.2f}, {2:05.2f}'.format(3.14159, 3.14159, 3.14159)\n'3.141590, 3.14, 03.14'\n>>>\n>>> '{:f}, {:.2f}, {:06.2f}'.format(3.14159, 3.14159, 3.14159)\n'3.141590, 3.14, 003.14'\n>>>\n>>> '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159)\n'3.141590, 3.14, 003.14'",
    "Method names and general arguments\nGiven this 3.1 auto-numbering change, the only clearly remaining potential advantages\nof the formatting method are that it replaces the % operator with a more mnemonic\nformat method name and does not distinguish between single and multiple substitution\nvalues. The former may make the method appear simpler to beginners at first glance\n(“format” may be easier to parse than multiple “%” characters), though this is too\nsubjective to call.\nThe latter difference might be more significant—with the format expression, a single\nvalue can be given by itself, but multiple values must be enclosed in a tuple:\n>>> '%.2f' % 1.2345\n'1.23'\n>>> '%.2f %s' % (1.2345, 99)\n'1.23 99'",
    "Technically, the formatting expression accepts either a single substitution value, or a\ntuple of one or more items. In fact, because a single item can be given either by itself or\nwithin a tuple, a tuple to be formatted must be provided as nested tuples:\n>>> '%s' % 1.23\n'1.23'\n>>> '%s' % (1.23,)\n'1.23'\n>>> '%s' % ((1.23,),)\n'(1.23,)'\n\nThe formatting method, on the other hand, tightens this up by accepting general function arguments in both cases:\n>>> '{0:.2f}'.format(1.2345)\n'1.23'\n>>> '{0:.2f} {1}'.format(1.2345, 99)\n'1.23 99'\n>>> '{0}'.format(1.23)\n'1.23'\n>>> '{0}'.format((1.23,))\n'(1.23,)'\n\n192 | Chapter 7: Strings",
    "The formatting method, on the other hand, tightens this up by accepting general function arguments in both cases:\n>>> '{0:.2f}'.format(1.2345)\n'1.23'\n>>> '{0:.2f} {1}'.format(1.2345, 99)\n'1.23 99'\n>>> '{0}'.format(1.23)\n'1.23'\n>>> '{0}'.format((1.23,))\n'(1.23,)'\n\n192 | Chapter 7: Strings\n\n\fConsequently, it might be less confusing to beginners and cause fewer programming\nmistakes. This is still a fairly minor issue, though—if you always enclose values in a\ntuple and ignore the nontupled option, the expression is essentially the same as the\nmethod call here. Moreover, the method incurs an extra price in inflated code size to\nachieve its limited flexibility. Given that the expression has been used extensively\nthroughout Python’s history, it’s not clear that this point justifies breaking existing\ncode for a new tool that is so similar, as the next section argues.",
    "Possible future deprecation?\nAs mentioned earlier, there is some risk that Python developers may deprecate the %\nexpression in favor of the format method in the future. In fact, there is a note to this\neffect in Python 3.0’s manuals.\nThis has not yet occurred, of course, and both formatting techniques are fully available\nand reasonable to use in Python 2.6 and 3.0 (the versions of Python this book covers).\nBoth techniques are supported in the upcoming Python 3.1 release as well, so deprecation of either seems unlikely for the foreseeable future. Moreover, because formatting\nexpressions are used extensively in almost all existing Python code written to date, most\nprogrammers will benefit from being familiar with both techniques for many years to\ncome.\nIf this deprecation ever does occur, though, you may need to recode all your % expressions as format methods, and translate those that appear in this book, in order to use",
    "expressions are used extensively in almost all existing Python code written to date, most\nprogrammers will benefit from being familiar with both techniques for many years to\ncome.\nIf this deprecation ever does occur, though, you may need to recode all your % expressions as format methods, and translate those that appear in this book, in order to use\na newer Python release. At the risk of editorializing here, I hope that such a change will\nbe based upon the future common practice of actual Python programmers, not the\nwhims of a handful of core developers—particularly given that the window for Python\n3.0’s many incompatible changes is now closed. Frankly, this deprecation would seem\nlike trading one complicated thing for another complicated thing—one that is largely\nequivalent to the tool it would replace! If you care about migrating to future Python\nreleases, though, be sure to watch for developments on this front over time.",
    "General Type Categories\nNow that we’ve explored the first of Python’s collection objects, the string, let’s pause\nto define a few general type concepts that will apply to most of the types we look at\nfrom here on. With regard to built-in types, it turns out that operations work the same\nfor all the types in the same category, so we’ll only need to define most of these ideas\nonce. We’ve only examined numbers and strings so far, but because they are representative of two of the three major type categories in Python, you already know more\nabout several other types than you might think.\n\nGeneral Type Categories | 193",
    "Types Share Operation Sets by Categories\nAs you’ve learned, strings are immutable sequences: they cannot be changed in-place\n(the immutable part), and they are positionally ordered collections that are accessed by\noffset (the sequence part). Now, it so happens that all the sequences we’ll study in this\npart of the book respond to the same sequence operations shown in this chapter at\nwork on strings—concatenation, indexing, iteration, and so on. More formally, there\nare three major type (and operation) categories in Python:\nNumbers (integer, floating-point, decimal, fraction, others)\nSupport addition, multiplication, etc.\nSequences (strings, lists, tuples)\nSupport indexing, slicing, concatenation, etc.\nMappings (dictionaries)\nSupport indexing by key, etc.\nSets are something of a category unto themselves (they don’t map keys to values and\nare not positionally ordered sequences), and we haven’t yet explored mappings on our",
    "Support addition, multiplication, etc.\nSequences (strings, lists, tuples)\nSupport indexing, slicing, concatenation, etc.\nMappings (dictionaries)\nSupport indexing by key, etc.\nSets are something of a category unto themselves (they don’t map keys to values and\nare not positionally ordered sequences), and we haven’t yet explored mappings on our\nin-depth tour (dictionaries are discussed in the next chapter). However, many of the\nother types we will encounter will be similar to numbers and strings. For example, for\nany sequence objects X and Y:\n• X + Y makes a new sequence object with the contents of both operands.\n• X * N makes a new sequence object with N copies of the sequence operand X.\nIn other words, these operations work the same way on any kind of sequence, including\nstrings, lists, tuples, and some user-defined object types. The only difference is that the\nnew result object you get back is of the same type as the operands X and Y—if you",
    "• X * N makes a new sequence object with N copies of the sequence operand X.\nIn other words, these operations work the same way on any kind of sequence, including\nstrings, lists, tuples, and some user-defined object types. The only difference is that the\nnew result object you get back is of the same type as the operands X and Y—if you\nconcatenate lists, you get back a new list, not a string. Indexing, slicing, and other\nsequence operations work the same on all sequences, too; the type of the objects being\nprocessed tells Python which flavor of the task to perform.",
    "Mutable Types Can Be Changed In-Place\nThe immutable classification is an important constraint to be aware of, yet it tends to\ntrip up new users. If an object type is immutable, you cannot change its value in-place;\nPython raises an error if you try. Instead, you must run code to make a new object\ncontaining the new value. The major core types in Python break down as follows:\nImmutables (numbers, strings, tuples, frozensets)\nNone of the object types in the immutable category support in-place changes,\nthough we can always run expressions to make new objects and assign their results\nto variables as needed.\n\n194 | Chapter 7: Strings",
    "194 | Chapter 7: Strings\n\n\fMutables (lists, dictionaries, sets)\nConversely, the mutable types can always be changed in-place with operations that\ndo not create new objects. Although such objects can be copied, in-place changes\nsupport direct modification.\nGenerally, immutable types give some degree of integrity by guaranteeing that an object\nwon’t be changed by another part of a program. For a refresher on why this matters,\nsee the discussion of shared object references in Chapter 6. To see how lists, dictionaries, and tuples participate in type categories, we need to move ahead to the next\nchapter.",
    "Chapter Summary\nIn this chapter, we took an in-depth tour of the string object type. We learned about\ncoding string literals, and we explored string operations, including sequence expressions, string method calls, and string formatting with both expressions and method\ncalls. Along the way, we studied a variety of concepts in depth, such as slicing, method\ncall syntax, and triple-quoted block strings. We also defined some core ideas common\nto a variety of types: sequences, for example, share an entire set of operations.\nIn the next chapter, we’ll continue our types tour with a look at the most general object\ncollections in Python—lists and dictionaries. As you’ll find, much of what you’ve\nlearned here will apply to those types as well. And as mentioned earlier, in the final part\nof this book we’ll return to Python’s string model to flesh out the details of Unicode\ntext and binary data, which are of interest to some, but not all, Python programmers.",
    "collections in Python—lists and dictionaries. As you’ll find, much of what you’ve\nlearned here will apply to those types as well. And as mentioned earlier, in the final part\nof this book we’ll return to Python’s string model to flesh out the details of Unicode\ntext and binary data, which are of interest to some, but not all, Python programmers.\nBefore moving on, though, here’s another chapter quiz to review the material covered\nhere.",
    "Test Your Knowledge: Quiz\n1. Can the string find method be used to search a list?\n2. Can a string slice expression be used on a list?\n3. How would you convert a character to its ASCII integer code? How would you\nconvert the other way, from an integer to a character?\n4. How might you go about changing a string in Python?\n5. Given a string S with the value \"s,pa,m\", name two ways to extract the two characters in the middle.\n6. How many characters are there in the string \"a\\nb\\x1f\\000d\"?\n7. Why might you use the string module instead of string method calls?\n\nTest Your Knowledge: Quiz | 195",
    "Test Your Knowledge: Answers\n1. No, because methods are always type-specific; that is, they only work on a single\ndata type. Expressions like X+Y and built-in functions like len(X) are generic,\nthough, and may work on a variety of types. In this case, for instance, the in membership expression has a similar effect as the string find, but it can be used to search\nboth strings and lists. In Python 3.0, there is some attempt to group methods by\ncategories (for example, the mutable sequence types list and bytearray have similar method sets), but methods are still more type-specific than other operation sets.\n2. Yes. Unlike methods, expressions are generic and apply to many types. In this case,\nthe slice expression is really a sequence operation—it works on any type of sequence object, including strings, lists, and tuples. The only difference is that when\nyou slice a list, you get back a new list.\n3. The built-in ord(S) function converts from a one-character string to an integer",
    "2. Yes. Unlike methods, expressions are generic and apply to many types. In this case,\nthe slice expression is really a sequence operation—it works on any type of sequence object, including strings, lists, and tuples. The only difference is that when\nyou slice a list, you get back a new list.\n3. The built-in ord(S) function converts from a one-character string to an integer\ncharacter code; chr(I) converts from the integer code back to a string.\n4. Strings cannot be changed; they are immutable. However, you can achieve a similar\neffect by creating a new string—by concatenating, slicing, running formatting expressions, or using a method call like replace—and then assigning the result back\nto the original variable name.\n5. You can slice the string using S[2:4], or split on the comma and index the string\nusing S.split(',')[1]. Try these interactively to see for yourself.\n6. Six. The string \"a\\nb\\x1f\\000d\" contains the bytes a, newline (\\n), b, binary 31 (a",
    "to the original variable name.\n5. You can slice the string using S[2:4], or split on the comma and index the string\nusing S.split(',')[1]. Try these interactively to see for yourself.\n6. Six. The string \"a\\nb\\x1f\\000d\" contains the bytes a, newline (\\n), b, binary 31 (a\nhex escape \\x1f), binary 0 (an octal escape \\000), and d. Pass the string to the builtin len function to verify this, and print each of its character’s ord results to see the\nactual byte values. See Table 7-2 for more details.\n7. You should never use the string module instead of string object method calls\ntoday—it’s deprecated, and its calls are removed completely in Python 3.0. The\nonly reason for using the string module at all is for its other tools, such as predefined constants. You might also see it appear in what is now very old and dusty\nPython code.",
    "196 | Chapter 7: Strings\n\n\fCHAPTER 8\n\nLists and Dictionaries\n\nThis chapter presents the list and dictionary object types, both of which are collections\nof other objects. These two types are the main workhorses in almost all Python scripts.\nAs you’ll see, both types are remarkably flexible: they can be changed in-place, can\ngrow and shrink on demand, and may contain and be nested in any other kind of object.\nBy leveraging these types, you can build up and process arbitrarily rich information\nstructures in your scripts.",
    "Lists\nThe next stop on our built-in object tour is the Python list. Lists are Python’s most\nflexible ordered collection object type. Unlike strings, lists can contain any sort of\nobject: numbers, strings, and even other lists. Also, unlike strings, lists may be changed\nin-place by assignment to offsets and slices, list method calls, deletion statements, and\nmore—they are mutable objects.\nPython lists do the work of most of the collection data structures you might have to\nimplement manually in lower-level languages such as C. Here is a quick look at their\nmain properties. Python lists are:\nOrdered collections of arbitrary objects\nFrom a functional view, lists are just places to collect other objects so you can treat\nthem as groups. Lists also maintain a left-to-right positional ordering among the\nitems they contain (i.e., they are sequences).\nAccessed by offset\nJust as with strings, you can fetch a component object out of a list by indexing the",
    "main properties. Python lists are:\nOrdered collections of arbitrary objects\nFrom a functional view, lists are just places to collect other objects so you can treat\nthem as groups. Lists also maintain a left-to-right positional ordering among the\nitems they contain (i.e., they are sequences).\nAccessed by offset\nJust as with strings, you can fetch a component object out of a list by indexing the\nlist on the object’s offset. Because items in lists are ordered by their positions, you\ncan also do tasks such as slicing and concatenation.",
    "197",
    "Variable-length, heterogeneous, and arbitrarily nestable\nUnlike strings, lists can grow and shrink in-place (their lengths can vary), and they\ncan contain any sort of object, not just one-character strings (they’re\nheterogeneous). Because lists can contain other complex objects, they also support\narbitrary nesting; you can create lists of lists of lists, and so on.\nOf the category “mutable sequence”\nIn terms of our type category qualifiers, lists are mutable (i.e., can be changed inplace) and can respond to all the sequence operations used with strings, such as\nindexing, slicing, and concatenation. In fact, sequence operations work the same\non lists as they do on strings; the only difference is that sequence operations such\nas concatenation and slicing return new lists instead of new strings when applied\nto lists. Because lists are mutable, however, they also support other operations that\nstrings don’t (such as deletion and index assignment operations, which change the",
    "on lists as they do on strings; the only difference is that sequence operations such\nas concatenation and slicing return new lists instead of new strings when applied\nto lists. Because lists are mutable, however, they also support other operations that\nstrings don’t (such as deletion and index assignment operations, which change the\nlists in-place).\nArrays of object references\nTechnically, Python lists contain zero or more references to other objects. Lists\nmight remind you of arrays of pointers (addresses) if you have a background in\nsome other languages. Fetching an item from a Python list is about as fast as indexing a C array; in fact, lists really are arrays inside the standard Python interpreter, not linked structures. As we learned in Chapter 6, though, Python always\nfollows a reference to an object whenever the reference is used, so your program",
    "some other languages. Fetching an item from a Python list is about as fast as indexing a C array; in fact, lists really are arrays inside the standard Python interpreter, not linked structures. As we learned in Chapter 6, though, Python always\nfollows a reference to an object whenever the reference is used, so your program\ndeals only with objects. Whenever you assign an object to a data structure component or variable name, Python always stores a reference to that same object, not\na copy of it (unless you request a copy explicitly).\nTable 8-1 summarizes common and representative list object operations. As usual, for\nthe full story see the Python standard library manual, or run a help(list) or\ndir(list) call interactively for a complete list of list methods—you can pass in a real\nlist, or the word list, which is the name of the list data type.\nTable 8-1. Common list literals and operations\nOperation",
    "Interpretation\n\nL = []\n\nAn empty list\n\nL = [0, 1, 2, 3]\n\nFour items: indexes 0..3\n\nL = ['abc', ['def', 'ghi']]\n\nNested sublists\n\nL = list('spam')\n\nLists of an iterable’s items, list of successive integers\n\nL = list(range(-4, 4))\nL[i]\nL[i][j]\nL[i:j]\nlen(L)\n\n198 | Chapter 8: Lists and Dictionaries\n\nIndex, index of index, slice, length\n\n\fOperation\n\nInterpretation\n\nL1 + L2\n\nConcatenate, repeat\n\nL * 3\nfor x in L: print(x)\n\nIteration, membership\n\n3 in L\nL.append(4)\n\nMethods: growing\n\nL.extend([5,6,7])\nL.insert(I, X)\nL.index(1)\n\nMethods: searching\n\nL.count(X)\nL.sort()\n\nMethods: sorting, reversing, etc.\n\nL.reverse()\ndel L[k]\n\nMethods, statement: shrinking\n\ndel L[i:j]\nL.pop()\nL.remove(2)\nL[i:j] = []\nL[i] = 1\n\nIndex assignment, slice assignment\n\nL[i:j] = [4,5,6]\nL = [x**2 for x in range(5)]\n\nList comprehensions and maps (Chapters 14, 20)\n\nlist(map(ord, 'spam'))",
    "List comprehensions and maps (Chapters 14, 20)\n\nlist(map(ord, 'spam'))\n\nWhen written down as a literal expression, a list is coded as a series of objects (really,\nexpressions that return objects) in square brackets, separated by commas. For instance,\nthe second row in Table 8-1 assigns the variable L to a four-item list. A nested list is\ncoded as a nested square-bracketed series (row 3), and the empty list is just a squarebracket pair with nothing inside (row 1).*\nMany of the operations in Table 8-1 should look familiar, as they are the same sequence\noperations we put to work on strings—indexing, concatenation, iteration, and so on.\nLists also respond to list-specific method calls (which provide utilities such as sorting,\nreversing, adding items to the end, etc.), as well as in-place change operations (deleting\nitems, assignment to indexes and slices, and so forth). Lists have these tools for change\noperations because they are a mutable object type.",
    "* In practice, you won’t see many lists written out like this in list-processing programs. It’s more common to\nsee code that processes lists constructed dynamically (at runtime). In fact, although it’s important to master\nliteral syntax, most data structures in Python are built by running program code at runtime.\n\nLists | 199\n\n\fLists in Action\nPerhaps the best way to understand lists is to see them at work. Let’s once again turn\nto some simple interpreter interactions to illustrate the operations in Table 8-1.\n\nBasic List Operations\nBecause they are sequences, lists support many of the same operations as strings. For\nexample, lists respond to the + and * operators much like strings—they mean concatenation and repetition here too, except that the result is a new list, not a string:\n% python\n>>> len([1, 2, 3])\n3\n>>> [1, 2, 3] + [4, 5, 6]\n[1, 2, 3, 4, 5, 6]\n>>> ['Ni!'] * 4\n['Ni!', 'Ni!', 'Ni!', 'Ni!']\n\n# Length\n# Concatenation\n# Repetition",
    "# Length\n# Concatenation\n# Repetition\n\nAlthough the + operator works the same for lists and strings, it’s important to know\nthat it expects the same sort of sequence on both sides—otherwise, you get a type error\nwhen the code runs. For instance, you cannot concatenate a list and a string unless you\nfirst convert the list to a string (using tools such as str or % formatting) or convert the\nstring to a list (the list built-in function does the trick):\n>>> str([1, 2]) + \"34\"\n'[1, 2]34'\n>>> [1, 2] + list(\"34\")\n[1, 2, '3', '4']\n\n# Same as \"[1, 2]\" + \"34\"\n# Same as [1, 2] + [\"3\", \"4\"]\n\nList Iteration and Comprehensions\nMore generally, lists respond to all the sequence operations we used on strings in the\nprior chapter, including iteration tools:\n>>> 3 in [1, 2, 3]\nTrue\n>>> for x in [1, 2, 3]:\n...\nprint(x, end=' ')\n...\n1 2 3\n\n# Membership\n# Iteration",
    "# Same as \"[1, 2]\" + \"34\"\n# Same as [1, 2] + [\"3\", \"4\"]\n\nList Iteration and Comprehensions\nMore generally, lists respond to all the sequence operations we used on strings in the\nprior chapter, including iteration tools:\n>>> 3 in [1, 2, 3]\nTrue\n>>> for x in [1, 2, 3]:\n...\nprint(x, end=' ')\n...\n1 2 3\n\n# Membership\n# Iteration\n\nWe will talk more formally about for iteration and the range built-ins in Chapter 13,\nbecause they are related to statement syntax. In short, for loops step through items in\nany sequence from left to right, executing one or more statements for each item.\nThe last items in Table 8-1, list comprehensions and map calls, are covered in more detail\nin Chapter 14 and expanded on in Chapter 20. Their basic operation is straightforward,\nthough—as introduced in Chapter 4, list comprehensions are a way to build a new list\n\n200 | Chapter 8: Lists and Dictionaries",
    "200 | Chapter 8: Lists and Dictionaries\n\n\fby applying an expression to each item in a sequence, and are close relatives to for\nloops:\n# List comprehensions\n\n>>> res = [c * 4 for c in 'SPAM']\n>>> res\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\nThis expression is functionally equivalent to a for loop that builds up a list of results\nmanually, but as we’ll learn in later chapters, list comprehensions are simpler to code\nand faster to run today:\n>>> res = []\n>>> for c in 'SPAM':\n...\nres.append(c * 4)\n...\n>>> res\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n# List comprehension equivalent\n\nAs also introduced in Chapter 4, the map built-in function does similar work, but applies\na function to items in a sequence and collects all the results in a new list:\n# map function across sequence\n\n>>> list(map(abs, [−1, −2, 0, 1, 2]))\n[1, 2, 0, 1, 2]",
    "# List comprehension equivalent\n\nAs also introduced in Chapter 4, the map built-in function does similar work, but applies\na function to items in a sequence and collects all the results in a new list:\n# map function across sequence\n\n>>> list(map(abs, [−1, −2, 0, 1, 2]))\n[1, 2, 0, 1, 2]\n\nBecause we’re not quite ready for the full iteration story, we’ll postpone further details\nfor now, but watch for a similar comprehension expression for dictionaries later in this\nchapter.\n\nIndexing, Slicing, and Matrixes\nBecauselists are sequences, indexing and slicing work the same way for lists as they do\nfor strings. However, the result of indexing a list is whatever type of object lives at the\noffset you specify, while slicing a list always returns a new list:\n>>> L = ['spam', 'Spam', 'SPAM!']\n>>> L[2]\n'SPAM!'\n>>> L[−2]\n'Spam'\n>>> L[1:]\n['Spam', 'SPAM!']\n\n# Offsets start at zero\n# Negative: count from the right\n# Slicing fetches sections",
    "# Offsets start at zero\n# Negative: count from the right\n# Slicing fetches sections\n\nOne note here: because you can nest lists and other object types within lists, you will\nsometimes need to string together index operations to go deeper into a data structure.\nFor example, one of the simplest ways to represent matrixes (multidimensional arrays)\nin Python is as lists with nested sublists. Here’s a basic 3 × 3 two-dimensional list-based\narray:\n>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nWith one index, you get an entire row (really, a nested sublist), and with two, you get\nan item within the row:\n\nLists in Action | 201\n\n\f>>> matrix[1]\n[4, 5, 6]\n>>> matrix[1][1]\n5\n>>> matrix[2][0]\n7\n>>> matrix = [[1, 2, 3],\n...\n[4, 5, 6],\n...\n[7, 8, 9]]\n>>> matrix[1][1]\n5",
    "With one index, you get an entire row (really, a nested sublist), and with two, you get\nan item within the row:\n\nLists in Action | 201\n\n\f>>> matrix[1]\n[4, 5, 6]\n>>> matrix[1][1]\n5\n>>> matrix[2][0]\n7\n>>> matrix = [[1, 2, 3],\n...\n[4, 5, 6],\n...\n[7, 8, 9]]\n>>> matrix[1][1]\n5\n\nNotice in the preceding interaction that lists can naturally span multiple lines if you\nwant them to because they are contained by a pair of brackets (more on syntax in the\nnext part of the book). Later in this chapter, you’ll also see a dictionary-based matrix\nrepresentation. For high-powered numeric work, the NumPy extension mentioned in\nChapter 5 provides other ways to handle matrixes.",
    "Notice in the preceding interaction that lists can naturally span multiple lines if you\nwant them to because they are contained by a pair of brackets (more on syntax in the\nnext part of the book). Later in this chapter, you’ll also see a dictionary-based matrix\nrepresentation. For high-powered numeric work, the NumPy extension mentioned in\nChapter 5 provides other ways to handle matrixes.\n\nChanging Lists In-Place\nBecause lists are mutable, they support operations that change a list object in-place.\nThat is, the operations in this section all modify the list object directly, without requiring that you make a new copy, as you had to for strings. Because Python deals only in\nobject references, this distinction between changing an object in-place and creating a\nnew object matters—as discussed in Chapter 6, if you change an object in-place, you\nmight impact more than one reference to it at the same time.",
    "Index and slice assignments\nWhen using a list, you can change its contents by assigning to either a particular item\n(offset) or an entire section (slice):\n>>> L = ['spam', 'Spam', 'SPAM!']\n>>> L[1] = 'eggs'\n# Index assignment\n>>> L\n['spam', 'eggs', 'SPAM!']\n>>> L[0:2] = ['eat', 'more']\n# Slice assignment: delete+insert\n>>> L\n# Replaces items 0,1\n['eat', 'more', 'SPAM!']\n\nBoth index and slice assignments are in-place changes—they modify the subject list\ndirectly, rather than generating a new list object for the result. Index assignment in\nPython works much as it does in C and most other languages: Python replaces the\nobject reference at the designated offset with a new one.\nSlice assignment, the last operation in the preceding example, replaces an entire section\nof a list in a single step. Because it can be a bit complex, it is perhaps best thought of\nas a combination of two steps:\n\n202 | Chapter 8: Lists and Dictionaries",
    "1. Deletion. The slice you specify to the left of the = is deleted.\n2. Insertion. The new items contained in the object to the right of the = are inserted\ninto the list on the left, at the place where the old slice was deleted.†\nThis isn’t what really happens, but it tends to help clarify why the number of items\ninserted doesn’t have to match the number of items deleted. For instance, given a list\nL that has the value [1,2,3], the assignment L[1:2]=[4,5] sets L to the list [1,4,5,3].\nPython first deletes the 2 (a one-item slice), then inserts the 4 and 5 where the deleted\n2 used to be. This also explains why L[1:2]=[] is really a deletion operation—Python\ndeletes the slice (the item at offset 1), and then inserts nothing.\nIn effect, slice assignment replaces an entire section, or “column,” all at once. Because\nthe length of the sequence being assigned does not have to match the length of the slice",
    "2 used to be. This also explains why L[1:2]=[] is really a deletion operation—Python\ndeletes the slice (the item at offset 1), and then inserts nothing.\nIn effect, slice assignment replaces an entire section, or “column,” all at once. Because\nthe length of the sequence being assigned does not have to match the length of the slice\nbeing assigned to, slice assignment can be used to replace (by overwriting), expand (by\ninserting), or shrink (by deleting) the subject list. It’s a powerful operation, but frankly,\none that you may not see very often in practice. There are usually more straightforward\nways to replace, insert, and delete (concatenation and the insert, pop, and remove list\nmethods, for example), which Python programmers tend to prefer in practice.",
    "List method calls\nLike strings, Python list objects also support type-specific method calls, many of which\nchange the subject list in-place:\n>>> L.append('please')\n>>> L\n['eat', 'more', 'SPAM!', 'please']\n>>> L.sort()\n>>> L\n['SPAM!', 'eat', 'more', 'please']\n\n# Append method call: add item at end\n# Sort list items ('S' < 'e')",
    "Methods were introduced in Chapter 7. In brief, they are functions (really, attributes\nthat reference functions) that are associated with particular objects. Methods provide\ntype-specific tools; the list methods presented here, for instance, are generally available\nonly for lists.\nPerhaps the most commonly used list method is append, which simply tacks a single\nitem (object reference) onto the end of the list. Unlike concatenation, append expects\nyou to pass in a single object, not a list. The effect of L.append(X) is similar to L+[X],\nbut while the former changes L in-place, the latter makes a new list.‡\nAnother commonly seen method, sort, orders a list in-place; it uses Python standard\ncomparison tests (here, string comparisons), and by default sorts in ascending order.\n† This description needs elaboration when the value and the slice being assigned overlap: L[2:5]=L[3:6], for\ninstance, works fine because the value to be inserted is fetched before the deletion happens on the left.",
    "Another commonly seen method, sort, orders a list in-place; it uses Python standard\ncomparison tests (here, string comparisons), and by default sorts in ascending order.\n† This description needs elaboration when the value and the slice being assigned overlap: L[2:5]=L[3:6], for\ninstance, works fine because the value to be inserted is fetched before the deletion happens on the left.\n‡ Unlike + concatenation, append doesn’t have to generate new objects, so it’s usually faster. You can also mimic\nappend with clever slice assignments: L[len(L):]=[X] is like L.append(X), and L[:0]=[X] is like appending at\nthe front of a list. Both delete an empty slice and insert X, changing L in-place quickly, like append.",
    "Lists in Action | 203\n\n\fYou can modify sort behavior by passing in keyword arguments—a special\n“name=value” syntax in function calls that specifies passing by name and is often used\nfor giving configuration options. In sorts, the key argument gives a one-argument function that returns the value to be used in sorting, and the reverse argument allows sorts\nto be made in descending instead of ascending order:\n>>> L = ['abc', 'ABD', 'aBe']\n>>> L.sort()\n>>> L\n['ABD', 'aBe', 'abc']\n>>> L = ['abc', 'ABD', 'aBe']\n>>> L.sort(key=str.lower)\n>>> L\n['abc', 'ABD', 'aBe']\n>>>\n>>> L = ['abc', 'ABD', 'aBe']\n>>> L.sort(key=str.lower, reverse=True)\n>>> L\n['aBe', 'ABD', 'abc']\n\n# Sort with mixed case\n\n# Normalize to lowercase\n\n# Change sort order",
    "The sort key argument might also be useful when sorting lists of dictionaries, to pick\nout a sort key by indexing each dictionary. We’ll study dictionaries later in this chapter,\nand you’ll learn more about keyword function arguments in Part IV.\nComparison and sorts in 3.0: In Python 2.6 and earlier, comparisons of\ndifferently typed objects (e.g., a string and a list) work—the language\ndefines a fixed ordering among different types, which is deterministic,\nif not aesthetically pleasing. That is, the ordering is based on the names\nof the types involved: all integers are less than all strings, for example,\nbecause \"int\" is less than \"str\". Comparisons never automatically convert types, except when comparing numeric type objects.\nIn Python 3.0, this has changed: comparison of mixed types raises an\nexception instead of falling back on the fixed cross-type ordering. Because sorting uses comparisons internally, this means that [1, 2,",
    "because \"int\" is less than \"str\". Comparisons never automatically convert types, except when comparing numeric type objects.\nIn Python 3.0, this has changed: comparison of mixed types raises an\nexception instead of falling back on the fixed cross-type ordering. Because sorting uses comparisons internally, this means that [1, 2,\n'spam'].sort() succeeds in Python 2.X but will raise an exception in\nPython 3.0 and later.\nPython 3.0 also no longer supports passing in an arbitrary comparison\nfunction to sorts, to implement different orderings. The suggested workaround is to use the key=func keyword argument to code value transformations during the sort, and use the reverse=True keyword argument\nto change the sort order to descending. These were the typical uses of\ncomparison functions in the past.",
    "One warning here: beware that append and sort change the associated list object inplace, but don’t return the list as a result (technically, they both return a value called\nNone). If you say something like L=L.append(X), you won’t get the modified value of L\n(in fact, you’ll lose the reference to the list altogether!). When you use attributes such\nas append and sort, objects are changed as a side effect, so there’s no reason to reassign.\n204 | Chapter 8: Lists and Dictionaries\n\n\fPartly because of such constraints, sorting is also available in recent Pythons as a builtin function, which sorts any collection (not just lists) and returns a new list for the result\n(instead of in-place changes):\n>>> L = ['abc', 'ABD', 'aBe']\n>>> sorted(L, key=str.lower, reverse=True)\n['aBe', 'ABD', 'abc']\n\n# Sorting built-in\n\n>>> L = ['abc', 'ABD', 'aBe']\n>>> sorted([x.lower() for x in L], reverse=True)\n['abe', 'abd', 'abc']\n\n# Pretransform items: differs!",
    "Notice the last example here—we can convert to lowercase prior to the sort with a list\ncomprehension, but the result does not contain the original list’s values as it does with\nthe key argument. The latter is applied temporarily during the sort, instead of changing\nthe values to be sorted. As we move along, we’ll see contexts in which the sorted builtin can sometimes be more useful than the sort method.\nLike strings, lists have other methods that perform other specialized operations. For\ninstance, reverse reverses the list in-place, and the extend and pop methods insert multiple items at the end of and delete an item from the end of the list, respectively. There\nis also a reversed built-in function that works much like sorted, but it must be wrapped\nin a list call because it’s an iterator (more on iterators later):\n>>> L = [1, 2]\n>>> L.extend([3,4,5])\n>>> L\n[1, 2, 3, 4, 5]\n>>> L.pop()\n5\n>>> L\n[1, 2, 3, 4]\n>>> L.reverse()\n>>> L\n[4, 3, 2, 1]\n>>> list(reversed(L))\n[1, 2, 3, 4]",
    "# Add many items at end\n# Delete and return last item\n\n# In-place reversal method\n# Reversal built-in with a result\n\nIn some types of programs, the list pop method used here is often used in conjunction\nwith append to implement a quick last-in-first-out (LIFO) stack structure. The end of\nthe list serves as the top of the stack:\n>>> L = []\n>>> L.append(1)\n>>> L.append(2)\n>>> L\n[1, 2]\n>>> L.pop()\n2\n>>> L\n[1]\n\n# Push onto stack\n\n# Pop off stack\n\nLists in Action | 205\n\n\fThe pop method also accepts an optional offset of the item to be deleted and returned\n(the default is the last item). Other list methods remove an item by value (remove), insert\nan item at an offset (insert), search for an item’s offset (index), and more:\n>>> L = ['spam', 'eggs', 'ham']\n>>> L.index('eggs')\n1\n>>> L.insert(1, 'toast')\n>>> L\n['spam', 'toast', 'eggs', 'ham']\n>>> L.remove('eggs')\n>>> L\n['spam', 'toast', 'ham']\n>>> L.pop(1)\n'toast'\n>>> L\n['spam', 'ham']",
    "# Index of an object\n# Insert at position\n# Delete by value\n# Delete by position\n\nSee other documentation sources or experiment with these calls interactively on your\nown to learn more about list methods.\n\nOther common list operations\nBecause lists are mutable, you can use the del statement to delete an item or section\nin-place:\n>>> L\n['SPAM!', 'eat', 'more', 'please']\n>>> del L[0]\n>>> L\n['eat', 'more', 'please']\n>>> del L[1:]\n>>> L\n['eat']\n\n# Delete one item\n# Delete an entire section\n# Same as L[1:] = []\n\nBecause slice assignment is a deletion plus an insertion, you can also delete a section\nof a list by assigning an empty list to a slice (L[i:j]=[]); Python deletes the slice named\non the left, and then inserts nothing. Assigning an empty list to an index, on the other\nhand, just stores a reference to the empty list in the specified slot, rather than deleting\nit:\n>>> L = ['Already', 'got', 'one']\n>>> L[1:] = []\n>>> L\n['Already']\n>>> L[0] = []\n>>> L\n[[]]",
    "Although all the operations just discussed are typical, there are additional list methods\nand operations not illustrated here (including methods for inserting and searching).\nFor a comprehensive and up-to-date list of type tools, you should always consult\n\n206 | Chapter 8: Lists and Dictionaries\n\n\fPython’s manuals, Python’s dir and help functions (which we first met in Chapter 4),\nor one of the reference texts mentioned in the Preface.\nI’d also like to remind you one more time that all the in-place change operations discussed here work only for mutable objects: they won’t work on strings (or tuples, discussed in Chapter 9), no matter how hard you try. Mutability is an inherent property\nof each object type.",
    "Dictionaries\nApart from lists, dictionaries are perhaps the most flexible built-in data type in Python.\nIf you think of lists as ordered collections of objects, you can think of dictionaries as\nunordered collections; the chief distinction is that in dictionaries, items are stored and\nfetched by key, instead of by positional offset.\nBeing a built-in type, dictionaries can replace many of the searching algorithms and\ndata structures you might have to implement manually in lower-level languages—\nindexing a dictionary is a very fast search operation. Dictionaries also sometimes do\nthe work of records and symbol tables used in other languages, can represent sparse\n(mostly empty) data structures, and much more. Here’s a rundown of their main properties. Python dictionaries are:\nAccessed by key, not offset\nDictionaries are sometimes called associative arrays or hashes. They associate a set\nof values with keys, so you can fetch an item out of a dictionary using the key under",
    "the work of records and symbol tables used in other languages, can represent sparse\n(mostly empty) data structures, and much more. Here’s a rundown of their main properties. Python dictionaries are:\nAccessed by key, not offset\nDictionaries are sometimes called associative arrays or hashes. They associate a set\nof values with keys, so you can fetch an item out of a dictionary using the key under\nwhich you originally stored it. You use the same indexing operation to get components in a dictionary as you do in a list, but the index takes the form of a key,\nnot a relative offset.\nUnordered collections of arbitrary objects\nUnlike in a list, items stored in a dictionary aren’t kept in any particular order; in\nfact, Python randomizes their left-to-right order to provide quick lookup. Keys\nprovide the symbolic (not physical) locations of items in a dictionary.\nVariable-length, heterogeneous, and arbitrarily nestable",
    "not a relative offset.\nUnordered collections of arbitrary objects\nUnlike in a list, items stored in a dictionary aren’t kept in any particular order; in\nfact, Python randomizes their left-to-right order to provide quick lookup. Keys\nprovide the symbolic (not physical) locations of items in a dictionary.\nVariable-length, heterogeneous, and arbitrarily nestable\nLike lists, dictionaries can grow and shrink in-place (without new copies being\nmade), they can contain objects of any type, and they support nesting to any depth\n(they can contain lists, other dictionaries, and so on).\nOf the category “mutable mapping”\nDictionaries can be changed in-place by assigning to indexes (they are mutable),\nbut they don’t support the sequence operations that work on strings and lists.\nBecause dictionaries are unordered collections, operations that depend on a fixed",
    "(they can contain lists, other dictionaries, and so on).\nOf the category “mutable mapping”\nDictionaries can be changed in-place by assigning to indexes (they are mutable),\nbut they don’t support the sequence operations that work on strings and lists.\nBecause dictionaries are unordered collections, operations that depend on a fixed\npositional order (e.g., concatenation, slicing) don’t make sense. Instead, dictionaries are the only built-in representatives of the mapping type category (objects\nthat map keys to values).",
    "Dictionaries | 207",
    "Tables of object references (hash tables)\nIf lists are arrays of object references that support access by position, dictionaries\nare unordered tables of object references that support access by key. Internally,\ndictionaries are implemented as hash tables (data structures that support very fast\nretrieval), which start small and grow on demand. Moreover, Python employs optimized hashing algorithms to find keys, so retrieval is quick. Like lists, dictionaries\nstore object references (not copies).\nTable 8-2 summarizes some of the most common and representative dictionary operations (again, see the library manual or run a dir(dict) or help(dict) call for a complete\nlist—dict is the name of the type). When coded as a literal expression, a dictionary is\nwritten as a series of key:value pairs, separated by commas, enclosed in curly\nbraces.§ An empty dictionary is an empty set of braces, and dictionaries can be nested",
    "list—dict is the name of the type). When coded as a literal expression, a dictionary is\nwritten as a series of key:value pairs, separated by commas, enclosed in curly\nbraces.§ An empty dictionary is an empty set of braces, and dictionaries can be nested\nby writing one as a value inside another dictionary, or within a list or tuple.\nTable 8-2. Common dictionary literals and operations\nOperation",
    "Interpretation\n\nD = {}\n\nEmpty dictionary\n\nD = {'spam': 2, 'eggs': 3}\n\nTwo-item dictionary\n\nD = {'food': {'ham': 1, 'egg': 2}}\n\nNesting\n\nD = dict(name='Bob', age=40)\n\nAlternative construction techniques:\n\nD = dict(zip(keyslist, valslist))\n\nkeywords, zipped pairs, key lists\n\nD = dict.fromkeys(['a', 'b'])\nD['eggs']\n\nIndexing by key\n\nD['food']['ham']\n'eggs' in D\n\nMembership: key present test\n\nD.keys()\n\nMethods: keys,\n\nD.values()\n\nvalues,\n\nD.items()\n\nkeys+values,\n\nD.copy()\n\ncopies,\n\nD.get(key, default)\n\ndefaults,\n\nD.update(D2)\n\nmerge,\n\nD.pop(key)\n\ndelete, etc.\n\nlen(D)\n\nLength: number of stored entries\n\nD[key] = 42\n\nAdding/changing keys\n\n§ As with lists, you won’t often see dictionaries constructed using literals. Lists and dictionaries are grown in\ndifferent ways, though. As you’ll see in the next section, dictionaries are typically built up by assigning to\nnew keys at runtime; this approach fails for lists (lists are commonly grown with append instead).",
    "Length: number of stored entries\n\nD[key] = 42\n\nAdding/changing keys\n\n§ As with lists, you won’t often see dictionaries constructed using literals. Lists and dictionaries are grown in\ndifferent ways, though. As you’ll see in the next section, dictionaries are typically built up by assigning to\nnew keys at runtime; this approach fails for lists (lists are commonly grown with append instead).\n\n208 | Chapter 8: Lists and Dictionaries\n\n\fOperation\n\nInterpretation\n\ndel D[key]\n\nDeleting entries by key\n\nlist(D.keys())\n\nDictionary views (Python 3.0)\n\nD1.keys() & D2.keys()\nD = {x: x*2 for x in range(10)}\n\nDictionary comprehensions (Python 3.0)",
    "208 | Chapter 8: Lists and Dictionaries\n\n\fOperation\n\nInterpretation\n\ndel D[key]\n\nDeleting entries by key\n\nlist(D.keys())\n\nDictionary views (Python 3.0)\n\nD1.keys() & D2.keys()\nD = {x: x*2 for x in range(10)}\n\nDictionary comprehensions (Python 3.0)\n\nDictionaries in Action\nAs Table 8-2 suggests, dictionaries are indexed by key, and nested dictionary entries\nare referenced by a series of indexes (keys in square brackets). When Python creates a\ndictionary, it stores its items in any left-to-right order it chooses; to fetch a value back,\nyou supply the key with which it is associated, not its relative position. Let’s go back\nto the interpreter to get a feel for some of the dictionary operations in Table 8-2.\n\nBasic Dictionary Operations\nIn normal operation, you create dictionaries with literals and store and access items by\nkey with indexing:\n% python\n>>> D = {'spam': 2, 'ham': 1, 'eggs': 3}\n>>> D['spam']\n2\n>>> D\n{'eggs': 3, 'ham': 1, 'spam': 2}",
    "Basic Dictionary Operations\nIn normal operation, you create dictionaries with literals and store and access items by\nkey with indexing:\n% python\n>>> D = {'spam': 2, 'ham': 1, 'eggs': 3}\n>>> D['spam']\n2\n>>> D\n{'eggs': 3, 'ham': 1, 'spam': 2}\n\n# Make a dictionary\n# Fetch a value by key\n# Order is scrambled",
    "Here, the dictionary is assigned to the variable D; the value of the key 'spam' is the\ninteger 2, and so on. We use the same square bracket syntax to index dictionaries by\nkey as we did to index lists by offset, but here it means access by key, not by position.\nNotice the end of this example: the left-to-right order of keys in a dictionary will almost\nalways be different from what you originally typed. This is on purpose: to implement\nfast key lookup (a.k.a. hashing), keys need to be reordered in memory. That’s why\noperations that assume a fixed left-to-right order (e.g., slicing, concatenation) do not\napply to dictionaries; you can fetch values only by key, not by position.\nThe built-in len function works on dictionaries, too; it returns the number of items\nstored in the dictionary or, equivalently, the length of its keys list. The dictionary in\nmembership operator allows you to test for key existence, and the keys method returns",
    "apply to dictionaries; you can fetch values only by key, not by position.\nThe built-in len function works on dictionaries, too; it returns the number of items\nstored in the dictionary or, equivalently, the length of its keys list. The dictionary in\nmembership operator allows you to test for key existence, and the keys method returns\nall the keys in the dictionary. The latter of these can be useful for processing dictionaries\nsequentially, but you shouldn’t depend on the order of the keys list. Because the keys\nresult can be used as a normal list, however, it can always be sorted if order matters\n(more on sorting and dictionaries later):\n>>> len(D)\n3\n>>> 'ham' in D",
    "# Number of entries in dictionary\n# Key membership test alternative\n\nDictionaries in Action | 209\n\n\fTrue\n>>> list(D.keys())\n['eggs', 'ham', 'spam']\n\n# Create a new list of my keys",
    "Notice the second expression in this listing. As mentioned earlier, the in membership\ntest used for strings and lists also works on dictionaries—it checks whether a key is\nstored in the dictionary. Technically, this works because dictionaries define iterators\nthat step through their keys lists. Other types provide iterators that reflect their\ncommon uses; files, for example, have iterators that read line by line. We’ll discuss\niterators in Chapters 14 and 20.\nAlso note the syntax of the last example in this listing. We have to enclose it in a list\ncall in Python 3.0 for similar reasons—keys in 3.0 returns an iterator, instead of a\nphysical list. The list call forces it to produce all its values at once so we can print\nthem. In 2.6, keys builds and returns an actual list, so the list call isn’t needed to\ndisplay results. More on this later in this chapter.\nThe order of keys in a dictionary is arbitrary and can change from release",
    "call in Python 3.0 for similar reasons—keys in 3.0 returns an iterator, instead of a\nphysical list. The list call forces it to produce all its values at once so we can print\nthem. In 2.6, keys builds and returns an actual list, so the list call isn’t needed to\ndisplay results. More on this later in this chapter.\nThe order of keys in a dictionary is arbitrary and can change from release\nto release, so don’t be alarmed if your dictionaries print in a different\norder than shown here. In fact, the order has changed for me too—I’m\nrunning all these examples with Python 3.0, but their keys had a different order in an earlier edition when displayed. You shouldn’t depend\non dictionary key ordering, in either programs or books!",
    "Changing Dictionaries In-Place\nLet’s continue with our interactive session. Dictionaries, like lists, are mutable, so you\ncan change, expand, and shrink them in-place without making new dictionaries: simply\nassign a value to a key to change or create an entry. The del statement works here, too;\nit deletes the entry associated with the key specified as an index. Notice also the nesting\nof a list inside a dictionary in this example (the value of the key 'ham'). All collection\ndata types in Python can nest inside each other arbitrarily:\n>>> D\n{'eggs': 3, 'ham': 1, 'spam': 2}\n>>> D['ham'] = ['grill', 'bake', 'fry']\n# Change entry\n>>> D\n{'eggs': 3, 'ham': ['grill', 'bake', 'fry'], 'spam': 2}\n>>> del D['eggs']\n>>> D\n{'ham': ['grill', 'bake', 'fry'], 'spam': 2}\n\n# Delete entry\n\n>>> D['brunch'] = 'Bacon'\n# Add new entry\n>>> D\n{'brunch': 'Bacon', 'ham': ['grill', 'bake', 'fry'], 'spam': 2}\n\n210 | Chapter 8: Lists and Dictionaries",
    "# Delete entry\n\n>>> D['brunch'] = 'Bacon'\n# Add new entry\n>>> D\n{'brunch': 'Bacon', 'ham': ['grill', 'bake', 'fry'], 'spam': 2}\n\n210 | Chapter 8: Lists and Dictionaries\n\n\fAs with lists, assigning to an existing index in a dictionary changes its associated value.\nUnlike with lists, however, whenever you assign a new dictionary key (one that hasn’t\nbeen assigned before) you create a new entry in the dictionary, as was done in the\nprevious example for the key 'brunch'. This doesn’t work for lists because Python\nconsiders an offset beyond the end of a list out of bounds and throws an error. To\nexpand a list, you need to use tools such as the append method or slice assignment\ninstead.",
    "More Dictionary Methods\nDictionary methods provide a variety of tools. For instance, the dictionary values and\nitems methods return the dictionary’s values and (key,value) pair tuples, respectively\n(as with keys, wrap them in a list call in Python 3.0 to collect their values for display):\n>>> D = {'spam': 2, 'ham': 1, 'eggs': 3}\n>>> list(D.values())\n[3, 1, 2]\n>>> list(D.items())\n[('eggs', 3), ('ham', 1), ('spam', 2)]\n\nSuch lists are useful in loops that need to step through dictionary entries one by one.\nFetching a nonexistent key is normally an error, but the get method returns a default\nvalue (None, or a passed-in default) if the key doesn’t exist. It’s an easy way to fill in a\ndefault for a key that isn’t present and avoid a missing-key error:\n>>> D.get('spam')\n2\n>>> print(D.get('toast'))\nNone\n>>> D.get('toast', 88)\n88\n\n# A key that is there\n# A key that is missing",
    "# A key that is there\n# A key that is missing\n\nThe update method provides something similar to concatenation for dictionaries,\nthough it has nothing to do with left-to-right ordering (again, there is no such thing in\ndictionaries). It merges the keys and values of one dictionary into another, blindly\noverwriting values of the same key:\n>>> D\n{'eggs': 3, 'ham': 1, 'spam': 2}\n>>> D2 = {'toast':4, 'muffin':5}\n>>> D.update(D2)\n>>> D\n{'toast': 4, 'muffin': 5, 'eggs': 3, 'ham': 1, 'spam': 2}\n\nFinally, the dictionary pop method deletes a key from a dictionary and returns the value\nit had. It’s similar to the list pop method, but it takes a key instead of an optional\nposition:\n# pop a dictionary by key\n>>> D\n{'toast': 4, 'muffin': 5, 'eggs': 3, 'ham': 1, 'spam': 2}\n>>> D.pop('muffin')\n\nDictionaries in Action | 211",
    "Finally, the dictionary pop method deletes a key from a dictionary and returns the value\nit had. It’s similar to the list pop method, but it takes a key instead of an optional\nposition:\n# pop a dictionary by key\n>>> D\n{'toast': 4, 'muffin': 5, 'eggs': 3, 'ham': 1, 'spam': 2}\n>>> D.pop('muffin')\n\nDictionaries in Action | 211\n\n\f5\n>>> D.pop('toast')\n4\n>>> D\n{'eggs': 3, 'ham': 1, 'spam': 2}\n# pop a list by position\n>>> L = ['aa', 'bb', 'cc', 'dd']\n>>> L.pop()\n'dd'\n>>> L\n['aa', 'bb', 'cc']\n>>> L.pop(1)\n'bb'\n>>> L\n['aa', 'cc']\n\n# Delete and return from a key\n\n# Delete and return from the end\n\n# Delete from a specific position\n\nDictionaries also provide a copy method; we’ll discuss this in Chapter 9, as it’s a way\nto avoid the potential side effects of shared references to the same dictionary. In fact,\ndictionaries come with many more methods than those listed in Table 8-2; see the\nPython library manual or other documentation sources for a comprehensive list.",
    "# Delete from a specific position\n\nDictionaries also provide a copy method; we’ll discuss this in Chapter 9, as it’s a way\nto avoid the potential side effects of shared references to the same dictionary. In fact,\ndictionaries come with many more methods than those listed in Table 8-2; see the\nPython library manual or other documentation sources for a comprehensive list.\n\nA Languages Table\nLet’s look at a more realistic dictionary example. The following example creates a table\nthat maps programming language names (the keys) to their creators (the values). You\nfetch creator names by indexing on language names:\n>>> table = {'Python': 'Guido van Rossum',\n...\n'Perl':\n'Larry Wall',\n...\n'Tcl':\n'John Ousterhout' }\n>>>\n>>> language = 'Python'\n>>> creator = table[language]\n>>> creator\n'Guido van Rossum'\n>>> for lang in table:\n...\nprint(lang, '\\t', table[lang])\n...\nTcl\nJohn Ousterhout\nPython Guido van Rossum\nPerl\nLarry Wall\n\n# Same as: for lang in table.keys()",
    "# Same as: for lang in table.keys()\n\nThe last command uses a for loop, which we haven’t covered in detail yet. If you aren’t\nfamiliar with for loops, this command simply iterates through each key in the table\nand prints a tab-separated list of keys and their values. We’ll learn more about for loops\nin Chapter 13.\nDictionaries aren’t sequences like lists and strings, but if you need to step through the\nitems in a dictionary, it’s easy—calling the dictionary keys method returns all stored\n\n212 | Chapter 8: Lists and Dictionaries",
    "212 | Chapter 8: Lists and Dictionaries\n\n\fkeys, which you can iterate through with a for. If needed, you can index from key to\nvalue inside the for loop, as was done in this code.\nIn fact, Python also lets you step through a dictionary’s keys list without actually calling\nthe keys method in most for loops. For any dictionary D, saying for key in D: works\nthe same as saying the complete for key in D.keys():. This is really just another instance of the iterators mentioned earlier, which allow the in membership operator to\nwork on dictionaries as well (more on iterators later in this book).",
    "Dictionary Usage Notes\nDictionaries are fairly straightforward tools once you get the hang of them, but here\nare a few additional pointers and reminders you should be aware of when using them:\n• Sequence operations don’t work. Dictionaries are mappings, not sequences; because there’s no notion of ordering among their items, things like concatenation\n(an ordered joining) and slicing (extracting a contiguous section) simply don’t apply. In fact, Python raises an error when your code runs if you try to do such things.\n• Assigning to new indexes adds entries. Keys can be created when you write a\ndictionary literal (in which case they are embedded in the literal itself), or when\nyou assign values to new keys of an existing dictionary object. The end result is the\nsame.\n• Keys need not always be strings. Our examples so far have used strings as keys,\nbut any other immutable objects (i.e., not lists) work just as well. For instance, you",
    "dictionary literal (in which case they are embedded in the literal itself), or when\nyou assign values to new keys of an existing dictionary object. The end result is the\nsame.\n• Keys need not always be strings. Our examples so far have used strings as keys,\nbut any other immutable objects (i.e., not lists) work just as well. For instance, you\ncan use integers as keys, which makes the dictionary look much like a list (when\nindexing, at least). Tuples are sometimes used as dictionary keys too, allowing for\ncompound key values. Class instance objects (discussed in Part VI) can also be used\nas keys, as long as they have the proper protocol methods; roughly, they need to\ntell Python that their values are hashable and won’t change, as otherwise they\nwould be useless as fixed keys.",
    "Using dictionaries to simulate flexible lists\nThe last point in the prior list is important enough to demonstrate with a few examples.\nWhen you use lists, it is illegal to assign to an offset that is off the end of the list:\n>>> L = []\n>>> L[99] = 'spam'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nIndexError: list assignment index out of range\n\nAlthough you can use repetition to preallocate as big a list as you’ll need (e.g.,\n[0]*100), you can also do something that looks similar with dictionaries that does not\nrequire such space allocations. By using integer keys, dictionaries can emulate lists that\nseem to grow on offset assignment:\n\nDictionaries in Action | 213\n\n\f>>> D = {}\n>>> D[99] = 'spam'\n>>> D[99]\n'spam'\n>>> D\n{99: 'spam'}",
    "Although you can use repetition to preallocate as big a list as you’ll need (e.g.,\n[0]*100), you can also do something that looks similar with dictionaries that does not\nrequire such space allocations. By using integer keys, dictionaries can emulate lists that\nseem to grow on offset assignment:\n\nDictionaries in Action | 213\n\n\f>>> D = {}\n>>> D[99] = 'spam'\n>>> D[99]\n'spam'\n>>> D\n{99: 'spam'}\n\nHere, it looks as if D is a 100-item list, but it’s really a dictionary with a single entry; the\nvalue of the key 99 is the string 'spam'. You can access this structure with offsets much\nlike a list, but you don’t have to allocate space for all the positions you might ever need\nto assign values to in the future. When used like this, dictionaries are like more flexible\nequivalents of lists.",
    "Here, it looks as if D is a 100-item list, but it’s really a dictionary with a single entry; the\nvalue of the key 99 is the string 'spam'. You can access this structure with offsets much\nlike a list, but you don’t have to allocate space for all the positions you might ever need\nto assign values to in the future. When used like this, dictionaries are like more flexible\nequivalents of lists.\n\nUsing dictionaries for sparse data structures\nIn a similar way, dictionary keys are also commonly leveraged to implement sparse data\nstructures—for example, multidimensional arrays where only a few positions have values stored in them:\n>>> Matrix = {}\n>>> Matrix[(2, 3, 4)] = 88\n>>> Matrix[(7, 8, 9)] = 99\n>>>\n>>> X = 2; Y = 3; Z = 4\n>>> Matrix[(X, Y, Z)]\n88\n>>> Matrix\n{(2, 3, 4): 88, (7, 8, 9): 99}\n\n# ; separates statements",
    "# ; separates statements\n\nHere, we’ve used a dictionary to represent a three-dimensional array that is empty\nexcept for the two positions (2,3,4) and (7,8,9). The keys are tuples that record the\ncoordinates of nonempty slots. Rather than allocating a large and mostly empty threedimensional matrix to hold these values, we can use a simple two-item dictionary. In\nthis scheme, accessing an empty slot triggers a nonexistent key exception, as these slots\nare not physically stored:\n>>> Matrix[(2,3,6)]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nKeyError: (2, 3, 6)",
    "Avoiding missing-key errors\nErrors for nonexistent key fetches are common in sparse matrixes, but you probably\nwon’t want them to shut down your program. There are at least three ways to fill in a\ndefault value instead of getting such an error message—you can test for keys ahead of\ntime in if statements, use a try statement to catch and recover from the exception\nexplicitly, or simply use the dictionary get method shown earlier to provide a default\nfor keys that do not exist:\n>>> if (2,3,6) in Matrix:\n...\nprint(Matrix[(2,3,6)])\n\n214 | Chapter 8: Lists and Dictionaries\n\n# Check for key before fetch\n# See Chapter 12 for if/else\n\n\f... else:\n...\nprint(0)\n...\n0\n>>> try:\n...\nprint(Matrix[(2,3,6)])\n... except KeyError:\n...\nprint(0)\n...\n0\n>>> Matrix.get((2,3,4), 0)\n88\n>>> Matrix.get((2,3,6), 0)\n0\n\n# Try to index\n# Catch and recover\n# See Chapter 33 for try/except\n# Exists; fetch and return\n# Doesn't exist; use default arg",
    "214 | Chapter 8: Lists and Dictionaries\n\n# Check for key before fetch\n# See Chapter 12 for if/else\n\n\f... else:\n...\nprint(0)\n...\n0\n>>> try:\n...\nprint(Matrix[(2,3,6)])\n... except KeyError:\n...\nprint(0)\n...\n0\n>>> Matrix.get((2,3,4), 0)\n88\n>>> Matrix.get((2,3,6), 0)\n0\n\n# Try to index\n# Catch and recover\n# See Chapter 33 for try/except\n# Exists; fetch and return\n# Doesn't exist; use default arg\n\nOf these, the get method is the most concise in terms of coding requirements; we’ll\nstudy the if and try statements in more detail later in this book.",
    "# Try to index\n# Catch and recover\n# See Chapter 33 for try/except\n# Exists; fetch and return\n# Doesn't exist; use default arg\n\nOf these, the get method is the most concise in terms of coding requirements; we’ll\nstudy the if and try statements in more detail later in this book.\n\nUsing dictionaries as “records”\nAs you can see, dictionaries can play many roles in Python. In general, they can replace\nsearch data structures (because indexing by key is a search operation) and can represent\nmany types of structured information. For example, dictionaries are one of many ways\nto describe the properties of an item in your program’s domain; that is, they can serve\nthe same role as “records” or “structs” in other languages.\nThe following, for example, fills out a dictionary by assigning to new keys over time:\n>>> rec = {}\n>>> rec['name'] = 'mel'\n>>> rec['age'] = 45\n>>> rec['job'] = 'trainer/writer'\n>>>\n>>> print(rec['name'])\nmel",
    "Especially when nested, Python’s built-in data types allow us to easily represent structured information. This example again uses a dictionary to capture object properties,\nbut it codes it all at once (rather than assigning to each key separately) and nests a list\nand a dictionary to represent structured property values:\n>>> mel = {'name': 'Mark',\n...\n'jobs': ['trainer', 'writer'],\n...\n'web': 'www.rmi.net/˜lutz',\n...\n'home': {'state': 'CO', 'zip':80513}}\n\nTo fetch components of nested objects, simply string together indexing operations:\n>>> mel['name']\n'Mark'\n>>> mel['jobs']\n['trainer', 'writer']\n>>> mel['jobs'][1]\n'writer'\n\nDictionaries in Action | 215\n\n\f>>> mel['home']['zip']\n80513\n\nAlthough we’ll learn in Part VI that classes (which group both data and logic) can be\nbetter in this record role, dictionaries are an easy-to-use tool for simpler requirements.",
    "Dictionaries in Action | 215\n\n\f>>> mel['home']['zip']\n80513\n\nAlthough we’ll learn in Part VI that classes (which group both data and logic) can be\nbetter in this record role, dictionaries are an easy-to-use tool for simpler requirements.\n\nWhy You Will Care: Dictionary Interfaces\nDictionaries aren’t just a convenient way to store information by key in your\nprograms—some Python extensions also present interfaces that look like and work the\nsame as dictionaries. For instance, Python’s interface to DBM access-by-key files looks\nmuch like a dictionary that must be opened. Strings are stored and fetched using key\nindexes:\nimport anydbm\nfile = anydbm.open(\"filename\") # Link to file\nfile['key'] = 'data'\n# Store data by key\ndata = file['key']\n# Fetch data by key",
    "In Chapter 27, you’ll see that you can store entire Python objects this way, too, if you\nreplace anydbm in the preceding code with shelve (shelves are access-by-key databases\nof persistent Python objects). For Internet work, Python’s CGI script support also\npresents a dictionary-like interface. A call to cgi.FieldStorage yields a dictionary-like\nobject with one entry per input field on the client’s web page:\nimport cgi\nform = cgi.FieldStorage()\n# Parse form data\nif 'name' in form:\nshowReply('Hello, ' + form['name'].value)\n\nAll of these, like dictionaries, are instances of mappings. Once you learn dictionary\ninterfaces, you’ll find that they apply to a variety of built-in tools in Python.",
    "All of these, like dictionaries, are instances of mappings. Once you learn dictionary\ninterfaces, you’ll find that they apply to a variety of built-in tools in Python.\n\nOther Ways to Make Dictionaries\nFinally, note that because dictionaries are so useful, more ways to build them have\nemerged over time. In Python 2.3 and later, for example, the last two calls to the dict\nconstructor (really, type name) shown here have the same effect as the literal and keyassignment forms above them:\n{'name': 'mel', 'age': 45}\n\n# Traditional literal expression\n\nD = {}\nD['name'] = 'mel'\nD['age'] = 45\n\n# Assign by keys dynamically\n\ndict(name='mel', age=45)\n\n# dict keyword argument form\n\ndict([('name', 'mel'), ('age', 45)])\n\n# dict key/value tuples form\n\nAll four of these forms create the same two-key dictionary, but they are useful in differing circumstances:\n216 | Chapter 8: Lists and Dictionaries",
    "• The first is handy if you can spell out the entire dictionary ahead of time.\n• The second is of use if you need to create the dictionary one field at a time on the\nfly.\n• The third involves less typing than the first, but it requires all keys to be strings.\n• The last is useful if you need to build up keys and values as sequences at runtime.\nWe met keyword arguments earlier when sorting; the third form illustrated in this code\nlisting has become especially popular in Python code today, since it has less syntax (and\nhence there is less opportunity for mistakes). As suggested previously in Table 8-2, the\nlast form in the listing is also commonly used in conjunction with the zip function, to\ncombine separate lists of keys and values obtained dynamically at runtime (parsed out\nof a data file’s columns, for instance). More on this option in the next section.\nProvided all the key’s values are the same initially, you can also create a dictionary with",
    "last form in the listing is also commonly used in conjunction with the zip function, to\ncombine separate lists of keys and values obtained dynamically at runtime (parsed out\nof a data file’s columns, for instance). More on this option in the next section.\nProvided all the key’s values are the same initially, you can also create a dictionary with\nthis special form—simply pass in a list of keys and an initial value for all of the values\n(the default is None):\n>>> dict.fromkeys(['a', 'b'], 0)\n{'a': 0, 'b': 0}",
    "Although you could get by with just literals and key assignments at this point in your\nPython career, you’ll probably find uses for all of these dictionary-creation forms as\nyou start applying them in realistic, flexible, and dynamic Python programs.\nThe listings in this section document the various ways to create dictionaries in both\nPython 2.6 and 3.0. However, there is yet another way to create dictionaries, available\nonly in Python 3.0 (and later): the dictionary comprehension expression. To see how\nthis last form looks, we need to move on to the next section.",
    "Dictionary Changes in Python 3.0\nThis chapter has so far focused on dictionary basics that span releases, but the dictionary’s functionality has mutated in Python 3.0. If you are using Python 2.X code,\nyou may come across some dictionary tools that either behave differently or are missing\naltogether in 3.0. Moreover, 3.0 coders have access to additional dictionary tools not\navailable in 2.X. Specifically, dictionaries in 3.0:\n• Support a new dictionary comprehension expression, a close cousin to list and set\ncomprehensions\n• Return iterable views instead of lists for the methods D.keys, D.values, and D.items\n• Require new coding styles for scanning by sorted keys, because of the prior point\n• No longer support relative magnitude comparisons directly—compare manually\ninstead\n• No longer have the D.has_key method—the in membership test is used instead\nLet’s take a look at what’s new in 3.0 dictionaries.\nDictionaries in Action | 217",
    "Dictionary comprehensions\nAs mentioned at the end of the prior section, dictionaries in 3.0 can also be created\nwith dictionary comprehensions. Like the set comprehensions we met in Chapter 5,\ndictionary comprehensions are available only in 3.0 (not in 2.6). Like the longstanding\nlist comprehensions we met briefly in Chapter 4 and earlier in this chapter, they run an\nimplied loop, collecting the key/value results of expressions on each iteration and using\nthem to fill out a new dictionary. A loop variable allows the comprehension to use loop\niteration values along the way.\nFor example, a standard way to initialize a dictionary dynamically in both 2.6 and 3.0\nis to zip together its keys and values and pass the result to the dict call. As we’ll learn\nin more detail in Chapter 13, the zip function is a way to construct a dictionary from\nkey and value lists in a single call. If you cannot predict the set of keys and values in",
    "iteration values along the way.\nFor example, a standard way to initialize a dictionary dynamically in both 2.6 and 3.0\nis to zip together its keys and values and pass the result to the dict call. As we’ll learn\nin more detail in Chapter 13, the zip function is a way to construct a dictionary from\nkey and value lists in a single call. If you cannot predict the set of keys and values in\nyour code, you can always build them up as lists and zip them together:\n>>> list(zip(['a', 'b', 'c'], [1, 2, 3]))\n[('a', 1), ('b', 2), ('c', 3)]",
    "# Zip together keys and values\n\n>>> D = dict(zip(['a', 'b', 'c'], [1, 2, 3]))\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n\n# Make a dict from zip result\n\nIn Python 3.0, you can achieve the same effect with a dictionary comprehension expression. The following builds a new dictionary with a key/value pair for every such\npair in the zip result (it reads almost the same in Python, but with a bit more formality):\nC:\\misc> c:\\python30\\python\n\n# Use a dict comprehension\n\n>>> D = {k: v for (k, v) in zip(['a', 'b', 'c'], [1, 2, 3])}\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n\nComprehensions actually require more code in this case, but they are also more general\nthan this example implies—we can use them to map a single stream of values to dictionaries as well, and keys can be computed with expressions just like values:\n>>> D = {x: x ** 2 for x in [1, 2, 3, 4]}\n>>> D\n{1: 1, 2: 4, 3: 9, 4: 16}\n\n# Or: range(1, 5)",
    "Comprehensions actually require more code in this case, but they are also more general\nthan this example implies—we can use them to map a single stream of values to dictionaries as well, and keys can be computed with expressions just like values:\n>>> D = {x: x ** 2 for x in [1, 2, 3, 4]}\n>>> D\n{1: 1, 2: 4, 3: 9, 4: 16}\n\n# Or: range(1, 5)\n\n>>> D = {c: c * 4 for c in 'SPAM'}\n# Loop over any iterable\n>>> D\n{'A': 'AAAA', 'P': 'PPPP', 'S': 'SSSS', 'M': 'MMMM'}\n>>> D = {c.lower(): c + '!' for c in ['SPAM', 'EGGS', 'HAM']}\n>>> D\n{'eggs': 'EGGS!', 'ham': 'HAM!', 'spam': 'SPAM!'}\n\nDictionary comprehensions are also useful for initializing dictionaries from keys lists,\nin much the same way as the fromkeys method we met at the end of the preceding\nsection:\n\n218 | Chapter 8: Lists and Dictionaries\n\n\f>>> D = dict.fromkeys(['a', 'b', 'c'], 0)\n>>> D\n{'a': 0, 'c': 0, 'b': 0}\n\n# Initialize dict from keys\n\n>>> D = {k:0 for k in ['a', 'b', 'c']}\n>>> D\n{'a': 0, 'c': 0, 'b': 0}",
    "Dictionary comprehensions are also useful for initializing dictionaries from keys lists,\nin much the same way as the fromkeys method we met at the end of the preceding\nsection:\n\n218 | Chapter 8: Lists and Dictionaries\n\n\f>>> D = dict.fromkeys(['a', 'b', 'c'], 0)\n>>> D\n{'a': 0, 'c': 0, 'b': 0}\n\n# Initialize dict from keys\n\n>>> D = {k:0 for k in ['a', 'b', 'c']}\n>>> D\n{'a': 0, 'c': 0, 'b': 0}\n\n# Same, but with a comprehension\n\n>>> D = dict.fromkeys('spam')\n>>> D\n{'a': None, 'p': None, 's': None, 'm': None}\n\n# Other iterators, default value\n\n>>> D = {k: None for k in 'spam'}\n>>> D\n{'a': None, 'p': None, 's': None, 'm': None}",
    "# Initialize dict from keys\n\n>>> D = {k:0 for k in ['a', 'b', 'c']}\n>>> D\n{'a': 0, 'c': 0, 'b': 0}\n\n# Same, but with a comprehension\n\n>>> D = dict.fromkeys('spam')\n>>> D\n{'a': None, 'p': None, 's': None, 'm': None}\n\n# Other iterators, default value\n\n>>> D = {k: None for k in 'spam'}\n>>> D\n{'a': None, 'p': None, 's': None, 'm': None}\n\nLike related tools, dictionary comprehensions support additional syntax not shown\nhere, including nested loops and if clauses. Unfortunately, to truly understand dictionary comprehensions, we need to also know more about iteration statements and\nconcepts in Python, and we don’t yet have enough information to address that story\nwell. We’ll learn much more about all flavors of comprehensions (list, set, and dictionary) in Chapters 14 and 20, so we’ll defer further details until later. We’ll also study\nthe zip built-in we used in this section in more detail in Chapter 13, when we explore\nfor loops.",
    "Dictionary views\nIn 3.0 the dictionary keys, values, and items methods all return view objects, whereas\nin 2.6 they return actual result lists. View objects are iterables, which simply means\nobjects that generate result items one at a time, instead of producing the result list all\nat once in memory. Besides being iterable, dictionary views also retain the original order\nof dictionary components, reflect future changes to the dictionary, and may support\nset operations. On the other hand, they are not lists, and they do not support operations\nlike indexing or the list sort method; nor do they display their items when printed.\nWe’ll discuss the notion of iterables more formally in Chapter 14, but for our purposes\nhere it’s enough to know that we have to run the results of these three methods through\nthe list built-in if we want to apply list operations or display their values:\n>>> D = dict(a=1, b=2, c=3)\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> K = D.keys()\n>>> K",
    "We’ll discuss the notion of iterables more formally in Chapter 14, but for our purposes\nhere it’s enough to know that we have to run the results of these three methods through\nthe list built-in if we want to apply list operations or display their values:\n>>> D = dict(a=1, b=2, c=3)\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> K = D.keys()\n>>> K\n<dict_keys object at 0x026D83C0>\n>>> list(K)\n['a', 'c', 'b']",
    "# Makes a view object in 3.0, not a list\n# Force a real list in 3.0 if needed\n\n>>> V = D.values()\n# Ditto for values and items views\n>>> V\n<dict_values object at 0x026D8260>\n\nDictionaries in Action | 219\n\n\f>>> list(V)\n[1, 3, 2]\n>>> list(D.items())\n[('a', 1), ('c', 3), ('b', 2)]\n>>> K[0]\n# List operations fail unless converted\nTypeError: 'dict_keys' object does not support indexing\n>>> list(K)[0]\n'a'\n\nApart from when displaying results at the interactive prompt, you will probably rarely\neven notice this change, because looping constructs in Python automatically force\niterable objects to produce one result on each iteration:\n>>> for k in D.keys(): print(k)\n...\na\nc\nb\n\n# Iterators used automatically in loops\n\nIn addition, 3.0 dictionaries still have iterators themselves, which return successive\nkeys—as in 2.6, it’s still often not necessary to call keys directly:\n>>> for key in D: print(key)\n...\na\nc\nb\n\n# Still no need to call keys() to iterate",
    "# Iterators used automatically in loops\n\nIn addition, 3.0 dictionaries still have iterators themselves, which return successive\nkeys—as in 2.6, it’s still often not necessary to call keys directly:\n>>> for key in D: print(key)\n...\na\nc\nb\n\n# Still no need to call keys() to iterate\n\nUnlike 2.X’s list results, though, dictionary views in 3.0 are not carved in stone when\ncreated—they dynamically reflect future changes made to the dictionary after the view\nobject has been created:\n>>> D = {'a':1, 'b':2, 'c':3}\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> K = D.keys()\n>>> V = D.values()\n>>> list(K)\n['a', 'c', 'b']\n>>> list(V)\n[1, 3, 2]\n\n# Views maintain same order as dictionary\n\n>>> del D['b']\n>>> D\n{'a': 1, 'c': 3}\n\n# Change the dictionary in-place\n\n>>> list(K)\n['a', 'c']\n>>> list(V)\n[1, 3]\n\n# Reflected in any current view objects\n\n220 | Chapter 8: Lists and Dictionaries\n\n# Not true in 2.X!",
    ">>> del D['b']\n>>> D\n{'a': 1, 'c': 3}\n\n# Change the dictionary in-place\n\n>>> list(K)\n['a', 'c']\n>>> list(V)\n[1, 3]\n\n# Reflected in any current view objects\n\n220 | Chapter 8: Lists and Dictionaries\n\n# Not true in 2.X!\n\n\fDictionary views and sets\nAlso unlike 2.X’s list results, 3.0’s view objects returned by the keys method are setlike and support common set operations such as intersection and union; values views\nare not, since they aren’t unique, but items results are if their (key, value) pairs are\nunique and hashable. Given that sets behave much like valueless dictionaries (and are\neven coded in curly braces like dictionaries in 3.0), this is a logical symmetry. Like\ndictionary keys, set items are unordered, unique, and immutable.\nHere is what keys lists look like when used in set operations. In set operations, views\nmay be mixed with other views, sets, and dictionaries (dictionaries are treated the same\nas their keys views in this context):\n>>> K | {'x': 4}\n{'a', 'x', 'c'}",
    "# Keys (and some items) views are set-like\n\n>>> V & {'x': 4}\nTypeError: unsupported operand type(s) for &: 'dict_values' and 'dict'\n>>> V & {'x': 4}.values()\nTypeError: unsupported operand type(s) for &: 'dict_values' and 'dict_values'\n>>> D = {'a':1, 'b':2, 'c':3}\n>>> D.keys() & D.keys()\n{'a', 'c', 'b'}\n>>> D.keys() & {'b'}\n{'b'}\n>>> D.keys() & {'b': 1}\n{'b'}\n>>> D.keys() | {'b', 'c', 'd'}\n{'a', 'c', 'b', 'd'}\n\n# Intersect keys views\n# Intersect keys and set\n# Intersect keys and dict\n# Union keys and set\n\nDictionary items views are set-like too if they are hashable—that is, if they contain only\nimmutable objects:\n>>> D = {'a': 1}\n>>> list(D.items())\n[('a', 1)]\n>>> D.items() | D.keys()\n{('a', 1), 'a'}\n>>> D.items() | D\n{('a', 1), 'a'}\n\n# Items set-like if hashable\n# Union view and view\n# dict treated same as its keys\n\n>>> D.items() | {('c', 3), ('d', 4)}\n{('a', 1), ('d', 4), ('c', 3)}\n>>> dict(D.items() | {('c', 3), ('d', 4)})\n{'a': 1, 'c': 3, 'd': 4}",
    "# Items set-like if hashable\n# Union view and view\n# dict treated same as its keys\n\n>>> D.items() | {('c', 3), ('d', 4)}\n{('a', 1), ('d', 4), ('c', 3)}\n>>> dict(D.items() | {('c', 3), ('d', 4)})\n{'a': 1, 'c': 3, 'd': 4}\n\n# Set of key/value pairs\n# dict accepts iterable sets too\n\nFor more details on set operations in general, see Chapter 5. Now, let’s look at three\nother quick coding notes for 3.0 dictionaries.\n\nDictionaries in Action | 221",
    "For more details on set operations in general, see Chapter 5. Now, let’s look at three\nother quick coding notes for 3.0 dictionaries.\n\nDictionaries in Action | 221\n\n\fSorting dictionary keys\nFirst of all, because keys does not return a list, the traditional coding pattern for scanning a dictionary by sorted keys in 2.X won’t work in 3.0. You must either convert to\na list manually or use the sorted call introduced in Chapter 4 and earlier in this chapter\non either a keys view or the dictionary itself:\n>>> D = {'a':1, 'b':2, 'c':3}\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> Ks = D.keys()\n# Sorting a view object doesn't work!\n>>> Ks.sort()\nAttributeError: 'dict_keys' object has no attribute 'sort'\n>>> Ks = list(Ks)\n>>> Ks.sort()\n>>> for k in Ks: print(k, D[k])\n...\na 1\nb 2\nc 3\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> Ks = D.keys()\n>>> for k in sorted(Ks): print(k, D[k])\n...\na 1\nb 2\nc 3\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> for k in sorted(D): print(k, D[k])\n...\na 1\nb 2\nc 3",
    "# Force it to be a list and then sort\n\n# Or you can use sorted() on the keys\n# sorted() accepts any iterable\n# sorted() returns its result\n\n# Better yet, sort the dict directly\n# dict iterators return keys\n\nDictionary magnitude comparisons no longer work\nSecondly, while in Python 2.6 dictionaries may be compared for relative magnitude\ndirectly with <, >, and so on, in Python 3.0 this no longer works. However, it can be\nsimulated by comparing sorted keys lists manually:\nsorted(D1.items()) < sorted(D2.items())\n\n# Like 2.6 D1 < D2\n\nDictionary equality tests still work in 3.0, though. Since we’ll revisit this in the next\nchapter in the context of comparisons at large, we’ll defer further details here.\n\n222 | Chapter 8: Lists and Dictionaries",
    "# Like 2.6 D1 < D2\n\nDictionary equality tests still work in 3.0, though. Since we’ll revisit this in the next\nchapter in the context of comparisons at large, we’ll defer further details here.\n\n222 | Chapter 8: Lists and Dictionaries\n\n\fThe has_key method is dead: long live in!\nFinally, the widely used dictionary has_key key presence test method is gone in 3.0.\nInstead, use the in membership expression, or a get with a default test (of these, in is\ngenerally preferred):\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> D.has_key('c')\n# 2.X only: True/False\nAttributeError: 'dict' object has no attribute 'has_key'\n>>> 'c' in D\nTrue\n>>> 'x' in D\nFalse\n>>> if 'c' in D: print('present', D['c'])\n...\npresent 3\n>>> print(D.get('c'))\n3\n>>> print(D.get('x'))\nNone\n>>> if D.get('c') != None: print('present', D['c'])\n...\npresent 3\n\n# Preferred in 3.0\n\n# Another option",
    "# Preferred in 3.0\n\n# Another option\n\nIf you work in 2.6 and care about 3.0 compatibility, note that the first two changes\n(comprehensions and views) can only be coded in 3.0, but the last three (sorted, manual\ncomparisons, and in) can be coded in 2.6 today to ease 3.0 migration in the future.",
    "Chapter Summary\nIn this chapter, we explored the list and dictionary types—probably the two most\ncommon, flexible, and powerful collection types you will see and use in Python code.\nWe learned that the list type supports positionally ordered collections of arbitrary objects, and that it may be freely nested and grown and shrunk on demand. The dictionary\ntype is similar, but it stores items by key instead of by position and does not maintain\nany reliable left-to-right order among its items. Both lists and dictionaries are mutable,\nand so support a variety of in-place change operations not available for strings: for\nexample, lists can be grown by append calls, and dictionaries by assignment to new keys.\nIn the next chapter, we will wrap up our in-depth core object type tour by looking at\ntuples and files. After that, we’ll move on to statements that code the logic that processes\nour objects, taking us another step toward writing complete programs. Before we tackle",
    "example, lists can be grown by append calls, and dictionaries by assignment to new keys.\nIn the next chapter, we will wrap up our in-depth core object type tour by looking at\ntuples and files. After that, we’ll move on to statements that code the logic that processes\nour objects, taking us another step toward writing complete programs. Before we tackle\nthose topics, though, here are some chapter quiz questions to review.",
    "Chapter Summary | 223\n\n\fTest Your Knowledge: Quiz\n1. Name two ways to build a list containing five integer zeros.\n2. Name two ways to build a dictionary with two keys, 'a' and 'b', each having an\nassociated value of 0.\n3. Name four operations that change a list object in-place.\n4. Name four operations that change a dictionary object in-place.",
    "Test Your Knowledge: Answers\n1. A literal expression like [0, 0, 0, 0, 0] and a repetition expression like [0] * 5\nwill each create a list of five zeros. In practice, you might also build one up with a\nloop that starts with an empty list and appends 0 to it in each iteration:\nL.append(0). A list comprehension ([0 for i in range(5)]) could work here, too,\nbut this is more work than you need to do.\n2. A literal expression such as {'a': 0, 'b': 0} or a series of assignments like D = {},\nD['a'] = 0, and D['b'] = 0 would create the desired dictionary. You can also use\nthe newer and simpler-to-code dict(a=0, b=0) keyword form, or the more flexible\ndict([('a', 0), ('b', 0)]) key/value sequences form. Or, because all the values\nare the same, you can use the special form dict.fromkeys('ab', 0). In 3.0, you can\nalso use a dictionary comprehension: {k:0 for k in 'ab'}.\n3. The append and extend methods grow a list in-place, the sort and reverse methods",
    "the newer and simpler-to-code dict(a=0, b=0) keyword form, or the more flexible\ndict([('a', 0), ('b', 0)]) key/value sequences form. Or, because all the values\nare the same, you can use the special form dict.fromkeys('ab', 0). In 3.0, you can\nalso use a dictionary comprehension: {k:0 for k in 'ab'}.\n3. The append and extend methods grow a list in-place, the sort and reverse methods\norder and reverse lists, the insert method inserts an item at an offset, the remove\nand pop methods delete from a list by value and by position, the del statement\ndeletes an item or slice, and index and slice assignment statements replace an item\nor entire section. Pick any four of these for the quiz.\n4. Dictionaries are primarily changed by assignment to a new or existing key, which\ncreates or changes the key’s entry in the table. Also, the del statement deletes a",
    "and pop methods delete from a list by value and by position, the del statement\ndeletes an item or slice, and index and slice assignment statements replace an item\nor entire section. Pick any four of these for the quiz.\n4. Dictionaries are primarily changed by assignment to a new or existing key, which\ncreates or changes the key’s entry in the table. Also, the del statement deletes a\nkey’s entry, the dictionary update method merges one dictionary into another inplace, and D.pop(key) removes a key and returns the value it had. Dictionaries also\nhave other, more exotic in-place change methods not listed in this chapter, such\nas setdefault; see reference sources for more details.",
    "224 | Chapter 8: Lists and Dictionaries\n\n\fCHAPTER 9\n\nTuples, Files, and Everything Else",
    "This chapter rounds out our in-depth look at the core object types in Python by exploring the tuple, a collection of other objects that cannot be changed, and the file, an\ninterface to external files on your computer. As you’ll see, the tuple is a relatively simple\nobject that largely performs operations you’ve already learned about for strings and\nlists. The file object is a commonly used and full-featured tool for processing files; the\nbasic overview of files here is supplemented by larger examples in later chapters.\nThis chapter also concludes this part of the book by looking at properties common to\nall the core object types we’ve met—the notions of equality, comparisons, object copies, and so on. We’ll also briefly explore other object types in the Python toolbox; as\nyou’ll see, although we’ve covered all the primary built-in types, the object story in\nPython is broader than I’ve implied thus far. Finally, we’ll close this part of the book",
    "all the core object types we’ve met—the notions of equality, comparisons, object copies, and so on. We’ll also briefly explore other object types in the Python toolbox; as\nyou’ll see, although we’ve covered all the primary built-in types, the object story in\nPython is broader than I’ve implied thus far. Finally, we’ll close this part of the book\nby taking a look at a set of common object type pitfalls and exploring some exercises\nthat will allow you to experiment with the ideas you’ve learned.",
    "Tuples\nThe last collection type in our survey is the Python tuple. Tuples construct simple\ngroups of objects. They work exactly like lists, except that tuples can’t be changed inplace (they’re immutable) and are usually written as a series of items in parentheses,\nnot square brackets. Although they don’t support as many methods, tuples share most\nof their properties with lists. Here’s a quick look at the basics. Tuples are:\nOrdered collections of arbitrary objects\nLike strings and lists, tuples are positionally ordered collections of objects (i.e.,\nthey maintain a left-to-right order among their contents); like lists, they can embed\nany kind of object.\nAccessed by offset\nLike strings and lists, items in a tuple are accessed by offset (not by key); they\nsupport all the offset-based access operations, such as indexing and slicing.\n\n225",
    "Of the category “immutable sequence”\nLike strings and lists, tuples are sequences; they support many of the same operations. However, like strings, tuples are immutable; they don’t support any of the\nin-place change operations applied to lists.\nFixed-length, heterogeneous, and arbitrarily nestable\nBecause tuples are immutable, you cannot change the size of a tuple without making a copy. On the other hand, tuples can hold any type of object, including other\ncompound objects (e.g., lists, dictionaries, other tuples), and so support arbitrary\nnesting.\nArrays of object references\nLike lists, tuples are best thought of as object reference arrays; tuples store access\npoints to other objects (references), and indexing a tuple is relatively quick.\nTable 9-1 highlights common tuple operations. A tuple is written as a series of objects\n(technically, expressions that generate objects), separated by commas and normally",
    "nesting.\nArrays of object references\nLike lists, tuples are best thought of as object reference arrays; tuples store access\npoints to other objects (references), and indexing a tuple is relatively quick.\nTable 9-1 highlights common tuple operations. A tuple is written as a series of objects\n(technically, expressions that generate objects), separated by commas and normally\nenclosed in parentheses. An empty tuple is just a parentheses pair with nothing inside.\nTable 9-1. Common tuple literals and operations\nOperation",
    "Interpretation\n\n()\n\nAn empty tuple\n\nT = (0,)\n\nA one-item tuple (not an expression)\n\nT = (0, 'Ni', 1.2, 3)\n\nA four-item tuple\n\nT = 0, 'Ni', 1.2, 3\n\nAnother four-item tuple (same as prior line)\n\nT = ('abc', ('def', 'ghi'))\n\nNested tuples\n\nT = tuple('spam')\n\nTuple of items in an iterable\n\nT[i]\n\nIndex, index of index, slice, length\n\nT[i][j]\nT[i:j]\nlen(T)\nT1 + T2\n\nConcatenate, repeat\n\nT * 3\nfor x in T: print(x)\n\nIteration, membership\n\n'spam' in T\n[x ** 2 for x in T]\nT.index('Ni')\n\nMethods in 2.6 and 3.0: search, count\n\nT.count('Ni')\n\n226 | Chapter 9: Tuples, Files, and Everything Else\n\n\fTuples in Action\nAs usual, let’s start an interactive session to explore tuples at work. Notice in Table 9-1 that tuples do not have all the methods that lists have (e.g., an append call won’t\nwork here). They do, however, support the usual sequence operations that we saw for\nboth strings and lists:\n>>> (1, 2) + (3, 4)\n(1, 2, 3, 4)\n\n# Concatenation\n\n>>> (1, 2) * 4\n(1, 2, 1, 2, 1, 2, 1, 2)\n\n# Repetition",
    "# Concatenation\n\n>>> (1, 2) * 4\n(1, 2, 1, 2, 1, 2, 1, 2)\n\n# Repetition\n\n>>> T = (1, 2, 3, 4)\n>>> T[0], T[1:3]\n(1, (2, 3))\n\n# Indexing, slicing\n\nTuple syntax peculiarities: Commas and parentheses\nThe second and fourth entries in Table 9-1 merit a bit more explanation. Because\nparentheses can also enclose expressions (see Chapter 5), you need to do something\nspecial to tell Python when a single object in parentheses is a tuple object and not a\nsimple expression. If you really want a single-item tuple, simply add a trailing comma\nafter the single item, before the closing parenthesis:\n>>> x = (40)\n>>> x\n40\n>>> y = (40,)\n>>> y\n(40,)\n\n# An integer!\n# A tuple containing an integer",
    "As a special case, Python also allows you to omit the opening and closing parentheses\nfor a tuple in contexts where it isn’t syntactically ambiguous to do so. For instance, the\nfourth line of Table 9-1 simply lists four items separated by commas. In the context of\nan assignment statement, Python recognizes this as a tuple, even though it doesn’t have\nparentheses.\nNow, some people will tell you to always use parentheses in your tuples, and some will\ntell you to never use parentheses in tuples (and still others have lives, and won’t tell\nyou what to do with your tuples!). The only significant places where the parentheses\nare required are when a tuple is passed as a literal in a function call (where parentheses\nmatter), and when one is listed in a Python 2.X print statement (where commas are\nsignificant).\nFor beginners, the best advice is that it’s probably easier to use the parentheses than it\nis to figure out when they are optional. Many programmers (myself included) also find",
    "are required are when a tuple is passed as a literal in a function call (where parentheses\nmatter), and when one is listed in a Python 2.X print statement (where commas are\nsignificant).\nFor beginners, the best advice is that it’s probably easier to use the parentheses than it\nis to figure out when they are optional. Many programmers (myself included) also find\nthat parentheses tend to aid script readability by making the tuples more explicit, but\nyour mileage may vary.",
    "Tuples | 227\n\n\fConversions, methods, and immutability\nApart from literal syntax differences, tuple operations (the middle rows in Table 9-1)\nare identical to string and list operations. The only differences worth noting are that\nthe +, *, and slicing operations return new tuples when applied to tuples, and that tuples\ndon’t provide the same methods you saw for strings, lists, and dictionaries. If you want\nto sort a tuple, for example, you’ll usually have to either first convert it to a list to gain\naccess to a sorting method call and make it a mutable object, or use the newer sorted\nbuilt-in that accepts any sequence object (and more):\n>>> T = ('cc', 'aa', 'dd', 'bb')\n>>> tmp = list(T)\n>>> tmp.sort()\n>>> tmp\n['aa', 'bb', 'cc', 'dd']\n>>> T = tuple(tmp)\n>>> T\n('aa', 'bb', 'cc', 'dd')\n>>> sorted(T)\n['aa', 'bb', 'cc', 'dd']\n\n# Make a list from a tuple's items\n# Sort the list\n# Make a tuple from the list's items\n\n# Or use the sorted built-in",
    "# Make a list from a tuple's items\n# Sort the list\n# Make a tuple from the list's items\n\n# Or use the sorted built-in\n\nHere, the list and tuple built-in functions are used to convert the object to a list and\nthen back to a tuple; really, both calls make new objects, but the net effect is like a\nconversion.\nList comprehensions can also be used to convert tuples. The following, for example,\nmakes a list from a tuple, adding 20 to each item along the way:\n>>> T = (1, 2, 3, 4, 5)\n>>> L = [x + 20 for x in T]\n>>> L\n[21, 22, 23, 24, 25]",
    "List comprehensions are really sequence operations—they always build new lists, but\nthey may be used to iterate over any sequence objects, including tuples, strings, and\nother lists. As we’ll see later in the book, they even work on some things that are not\nphysically stored sequences—any iterable objects will do, including files, which are\nautomatically read line by line.\nAlthough tuples don’t have the same methods as lists and strings, they do have two of\ntheir own as of Python 2.6 and 3.0—index and count works as they do for lists, but\nthey are defined for tuple objects:\n>>> T = (1, 2, 3, 2, 4, 2)\n>>> T.index(2)\n1\n>>> T.index(2, 2)\n3\n>>> T.count(2)\n3\n\n228 | Chapter 9: Tuples, Files, and Everything Else\n\n# Tuple methods in 2.6 and 3.0\n# Offset of first appearance of 2\n# Offset of appearance after offset 2\n# How many 2s are there?",
    "228 | Chapter 9: Tuples, Files, and Everything Else\n\n# Tuple methods in 2.6 and 3.0\n# Offset of first appearance of 2\n# Offset of appearance after offset 2\n# How many 2s are there?\n\n\fPrior to 2.6 and 3.0, tuples have no methods at all—this was an old Python convention\nfor immutable types, which was violated years ago on grounds of practicality with\nstrings, and more recently with both numbers and tuples.\nAlso, note that the rule about tuple immutability applies only to the top level of the\ntuple itself, not to its contents. A list inside a tuple, for instance, can be changed as usual:\n>>> T = (1, [2, 3], 4)\n>>> T[1] = 'spam'\n# This fails: can't change tuple itself\nTypeError: object doesn't support item assignment\n>>> T[1][0] = 'spam'\n>>> T\n(1, ['spam', 3], 4)\n\n# This works: can change mutables inside\n\nFor most programs, this one-level-deep immutability is sufficient for common tuple\nroles. Which, coincidentally, brings us to the next section.",
    "Why Lists and Tuples?\nThis seems to be the first question that always comes up when teaching beginners about\ntuples: why do we need tuples if we have lists? Some of the reasoning may be historic;\nPython’s creator is a mathematician by training, and he has been quoted as seeing a\ntuple as a simple association of objects and a list as a data structure that changes over\ntime. In fact, this use of the word “tuple” derives from mathematics, as does its frequent\nuse for a row in a relational database table.\nThe best answer, however, seems to be that the immutability of tuples provides some\nintegrity—you can be sure a tuple won’t be changed through another reference elsewhere in a program, but there’s no such guarantee for lists. Tuples, therefore, serve a\nsimilar role to “constant” declarations in other languages, though the notion of\nconstantness is associated with objects in Python, not variables.\nTuples can also be used in places that lists cannot—for example, as dictionary keys",
    "integrity—you can be sure a tuple won’t be changed through another reference elsewhere in a program, but there’s no such guarantee for lists. Tuples, therefore, serve a\nsimilar role to “constant” declarations in other languages, though the notion of\nconstantness is associated with objects in Python, not variables.\nTuples can also be used in places that lists cannot—for example, as dictionary keys\n(see the sparse matrix example in Chapter 8). Some built-in operations may also require\nor imply tuples, not lists, though such operations have often been generalized in recent\nyears. As a rule of thumb, lists are the tool of choice for ordered collections that might\nneed to change; tuples can handle the other cases of fixed associations.",
    "Files\nYou may already be familiar with the notion of files, which are named storage compartments on your computer that are managed by your operating system. The last major\nbuilt-in object type that we’ll examine on our object types tour provides a way to access\nthose files inside Python programs.\n\nFiles | 229",
    "Files | 229\n\n\fIn short, the built-in open function creates a Python file object, which serves as a link\nto a file residing on your machine. After calling open, you can transfer strings of data\nto and from the associated external file by calling the returned file object’s methods.\nCompared to the types you’ve seen so far, file objects are somewhat unusual. They’re\nnot numbers, sequences, or mappings, and they don’t respond to expression operators;\nthey export only methods for common file-processing tasks. Most file methods are\nconcerned with performing input from and output to the external file associated with\na file object, but other file methods allow us to seek to a new position in the file, flush\noutput buffers, and so on. Table 9-2 summarizes common file operations.\nTable 9-2. Common file operations\nOperation\n\nInterpretation\n\noutput = open(r'C:\\spam', 'w')\n\nCreate output file ('w' means write)\n\ninput = open('data', 'r')\n\nCreate input file ('r' means read)\n\ninput = open('data')",
    "Interpretation\n\noutput = open(r'C:\\spam', 'w')\n\nCreate output file ('w' means write)\n\ninput = open('data', 'r')\n\nCreate input file ('r' means read)\n\ninput = open('data')\n\nSame as prior line ('r' is the default)\n\naString = input.read()\n\nRead entire file into a single string\n\naString = input.read(N)\n\nRead up to next N characters (or bytes) into a string\n\naString = input.readline()\n\nRead next line (including \\n newline) into a string\n\naList = input.readlines()\n\nRead entire file into list of line strings (with \\n)\n\noutput.write(aString)\n\nWrite a string of characters (or bytes) into file\n\noutput.writelines(aList)\n\nWrite all line strings in a list into file\n\noutput.close()\n\nManual close (done for you when file is collected)\n\noutput.flush()\n\nFlush output buffer to disk without closing\n\nanyFile.seek(N)\n\nChange file position to offset N for next operation\n\nfor line in open('data'): use line\n\nFile iterators read line by line\n\nopen('f.txt', encoding='latin-1')",
    "output.writelines(aList)\n\nWrite all line strings in a list into file\n\noutput.close()\n\nManual close (done for you when file is collected)\n\noutput.flush()\n\nFlush output buffer to disk without closing\n\nanyFile.seek(N)\n\nChange file position to offset N for next operation\n\nfor line in open('data'): use line\n\nFile iterators read line by line\n\nopen('f.txt', encoding='latin-1')\n\nPython 3.0 Unicode text files (str strings)\n\nopen('f.bin', 'rb')\n\nPython 3.0 binary bytes files (bytes strings)\n\nOpening Files\nTo open a file, a program calls the built-in open function, with the external filename\nfirst, followed by a processing mode. The mode is typically the string 'r' to open for\ntext input (the default), 'w' to create and open for text output, or 'a' to open for\nappending text to the end. The processing mode argument can specify additional\noptions:\n• Adding a b to the mode string allows for binary data (end-of-line translations and\n3.0 Unicode encodings are turned off).",
    "230 | Chapter 9: Tuples, Files, and Everything Else\n\n\f• Adding a + opens the file for both input and output (i.e., you can both read and\nwrite to the same file object, often in conjunction with seek operations to reposition\nin the file).\nBoth arguments to open must be Python strings, and an optional third argument can\nbe used to control output buffering—passing a zero means that output is unbuffered\n(it is transferred to the external file immediately on a write method call). The external\nfilename argument may include a platform-specific and absolute or relative directory\npath prefix; without a directory path, the file is assumed to exist in the current working\ndirectory (i.e., where the script runs). We’ll cover file fundamentals and explore some\nbasic examples here, but we won’t go into all file-processing mode options; as usual,\nconsult the Python library manual for additional details.",
    "Using Files\nOnce you make a file object with open, you can call its methods to read from or write\nto the associated external file. In all cases, file text takes the form of strings in Python\nprograms; reading a file returns its text in strings, and text is passed to the write methods\nas strings. Reading and writing methods come in multiple flavors; Table 9-2 lists the\nmost common. Here are a few fundamental usage notes:\nFile iterators are best for reading lines\nThough the reading and writing methods in the table are common, keep in mind\nthat probably the best way to read lines from a text file today is to not read the file\nat all—as we’ll see in Chapter 14, files also have an iterator that automatically reads\none line at a time in a for loop, list comprehension, or other iteration context.\nContent is strings, not objects\nNotice in Table 9-2 that data read from a file always comes back to your script as",
    "that probably the best way to read lines from a text file today is to not read the file\nat all—as we’ll see in Chapter 14, files also have an iterator that automatically reads\none line at a time in a for loop, list comprehension, or other iteration context.\nContent is strings, not objects\nNotice in Table 9-2 that data read from a file always comes back to your script as\na string, so you’ll have to convert it to a different type of Python object if a string\nis not what you need. Similarly, unlike with the print operation, Python does not\nadd any formatting and does not convert objects to strings automatically when you\nwrite data to a file—you must send an already formatted string. Because of this,\nthe tools we have already met to convert objects to and from strings (e.g., int,\nfloat, str, and the string formatting expression and method) come in handy when",
    "add any formatting and does not convert objects to strings automatically when you\nwrite data to a file—you must send an already formatted string. Because of this,\nthe tools we have already met to convert objects to and from strings (e.g., int,\nfloat, str, and the string formatting expression and method) come in handy when\ndealing with files. Python also includes advanced standard library tools for handling generic object storage (such as the pickle module) and for dealing with\npacked binary data in files (such as the struct module). We’ll see both of these at\nwork later in this chapter.\nclose is usually optional\nCalling the file close method terminates your connection to the external file. As\ndiscussed in Chapter 6, in Python an object’s memory space is automatically reclaimed as soon as the object is no longer referenced anywhere in the program.\nWhen file objects are reclaimed, Python also automatically closes the files if they",
    "work later in this chapter.\nclose is usually optional\nCalling the file close method terminates your connection to the external file. As\ndiscussed in Chapter 6, in Python an object’s memory space is automatically reclaimed as soon as the object is no longer referenced anywhere in the program.\nWhen file objects are reclaimed, Python also automatically closes the files if they\nare still open (this also happens when a program shuts down). This means you\nFiles | 231",
    "don’t always need to manually close your files, especially in simple scripts that\ndon’t run for long. On the other hand, including manual close calls can’t hurt and\nis usually a good idea in larger systems. Also, strictly speaking, this auto-close-oncollection feature of files is not part of the language definition, and it may change\nover time. Consequently, manually issuing file close method calls is a good habit\nto form. (For an alternative way to guarantee automatic file closes, also see this\nsection’s later discussion of the file object’s context manager, used with the new\nwith/as statement in Python 2.6 and 3.0.)\nFiles are buffered and seekable.\nThe prior paragraph’s notes about closing files are important, because closing both\nfrees up operating system resources and flushes output buffers. By default, output\nfiles are always buffered, which means that text you write may not be transferred\nfrom memory to disk immediately—closing a file, or running its flush method,",
    "Files are buffered and seekable.\nThe prior paragraph’s notes about closing files are important, because closing both\nfrees up operating system resources and flushes output buffers. By default, output\nfiles are always buffered, which means that text you write may not be transferred\nfrom memory to disk immediately—closing a file, or running its flush method,\nforces the buffered data to disk. You can avoid buffering with extra open arguments,\nbut it may impede performance. Python files are also random-access on a byte offset\nbasis—their seek method allows your scripts to jump around to read and write at\nspecific locations.",
    "Files in Action\nLet’s work through a simple example that demonstrates file-processing basics. The\nfollowing code begins by opening a new text file for output, writing two lines (strings\nterminated with a newline marker, \\n), and closing the file. Later, the example opens\nthe same file again in input mode and reads the lines back one at a time with\nreadline. Notice that the third readline call returns an empty string; this is how Python\nfile methods tell you that you’ve reached the end of the file (empty lines in the file come\nback as strings containing just a newline character, not as empty strings). Here’s the\ncomplete interaction:\n>>> myfile = open('myfile.txt', 'w')\n>>> myfile.write('hello text file\\n')\n16\n>>> myfile.write('goodbye text file\\n')\n18\n>>> myfile.close()\n\n# Open for text output: create/empty\n# Write a line of text: string\n\n>>> myfile = open('myfile.txt')\n>>> myfile.readline()\n'hello text file\\n'\n>>> myfile.readline()\n'goodbye text file\\n'\n>>> myfile.readline()\n''",
    "# Open for text output: create/empty\n# Write a line of text: string\n\n>>> myfile = open('myfile.txt')\n>>> myfile.readline()\n'hello text file\\n'\n>>> myfile.readline()\n'goodbye text file\\n'\n>>> myfile.readline()\n''\n\n# Open for text input: 'r' is default\n# Read the lines back\n\n# Flush output buffers to disk\n\n# Empty string: end of file\n\nNotice that file write calls return the number of characters written in Python 3.0; in\n2.6 they don’t, so you won’t see these numbers echoed interactively. This example\nwrites each line of text, including its end-of-line terminator, \\n, as a string; write\n\n232 | Chapter 9: Tuples, Files, and Everything Else",
    "# Flush output buffers to disk\n\n# Empty string: end of file\n\nNotice that file write calls return the number of characters written in Python 3.0; in\n2.6 they don’t, so you won’t see these numbers echoed interactively. This example\nwrites each line of text, including its end-of-line terminator, \\n, as a string; write\n\n232 | Chapter 9: Tuples, Files, and Everything Else\n\n\fmethods don’t add the end-of-line character for us, so we must include it to properly\nterminate our lines (otherwise the next write will simply extend the current line in the\nfile).\nIf you want to display the file’s content with end-of-line characters interpreted, read\nthe entire file into a string all at once with the file object’s read method and print it:\n>>> open('myfile.txt').read()\n'hello text file\\ngoodbye text file\\n'\n\n# Read all at once into string\n\n>>> print(open('myfile.txt').read())\nhello text file\ngoodbye text file\n\n# User-friendly display",
    "# Read all at once into string\n\n>>> print(open('myfile.txt').read())\nhello text file\ngoodbye text file\n\n# User-friendly display\n\nAnd if you want to scan a text file line by line, file iterators are often your best option:\n>>> for line in open('myfile'):\n...\nprint(line, end='')\n...\nhello text file\ngoodbye text file\n\n# Use file iterators, not reads\n\nWhen coded this way, the temporary file object created by open will automatically read\nand return one line on each loop iteration. This form is usually easiest to code, good\non memory use, and may be faster than some other options (depending on many variables, of course). Since we haven’t reached statements or iterators yet, though, you’ll\nhave to wait until Chapter 14 for a more complete explanation of this code.",
    "Text and binary files in Python 3.0\nStrictly speaking, the example in the prior section uses text files. In both Python 3.0\nand 2.6, file type is determined by the second argument to open, the mode string—an\nincluded “b” means binary. Python has always supported both text and binary files,\nbut in Python 3.0 there is a sharper distinction between the two:\n• Text files represent content as normal str strings, perform Unicode encoding and\ndecoding automatically, and perform end-of-line translation by default.\n• Binary files represent content as a special bytes string type and allow programs to\naccess file content unaltered.\nIn contrast, Python 2.6 text files handle both 8-bit text and binary data, and a special\nstring type and file interface (unicode strings and codecs.open) handles Unicode text.\nThe differences in Python 3.0 stem from the fact that simple and Unicode text have",
    "• Binary files represent content as a special bytes string type and allow programs to\naccess file content unaltered.\nIn contrast, Python 2.6 text files handle both 8-bit text and binary data, and a special\nstring type and file interface (unicode strings and codecs.open) handles Unicode text.\nThe differences in Python 3.0 stem from the fact that simple and Unicode text have\nbeen merged in the normal string type—which makes sense, given that all text is Unicode, including ASCII and other 8-bit encodings.\nBecause most programmers deal only with ASCII text, they can get by with the basic\ntext file interface used in the prior example, and normal strings. All strings are technically Unicode in 3.0, but ASCII users will not generally notice. In fact, files and strings\nwork the same in 3.0 and 2.6 if your script’s scope is limited to such simple forms of text.",
    "Files | 233\n\n\fIf you need to handle internationalized applications or byte-oriented data, though, the\ndistinction in 3.0 impacts your code (usually for the better). In general, you must use\nbytes strings for binary files, and normal str strings for text files. Moreover, because\ntext files implement Unicode encodings, you cannot open a binary data file in text\nmode—decoding its content to Unicode text will likely fail.\nLet’s look at an example. When you read a binary data file you get back a bytes object—\na sequence of small integers that represent absolute byte values (which may or may not\ncorrespond to characters), which looks and feels almost exactly like a normal string:\n>>> data = open('data.bin', 'rb').read()\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> data[4:8]\nb'spam'\n>>> data[0]\n115\n>>> bin(data[0])\n'0b1110011'\n\n# Open binary file: rb=read binary\n# bytes string holds binary data\n# Act like strings\n# But really are small 8-bit integers\n# Python 3.0 bin() function",
    "# Open binary file: rb=read binary\n# bytes string holds binary data\n# Act like strings\n# But really are small 8-bit integers\n# Python 3.0 bin() function\n\nIn addition, binary files do not perform any end-of-line translation on data; text files\nby default map all forms to and from \\n when written and read and implement Unicode\nencodings on transfers. Since Unicode and binary data is of marginal interest to many\nPython programmers, we’ll postpone the full story until Chapter 36. For now, let’s\nmove on to some more substantial file examples.",
    "Storing and parsing Python objects in files\nOur next example writes a variety of Python objects into a text file on multiple lines.\nNotice that it must convert objects to strings using conversion tools. Again, file data is\nalways strings in our scripts, and write methods do not do any automatic to-string\nformatting for us (for space, I’m omitting byte-count return values from write methods\nfrom here on):\n>>> X, Y, Z = 43, 44, 45\n>>> S = 'Spam'\n>>> D = {'a': 1, 'b': 2}\n>>> L = [1, 2, 3]\n>>>\n>>> F = open('datafile.txt', 'w')\n>>> F.write(S + '\\n')\n>>> F.write('%s,%s,%s\\n' % (X, Y, Z))\n>>> F.write(str(L) + '$' + str(D) + '\\n')\n>>> F.close()\n\n# Native Python objects\n# Must be strings to store in file\n\n# Create output file\n# Terminate lines with \\n\n# Convert numbers to strings\n# Convert and separate with $",
    "# Native Python objects\n# Must be strings to store in file\n\n# Create output file\n# Terminate lines with \\n\n# Convert numbers to strings\n# Convert and separate with $\n\nOnce we have created our file, we can inspect its contents by opening it and reading it\ninto a string (a single operation). Notice that the interactive echo gives the exact byte\ncontents, while the print operation interprets embedded end-of-line characters to render a more user-friendly display:\n>>> chars = open('datafile.txt').read()\n>>> chars\n\n234 | Chapter 9: Tuples, Files, and Everything Else\n\n# Raw string display\n\n\f\"Spam\\n43,44,45\\n[1, 2, 3]${'a': 1, 'b': 2}\\n\"\n>>> print(chars)\n# User-friendly display\nSpam\n43,44,45\n[1, 2, 3]${'a': 1, 'b': 2}",
    "234 | Chapter 9: Tuples, Files, and Everything Else\n\n# Raw string display\n\n\f\"Spam\\n43,44,45\\n[1, 2, 3]${'a': 1, 'b': 2}\\n\"\n>>> print(chars)\n# User-friendly display\nSpam\n43,44,45\n[1, 2, 3]${'a': 1, 'b': 2}\n\nWe now have to use other conversion tools to translate from the strings in the text file\nto real Python objects. As Python never converts strings to numbers (or other types of\nobjects) automatically, this is required if we need to gain access to normal object tools\nlike indexing, addition, and so on:\n>>> F = open('datafile.txt')\n>>> line = F.readline()\n>>> line\n'Spam\\n'\n>>> line.rstrip()\n'Spam'\n\n# Open again\n# Read one line\n# Remove end-of-line",
    "# Open again\n# Read one line\n# Remove end-of-line\n\nFor this first line, we used the string rstrip method to get rid of the trailing end-of-line\ncharacter; a line[:−1] slice would work, too, but only if we can be sure all lines end in\nthe \\n character (the last line in a file sometimes does not).\nSo far, we’ve read the line containing the string. Now let’s grab the next line, which\ncontains numbers, and parse out (that is, extract) the objects on that line:\n>>> line = F.readline()\n>>> line\n'43,44,45\\n'\n>>> parts = line.split(',')\n>>> parts\n['43', '44', '45\\n']\n\n# Next line from file\n# It's a string here\n# Split (parse) on commas\n\nWe used the string split method here to chop up the line on its comma delimiters; the\nresult is a list of substrings containing the individual numbers. We still must convert\nfrom strings to integers, though, if we wish to perform math on these:\n>>> int(parts[1])\n44\n>>> numbers = [int(P) for P in parts]\n>>> numbers\n[43, 44, 45]",
    "# Next line from file\n# It's a string here\n# Split (parse) on commas\n\nWe used the string split method here to chop up the line on its comma delimiters; the\nresult is a list of substrings containing the individual numbers. We still must convert\nfrom strings to integers, though, if we wish to perform math on these:\n>>> int(parts[1])\n44\n>>> numbers = [int(P) for P in parts]\n>>> numbers\n[43, 44, 45]\n\n# Convert from string to int\n# Convert all in list at once",
    "# Convert from string to int\n# Convert all in list at once\n\nAs we have learned, int translates a string of digits into an integer object, and the list\ncomprehension expression introduced in Chapter 4 can apply the call to each item in\nour list all at once (you’ll find more on list comprehensions later in this book). Notice\nthat we didn’t have to run rstrip to delete the \\n at the end of the last part; int and\nsome other converters quietly ignore whitespace around digits.\nFinally, to convert the stored list and dictionary in the third line of the file, we can run\nthem through eval, a built-in function that treats a string as a piece of executable program code (technically, a string containing a Python expression):\n>>> line = F.readline()\n>>> line\n\nFiles | 235\n\n\f\"[1, 2, 3]${'a': 1, 'b': 2}\\n\"\n>>> parts = line.split('$')\n>>> parts\n['[1, 2, 3]', \"{'a': 1, 'b': 2}\\n\"]\n>>> eval(parts[0])\n[1, 2, 3]\n>>> objects = [eval(P) for P in parts]\n>>> objects\n[[1, 2, 3], {'a': 1, 'b': 2}]",
    "Files | 235\n\n\f\"[1, 2, 3]${'a': 1, 'b': 2}\\n\"\n>>> parts = line.split('$')\n>>> parts\n['[1, 2, 3]', \"{'a': 1, 'b': 2}\\n\"]\n>>> eval(parts[0])\n[1, 2, 3]\n>>> objects = [eval(P) for P in parts]\n>>> objects\n[[1, 2, 3], {'a': 1, 'b': 2}]\n\n# Split (parse) on $\n# Convert to any object type\n# Do same for all in list\n\nBecause the end result of all this parsing and converting is a list of normal Python objects\ninstead of strings, we can now apply list and dictionary operations to them in our script.",
    "Storing native Python objects with pickle\nUsing eval to convert from strings to objects, as demonstrated in the preceding code,\nis a powerful tool. In fact, sometimes it’s too powerful. eval will happily run any Python\nexpression—even one that might delete all the files on your computer, given the necessary permissions! If you really want to store native Python objects, but you can’t trust\nthe source of the data in the file, Python’s standard library pickle module is ideal.\nThe pickle module is an advanced tool that allows us to store almost any Python object\nin a file directly, with no to- or from-string conversion requirement on our part. It’s like\na super-general data formatting and parsing utility. To store a dictionary in a file, for\ninstance, we pickle it directly:\n>>> D = {'a': 1, 'b': 2}\n>>> F = open('datafile.pkl', 'wb')\n>>> import pickle\n>>> pickle.dump(D, F)\n>>> F.close()\n\n# Pickle any object to file",
    "# Pickle any object to file\n\nThen, to get the dictionary back later, we simply use pickle again to re-create it:\n>>> F = open('datafile.pkl', 'rb')\n>>> E = pickle.load(F)\n>>> E\n{'a': 1, 'b': 2}\n\n# Load any object from file\n\nWe get back an equivalent dictionary object, with no manual splitting or converting\nrequired. The pickle module performs what is known as object serialization—converting objects to and from strings of bytes—but requires very little work on our part. In\nfact, pickle internally translates our dictionary to a string form, though it’s not much\nto look at (and may vary if we pickle in other data protocol modes):\n>>> open('datafile.pkl', 'rb').read()\n# Format is prone to change!\nb'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x00aq\\x01K\\x01X\\x01\\x00\\x00\\x00bq\\x02K\\x02u.'",
    "Because pickle can reconstruct the object from this format, we don’t have to deal with\nthat ourselves. For more on the pickle module, see the Python standard library manual,\nor import pickle and pass it to help interactively. While you’re exploring, also take a\nlook at the shelve module. shelve is a tool that uses pickle to store Python objects in\nan access-by-key filesystem, which is beyond our scope here (though you will get to see\n236 | Chapter 9: Tuples, Files, and Everything Else",
    "an example of shelve in action in Chapter 27, and other pickle examples in Chapters\n30 and 36).\nNote that I opened the file used to store the pickled object in binary\nmode; binary mode is always required in Python 3.0, because the pickler\ncreates and uses a bytes string object, and these objects imply binarymode files (text-mode files imply str strings in 3.0). In earlier Pythons\nit’s OK to use text-mode files for protocol 0 (the default, which creates\nASCII text), as long as text mode is used consistently; higher protocols\nrequire binary-mode files. Python 3.0’s default protocol is 3 (binary),\nbut it creates bytes even for protocol 0. See Chapter 36, Python’s library\nmanual, or reference books for more details on this.\nPython 2.6 also has a cPickle module, which is an optimized version of\npickle that can be imported directly for speed. Python 3.0 renames this\nmodule _pickle and uses it automatically in pickle—scripts simply import pickle and let Python optimize itself.",
    "Storing and parsing packed binary data in files\nOne other file-related note before we move on: some advanced applications also need\nto deal with packed binary data, created perhaps by a C language program. Python’s\nstandard library includes a tool to help in this domain—the struct module knows how\nto both compose and parse packed binary data. In a sense, this is another dataconversion tool that interprets strings in files as binary data.\nTo create a packed binary data file, for example, open it in 'wb' (write binary) mode,\nand pass struct a format string and some Python objects. The format string used here\nmeans pack as a 4-byte integer, a 4-character string, and a 2-byte integer, all in bigendian form (other format codes handle padding bytes, floating-point numbers, and\nmore):\n>>> F = open('data.bin', 'wb')\n>>> import struct\n>>> data = struct.pack('>i4sh', 7, 'spam', 8)\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> F.write(data)\n>>> F.close()",
    "# Open binary output file\n# Make packed binary data\n# Write byte string\n\nPython creates a binary bytes data string, which we write out to the file normally—this\none consists mostly of nonprintable characters printed in hexadecimal escapes, and is\nthe same binary file we met earlier. To parse the values out to normal Python objects,\nwe simply read the string back and unpack it using the same format string. Python\nextracts the values into normal Python objects—integers and a string:\n>>> F = open('data.bin', 'rb')\n>>> data = F.read()\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n\n# Get packed binary data\n\nFiles | 237\n\n\f>>> values = struct.unpack('>i4sh', data)\n>>> values\n(7, 'spam', 8)\n\n# Convert to Python objects",
    "# Get packed binary data\n\nFiles | 237\n\n\f>>> values = struct.unpack('>i4sh', data)\n>>> values\n(7, 'spam', 8)\n\n# Convert to Python objects\n\nBinary data files are advanced and somewhat low-level tools that we won’t cover in\nmore detail here; for more help, see Chapter 36, consult the Python library manual, or\nimport struct and pass it to the help function interactively. Also note that the binary\nfile-processing modes 'wb' and 'rb' can be used to process a simpler binary file such\nas an image or audio file as a whole without having to unpack its contents.",
    "File context managers\nYou’ll also want to watch for Chapter 33’s discussion of the file’s context manager\nsupport, new in Python 3.0 and 2.6. Though more a feature of exception processing\nthan files themselves, it allows us to wrap file-processing code in a logic layer that\nensures that the file will be closed automatically on exit, instead of relying on the autoclose on garbage collection:\nwith open(r'C:\\misc\\data.txt') as myfile:\nfor line in myfile:\n...use line here...\n\n# See Chapter 33 for details\n\nThe try/finally statement we’ll look at in Chapter 33 can provide similar functionality,\nbut at some cost in extra code—three extra lines, to be precise (though we can often\navoid both options and let Python close files for us automatically):\nmyfile = open(r'C:\\misc\\data.txt')\ntry:\nfor line in myfile:\n...use line here...\nfinally:\nmyfile.close()\n\nSince both these options require more information than we have yet obtained, we’ll\npostpone details until later in this book.",
    "Since both these options require more information than we have yet obtained, we’ll\npostpone details until later in this book.\n\nOther File Tools\nThere are additional, more advanced file methods shown in Table 9-2, and even more\nthat are not in the table. For instance, as mentioned earlier, seek resets your current\nposition in a file (the next read or write happens at that position), flush forces buffered\noutput to be written out to disk (by default, files are always buffered), and so on.\nThe Python standard library manual and the reference books described in the Preface\nprovide complete lists of file methods; for a quick look, run a dir or help call interactively, passing in an open file object (in Python 2.6 but not 3.0, you can pass in the\nname file instead). For more file-processing examples, watch for the sidebar “Why\nYou Will Care: File Scanners” on page 340. It sketches common file-scanning loop\ncode patterns with statements we have not covered enough yet to use here.",
    "238 | Chapter 9: Tuples, Files, and Everything Else",
    "Also, note that although the open function and the file objects it returns are your main\ninterface to external files in a Python script, there are additional file-like tools in the\nPython toolset. Also available, to name a few, are:\nStandard streams\nPreopened file objects in the sys module, such as sys.stdout (see “Print Operations” on page 297)\nDescriptor files in the os module\nInteger file handles that support lower-level tools such as file locking\nSockets, pipes, and FIFOs\nFile-like objects used to synchronize processes or communicate over networks\nAccess-by-key files known as “shelves”\nUsed to store unaltered Python objects directly, by key (used in Chapter 27)\nShell command streams\nTools such as os.popen and subprocess.Popen that support spawning shell commands and reading and writing to their standard streams\nThe third-party open source domain offers even more file-like tools, including support",
    "Access-by-key files known as “shelves”\nUsed to store unaltered Python objects directly, by key (used in Chapter 27)\nShell command streams\nTools such as os.popen and subprocess.Popen that support spawning shell commands and reading and writing to their standard streams\nThe third-party open source domain offers even more file-like tools, including support\nfor communicating with serial ports in the PySerial extension and interactive programs\nin the pexpect system. See more advanced Python texts and the Web at large for additional information on file-like tools.\nVersion skew note: In Python 2.5 and earlier, the built-in name open is\nessentially a synonym for the name file, and files may technically be\nopened by calling either open or file (though open is generally preferred\nfor opening). In Python 3.0, the name file is no longer available, because of its redundancy with open.\nPython 2.6 users may also use the name file as the file object type, in",
    "Version skew note: In Python 2.5 and earlier, the built-in name open is\nessentially a synonym for the name file, and files may technically be\nopened by calling either open or file (though open is generally preferred\nfor opening). In Python 3.0, the name file is no longer available, because of its redundancy with open.\nPython 2.6 users may also use the name file as the file object type, in\norder to customize files with object-oriented programming (described\nlater in this book). In Python 3.0, files have changed radically. The\nclasses used to implement file objects live in the standard library module\nio. See this module’s documentation or code for the classes it makes\navailable for customization, and run a type(F) call on open files F for\nhints.",
    "Type Categories Revisited\nNow that we’ve seen all of Python’s core built-in types in action, let’s wrap up our\nobject types tour by reviewing some of the properties they share. Table 9-3 classifies\nall the major types we’ve seen so far according to the type categories introduced earlier.\nHere are some points to remember:\n\nType Categories Revisited | 239",
    "• Objects share operations according to their category; for instance, strings, lists,\nand tuples all share sequence operations such as concatenation, length, and\nindexing.\n• Only mutable objects (lists, dictionaries, and sets) may be changed in-place; you\ncannot change numbers, strings, or tuples in-place.\n• Files export only methods, so mutability doesn’t really apply to them—their state\nmay be changed when they are processed, but this isn’t quite the same as Python\ncore type mutability constraints.\n• “Numbers” in Table 9-3 includes all number types: integer (and the distinct long\ninteger in 2.6), floating-point, complex, decimal, and fraction.\n• “Strings” in Table 9-3 includes str, as well as bytes in 3.0 and unicode in 2.6; the\nbytearray string type in 3.0 is mutable.\n• Sets are something like the keys of a valueless dictionary, but they don’t map to\nvalues and are not ordered, so sets are neither a mapping nor a sequence type;\nfrozenset is an immutable variant of set.",
    "integer in 2.6), floating-point, complex, decimal, and fraction.\n• “Strings” in Table 9-3 includes str, as well as bytes in 3.0 and unicode in 2.6; the\nbytearray string type in 3.0 is mutable.\n• Sets are something like the keys of a valueless dictionary, but they don’t map to\nvalues and are not ordered, so sets are neither a mapping nor a sequence type;\nfrozenset is an immutable variant of set.\n• In addition to type category operations, as of Python 2.6 and 3.0 all the types in\nTable 9-3 have callable methods, which are generally specific to their type.\nTable 9-3. Object classifications\nObject type",
    "Category\n\nMutable?\n\nNumbers (all)\n\nNumeric\n\nNo\n\nStrings\n\nSequence\n\nNo\n\nLists\n\nSequence\n\nYes\n\nDictionaries\n\nMapping\n\nYes\n\nTuples\n\nSequence\n\nNo\n\nFiles\n\nExtension\n\nN/A\n\nSets\n\nSet\n\nYes\n\nfrozenset\n\nSet\n\nNo\n\nbytearray (3.0)\n\nSequence\n\nYes\n\nWhy You Will Care: Operator Overloading\nIn Part VI of this book, we’ll see that objects we implement with classes can pick and\nchoose from these categories arbitrarily. For instance, if we want to provide a new kind\nof specialized sequence object that is consistent with built-in sequences, we can code\na class that overloads things like indexing and concatenation:\nclass MySequence:\ndef __getitem__(self, index):\n# Called on self[index], others\ndef __add__(self, other):\n# Called on self + other\n\n240 | Chapter 9: Tuples, Files, and Everything Else",
    "240 | Chapter 9: Tuples, Files, and Everything Else\n\n\fand so on. We can also make the new object mutable or not by selectively implementing\nmethods called for in-place change operations (e.g., __setitem__ is called on\nself[index]=value assignments). Although it’s beyond this book’s scope, it’s also possible to implement new objects in an external language like C as C extension types. For\nthese, we fill in C function pointer slots to choose between number, sequence, and\nmapping operation sets.",
    "Object Flexibility\nThis part of the book introduced a number of compound object types (collections with\ncomponents). In general:\n• Lists, dictionaries, and tuples can hold any kind of object.\n• Lists, dictionaries, and tuples can be arbitrarily nested.\n• Lists and dictionaries can dynamically grow and shrink.\nBecause they support arbitrary structures, Python’s compound object types are good\nat representing complex information in programs. For example, values in dictionaries\nmay be lists, which may contain tuples, which may contain dictionaries, and so on. The\nnesting can be as deep as needed to model the data to be processed.\nLet’s look at an example of nesting. The following interaction defines a tree of nested\ncompound sequence objects, shown in Figure 9-1. To access its components, you may\ninclude as many index operations as required. Python evaluates the indexes from left",
    "nesting can be as deep as needed to model the data to be processed.\nLet’s look at an example of nesting. The following interaction defines a tree of nested\ncompound sequence objects, shown in Figure 9-1. To access its components, you may\ninclude as many index operations as required. Python evaluates the indexes from left\nto right, and fetches a reference to a more deeply nested object at each step. Figure 9-1 may be a pathologically complicated data structure, but it illustrates the syntax\nused to access nested objects in general:\n>>> L = ['abc', [(1, 2), ([3], 4)], 5]\n>>> L[1]\n[(1, 2), ([3], 4)]\n>>> L[1][1]\n([3], 4)\n>>> L[1][1][0]\n[3]\n>>> L[1][1][0][0]\n3",
    "References Versus Copies\nChapter 6 mentioned that assignments always store references to objects, not copies\nof those objects. In practice, this is usually what you want. Because assignments can\ngenerate multiple references to the same object, though, it’s important to be aware that\nchanging a mutable object in-place may affect other references to the same object\n\nReferences Versus Copies | 241\n\n\fFigure 9-1. A nested object tree with the offsets of its components, created by running the literal\nexpression ['abc', [(1, 2), ([3], 4)], 5]. Syntactically nested objects are internally represented as\nreferences (i.e., pointers) to separate pieces of memory.",
    "References Versus Copies | 241\n\n\fFigure 9-1. A nested object tree with the offsets of its components, created by running the literal\nexpression ['abc', [(1, 2), ([3], 4)], 5]. Syntactically nested objects are internally represented as\nreferences (i.e., pointers) to separate pieces of memory.\n\nelsewhere in your program. If you don’t want such behavior, you’ll need to tell Python\nto copy the object explicitly.\nWe studied this phenomenon in Chapter 6, but it can become more subtle when larger\nobjects come into play. For instance, the following example creates a list assigned to\nX, and another list assigned to L that embeds a reference back to list X. It also creates a\ndictionary D that contains another reference back to list X:\n>>> X = [1, 2, 3]\n>>> L = ['a', X, 'b']\n>>> D = {'x':X, 'y':2}\n\n# Embed references to X's object",
    "# Embed references to X's object\n\nAt this point, there are three references to the first list created: from the name X, from\ninside the list assigned to L, and from inside the dictionary assigned to D. The situation\nis illustrated in Figure 9-2.\nBecause lists are mutable, changing the shared list object from any of the three references also changes what the other two reference:\n>>> X[1] = 'surprise'\n# Changes all three references!\n>>> L\n['a', [1, 'surprise', 3], 'b']\n>>> D\n{'x': [1, 'surprise', 3], 'y': 2}\n\nReferences are a higher-level analog of pointers in other languages. Although you can’t\ngrab hold of the reference itself, it’s possible to store the same reference in more than\none place (variables, lists, and so on). This is a feature—you can pass a large object\n\n242 | Chapter 9: Tuples, Files, and Everything Else",
    "References are a higher-level analog of pointers in other languages. Although you can’t\ngrab hold of the reference itself, it’s possible to store the same reference in more than\none place (variables, lists, and so on). This is a feature—you can pass a large object\n\n242 | Chapter 9: Tuples, Files, and Everything Else\n\n\fFigure 9-2. Shared object references: because the list referenced by variable X is also referenced from\nwithin the objects referenced by L and D, changing the shared list from X makes it look different from\nL and D, too.",
    "242 | Chapter 9: Tuples, Files, and Everything Else\n\n\fFigure 9-2. Shared object references: because the list referenced by variable X is also referenced from\nwithin the objects referenced by L and D, changing the shared list from X makes it look different from\nL and D, too.\n\naround a program without generating expensive copies of it along the way. If you really\ndo want copies, however, you can request them:\n• Slice expressions with empty limits (L[:]) copy sequences.\n• The dictionary and set copy method (X.copy()) copies a dictionary or set.\n• Some built-in functions, such as list, make copies (list(L)).\n• The copy standard library module makes full copies.\nFor example, say you have a list and a dictionary, and you don’t want their values to\nbe changed through other variables:\n>>> L = [1,2,3]\n>>> D = {'a':1, 'b':2}\n\nTo prevent this, simply assign copies to the other variables, not references to the same\nobjects:\n>>> A = L[:]\n>>> B = D.copy()",
    "To prevent this, simply assign copies to the other variables, not references to the same\nobjects:\n>>> A = L[:]\n>>> B = D.copy()\n\n# Instead of A = L (or list(L))\n# Instead of B = D (ditto for sets)\n\nThis way, changes made from the other variables will change the copies, not the\noriginals:\n>>> A[1] = 'Ni'\n>>> B['c'] = 'spam'\n>>>\n>>> L, D\n([1, 2, 3], {'a': 1, 'b': 2})\n>>> A, B\n([1, 'Ni', 3], {'a': 1, 'c': 'spam', 'b': 2})\n\nIn terms of our original example, you can avoid the reference side effects by slicing the\noriginal list instead of simply naming it:\nReferences Versus Copies | 243\n\n\f>>> X = [1, 2, 3]\n>>> L = ['a', X[:], 'b']\n>>> D = {'x':X[:], 'y':2}\n\n# Embed copies of X's object",
    "# Embed copies of X's object\n\nThis changes the picture in Figure 9-2—L and D will now point to different lists than\nX. The net effect is that changes made through X will impact only X, not L and D; similarly,\nchanges to L or D will not impact X.\nOne final note on copies: empty-limit slices and the dictionary copy method only make\ntop-level copies; that is, they do not copy nested data structures, if any are present. If\nyou need a complete, fully independent copy of a deeply nested data structure, use the\nstandard copy module: include an import copy statement and say X = copy.deep\ncopy(Y) to fully copy an arbitrarily nested object Y. This call recursively traverses objects\nto copy all their parts. This is a much more rare case, though (which is why you have\nto say more to make it go). References are usually what you will want; when they are\nnot, slices and copy methods are usually as much copying as you’ll need to do.",
    "Comparisons, Equality, and Truth\nAll Python objects also respond to comparisons: tests for equality, relative magnitude,\nand so on. Python comparisons always inspect all parts of compound objects until a\nresult can be determined. In fact, when nested objects are present, Python automatically\ntraverses data structures to apply comparisons recursively from left to right, and as\ndeeply as needed. The first difference found along the way determines the comparison\nresult.\nFor instance, a comparison of list objects compares all their components automatically:\n>>> L1 = [1, ('a', 3)]\n>>> L2 = [1, ('a', 3)]\n>>> L1 == L2, L1 is L2\n(True, False)\n\n# Same value, unique objects\n# Equivalent? Same object?",
    "# Same value, unique objects\n# Equivalent? Same object?\n\nHere, L1 and L2 are assigned lists that are equivalent but distinct objects. Because of\nthe nature of Python references (studied in Chapter 6), there are two ways to test for\nequality:\n• The == operator tests value equivalence. Python performs an equivalence test,\ncomparing all nested objects recursively.\n• The is operator tests object identity. Python tests whether the two are really the\nsame object (i.e., live at the same address in memory).\nIn the preceding example, L1 and L2 pass the == test (they have equivalent values because\nall their components are equivalent) but fail the is check (they reference two different\nobjects, and hence two different pieces of memory). Notice what happens for short\nstrings, though:\n>>> S1 = 'spam'\n>>> S2 = 'spam'\n\n244 | Chapter 9: Tuples, Files, and Everything Else\n\n\f>>> S1 == S2, S1 is S2\n(True, True)",
    "244 | Chapter 9: Tuples, Files, and Everything Else\n\n\f>>> S1 == S2, S1 is S2\n(True, True)\n\nHere, we should again have two distinct objects that happen to have the same value:\n== should be true, and is should be false. But because Python internally caches and\nreuses some strings as an optimization, there really is just a single string 'spam' in\nmemory, shared by S1 and S2; hence, the is identity test reports a true result. To trigger\nthe normal behavior, we need to use longer strings:\n>>> S1 = 'a longer string'\n>>> S2 = 'a longer string'\n>>> S1 == S2, S1 is S2\n(True, False)",
    "Of course, because strings are immutable, the object caching mechanism is irrelevant\nto your code—strings can’t be changed in-place, regardless of how many variables refer\nto them. If identity tests seem confusing, see Chapter 6 for a refresher on object reference concepts.\nAs a rule of thumb, the == operator is what you will want to use for almost all equality\nchecks; is is reserved for highly specialized roles. We’ll see cases where these operators\nare put to use later in the book.\nRelative magnitude comparisons are also applied recursively to nested data structures:\n>>> L1 = [1, ('a', 3)]\n>>> L2 = [1, ('a', 2)]\n>>> L1 < L2, L1 == L2, L1 > L2\n(False, False, True)\n\n# Less, equal, greater: tuple of results",
    "Here, L1 is greater than L2 because the nested 3 is greater than 2. The result of the last\nline is really a tuple of three objects—the results of the three expressions typed (an\nexample of a tuple without its enclosing parentheses).\nIn general, Python compares types as follows:\n• Numbers are compared by relative magnitude.\n• Strings are compared lexicographically, character by character (\"abc\" < \"ac\").\n• Lists and tuples are compared by comparing each component from left to right.\n• Dictionaries compare as equal if their sorted (key, value) lists are equal. Relative\nmagnitude comparisons are not supported for dictionaries in Python 3.0, but they\nwork in 2.6 and earlier as though comparing sorted (key, value) lists.\n• Nonnumeric mixed-type comparisons (e.g., 1 < 'spam') are errors in Python 3.0.\nThey are allowed in Python 2.6, but use a fixed but arbitrary ordering rule. By\nproxy, this also applies to sorts, which use comparisons internally: nonnumeric",
    "magnitude comparisons are not supported for dictionaries in Python 3.0, but they\nwork in 2.6 and earlier as though comparing sorted (key, value) lists.\n• Nonnumeric mixed-type comparisons (e.g., 1 < 'spam') are errors in Python 3.0.\nThey are allowed in Python 2.6, but use a fixed but arbitrary ordering rule. By\nproxy, this also applies to sorts, which use comparisons internally: nonnumeric\nmixed-type collections cannot be sorted in 3.0.\nIn general, comparisons of structured objects proceed as though you had written the\nobjects as literals and compared all their parts one at a time from left to right. In later\nchapters, we’ll see other object types that can change the way they get compared.\nComparisons, Equality, and Truth | 245",
    "Python 3.0 Dictionary Comparisons\nThe second to last point in the preceding section merits illustration. In Python 2.6 and\nearlier, dictionaries support magnitude comparisons, as though you were comparing\nsorted key/value lists:\nC:\\misc> c:\\python26\\python\n>>> D1 = {'a':1, 'b':2}\n>>> D2 = {'a':1, 'b':3}\n>>> D1 == D2\nFalse\n>>> D1 < D2\nTrue",
    "In Python 3.0, magnitude comparisons for dictionaries are removed because they incur\ntoo much overhead when equality is desired (equality uses an optimized scheme in 3.0\nthat doesn’t literally compare sorted key/value lists). The alternative in 3.0 is to either\nwrite loops to compare values by key or compare the sorted key/value lists manually—\nthe items dictionary methods and sorted built-in suffice:\nC:\\misc> c:\\python30\\python\n>>> D1 = {'a':1, 'b':2}\n>>> D2 = {'a':1, 'b':3}\n>>> D1 == D2\nFalse\n>>> D1 < D2\nTypeError: unorderable types: dict() < dict()\n>>> list(D1.items())\n[('a', 1), ('b', 2)]\n>>> sorted(D1.items())\n[('a', 1), ('b', 2)]\n>>> sorted(D1.items()) < sorted(D2.items())\nTrue\n>>> sorted(D1.items()) > sorted(D2.items())\nFalse\n\nIn practice, most programs requiring this behavior will develop more efficient ways to\ncompare data in dictionaries than either this workaround or the original behavior in\nPython 2.6.",
    "In practice, most programs requiring this behavior will develop more efficient ways to\ncompare data in dictionaries than either this workaround or the original behavior in\nPython 2.6.\n\nThe Meaning of True and False in Python\nNotice that the test results returned in the last two examples represent true and false\nvalues. They print as the words True and False, but now that we’re using logical tests\nlike these in earnest, I should be a bit more formal about what these names really mean.\nIn Python, as in most programming languages, an integer 0 represents false, and an\ninteger 1 represents true. In addition, though, Python recognizes any empty data structure as false and any nonempty data structure as true. More generally, the notions of\n\n246 | Chapter 9: Tuples, Files, and Everything Else",
    "246 | Chapter 9: Tuples, Files, and Everything Else\n\n\ftrue and false are intrinsic properties of every object in Python—each object is either\ntrue or false, as follows:\n• Numbers are true if nonzero.\n• Other objects are true if nonempty.\nTable 9-4 gives examples of true and false objects in Python.\nTable 9-4. Example object truth values\nObject\n\nValue\n\n\"spam\"\n\nTrue\n\n\"\"\n\nFalse\n\n[]\n\nFalse\n\n{}\n\nFalse\n\n1\n\nTrue\n\n0.0\n\nFalse\n\nNone\n\nFalse\n\nAs one application, because objects are true or false themselves, it’s common to see\nPython programmers code tests like if X:, which, assuming X is a string, is the same\nas if X != '':. In other words, you can test the object itself, instead of comparing it\nto an empty object. (More on if statements in Part III.)",
    "The None object\nAs shown in the last item in Table 9-4, Python also provides a special object called\nNone, which is always considered to be false. None was introduced in Chapter 4; it is the\nonly value of a special data type in Python and typically serves as an empty placeholder\n(much like a NULL pointer in C).\nFor example, recall that for lists you cannot assign to an offset unless that offset already\nexists (the list does not magically grow if you make an out-of-bounds assignment). To\npreallocate a 100-item list such that you can add to any of the 100 offsets, you can fill\nit with None objects:\n>>> L = [None] * 100\n>>>\n>>> L\n[None, None, None, None, None, None, None, ... ]\n\nThis doesn’t limit the size of the list (it can still grow and shrink later), but simply\npresets an initial size to allow for future index assignments. You could initialize a list\nwith zeros the same way, of course, but best practice dictates using None if the list’s\ncontents are not yet known.",
    "This doesn’t limit the size of the list (it can still grow and shrink later), but simply\npresets an initial size to allow for future index assignments. You could initialize a list\nwith zeros the same way, of course, but best practice dictates using None if the list’s\ncontents are not yet known.\n\nComparisons, Equality, and Truth | 247\n\n\fKeep in mind that None does not mean “undefined.” That is, None is something, not\nnothing (despite its name!)—it is a real object and piece of memory, given a built-in\nname by Python. Watch for other uses of this special object later in the book; it is also\nthe default return value of functions, as we’ll see in Part IV.",
    "The bool type\nAlso keep in mind that the Python Boolean type bool, introduced in Chapter 5, simply\naugments the notions of true and false in Python. As we learned in Chapter 5, the builtin words True and False are just customized versions of the integers 1 and 0—it’s as if\nthese two words have been preassigned to 1 and 0 everywhere in Python. Because of\nthe way this new type is implemented, this is really just a minor extension to the notions\nof true and false already described, designed to make truth values more explicit:\n• When used explicitly in truth test code, the words True and False are equivalent\nto 1 and 0, but they make the programmer’s intent clearer.\n• Results of Boolean tests run interactively print as the words True and False, instead\nof as 1 and 0, to make the type of result clearer.\nYou are not required to use only Boolean types in logical statements such as if; all\nobjects are still inherently true or false, and all the Boolean concepts mentioned in this",
    "to 1 and 0, but they make the programmer’s intent clearer.\n• Results of Boolean tests run interactively print as the words True and False, instead\nof as 1 and 0, to make the type of result clearer.\nYou are not required to use only Boolean types in logical statements such as if; all\nobjects are still inherently true or false, and all the Boolean concepts mentioned in this\nchapter still work as described if you use other types. Python also provides a bool builtin function that can be used to test the Boolean value of an object (i.e., whether it is\nTrue—that is, nonzero or nonempty):\n>>> bool(1)\nTrue\n>>> bool('spam')\nTrue\n>>> bool({})\nFalse",
    "In practice, though, you’ll rarely notice the Boolean type produced by logic tests, because Boolean results are used automatically by if statements and other selection tools.\nWe’ll explore Booleans further when we study logical statements in Chapter 12.\n\nPython’s Type Hierarchies\nFigure 9-3 summarizes all the built-in object types available in Python and their relationships. We’ve looked at the most prominent of these; most of the other kinds of\nobjects in Figure 9-3 correspond to program units (e.g., functions and modules) or\nexposed interpreter internals (e.g., stack frames and compiled code).\nThe main point to notice here is that everything in a Python system is an object type\nand may be processed by your Python programs. For instance, you can pass a class to\na function, assign it to a variable, stuff it in a list or dictionary, and so on.\n\n248 | Chapter 9: Tuples, Files, and Everything Else",
    "248 | Chapter 9: Tuples, Files, and Everything Else\n\n\fFigure 9-3. Python’s major built-in object types, organized by categories. Everything is a type of object\nin Python, even the type of an object!\nPython’s Type Hierarchies | 249",
    "Type Objects\nIn fact, even types themselves are an object type in Python: the type of an object is an\nobject of type type (say that three times fast!). Seriously, a call to the built-in function\ntype(X) returns the type object of object X. The practical application of this is that type\nobjects can be used for manual type comparisons in Python if statements. However,\nfor reasons introduced in Chapter 4, manual type testing is usually not the right thing\nto do in Python, since it limits your code’s flexibility.\nOne note on type names: as of Python 2.2, each core type has a new built-in name\nadded to support type customization through object-oriented subclassing: dict, list,\nstr, tuple, int, float, complex, bytes, type, set, and more (in Python 2.6 but not 3.0,\nfile is also a type name and a synonym for open). Calls to these names are really object\nconstructor calls, not simply conversion functions, though you can treat them as simple\nfunctions for basic usage.",
    "added to support type customization through object-oriented subclassing: dict, list,\nstr, tuple, int, float, complex, bytes, type, set, and more (in Python 2.6 but not 3.0,\nfile is also a type name and a synonym for open). Calls to these names are really object\nconstructor calls, not simply conversion functions, though you can treat them as simple\nfunctions for basic usage.\nIn addition, the types standard library module in Python 3.0 provides additional type\nnames for types that are not available as built-ins (e.g., the type of a function; in Python\n2.6 but not 3.0, this module also includes synonyms for built-in type names), and it is\npossible to do type tests with the isinstance function. For example, all of the following\ntype tests are true:\ntype([1]) == type([])\ntype([1]) == list\nisinstance([1], list)",
    "# Type of another list\n# List type name\n# List or customization thereof\n\nimport types\ndef f(): pass\ntype(f) == types.FunctionType\n\n# types has names for other types\n\nBecause types can be subclassed in Python today, the isinstance technique is generally\nrecommended. See Chapter 31 for more on subclassing built-in types in Python 2.2 and\nlater.\nAlso in Chapter 31, we will explore how type(X) and type-testing in general apply to\ninstances of user-defined classes. In short, in Python 3.0 and for new-style classes in\nPython 2.6, the type of a class instance is the class from which the instance was made.\nFor classic classes in Python 2.6 and earlier, all class instances are of the type “instance,”\nand we must compare instance __class__ attributes to compare their types meaningfully. Since we’re not ready for classes yet, we’ll postpone the rest of this story until\nChapter 31.",
    "Other Types in Python\nBesides the core objects studied in this part of the book, and the program-unit objects\nsuch as functions, modules, and classes that we’ll meet later, a typical Python installation has dozens of additional object types available as linked-in C extensions or\n\n250 | Chapter 9: Tuples, Files, and Everything Else",
    "250 | Chapter 9: Tuples, Files, and Everything Else\n\n\fPython classes—regular expression objects, DBM files, GUI widgets, network sockets,\nand so on.\nThe main difference between these extra tools and the built-in types we’ve seen so far\nis that the built-ins provide special language creation syntax for their objects (e.g., 4 for\nan integer, [1,2] for a list, the open function for files, and def and lambda for functions).\nOther tools are generally made available in standard library modules that you must first\nimport to use. For instance, to make a regular expression object, you import re and call\nre.compile(). See Python’s library reference for a comprehensive guide to all the tools\navailable to Python programs.",
    "Built-in Type Gotchas\nThat’s the end of our look at core data types. We’ll wrap up this part of the book with\na discussion of common problems that seem to bite new users (and the occasional\nexpert), along with their solutions. Some of this is a review of ideas we’ve already covered, but these issues are important enough to warn about again here.\n\nAssignment Creates References, Not Copies\nBecause this is such a central concept, I’ll mention it again: you need to understand\nwhat’s going on with shared references in your program. For instance, in the following\nexample, the list object assigned to the name L is referenced from L and from inside the\nlist assigned to the name M. Changing L in-place changes what M references, too:\n>>> L = [1, 2, 3]\n>>> M = ['X', L, 'Y']\n>>> M\n['X', [1, 2, 3], 'Y']\n>>> L[1] = 0\n>>> M\n['X', [1, 0, 3], 'Y']\n\n# Embed a reference to L\n\n# Changes M too",
    "# Embed a reference to L\n\n# Changes M too\n\nThis effect usually becomes important only in larger programs, and shared references\nare often exactly what you want. If they’re not, you can avoid sharing objects by copying\nthem explicitly. For lists, you can always make a top-level copy by using an emptylimits slice:\n>>> L = [1, 2, 3]\n>>> M = ['X', L[:], 'Y']\n>>> L[1] = 0\n>>> L\n[1, 0, 3]\n>>> M\n['X', [1, 2, 3], 'Y']\n\n# Embed a copy of L\n# Changes only L, not M\n\nBuilt-in Type Gotchas | 251\n\n\fRemember, slice limits default to 0 and the length of the sequence being sliced; if both\nare omitted, the slice extracts every item in the sequence and so makes a top-level copy\n(a new, unshared object).",
    "# Embed a copy of L\n# Changes only L, not M\n\nBuilt-in Type Gotchas | 251\n\n\fRemember, slice limits default to 0 and the length of the sequence being sliced; if both\nare omitted, the slice extracts every item in the sequence and so makes a top-level copy\n(a new, unshared object).\n\nRepetition Adds One Level Deep\nRepeating a sequence is like adding it to itself a number of times. However, when\nmutable sequences are nested, the effect might not always be what you expect. For\ninstance, in the following example X is assigned to L repeated four times, whereas Y is\nassigned to a list containing L repeated four times:\n>>> L = [4, 5, 6]\n>>> X = L * 4\n>>> Y = [L] * 4\n\n# Like [4, 5, 6] + [4, 5, 6] + ...\n# [L] + [L] + ... = [L, L,...]\n\n>>> X\n[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]\n>>> Y\n[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]",
    "# Like [4, 5, 6] + [4, 5, 6] + ...\n# [L] + [L] + ... = [L, L,...]\n\n>>> X\n[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]\n>>> Y\n[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]\n\nBecause L was nested in the second repetition, Y winds up embedding references back\nto the original list assigned to L, and so is open to the same sorts of side effects noted\nin the last section:\n>>> L[1] = 0\n# Impacts Y but not X\n>>> X\n[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]\n>>> Y\n[[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]\n\nThe same solutions to this problem apply here as in the previous section, as this is really\njust another way to create the shared mutable object reference case. If you remember\nthat repetition, concatenation, and slicing copy only the top level of their operand\nobjects, these sorts of cases make much more sense.",
    "The same solutions to this problem apply here as in the previous section, as this is really\njust another way to create the shared mutable object reference case. If you remember\nthat repetition, concatenation, and slicing copy only the top level of their operand\nobjects, these sorts of cases make much more sense.\n\nBeware of Cyclic Data Structures\nWe actually encountered this concept in a prior exercise: if a collection object contains\na reference to itself, it’s called a cyclic object. Python prints a [...] whenever it detects\na cycle in the object, rather than getting stuck in an infinite loop:\n>>> L = ['grail']\n>>> L.append(L)\n>>> L\n['grail', [...]]\n\n# Append reference to same object\n# Generates cycle in object: [...]",
    "# Append reference to same object\n# Generates cycle in object: [...]\n\nBesides understanding that the three dots in square brackets represent a cycle in the\nobject, this case is worth knowing about because it can lead to gotchas—cyclic structures may cause code of your own to fall into unexpected loops if you don’t anticipate\nthem. For instance, some programs keep a list or dictionary of already visited items and\n\n252 | Chapter 9: Tuples, Files, and Everything Else\n\n\fcheck it to determine whether they’re in a cycle. See the solutions to the “Test Your\nKnowledge: Part I Exercises” in Appendix B for more on this problem, and check out\nthe reloadall.py program in Chapter 24 for a solution.\nDon’t use cyclic references unless you really need to. There are good reasons to create\ncycles, but unless you have code that knows how to handle them, you probably won’t\nwant to make your objects reference themselves very often in practice.",
    "Immutable Types Can’t Be Changed In-Place\nYou can’t change an immutable object in-place. Instead, you construct a new object\nwith slicing, concatenation, and so on, and assign it back to the original reference, if\nneeded:\nT = (1, 2, 3)\nT[2] = 4\n\n# Error!\n\nT = T[:2] + (4,)\n\n# OK: (1, 2, 4)\n\nThat might seem like extra coding work, but the upside is that the previous gotchas\ncan’t happen when you’re using immutable objects such as tuples and strings; because\nthey can’t be changed in-place, they are not open to the sorts of side effects that lists are.",
    "Chapter Summary\nThis chapter explored the last two major core object types—the tuple and the file. We\nlearned that tuples support all the usual sequence operations, have just a few methods,\nand do not allow any in-place changes because they are immutable. We also learned\nthat files are returned by the built-in open function and provide methods for reading\nand writing data. We explored how to translate Python objects to and from strings for\nstoring in files, and we looked at the pickle and struct modules for advanced roles\n(object serialization and binary data). Finally, we wrapped up by reviewing some properties common to all object types (e.g., shared references) and went through a list of\ncommon mistakes (“gotchas”) in the object type domain.\nIn the next part, we’ll shift gears, turning to the topic of statement syntax in Python—\nwe’ll explore all of Python’s basic procedural statements in the chapters that follow.",
    "common mistakes (“gotchas”) in the object type domain.\nIn the next part, we’ll shift gears, turning to the topic of statement syntax in Python—\nwe’ll explore all of Python’s basic procedural statements in the chapters that follow.\nThe next chapter kicks off that part of the book with an introduction to Python’s general\nsyntax model, which is applicable to all statement types. Before moving on, though,\ntake the chapter quiz, and then work through the end-of-part lab exercises to review\ntype concepts. Statements largely just create and process objects, so make sure you’ve\nmastered this domain by working through all the exercises before reading on.",
    "Chapter Summary | 253\n\n\fTest Your Knowledge: Quiz\n1. How can you determine how large a tuple is? Why is this tool located where it is?\n2. Write an expression that changes the first item in a tuple. (4, 5, 6) should become\n(1, 5, 6) in the process.\n3. What is the default for the processing mode argument in a file open call?\n4. What module might you use to store Python objects in a file without converting\nthem to strings yourself?\n5. How might you go about copying all parts of a nested structure at once?\n6. When does Python consider an object true?\n7. What is your quest?",
    "Test Your Knowledge: Answers\n1. The built-in len function returns the length (number of contained items) for any\ncontainer object in Python, including tuples. It is a built-in function instead of a\ntype method because it applies to many different types of objects. In general, builtin functions and expressions may span many object types; methods are specific to\na single object type, though some may be available on more than one type (index,\nfor example, works on lists and tuples).\n2. Because they are immutable, you can’t really change tuples in-place, but you can\ngenerate a new tuple with the desired value. Given T = (4, 5, 6), you can change\nthe first item by making a new tuple from its parts by slicing and concatenating:\nT = (1,) + T[1:]. (Recall that single-item tuples require a trailing comma.) You\ncould also convert the tuple to a list, change it in-place, and convert it back to a\ntuple, but this is more expensive and is rarely required in practice—simply use a",
    "the first item by making a new tuple from its parts by slicing and concatenating:\nT = (1,) + T[1:]. (Recall that single-item tuples require a trailing comma.) You\ncould also convert the tuple to a list, change it in-place, and convert it back to a\ntuple, but this is more expensive and is rarely required in practice—simply use a\nlist if you know that the object will require in-place changes.\n3. The default for the processing mode argument in a file open call is 'r', for reading\ntext input. For input text files, simply pass in the external file’s name.\n4. The pickle module can be used to store Python objects in a file without explicitly\nconverting them to strings. The struct module is related, but it assumes the data\nis to be in packed binary format in the file.\n5. Import the copy module, and call copy.deepcopy(X) if you need to copy all parts of\na nested structure X. This is also rarely seen in practice; references are usually the",
    "4. The pickle module can be used to store Python objects in a file without explicitly\nconverting them to strings. The struct module is related, but it assumes the data\nis to be in packed binary format in the file.\n5. Import the copy module, and call copy.deepcopy(X) if you need to copy all parts of\na nested structure X. This is also rarely seen in practice; references are usually the\ndesired behavior, and shallow copies (e.g., aList[:], aDict.copy()) usually suffice\nfor most copies.",
    "254 | Chapter 9: Tuples, Files, and Everything Else\n\n\f6. An object is considered true if it is either a nonzero number or a nonempty collection object. The built-in words True and False are essentially predefined to have\nthe same meanings as integer 1 and 0, respectively.\n7. Acceptable answers include “To learn Python,” “To move on to the next part of\nthe book,” or “To seek the Holy Grail.”",
    "Test Your Knowledge: Part II Exercises\nThis session asks you to get your feet wet with built-in object fundamentals. As before,\na few new ideas may pop up along the way, so be sure to flip to the answers in Appendix B when you’re done (or when you’re not, if necessary). If you have limited time, I\nsuggest starting with exercises 10 and 11 (the most practical of the bunch), and then\nworking from first to last as time allows. This is all fundamental material, though, so\ntry to do as many of these as you can.\n1. The basics. Experiment interactively with the common type operations found in\nthe various operation tables in this part of the book. To get started, bring up the\nPython interactive interpreter, type each of the following expressions, and try to\nexplain what’s happening in each case. Note that the semicolon in some of these\nis being used as a statement separator, to squeeze multiple statements onto a single",
    "the various operation tables in this part of the book. To get started, bring up the\nPython interactive interpreter, type each of the following expressions, and try to\nexplain what’s happening in each case. Note that the semicolon in some of these\nis being used as a statement separator, to squeeze multiple statements onto a single\nline: for example, X=1;X assigns and then prints a variable (more on statement\nsyntax in the next part of the book). Also remember that a comma between expressions usually builds a tuple, even if there are no enclosing parentheses: X,Y,Z\nis a three-item tuple, which Python prints back to you in parentheses.\n2 ** 16\n2 / 5, 2 / 5.0\n\"spam\" + \"eggs\"\nS = \"ham\"\n\"eggs \" + S\nS * 5\nS[:0]\n\"green %s and %s\" % (\"eggs\", S)\n'green {0} and {1}'.format('eggs', S)\n('x',)[0]\n('x', 'y')[1]\nL = [1,2,3] + [4,5,6]\nL, L[:], L[:0], L[−2], L[−2:]\n([1,2,3] + [4,5,6])[2:4]\n[L[2], L[3]]\nL.reverse(); L\nL.sort(); L\nL.index(4)\n{'a':1, 'b':2}['b']\nD = {'x':1, 'y':2, 'z':3}",
    "Test Your Knowledge: Part II Exercises | 255\n\n\fD['w'] = 0\nD['x'] + D['w']\nD[(1,2,3)] = 4\nlist(D.keys()), list(D.values()), (1,2,3) in D\n[[]], [\"\",[],(),{},None]",
    "2. Indexing and slicing. At the interactive prompt, define a list named L that contains\nfour strings or numbers (e.g., L=[0,1,2,3]). Then, experiment with some boundary\ncases; you may not ever see these cases in real programs, but they are intended to\nmake you think about the underlying model, and some may be useful in less artificial forms:\na. What happens when you try to index out of bounds (e.g., L[4])?\nb. What about slicing out of bounds (e.g., L[−1000:100])?\nc. Finally, how does Python handle it if you try to extract a sequence in reverse,\nwith the lower bound greater than the higher bound (e.g., L[3:1])? Hint: try\nassigning to this slice (L[3:1]=['?']), and see where the value is put. Do you\nthink this may be the same phenomenon you saw when slicing out of bounds?\n3. Indexing, slicing, and del. Define another list L with four items, and assign an empty\nlist to one of its offsets (e.g., L[2]=[]). What happens? Then, assign an empty list",
    "assigning to this slice (L[3:1]=['?']), and see where the value is put. Do you\nthink this may be the same phenomenon you saw when slicing out of bounds?\n3. Indexing, slicing, and del. Define another list L with four items, and assign an empty\nlist to one of its offsets (e.g., L[2]=[]). What happens? Then, assign an empty list\nto a slice (L[2:3]=[]). What happens now? Recall that slice assignment deletes the\nslice and inserts the new value where it used to be.\nThe del statement deletes offsets, keys, attributes, and names. Use it on your list\nto delete an item (e.g., del L[0]). What happens if you delete an entire slice\n(del L[1:])? What happens when you assign a nonsequence to a slice (L[1:2]=1)?\n4. Tuple assignment. Type the following lines:\n>>> X = 'spam'\n>>> Y = 'eggs'\n>>> X, Y = Y, X",
    "What do you think is happening to X and Y when you type this sequence?\n5. Dictionary keys. Consider the following code fragments:\n>>> D = {}\n>>> D[1] = 'a'\n>>> D[2] = 'b'\n\nYou’ve learned that dictionaries aren’t accessed by offsets, so what’s going on here?\nDoes the following shed any light on the subject? (Hint: strings, integers, and tuples\nshare which type category?)\n>>> D[(1, 2, 3)] = 'c'\n>>> D\n{1: 'a', 2: 'b', (1, 2, 3): 'c'}\n\n256 | Chapter 9: Tuples, Files, and Everything Else",
    "6. Dictionary indexing. Create a dictionary named D with three entries, for keys 'a',\n'b', and 'c'. What happens if you try to index a nonexistent key (D['d'])? What\ndoes Python do if you try to assign to a nonexistent key 'd' (e.g., D['d']='spam')?\nHow does this compare to out-of-bounds assignments and references for lists?\nDoes this sound like the rule for variable names?\n7. Generic operations. Run interactive tests to answer the following questions:\na. What happens when you try to use the + operator on different/mixed types\n(e.g., string + list, list + tuple)?\nb. Does + work when one of the operands is a dictionary?\nc. Does the append method work for both lists and strings? How about using the\nkeys method on lists? (Hint: what does append assume about its subject object?)\nd. Finally, what type of object do you get back when you slice or concatenate two\nlists or two strings?\n8. String indexing. Define a string S of four characters: S = \"spam\". Then type the",
    "c. Does the append method work for both lists and strings? How about using the\nkeys method on lists? (Hint: what does append assume about its subject object?)\nd. Finally, what type of object do you get back when you slice or concatenate two\nlists or two strings?\n8. String indexing. Define a string S of four characters: S = \"spam\". Then type the\nfollowing expression: S[0][0][0][0][0]. Any clue as to what’s happening this time?\n(Hint: recall that a string is a collection of characters, but Python characters are\none-character strings.) Does this indexing expression still work if you apply it to a\nlist such as ['s', 'p', 'a', 'm']? Why?\n9. Immutable types. Define a string S of four characters again: S = \"spam\". Write an\nassignment that changes the string to \"slam\", using only slicing and concatenation.\nCould you perform the same operation using just indexing and concatenation?\nHow about index assignment?\n10. Nesting. Write a data structure that represents your personal information: name",
    "list such as ['s', 'p', 'a', 'm']? Why?\n9. Immutable types. Define a string S of four characters again: S = \"spam\". Write an\nassignment that changes the string to \"slam\", using only slicing and concatenation.\nCould you perform the same operation using just indexing and concatenation?\nHow about index assignment?\n10. Nesting. Write a data structure that represents your personal information: name\n(first, middle, last), age, job, address, email address, and phone number. You may\nbuild the data structure with any combination of built-in object types you like (lists,\ntuples, dictionaries, strings, numbers). Then, access the individual components of\nyour data structures by indexing. Do some structures make more sense than others\nfor this object?\n11. Files. Write a script that creates a new output file called myfile.txt and writes the\nstring \"Hello file world!\" into it. Then write another script that opens\nmyfile.txt and reads and prints its contents. Run your two scripts from the system",
    "your data structures by indexing. Do some structures make more sense than others\nfor this object?\n11. Files. Write a script that creates a new output file called myfile.txt and writes the\nstring \"Hello file world!\" into it. Then write another script that opens\nmyfile.txt and reads and prints its contents. Run your two scripts from the system\ncommand line. Does the new file show up in the directory where you ran your\nscripts? What if you add a different directory path to the filename passed to open?\nNote: file write methods do not add newline characters to your strings; add an\nexplicit \\n at the end of the string if you want to fully terminate the line in the file.",
    "Test Your Knowledge: Part II Exercises | 257\n\n\f\fPART III\n\nStatements and Syntax\n\n\f\fCHAPTER 10\n\nIntroducing Python Statements\n\nNow that you’re familiar with Python’s core built-in object types, this chapter begins\nour exploration of its fundamental statement forms. As in the previous part, we’ll begin\nhere with a general introduction to statement syntax, and we’ll follow up with more\ndetails about specific statements in the next few chapters.\nIn simple terms, statements are the things you write to tell Python what your programs\nshould do. If programs “do things with stuff,” statements are the way you specify what\nsort of things a program does. Python is a procedural, statement-based language; by\ncombining statements, you specify a procedure that Python performs to satisfy a program’s goals.",
    "Python Program Structure Revisited\nAnother way to understand the role of statements is to revisit the concept hierarchy\nintroduced in Chapter 4, which talked about built-in objects and the expressions used\nto manipulate them. This chapter climbs the hierarchy to the next level:\n1. Programs are composed of modules.\n2. Modules contain statements.\n3. Statements contain expressions.\n4. Expressions create and process objects.\nAt its core, Python syntax is composed of statements and expressions. Expressions\nprocess objects and are embedded in statements. Statements code the larger logic of a\nprogram’s operation—they use and direct expressions to process the objects we studied\nin the preceding chapters. Moreover, statements are where objects spring into existence\n(e.g., in expressions within assignment statements), and some statements create entirely new kinds of objects (functions, classes, and so on). Statements always exist in\nmodules, which themselves are managed with statements.\n\n261",
    "261\n\n\fPython’s Statements\nTable 10-1 summarizes Python’s statement set. This part of the book deals with entries\nin the table from the top through break and continue. You’ve informally been introduced to a few of the statements in Table 10-1 already; this part of the book will fill in\ndetails that were skipped earlier, introduce the rest of Python’s procedural statement\nset, and cover the overall syntax model. Statements lower in Table 10-1 that have to\ndo with larger program units—functions, classes, modules, and exceptions—lead to\nlarger programming ideas, so they will each have a section of their own. More focused\nstatements (like del, which deletes various components) are covered elsewhere in the\nbook, or in Python’s standard manuals.\nTable 10-1. Python 3.0 statements\nStatement\n\nRole\n\nExample\n\nAssignment\n\nCreating references\n\na, *b = 'good', 'bad', 'ugly'\n\nCalls and other expressions\n\nRunning functions\n\nlog.write(\"spam, ham\")\n\nprint calls\n\nPrinting objects",
    "Role\n\nExample\n\nAssignment\n\nCreating references\n\na, *b = 'good', 'bad', 'ugly'\n\nCalls and other expressions\n\nRunning functions\n\nlog.write(\"spam, ham\")\n\nprint calls\n\nPrinting objects\n\nprint('The Killer', joke)\n\nif/elif/else\n\nSelecting actions\n\nif \"python\" in text:\nprint(text)\n\nfor/else\n\nSequence iteration\n\nfor x in mylist:\nprint(x)\n\nwhile/else\n\nGeneral loops\n\nwhile X > Y:\nprint('hello')\n\npass\n\nEmpty placeholder\n\nwhile True:\npass\n\nbreak\n\nLoop exit\n\nwhile True:\nif exittest(): break\n\ncontinue\n\nLoop continue\n\nwhile True:\nif skiptest(): continue\n\ndef\n\nFunctions and methods\n\ndef f(a, b, c=1, *d):\nprint(a+b+c+d[0])\n\nreturn\n\nFunctions results\n\ndef f(a, b, c=1, *d):\nreturn a+b+c+d[0]\n\nyield\n\nGenerator functions\n\ndef gen(n):\nfor i in n: yield i*2\n\nglobal\n\nNamespaces\n\nx = 'old'\ndef function():\nglobal x, y; x = 'new'\n\nnonlocal\n\nNamespaces (3.0+)\n\ndef outer():\nx = 'old'\ndef function():\nnonlocal x; x = 'new'\n\nimport\n\nModule access\n\nimport sys\n\nfrom\n\nAttribute access\n\nfrom sys import stdin\n\nclass",
    "return\n\nFunctions results\n\ndef f(a, b, c=1, *d):\nreturn a+b+c+d[0]\n\nyield\n\nGenerator functions\n\ndef gen(n):\nfor i in n: yield i*2\n\nglobal\n\nNamespaces\n\nx = 'old'\ndef function():\nglobal x, y; x = 'new'\n\nnonlocal\n\nNamespaces (3.0+)\n\ndef outer():\nx = 'old'\ndef function():\nnonlocal x; x = 'new'\n\nimport\n\nModule access\n\nimport sys\n\nfrom\n\nAttribute access\n\nfrom sys import stdin\n\nclass\n\nBuilding objects\n\nclass Subclass(Superclass):\nstaticData = []\ndef method(self): pass\n\n262 | Chapter 10: Introducing Python Statements\n\n\fStatement\n\nRole\n\nExample\n\ntry/except/ finally\n\nCatching exceptions\n\ntry:\n\nraise\n\nTriggering exceptions\n\nraise EndSearch(location)\n\nassert\n\nDebugging checks\n\nassert X > Y, 'X too small'\n\nwith/as\n\nContext managers (2.6+)\n\nwith open('data') as myfile:\nprocess(myfile)\n\ndel\n\nDeleting references\n\ndel data[k]\ndel data[i:j]\ndel obj.attr\ndel variable\n\naction()\nexcept:\nprint('action error')",
    "Table 10-1 reflects the statement forms in Python 3.0—units of code that each have a\nspecific syntax and purpose. Here are a few fine points about its content:\n• Assignment statements come in a variety of syntax flavors, described in Chapter 11: basic, sequence, augmented, and more.\n• print is technically neither a reserved word nor a statement in 3.0, but a built-in\nfunction call; because it will nearly always be run as an expression statement,\nthough (that is, on a line by itself), it’s generally thought of as a statement type.\nWe’ll study print operations in Chapter 11 the next chapter.\n• yield is actually an expression instead of a statement too, as of 2.5; like print, it’s\ntypically used in a line by itself and so is included in this table, but scripts occasionally assign or otherwise use its result, as we’ll see in Chapter 20. As an expression, yield is also a reserved word, unlike print.\nMost of this table applies to Python 2.6, too, except where it doesn’t—if you are using",
    "• yield is actually an expression instead of a statement too, as of 2.5; like print, it’s\ntypically used in a line by itself and so is included in this table, but scripts occasionally assign or otherwise use its result, as we’ll see in Chapter 20. As an expression, yield is also a reserved word, unlike print.\nMost of this table applies to Python 2.6, too, except where it doesn’t—if you are using\nPython 2.6 or older, here are a few notes for your Python, too:\n• In 2.6, nonlocal is not available; as we’ll see in Chapter 17, there are alternative\nways to achieve this statement’s writeable state-retention effect.\n• In 2.6, print is a statement instead of a built-in function call, with specific syntax\ncovered in Chapter 11.\n• In 2.6, the 3.0 exec code execution built-in function is a statement, with specific\nsyntax; since it supports enclosing parentheses, though, you can generally use its\n3.0 call form in 2.6 code.",
    "ways to achieve this statement’s writeable state-retention effect.\n• In 2.6, print is a statement instead of a built-in function call, with specific syntax\ncovered in Chapter 11.\n• In 2.6, the 3.0 exec code execution built-in function is a statement, with specific\nsyntax; since it supports enclosing parentheses, though, you can generally use its\n3.0 call form in 2.6 code.\n• In 2.5, the try/except and try/finally statements were merged: the two were formerly separate statements, but we can now say both except and finally in the same\ntry statement.\n• In 2.5, with/as is an optional extension, and it is not available unless you explicitly\nturn it on by running the statement from __future__ import with_statement (see\nChapter 33).",
    "Python Program Structure Revisited | 263\n\n\fA Tale of Two ifs\nBefore we delve into the details of any of the concrete statements in Table 10-1, I want\nto begin our look at Python statement syntax by showing you what you are not going\nto type in Python code so you can compare and contrast it with other syntax models\nyou might have seen in the past.\nConsider the following if statement, coded in a C-like language:\nif (x > y) {\nx = 1;\ny = 2;\n}\n\nThis might be a statement in C, C++, Java, JavaScript, or Perl. Now, look at the equivalent statement in the Python language:\nif x > y:\nx = 1\ny = 2",
    "This might be a statement in C, C++, Java, JavaScript, or Perl. Now, look at the equivalent statement in the Python language:\nif x > y:\nx = 1\ny = 2\n\nThe first thing that may pop out at you is that the equivalent Python statement is less,\nwell, cluttered—that is, there are fewer syntactic components. This is by design; as a\nscripting language, one of Python’s goals is to make programmers’ lives easier by requiring less typing.\nMore specifically, when you compare the two syntax models, you’ll notice that Python\nadds one new thing to the mix, and that three items that are present in the C-like\nlanguage are not present in Python code.",
    "What Python Adds\nThe one new syntax component in Python is the colon character (:). All Python compound statements (i.e., statements that have statements nested inside them) follow the\nsame general pattern of a header line terminated in a colon, followed by a nested block\nof code usually indented underneath the header line, like this:\nHeader line:\nNested statement block\n\nThe colon is required, and omitting it is probably the most common coding mistake\namong new Python programmers—it’s certainly one I’ve witnessed thousands of times\nin Python training classes. In fact, if you are new to Python, you’ll almost certainly\nforget the colon character very soon. Most Python-friendly editors make this mistake\neasy to spot, and including it eventually becomes an unconscious habit (so much so\nthat you may start typing colons in your C++ code, too, generating many entertaining\nerror messages from your C++ compiler!).\n\n264 | Chapter 10: Introducing Python Statements",
    "264 | Chapter 10: Introducing Python Statements\n\n\fWhat Python Removes\nAlthough Python requires the extra colon character, there are three things programmers\nin C-like languages must include that you don’t generally have to in Python.\n\nParentheses are optional\nThe first of these is the set of parentheses around the tests at the top of the statement:\nif (x < y)\n\nThe parentheses here are required by the syntax of many C-like languages. In Python,\nthough, they are not—we simply omit the parentheses, and the statement works the\nsame way:\nif x < y\n\nTechnically speaking, because every expression can be enclosed in parentheses, including them will not hurt in this Python code, and they are not treated as an error if\npresent. But don’t do that: you’ll be wearing out your keyboard needlessly, and broadcasting to the world that you’re an ex-C programmer still learning Python (I was once,\ntoo). The Python way is to simply omit the parentheses in these kinds of statements\naltogether.",
    "End of line is end of statement\nThe second and more significant syntax component you won’t find in Python code is\nthe semicolon. You don’t need to terminate statements with semicolons in Python the\nway you do in C-like languages:\nx = 1;\n\nIn Python, the general rule is that the end of a line automatically terminates the statement that appears on that line. In other words, you can leave off the semicolons, and\nit works the same way:\nx = 1",
    "In Python, the general rule is that the end of a line automatically terminates the statement that appears on that line. In other words, you can leave off the semicolons, and\nit works the same way:\nx = 1\n\nThere are some ways to work around this rule, as you’ll see in a moment. But, in general,\nyou write one statement per line for the vast majority of Python code, and no semicolon\nis required.\nHere, too, if you are pining for your C programming days (if such a state is possible...)\nyou can continue to use semicolons at the end of each statement—the language lets\nyou get away with them if they are present. But don’t do that either (really!); again, doing\nso tells the world that you’re still a C programmer who hasn’t quite made the switch\nto Python coding. The Pythonic style is to leave off the semicolons altogether.\n\nA Tale of Two ifs | 265",
    "A Tale of Two ifs | 265\n\n\fEnd of indentation is end of block\nThe third and final syntax component that Python removes, and the one that may seem\nthe most unusual to soon-to-be-ex-C programmers (until they’ve used it for 10 minutes\nand realize it’s actually a feature), is that you do not type anything explicit in your code\nto syntactically mark the beginning and end of a nested block of code. You don’t need\nto include begin/end, then/endif, or braces around the nested block, as you do in Clike languages:\nif (x > y) {\nx = 1;\ny = 2;\n}\n\nInstead, in Python, we consistently indent all the statements in a given single nested\nblock the same distance to the right, and Python uses the statements’ physical indentation to determine where the block starts and stops:\nif x > y:\nx = 1\ny = 2",
    "Instead, in Python, we consistently indent all the statements in a given single nested\nblock the same distance to the right, and Python uses the statements’ physical indentation to determine where the block starts and stops:\nif x > y:\nx = 1\ny = 2\n\nBy indentation, I mean the blank whitespace all the way to the left of the two nested\nstatements here. Python doesn’t care how you indent (you may use either spaces or\ntabs), or how much you indent (you may use any number of spaces or tabs). In fact,\nthe indentation of one nested block can be totally different from that of another. The\nsyntax rule is only that for a given single nested block, all of its statements must be\nindented the same distance to the right. If this is not the case, you will get a syntax\nerror, and your code will not run until you repair its indentation to be consistent.",
    "Why Indentation Syntax?\nThe indentation rule may seem unusual at first glance to programmers accustomed to\nC-like languages, but it is a deliberate feature of Python, and it’s one of the main ways\nthat Python almost forces programmers to produce uniform, regular, and readable\ncode. It essentially means that you must line up your code vertically, in columns, according to its logical structure. The net effect is to make your code more consistent and\nreadable (unlike much of the code written in C-like languages).\nTo put that more strongly, aligning your code according to its logical structure is a\nmajor part of making it readable, and thus reusable and maintainable, by yourself and\nothers. In fact, even if you never use Python after reading this book, you should get into\nthe habit of aligning your code for readability in any block-structured language. Python\nforces the issue by making this a part of its syntax, but it’s an important thing to do in",
    "major part of making it readable, and thus reusable and maintainable, by yourself and\nothers. In fact, even if you never use Python after reading this book, you should get into\nthe habit of aligning your code for readability in any block-structured language. Python\nforces the issue by making this a part of its syntax, but it’s an important thing to do in\nany programming language, and it has a huge impact on the usefulness of your code.\nYour experience may vary, but when I was still doing development on a full-time basis,\nI was mostly paid to work on large old C++ programs that had been worked on by\nmany programmers over the years. Almost invariably, each programmer had his or her\n266 | Chapter 10: Introducing Python Statements",
    "own style for indenting code. For example, I’d often be asked to change a while loop\ncoded in the C++ language that began like this:\nwhile (x > 0) {\n\nBefore we even get into indentation, there are three or four ways that programmers can\narrange these braces in a C-like language, and organizations often have political debates\nand write standards manuals to address the options (which seems more than a little\noff-topic for the problem to be solved by programming). Ignoring that, here’s the scenario I often encountered in C++ code. The first person who worked on the code\nindented the loop four spaces:\nwhile (x > 0) {\n--------;\n--------;\n\nThat person eventually moved on to management, only to be replaced by someone who\nliked to indent further to the right:\nwhile (x > 0) {\n--------;\n--------;\n--------;\n--------;",
    "That person eventually moved on to management, only to be replaced by someone who\nliked to indent further to the right:\nwhile (x > 0) {\n--------;\n--------;\n--------;\n--------;\n\nThat person later moved on to other opportunities, and someone else picked up the\ncode who liked to indent less:\nwhile (x > 0) {\n--------;\n--------;\n--------;\n--------;\n--------;\n--------;\n}",
    "That person later moved on to other opportunities, and someone else picked up the\ncode who liked to indent less:\nwhile (x > 0) {\n--------;\n--------;\n--------;\n--------;\n--------;\n--------;\n}\n\nAnd so on. Eventually, the block is terminated by a closing brace (}), which of course\nmakes this “block-structured code” (he says, sarcastically). In any block-structured\nlanguage, Python or otherwise, if nested blocks are not indented consistently, they\nbecome very difficult for the reader to interpret, change, or reuse, because the code no\nlonger visually reflects its logical meaning. Readability matters, and indentation is a\nmajor component of readability.\nHere is another example that may have burned you in the past if you’ve done much\nprogramming in a C-like language. Consider the following statement in C:\nif (x)\nif (y)\nstatement1;\nelse\nstatement2;\n\nA Tale of Two ifs | 267",
    "A Tale of Two ifs | 267\n\n\fWhich if does the else here go with? Surprisingly, the else is paired with the nested\nif statement (if (y)), even though it looks visually as though it is associated with the\nouter if (x). This is a classic pitfall in the C language, and it can lead to the reader\ncompletely misinterpreting the code and changing it incorrectly in ways that might not\nbe uncovered until the Mars rover crashes into a giant rock!\nThis cannot happen in Python—because indentation is significant, the way the code\nlooks is the way it will work. Consider an equivalent Python statement:\nif x:\n\nif y:\n\nstatement1\n\nelse:\n\nstatement2",
    "In this example, the if that the else lines up with vertically is the one it is associated\nwith logically (the outer if x). In a sense, Python is a WYSIWYG language—what you\nsee is what you get because the way code looks is the way it runs, regardless of who\ncoded it.\nIf this still isn’t enough to underscore the benefits of Python’s syntax, here’s another\nanecdote. Early in my career, I worked at a successful company that developed systems\nsoftware in the C language, where consistent indentation is not required. Even so, when\nwe checked our code into source control at the end of the day, this company ran an\nautomated script that analyzed the indentation used in the code. If the script noticed\nthat we’d indented our code inconsistently, we received an automated email about it\nthe next morning—and so did our managers!\nThe point is that even when a language doesn’t require it, good programmers know\nthat consistent use of indentation has a huge impact on code readability and quality.",
    "automated script that analyzed the indentation used in the code. If the script noticed\nthat we’d indented our code inconsistently, we received an automated email about it\nthe next morning—and so did our managers!\nThe point is that even when a language doesn’t require it, good programmers know\nthat consistent use of indentation has a huge impact on code readability and quality.\nThe fact that Python promotes this to the level of syntax is seen by most as a feature of\nthe language.\nAlso keep in mind that nearly every programmer-friendly text editor has built-in support for Python’s syntax model. In the IDLE Python GUI, for example, lines of code\nare automatically indented when you are typing a nested block; pressing the Backspace\nkey backs up one level of indentation, and you can customize how far to the right IDLE\nindents statements in a nested block. There is no universal standard on this: four spaces\nor one tab per level is common, but it’s up to you to decide how and how much you",
    "are automatically indented when you are typing a nested block; pressing the Backspace\nkey backs up one level of indentation, and you can customize how far to the right IDLE\nindents statements in a nested block. There is no universal standard on this: four spaces\nor one tab per level is common, but it’s up to you to decide how and how much you\nwish to indent. Indent further to the right for further nested blocks, and less to close\nthe prior block.\nAs a rule of thumb, you probably shouldn’t mix tabs and spaces in the same block in\nPython, unless you do so consistently; use tabs or spaces in a given block, but not both\n(in fact, Python 3.0 now issues an error for inconsistent use of tabs and spaces, as we’ll\nsee in Chapter 12). But you probably shouldn’t mix tabs or spaces in indentation in\nany structured language—such code can cause major readability issues if the next programmer has his or her editor set to display tabs differently than yours. C-like languages",
    "268 | Chapter 10: Introducing Python Statements\n\n\fmight let coders get away with this, but they shouldn’t: the result can be a mangled\nmess.\nI can’t stress enough that regardless of which language you code in, you should be\nindenting consistently for readability. In fact, if you weren’t taught to do this earlier in\nyour career, your teachers did you a disservice. Most programmers—especially those\nwho must read others’ code—consider it a major asset that Python elevates this to the\nlevel of syntax. Moreover, generating tabs instead of braces is no more difficult in practice for tools that must output Python code. In general, if you do what you should be\ndoing in a C-like language anyhow, but get rid of the braces, your code will satisfy\nPython’s syntax rules.",
    "A Few Special Cases\nAs mentioned previously, in Python’s syntax model:\n• The end of a line terminates the statement on that line (without semicolons).\n• Nested statements are blocked and associated by their physical indentation (without braces).\nThose rules cover almost all Python code you’ll write or see in practice. However,\nPython also provides some special-purpose rules that allow customization of both\nstatements and nested statement blocks.\n\nStatement rule special cases\nAlthough statements normally appear one per line, it is possible to squeeze more than\none statement onto a single line in Python by separating them with semicolons:\na = 1; b = 2; print(a + b)\n\n# Three statements on one line",
    "This is the only place in Python where semicolons are required: as statement separators. This only works, though, if the statements thus combined are not themselves\ncompound statements. In other words, you can chain together only simple statements,\nlike assignments, prints, and function calls. Compound statements must still appear\non lines of their own (otherwise, you could squeeze an entire program onto one line,\nwhich probably would not make you very popular among your coworkers!).\nThe other special rule for statements is essentially the inverse: you can make a single\nstatement span across multiple lines. To make this work, you simply have to enclose\npart of your statement in a bracketed pair—parentheses (()), square brackets ([]), or\ncurly braces ({}). Any code enclosed in these constructs can cross multiple lines: your\nstatement doesn’t end until Python reaches the line containing the closing part of the\npair. For instance, to continue a list literal:\nmlist = [111,\n222,\n333]",
    "A Tale of Two ifs | 269\n\n\fBecause the code is enclosed in a square brackets pair, Python simply drops down to\nthe next line until it encounters the closing bracket. The curly braces surrounding dictionaries (as well as set literals and dictionary and set comprehensions in 3.0) allow\nthem to span lines this way too, and parentheses handle tuples, function calls, and\nexpressions. The indentation of the continuation lines does not matter, though common sense dictates that the lines should be aligned somehow for readability.\nParentheses are the catchall device—because any expression can be wrapped up in\nthem, simply inserting a left parenthesis allows you to drop down to the next line and\ncontinue your statement:\nX = (A + B +\nC + D)\n\nThis technique works with compound statements, too, by the way. Anywhere you need\nto code a large expression, simply wrap it in parentheses to continue it on the next line:\nif (A == 1 and\nB == 2 and\nC == 3):\nprint('spam' * 3)",
    "This technique works with compound statements, too, by the way. Anywhere you need\nto code a large expression, simply wrap it in parentheses to continue it on the next line:\nif (A == 1 and\nB == 2 and\nC == 3):\nprint('spam' * 3)\n\nAn older rule also allows for continuation lines when the prior line ends in a backslash:\nX = A + B + \\\nC + D\n\n# An error-prone alternative\n\nThis alternative technique is dated, though, and is frowned on today because it’s difficult to notice and maintain the backslashes, and it’s fairly brittle—there can be no\nspaces after the backslash, and omitting it can have unexpected effects if the next line\nis mistaken to be a new statement. It’s also another throwback to the C language, where\nit is commonly used in “#define” macros; again, when in Pythonland, do as Pythonistas\ndo, not as C programmers do.",
    "Block rule special case\nAs mentioned previously, statements in a nested block of code are normally associated\nby being indented the same amount to the right. As one special case here, the body of\na compound statement can instead appear on the same line as the header in Python,\nafter the colon:\nif x > y: print(x)\n\nThis allows us to code single-line if statements, single-line loops, and so on. Here again,\nthough, this will work only if the body of the compound statement itself does not\ncontain any compound statements. That is, only simple statements—assignments,\nprints, function calls, and the like—are allowed after the colon. Larger statements must\nstill appear on lines by themselves. Extra parts of compound statements (such as the\nelse part of an if, which we’ll meet later) must also be on separate lines of their own.\nThe body can consist of multiple simple statements separated by semicolons, but this\ntends to be frowned upon.\n270 | Chapter 10: Introducing Python Statements",
    "In general, even though it’s not always required, if you keep all your statements on\nindividual lines and always indent your nested blocks, your code will be easier to read\nand change in the future. Moreover, some code profiling and coverage tools may not\nbe able to distinguish between multiple statements squeezed onto a single line or the\nheader and body of a one-line compound statement. It is almost always to your advantage to keep things simple in Python.\nTo see a prime and common exception to one of these rules in action, however (the use\nof a single-line if statement to break out of a loop), let’s move on to the next section\nand write some real code.",
    "A Quick Example: Interactive Loops\nWe’ll see all these syntax rules in action when we tour Python’s specific compound\nstatements in the next few chapters, but they work the same everywhere in the Python\nlanguage. To get started, let’s work through a brief, realistic example that demonstrates\nthe way that statement syntax and statement nesting come together in practice, and\nintroduces a few statements along the way.",
    "A Simple Interactive Loop\nSuppose you’re asked to write a Python program that interacts with a user in a console\nwindow. Maybe you’re accepting inputs to send to a database, or reading numbers to\nbe used in a calculation. Regardless of the purpose, you need to code a loop that reads\none or more inputs from a user typing on a keyboard, and prints back a result for each.\nIn other words, you need to write a classic read/evaluate/print loop program.\nIn Python, typical boilerplate code for such an interactive loop might look like this:\nwhile True:\nreply = input('Enter text:')\nif reply == 'stop': break\nprint(reply.upper())",
    "This code makes use of a few new ideas:\n• The code leverages the Python while loop, Python’s most general looping statement. We’ll study the while statement in more detail later, but in short, it consists\nof the word while, followed by an expression that is interpreted as a true or false\nresult, followed by a nested block of code that is repeated while the test at the top\nis true (the word True here is considered always true).\n• The input built-in function we met earlier in the book is used here for general\nconsole input—it prints its optional argument string as a prompt and returns the\nuser’s typed reply as a string.\n• A single-line if statement that makes use of the special rule for nested blocks also\nappears here: the body of the if appears on the header line after the colon instead\n\nA Quick Example: Interactive Loops | 271",
    "of being indented on a new line underneath it. This would work either way, but as\nit’s coded, we’ve saved an extra line.\n• Finally, the Python break statement is used to exit the loop immediately—it simply\njumps out of the loop statement altogether, and the program continues after the\nloop. Without this exit statement, the while would loop forever, as its test is always\ntrue.\nIn effect, this combination of statements essentially means “read a line from the user\nand print it in uppercase until the user enters the word ‘stop.’” There are other ways\nto code such a loop, but the form used here is very common in Python code.\nNotice that all three lines nested under the while header line are indented the same\namount—because they line up vertically in a column this way, they are the block of\ncode that is associated with the while test and repeated. Either the end of the source\nfile or a lesser-indented statement will terminate the loop body block.",
    "Notice that all three lines nested under the while header line are indented the same\namount—because they line up vertically in a column this way, they are the block of\ncode that is associated with the while test and repeated. Either the end of the source\nfile or a lesser-indented statement will terminate the loop body block.\nWhen run, here is the sort of interaction we get from this code:\nEnter text:spam\nSPAM\nEnter text:42\n42\nEnter text:stop",
    "Version skew note: This example is coded for Python 3.0. If you are\nworking in Python 2.6 or earlier, the code works the same, but you\nshould use raw_input instead of input, and you can omit the outer parentheses in print statements. In 3.0 the former was renamed, and the\nlatter is a built-in function instead of a statement (more on prints in the\nnext chapter).\n\nDoing Math on User Inputs\nOur script works, but now suppose that instead of converting a text string to uppercase,\nwe want to do some math with numeric input—squaring it, for example, perhaps in\nsome misguided effort to discourage users who happen to be obsessed with youth. We\nmight try statements like these to achieve the desired effect:\n>>> reply = '20'\n>>> reply ** 2\n...error text omitted...\nTypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'",
    "This won’t quite work in our script, though, because (as discussed in the prior part of\nthe book) Python won’t convert object types in expressions unless they are all numeric,\nand input from a user is always returned to our script as a string. We cannot raise a\nstring of digits to a power unless we convert it manually to an integer:\n\n272 | Chapter 10: Introducing Python Statements\n\n\f>>> int(reply) ** 2\n400\n\nArmed with this information, we can now recode our loop to perform the necessary\nmath. Type the following in a file to test it:\nwhile True:\nreply = input('Enter text:')\nif reply == 'stop': break\nprint(int(reply) ** 2)\nprint('Bye')",
    "272 | Chapter 10: Introducing Python Statements\n\n\f>>> int(reply) ** 2\n400\n\nArmed with this information, we can now recode our loop to perform the necessary\nmath. Type the following in a file to test it:\nwhile True:\nreply = input('Enter text:')\nif reply == 'stop': break\nprint(int(reply) ** 2)\nprint('Bye')\n\nThis script uses a single-line if statement to exit on “stop” as before, but it also converts\ninputs to perform the required math. This version also adds an exit message at the\nbottom. Because the print statement in the last line is not indented as much as the\nnested block of code, it is not considered part of the loop body and will run only once,\nafter the loop is exited:\nEnter text:2\n4\nEnter text:40\n1600\nEnter text:stop\nBye",
    "One note here: I’m assuming that this code is stored in and run from a script file. If you\nare entering this code interactively, be sure to include a blank line (i.e., press Enter\ntwice) before the final print statement, to terminate the loop. The final print doesn’t\nquite make sense in interactive mode, though (you’ll have to code it after interacting\nwith the loop!).\n\nHandling Errors by Testing Inputs\nSo far so good, but notice what happens when the input is invalid:\nEnter text:xxx\n...error text omitted...\nValueError: invalid literal for int() with base 10: 'xxx'\n\nThe built-in int function raises an exception here in the face of a mistake. If we want\nour script to be robust, we can check the string’s content ahead of time with the string\nobject’s isdigit method:\n>>> S = '123'\n>>> T = 'xxx'\n>>> S.isdigit(), T.isdigit()\n(True, False)",
    "The built-in int function raises an exception here in the face of a mistake. If we want\nour script to be robust, we can check the string’s content ahead of time with the string\nobject’s isdigit method:\n>>> S = '123'\n>>> T = 'xxx'\n>>> S.isdigit(), T.isdigit()\n(True, False)\n\nThis also gives us an excuse to further nest the statements in our example. The following\nnew version of our interactive script uses a full-blown if statement to work around the\nexception on errors:\nwhile True:\nreply = input('Enter text:')\n\nA Quick Example: Interactive Loops | 273\n\n\fif reply == 'stop':\nbreak\nelif not reply.isdigit():\nprint('Bad!' * 8)\nelse:\nprint(int(reply) ** 2)\nprint('Bye')",
    "We’ll study the if statement in more detail in Chapter 12, but it’s a fairly lightweight\ntool for coding logic in scripts. In its full form, it consists of the word if followed by a\ntest and an associated block of code, one or more optional elif (“else if”) tests and\ncode blocks, and an optional else part, with an associated block of code at the bottom\nto serve as a default. Python runs the block of code associated with the first test that is\ntrue, working from top to bottom, or the else part if all tests are false.\nThe if, elif, and else parts in the preceding example are associated as part of the same\nstatement because they all line up vertically (i.e., share the same level of indentation).\nThe if statement spans from the word if to the start of the print statement on the last\nline of the script. In turn, the entire if block is part of the while loop because all of it\nis indented under the loop’s header line. Statement nesting is natural once you get the\nhang of it.",
    "statement because they all line up vertically (i.e., share the same level of indentation).\nThe if statement spans from the word if to the start of the print statement on the last\nline of the script. In turn, the entire if block is part of the while loop because all of it\nis indented under the loop’s header line. Statement nesting is natural once you get the\nhang of it.\nWhen we run our new script, its code catches errors before they occur and prints an\n(arguably silly) error message to demonstrate:\nEnter text:5\n25\nEnter text:xyz\nBad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!\nEnter text:10\n100\nEnter text:stop",
    "Handling Errors with try Statements\nThe preceding solution works, but as you’ll see later in the book, the most general way\nto handle errors in Python is to catch and recover from them completely using the\nPython try statement. We’ll explore this statement in depth in Part VII of this book,\nbut as a preview, using a try here can lead to code that some would claim is simpler\nthan the prior version:\nwhile True:\nreply = input('Enter text:')\nif reply == 'stop': break\ntry:\nnum = int(reply)\nexcept:\nprint('Bad!' * 8)\nelse:\nprint(int(reply) ** 2)\nprint('Bye')\n\n274 | Chapter 10: Introducing Python Statements",
    "This version works exactly like the previous one, but we’ve replaced the explicit error\ncheck with code that assumes the conversion will work and wraps it up in an exception\nhandler for cases when it doesn’t. This try statement is composed of the word try,\nfollowed by the main block of code (the action we are trying to run), followed by an\nexcept part that gives the exception handler code and an else part to be run if no\nexception is raised in the try part. Python first runs the try part, then runs either the\nexcept part (if an exception occurs) or the else part (if no exception occurs).\nIn terms of statement nesting, because the words try, except, and else are all indented\nto the same level, they are all considered part of the same single try statement. Notice\nthat the else part is associated with the try here, not the if. As we’ve seen, else can\nappear in if statements in Python, but it can also appear in try statements and loops—",
    "In terms of statement nesting, because the words try, except, and else are all indented\nto the same level, they are all considered part of the same single try statement. Notice\nthat the else part is associated with the try here, not the if. As we’ve seen, else can\nappear in if statements in Python, but it can also appear in try statements and loops—\nits indentation tells you what statement it is a part of. In this case, the try statement\nspans from the word try through the code indented under the word else, because the\nelse is indented to the same level as try. The if statement in this code is a one-liner\nand ends after the break.\nAgain, we’ll come back to the try statement later in this book. For now, be aware that\nbecause try can be used to intercept any error, it reduces the amount of error-checking\ncode you have to write, and it’s a very general approach to dealing with unusual cases.\nIf we wanted to support input of floating-point numbers instead of just integers, for",
    "and ends after the break.\nAgain, we’ll come back to the try statement later in this book. For now, be aware that\nbecause try can be used to intercept any error, it reduces the amount of error-checking\ncode you have to write, and it’s a very general approach to dealing with unusual cases.\nIf we wanted to support input of floating-point numbers instead of just integers, for\nexample, using try would be much easier than manual error testing—we could simply\nrun a float call and catch its exceptions, instead of trying to analyze all possible floatingpoint syntax.",
    "Nesting Code Three Levels Deep\nLet’s look at one last mutation of our script. Nesting can take us even further if we need\nit to—we could, for example, branch to one of a set of alternatives based on the relative\nmagnitude of a valid input:\nwhile True:\nreply = input('Enter text:')\nif reply == 'stop':\nbreak\nelif not reply.isdigit():\nprint('Bad!' * 8)\nelse:\nnum = int(reply)\nif num < 20:\nprint('low')\nelse:\nprint(num ** 2)\nprint('Bye')\n\nA Quick Example: Interactive Loops | 275\n\n\fThis version includes an if statement nested in the else clause of another if statement,\nwhich is in turn nested in the while loop. When code is conditional, or repeated like\nthis, we simply indent it further to the right. The net effect is like that of the prior\nversions, but we’ll now print “low” for numbers less than 20:\nEnter text:19\nlow\nEnter text:20\n400\nEnter text:spam\nBad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!\nEnter text:stop\nBye",
    "Chapter Summary\nThat concludes our quick look at Python statement syntax. This chapter introduced\nthe general rules for coding statements and blocks of code. As you’ve learned, in Python\nwe normally code one statement per line and indent all the statements in a nested block\nthe same amount (indentation is part of Python’s syntax). However, we also looked at\na few exceptions to these rules, including continuation lines and single-line tests and\nloops. Finally, we put these ideas to work in an interactive script that demonstrated a\nhandful of statements and showed statement syntax in action.\nIn the next chapter, we’ll start to dig deeper by going over each of Python’s basic procedural statements in depth. As you’ll see, though, all statements follow the same general rules introduced here.",
    "Test Your Knowledge: Quiz\n1. What three things are required in a C-like language but omitted in Python?\n2. How is a statement normally terminated in Python?\n3. How are the statements in a nested block of code normally associated in Python?\n4. How can you make a single statement span multiple lines?\n5. How can you code a compound statement on a single line?\n6. Is there any valid reason to type a semicolon at the end of a statement in Python?\n7. What is a try statement for?\n8. What is the most common coding mistake among Python beginners?\n\n276 | Chapter 10: Introducing Python Statements",
    "Test Your Knowledge: Answers\n1. C-like languages require parentheses around the tests in some statements, semicolons at the end of each statement, and braces around a nested block of code.\n2. The end of a line terminates the statement that appears on that line. Alternatively,\nif more than one statement appears on the same line, they can be terminated with\nsemicolons; similarly, if a statement spans many lines, you must terminate it by\nclosing a bracketed syntactic pair.\n3. The statements in a nested block are all indented the same number of tabs or spaces.\n4. A statement can be made to span many lines by enclosing part of it in parentheses,\nsquare brackets, or curly braces; the statement ends when Python sees a line that\ncontains the closing part of the pair.\n5. The body of a compound statement can be moved to the header line after the colon,\nbut only if the body consists of only noncompound statements.",
    "4. A statement can be made to span many lines by enclosing part of it in parentheses,\nsquare brackets, or curly braces; the statement ends when Python sees a line that\ncontains the closing part of the pair.\n5. The body of a compound statement can be moved to the header line after the colon,\nbut only if the body consists of only noncompound statements.\n6. Only when you need to squeeze more than one statement onto a single line of code.\nEven then, this only works if all the statements are noncompound, and it’s discouraged because it can lead to code that is difficult to read.\n7. The try statement is used to catch and recover from exceptions (errors) in a Python\nscript. It’s usually an alternative to manually checking for errors in your code.\n8. Forgetting to type the colon character at the end of the header line in a compound\nstatement is the most common beginner’s mistake. If you haven’t made it yet, you\nprobably will soon!",
    "Test Your Knowledge: Answers | 277\n\n\f\fCHAPTER 11\n\nAssignments, Expressions, and Prints\n\nNow that we’ve had a quick introduction to Python statement syntax, this chapter\nbegins our in-depth tour of specific Python statements. We’ll begin with the basics:\nassignment statements, expression statements, and print operations. We’ve already\nseen all of these in action, but here we’ll fill in important details we’ve skipped so far.\nAlthough they’re fairly simple, as you’ll see, there are optional variations for each of\nthese statement types that will come in handy once you begin writing real Python\nprograms.",
    "Assignment Statements\nWe’ve been using the Python assignment statement for a while to assign objects to\nnames. In its basic form, you write the target of an assignment on the left of an equals\nsign, and the object to be assigned on the right. The target on the left may be a name\nor object component, and the object on the right can be an arbitrary expression that\ncomputes an object. For the most part, assignments are straightforward, but here are\na few properties to keep in mind:\n• Assignments create object references. As discussed in Chapter 6, Python assignments store references to objects in names or data structure components. They\nalways create references to objects instead of copying the objects. Because of that,\nPython variables are more like pointers than data storage areas.\n• Names are created when first assigned. Python creates a variable name the first\ntime you assign it a value (i.e., an object reference), so there’s no need to predeclare",
    "always create references to objects instead of copying the objects. Because of that,\nPython variables are more like pointers than data storage areas.\n• Names are created when first assigned. Python creates a variable name the first\ntime you assign it a value (i.e., an object reference), so there’s no need to predeclare\nnames ahead of time. Some (but not all) data structure slots are created when\nassigned, too (e.g., dictionary entries, some object attributes). Once assigned, a\nname is replaced with the value it references whenever it appears in an expression.\n• Names must be assigned before being referenced. It’s an error to use a name\nto which you haven’t yet assigned a value. Python raises an exception if you try,\nrather than returning some sort of ambiguous default value; if it returned a default\ninstead, it would be more difficult for you to spot typos in your code.",
    "279\n\n\f• Some operations perform assignments implicitly. In this section we’re concerned with the = statement, but assignment occurs in many contexts in Python.\nFor instance, we’ll see later that module imports, function and class definitions,\nfor loop variables, and function arguments are all implicit assignments. Because\nassignment works the same everywhere it pops up, all these contexts simply bind\nnames to object references at runtime.\n\nAssignment Statement Forms\nAlthough assignment is a general and pervasive concept in Python, we are primarily\ninterested in assignment statements in this chapter. Table 11-1 illustrates the different\nassignment statement forms in Python.\nTable 11-1. Assignment statement forms\nOperation\n\nInterpretation\n\nspam = 'Spam'\n\nBasic form\n\nspam, ham = 'yum', 'YUM'\n\nTuple assignment (positional)\n\n[spam, ham] = ['yum', 'YUM']\n\nList assignment (positional)\n\na, b, c, d = 'spam'\n\nSequence assignment, generalized\n\na, *b = 'spam'",
    "Interpretation\n\nspam = 'Spam'\n\nBasic form\n\nspam, ham = 'yum', 'YUM'\n\nTuple assignment (positional)\n\n[spam, ham] = ['yum', 'YUM']\n\nList assignment (positional)\n\na, b, c, d = 'spam'\n\nSequence assignment, generalized\n\na, *b = 'spam'\n\nExtended sequence unpacking (Python 3.0)\n\nspam = ham = 'lunch'\n\nMultiple-target assignment\n\nspams += 42\n\nAugmented assignment (equivalent to spams = spams + 42)",
    "The first form in Table 11-1 is by far the most common: binding a name (or data structure component) to a single object. In fact, you could get all your work done with this\nbasic form alone. The other table entries represent special forms that are all optional,\nbut that programmers often find convenient in practice:\nTuple- and list-unpacking assignments\nThe second and third forms in the table are related. When you code a tuple or list\non the left side of the =, Python pairs objects on the right side with targets on the\nleft by position and assigns them from left to right. For example, in the second line\nof Table 11-1, the name spam is assigned the string 'yum', and the name ham is bound\nto the string 'YUM'. In this case Python internally makes a tuple of the items on the\nright, which is why this is called tuple-unpacking assignment.\nSequence assignments\nIn recent versions of Python, tuple and list assignments have been generalized into",
    "of Table 11-1, the name spam is assigned the string 'yum', and the name ham is bound\nto the string 'YUM'. In this case Python internally makes a tuple of the items on the\nright, which is why this is called tuple-unpacking assignment.\nSequence assignments\nIn recent versions of Python, tuple and list assignments have been generalized into\ninstances of what we now call sequence assignment—any sequence of names can\nbe assigned to any sequence of values, and Python assigns the items one at a time\nby position. We can even mix and match the types of the sequences involved. The\nfourth line in Table 11-1, for example, pairs a tuple of names with a string of\ncharacters: a is assigned 's', b is assigned 'p', and so on.\n280 | Chapter 11: Assignments, Expressions, and Prints",
    "Extended sequence unpacking\nIn Python 3.0, a new form of sequence assignment allows us to be more flexible in\nhow we select portions of a sequence to assign. The fifth line in Table 11-1, for\nexample, matches a with the first character in the string on the right and b with the\nrest: a is assigned 's', and b is assigned 'pam'. This provides a simpler alternative\nto assigning the results of manual slicing operations.\nMultiple-target assignments\nThe sixth line in Table 11-1 shows the multiple-target form of assignment. In this\nform, Python assigns a reference to the same object (the object farthest to the right)\nto all the targets on the left. In the table, the names spam and ham are both assigned\nreferences to the same string object, 'lunch'. The effect is the same as if we had\ncoded ham = 'lunch' followed by spam = ham, as ham evaluates to the original string\nobject (i.e., not a separate copy of that object).\nAugmented assignments",
    "to all the targets on the left. In the table, the names spam and ham are both assigned\nreferences to the same string object, 'lunch'. The effect is the same as if we had\ncoded ham = 'lunch' followed by spam = ham, as ham evaluates to the original string\nobject (i.e., not a separate copy of that object).\nAugmented assignments\nThe last line in Table 11-1 is an example of augmented assignment—a shorthand\nthat combines an expression and an assignment in a concise way. Saying spam +=\n42, for example, has the same effect as spam = spam + 42, but the augmented form\nrequires less typing and is generally quicker to run. In addition, if the subject is\nmutable and supports the operation, an augmented assignment may run even\nquicker by choosing an in-place update operation instead of an object copy. There\nis one augmented assignment statement for every binary expression operator in\nPython.",
    "Sequence Assignments\nWe’ve already used basic assignments in this book. Here are a few simple examples of\nsequence-unpacking assignments in action:\n% python\n>>> nudge = 1\n>>> wink = 2\n>>> A, B = nudge, wink\n>>> A, B\n(1, 2)\n>>> [C, D] = [nudge, wink]\n>>> C, D\n(1, 2)\n\n# Tuple assignment\n# Like A = nudge; B = wink\n# List assignment\n\nNotice that we really are coding two tuples in the third line in this interaction—we’ve\njust omitted their enclosing parentheses. Python pairs the values in the tuple on the\nright side of the assignment operator with the variables in the tuple on the left side and\nassigns the values one at a time.\nTuple assignment leads to a common coding trick in Python that was introduced in a\nsolution to the exercises at the end of Part II. Because Python creates a temporary tuple\nthat saves the original values of the variables on the right while the statement runs,\n\nAssignment Statements | 281",
    "Assignment Statements | 281\n\n\funpacking assignments are also a way to swap two variables’ values without creating\na temporary variable of your own—the tuple on the right remembers the prior values\nof the variables automatically:\n>>> nudge = 1\n>>> wink = 2\n>>> nudge, wink = wink, nudge\n>>> nudge, wink\n(2, 1)\n\n# Tuples: swaps values\n# Like T = nudge; nudge = wink; wink = T\n\nIn fact, the original tuple and list assignment forms in Python have been generalized to\naccept any type of sequence on the right as long as it is of the same length as the sequence\non the left. You can assign a tuple of values to a list of variables, a string of characters\nto a tuple of variables, and so on. In all cases, Python assigns items in the sequence on\nthe right to variables in the sequence on the left by position, from left to right:\n>>> [a, b, c] = (1, 2, 3)\n>>> a, c\n(1, 3)\n>>> (a, b, c) = \"ABC\"\n>>> a, c\n('A', 'C')\n\n# Assign tuple of values to list of names\n# Assign string of characters to tuple",
    "# Assign tuple of values to list of names\n# Assign string of characters to tuple\n\nTechnically speaking, sequence assignment actually supports any iterable object on the\nright, not just any sequence. This is a more general concept that we will explore in\nChapters 14 and 20.\n\nAdvanced sequence assignment patterns\nAlthough we can mix and match sequence types around the = symbol, we must have\nthe same number of items on the right as we have variables on the left, or we’ll get an\nerror. Python 3.0 allows us to be more general with extended unpacking syntax, described in the next section. But normally, and always in Python 2.X, the number of\nitems in the assignment target and subject must match:\n>>> string = 'SPAM'\n>>> a, b, c, d = string\n>>> a, d\n('S', 'M')\n>>> a, b, c = string\n...error text omitted...\nValueError: too many values to unpack\n\n# Same number on both sides\n\n# Error if not",
    "# Same number on both sides\n\n# Error if not\n\nTo be more general, we can slice. There are a variety of ways to employ slicing to make\nthis last case work:\n>>> a, b, c = string[0], string[1], string[2:]\n>>> a, b, c\n('S', 'P', 'AM')\n\n# Index and slice\n\n>>> a, b, c = list(string[:2]) + [string[2:]]\n>>> a, b, c\n\n# Slice and concatenate\n\n282 | Chapter 11: Assignments, Expressions, and Prints\n\n\f('S', 'P', 'AM')\n>>> a, b = string[:2]\n>>> c = string[2:]\n>>> a, b, c\n('S', 'P', 'AM')\n\n# Same, but simpler\n\n>>> (a, b), c = string[:2], string[2:]\n>>> a, b, c\n('S', 'P', 'AM')\n\n# Nested sequences\n\nAs the last example in this interaction demonstrates, we can even assign nested sequences, and Python unpacks their parts according to their shape, as expected. In this\ncase, we are assigning a tuple of two items, where the first item is a nested sequence (a\nstring), exactly as though we had coded it this way:\n# Paired by shape and position\n\n>>> ((a, b), c) = ('SP', 'AM')\n>>> a, b, c\n('S', 'P', 'AM')",
    ">>> ((a, b), c) = ('SP', 'AM')\n>>> a, b, c\n('S', 'P', 'AM')\n\nPython pairs the first string on the right ('SP') with the first tuple on the left ((a, b))\nand assigns one character at a time, before assigning the entire second string ('AM') to\nthe variable c all at once. In this event, the sequence-nesting shape of the object on the\nleft must match that of the object on the right. Nested sequence assignment like this is\nsomewhat advanced, and rare to see, but it can be convenient for picking out the parts\nof data structures with known shapes.\nFor example, we’ll see in Chapter 13 that this technique also works in for loops, because\nloop items are assigned to the target given in the loop header:\nfor (a, b, c) in [(1, 2, 3), (4, 5, 6)]: ...\n\n# Simple tuple assignment\n\nfor ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: ...\n\n# Nested tuple assignment",
    "# Simple tuple assignment\n\nfor ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: ...\n\n# Nested tuple assignment\n\nIn a note in Chapter 18, we’ll also see that this nested tuple (really, sequence) unpacking\nassignment form works for function argument lists in Python 2.6 (though not in 3.0),\nbecause function arguments are passed by assignment as well:\ndef f(((a, b), c)):\nf(((1, 2), 3))\n\n# For arguments too in Python 2.6, but not 3.0\n\nSequence-unpacking assignments also give rise to another common coding idiom in\nPython—assigning an integer series to a set of variables:\n>>> red, green, blue = range(3)\n>>> red, blue\n(0, 2)\n\nThis initializes the three names to the integer codes 0, 1, and 2, respectively (it’s Python’s\nequivalent of the enumerated data types you may have seen in other languages). To\nmake sense of this, you need to know that the range built-in function generates a list\nof successive integers:\n\nAssignment Statements | 283\n\n\f>>> range(3)\n[0, 1, 2]\n\n# Use list(range(3)) in Python 3.0",
    "This initializes the three names to the integer codes 0, 1, and 2, respectively (it’s Python’s\nequivalent of the enumerated data types you may have seen in other languages). To\nmake sense of this, you need to know that the range built-in function generates a list\nof successive integers:\n\nAssignment Statements | 283\n\n\f>>> range(3)\n[0, 1, 2]\n\n# Use list(range(3)) in Python 3.0\n\nBecause range is commonly used in for loops, we’ll say more about it in Chapter 13.\nAnother place you may see a tuple assignment at work is for splitting a sequence into\nits front and the rest in loops like this:\n>>> L = [1, 2, 3, 4]\n>>> while L:\n...\nfront, L = L[0], L[1:]\n...\nprint(front, L)\n...\n1 [2, 3, 4]\n2 [3, 4]\n3 [4]\n4 []\n\n# See next section for 3.0 alternative\n\nThe tuple assignment in the loop here could be coded as the following two lines instead,\nbut it’s often more convenient to string them together:\n...\n...\n\nfront = L[0]\nL = L[1:]",
    "# See next section for 3.0 alternative\n\nThe tuple assignment in the loop here could be coded as the following two lines instead,\nbut it’s often more convenient to string them together:\n...\n...\n\nfront = L[0]\nL = L[1:]\n\nNotice that this code is using the list as a sort of stack data structure, which can often\nalso be achieved with the append and pop methods of list objects; here, front =\nL.pop(0) would have much the same effect as the tuple assignment statement, but it\nwould be an in-place change. We’ll learn more about while loops, and other (often\nbetter) ways to step through a sequence with for loops, in Chapter 13.",
    "Extended Sequence Unpacking in Python 3.0\nThe prior section demonstrated how to use manual slicing to make sequence assignments more general. In Python 3.0 (but not 2.6), sequence assignment has been generalized to make this easier. In short, a single starred name, *X, can be used in the\nassignment target in order to specify a more general matching against the sequence—\nthe starred name is assigned a list, which collects all items in the sequence not assigned\nto other names. This is especially handy for common coding patterns such as splitting\na sequence into its “front” and “rest”, as in the preceding section’s last example.",
    "Extended unpacking in action\nLet’s look at an example. As we’ve seen, sequence assignments normally require exactly\nas many names in the target on the left as there are items in the subject on the right.\nWe get an error if the lengths disagree (unless we manually sliced on the right, as shown\nin the prior section):\nC:\\misc> c:\\python30\\python\n>>> seq = [1, 2, 3, 4]\n>>> a, b, c, d = seq\n>>> print(a, b, c, d)\n1 2 3 4\n\n284 | Chapter 11: Assignments, Expressions, and Prints\n\n\f>>> a, b = seq\nValueError: too many values to unpack\n\nIn Python 3.0, though, we can use a single starred name in the target to match more\ngenerally. In the following continuation of our interactive session, a matches the first\nitem in the sequence, and b matches the rest:\n>>> a, *b = seq\n>>> a\n1\n>>> b\n[2, 3, 4]",
    "284 | Chapter 11: Assignments, Expressions, and Prints\n\n\f>>> a, b = seq\nValueError: too many values to unpack\n\nIn Python 3.0, though, we can use a single starred name in the target to match more\ngenerally. In the following continuation of our interactive session, a matches the first\nitem in the sequence, and b matches the rest:\n>>> a, *b = seq\n>>> a\n1\n>>> b\n[2, 3, 4]\n\nWhen a starred name is used, the number of items in the target on the left need not\nmatch the length of the subject sequence. In fact, the starred name can appear anywhere\nin the target. For instance, in the next interaction b matches the last item in the sequence, and a matches everything before the last:\n>>> *a, b = seq\n>>> a\n[1, 2, 3]\n>>> b\n4\n\nWhen the starred name appears in the middle, it collects everything between the other\nnames listed. Thus, in the following interaction a and c are assigned the first and last\nitems, and b gets everything in between them:\n>>> a, *b, c = seq\n>>> a\n1\n>>> b\n[2, 3]\n>>> c\n4",
    "When the starred name appears in the middle, it collects everything between the other\nnames listed. Thus, in the following interaction a and c are assigned the first and last\nitems, and b gets everything in between them:\n>>> a, *b, c = seq\n>>> a\n1\n>>> b\n[2, 3]\n>>> c\n4\n\nMore generally, wherever the starred name shows up, it will be assigned a list that\ncollects every unassigned name at that position:\n>>> a, b, *c = seq\n>>> a\n1\n>>> b\n2\n>>> c\n[3, 4]\n\nNaturally, like normal sequence assignment, extended sequence unpacking syntax\nworks for any sequence types, not just lists. Here it is unpacking characters in a string:\n>>> a, *b = 'spam'\n>>> a, b\n('s', ['p', 'a', 'm'])\n>>> a, *b, c = 'spam'\n\nAssignment Statements | 285\n\n\f>>> a, b, c\n('s', ['p', 'a'], 'm')",
    "Naturally, like normal sequence assignment, extended sequence unpacking syntax\nworks for any sequence types, not just lists. Here it is unpacking characters in a string:\n>>> a, *b = 'spam'\n>>> a, b\n('s', ['p', 'a', 'm'])\n>>> a, *b, c = 'spam'\n\nAssignment Statements | 285\n\n\f>>> a, b, c\n('s', ['p', 'a'], 'm')\n\nThis is similar in spirit to slicing, but not exactly the same—a sequence unpacking\nassignment always returns a list for multiple matched items, whereas slicing returns a\nsequence of the same type as the object sliced:\n>>> S = 'spam'\n>>> S[0], S[1:]\n('s', 'pam')\n\n# Slices are type-specific, * assignment always returns a list\n\n>>> S[0], S[1:3], S[3]\n('s', 'pa', 'm')\n\nGiven this extension in 3.0, as long as we’re processing a list the last example of the\nprior section becomes even simpler, since we don’t have to manually slice to get the\nfirst and rest of the items:\n>>> L = [1, 2, 3, 4]\n>>> while L:\n...\nfront, *L = L\n...\nprint(front, L)\n...\n1 [2, 3, 4]\n2 [3, 4]\n3 [4]\n4 []",
    ">>> S[0], S[1:3], S[3]\n('s', 'pa', 'm')\n\nGiven this extension in 3.0, as long as we’re processing a list the last example of the\nprior section becomes even simpler, since we don’t have to manually slice to get the\nfirst and rest of the items:\n>>> L = [1, 2, 3, 4]\n>>> while L:\n...\nfront, *L = L\n...\nprint(front, L)\n...\n1 [2, 3, 4]\n2 [3, 4]\n3 [4]\n4 []\n\n# Get first, rest without slicing\n\nBoundary cases\nAlthough extended sequence unpacking is flexible, some boundary cases are worth\nnoting. First, the starred name may match just a single item, but is always assigned a list:\n>>> seq\n[1, 2, 3, 4]\n>>> a, b, c, *d = seq\n>>> print(a, b, c, d)\n1 2 3 [4]",
    "# Get first, rest without slicing\n\nBoundary cases\nAlthough extended sequence unpacking is flexible, some boundary cases are worth\nnoting. First, the starred name may match just a single item, but is always assigned a list:\n>>> seq\n[1, 2, 3, 4]\n>>> a, b, c, *d = seq\n>>> print(a, b, c, d)\n1 2 3 [4]\n\nSecond, if there is nothing left to match the starred name, it is assigned an empty list,\nregardless of where it appears. In the following, a, b, c, and d have matched every item\nin the sequence, but Python assigns e an empty list instead of treating this as an error\ncase:\n>>> a, b, c, d, *e = seq\n>>> print(a, b, c, d, e)\n1 2 3 4 []\n>>> a, b, *e, c, d = seq\n>>> print(a, b, c, d, e)\n1 2 3 4 []\n\n286 | Chapter 11: Assignments, Expressions, and Prints",
    "286 | Chapter 11: Assignments, Expressions, and Prints\n\n\fFinally, errors can still be triggered if there is more than one starred name, if there are\ntoo few values and no star (as before), and if the starred name is not itself coded inside\na sequence:\n>>> a, *b, c, *d = seq\nSyntaxError: two starred expressions in assignment\n>>> a, b = seq\nValueError: too many values to unpack\n>>> *a = seq\nSyntaxError: starred assignment target must be in a list or tuple\n>>> *a, = seq\n>>> a\n[1, 2, 3, 4]\n\nA useful convenience\nKeep in mind that extended sequence unpacking assignment is just a convenience. We\ncan usually achieve the same effects with explicit indexing and slicing (and in fact must\nin Python 2.X), but extended unpacking is simpler to code. The common “first, rest”\nsplitting coding pattern, for example, can be coded either way, but slicing involves extra\nwork:\n>>> seq\n[1, 2, 3, 4]\n>>> a, *b = seq\n>>> a, b\n(1, [2, 3, 4])\n\n# First, rest\n\n>>> a, b = seq[0], seq[1:]\n>>> a, b\n(1, [2, 3, 4])",
    "# First, rest\n\n>>> a, b = seq[0], seq[1:]\n>>> a, b\n(1, [2, 3, 4])\n\n# First, rest: traditional\n\nThe also common “rest, last” splitting pattern can similarly be coded either way, but\nthe new extended unpacking syntax requires noticeably fewer keystrokes:\n>>> *a, b = seq\n>>> a, b\n([1, 2, 3], 4)\n\n# Rest, last\n\n>>> a, b = seq[:-1], seq[-1]\n>>> a, b\n([1, 2, 3], 4)\n\n# Rest, last: traditional\n\nBecause it is not only simpler but, arguably, more natural, extended sequence unpacking syntax will likely become widespread in Python code over time.\n\nAssignment Statements | 287\n\n\fApplication to for loops\nBecause the loop variable in the for loop statement can be any assignment target, extended sequence assignment works here too. We met the for loop iteration tool briefly\nin Part II and will study it formally in Chapter 13. In Python 3.0, extended assignments\nmay show up after the word for, where a simple variable name is more commonly used:\nfor (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:\n...",
    "When used in this context, on each iteration Python simply assigns the next tuple of\nvalues to the tuple of names. On the first loop, for example, it’s as if we’d run the\nfollowing assignment statement:\na, *b, c = (1, 2, 3, 4)\n\n# b gets [2, 3]\n\nThe names a, b, and c can be used within the loop’s code to reference the extracted\ncomponents. In fact, this is really not a special case at all, but just an instance of general\nassignment at work. As we saw earlier in this chapter, we can do the same thing with\nsimple tuple assignment in both Python 2.X and 3.X:\nfor (a, b, c) in [(1, 2, 3), (4, 5, 6)]:\n\n# a, b, c = (1, 2, 3), ...\n\nAnd we can always emulate 3.0’s extended assignment behavior in 2.6 by manually\nslicing:\nfor all in [(1, 2, 3, 4), (5, 6, 7, 8)]:\na, b, c = all[0], all[1:3], all[3]\n\nSince we haven’t learned enough to get more detailed about the syntax of for loops,\nwe’ll return to this topic in Chapter 13.",
    "# a, b, c = (1, 2, 3), ...\n\nAnd we can always emulate 3.0’s extended assignment behavior in 2.6 by manually\nslicing:\nfor all in [(1, 2, 3, 4), (5, 6, 7, 8)]:\na, b, c = all[0], all[1:3], all[3]\n\nSince we haven’t learned enough to get more detailed about the syntax of for loops,\nwe’ll return to this topic in Chapter 13.\n\nMultiple-Target Assignments\nA multiple-target assignment simply assigns all the given names to the object all the\nway to the right. The following, for example, assigns the three variables a, b, and c to\nthe string 'spam':\n>>> a = b = c = 'spam'\n>>> a, b, c\n('spam', 'spam', 'spam')\n\nThis form is equivalent to (but easier to code than) these three assignments:\n>>> c = 'spam'\n>>> b = c\n>>> a = b",
    "Multiple-Target Assignments\nA multiple-target assignment simply assigns all the given names to the object all the\nway to the right. The following, for example, assigns the three variables a, b, and c to\nthe string 'spam':\n>>> a = b = c = 'spam'\n>>> a, b, c\n('spam', 'spam', 'spam')\n\nThis form is equivalent to (but easier to code than) these three assignments:\n>>> c = 'spam'\n>>> b = c\n>>> a = b\n\nMultiple-target assignment and shared references\nKeep in mind that there is just one object here, shared by all three variables (they all\nwind up pointing to the same object in memory). This behavior is fine for immutable\ntypes—for example, when initializing a set of counters to zero (recall that variables\n\n288 | Chapter 11: Assignments, Expressions, and Prints\n\n\fmust be assigned before they can be used in Python, so you must initialize counters to\nzero before you can start adding to them):\n>>> a = b = 0\n>>> b = b + 1\n>>> a, b\n(0, 1)",
    "288 | Chapter 11: Assignments, Expressions, and Prints\n\n\fmust be assigned before they can be used in Python, so you must initialize counters to\nzero before you can start adding to them):\n>>> a = b = 0\n>>> b = b + 1\n>>> a, b\n(0, 1)\n\nHere, changing b only changes b because numbers do not support in-place changes. As\nlong as the object assigned is immutable, it’s irrelevant if more than one name references\nit.\nAs usual, though, we have to be more cautious when initializing variables to an empty\nmutable object such as a list or dictionary:\n>>> a = b = []\n>>> b.append(42)\n>>> a, b\n([42], [42])",
    "Here, changing b only changes b because numbers do not support in-place changes. As\nlong as the object assigned is immutable, it’s irrelevant if more than one name references\nit.\nAs usual, though, we have to be more cautious when initializing variables to an empty\nmutable object such as a list or dictionary:\n>>> a = b = []\n>>> b.append(42)\n>>> a, b\n([42], [42])\n\nThis time, because a and b reference the same object, appending to it in-place through\nb will impact what we see through a as well. This is really just another example of the\nshared reference phenomenon we first met in Chapter 6. To avoid the issue, initialize\nmutable objects in separate statements instead, so that each creates a distinct empty\nobject by running a distinct literal expression:\n>>> a = []\n>>> b = []\n>>> b.append(42)\n>>> a, b\n([], [42])",
    "Augmented Assignments\nBeginning with Python 2.0, the set of additional assignment statement formats listed\nin Table 11-2 became available. Known as augmented assignments, and borrowed from\nthe C language, these formats are mostly just shorthand. They imply the combination\nof a binary expression and an assignment. For instance, the following two formats are\nnow roughly equivalent:\n# Traditional form\n# Newer augmented form\n\nX = X + Y\nX += Y\n\nTable 11-2. Augmented assignment statements\nX += Y\n\nX &= Y\n\nX -= Y\n\nX |= Y\n\nX *= Y\n\nX ^= Y\n\nX /= Y\n\nX >>= Y\n\nX %= Y\n\nX <<= Y\n\nX **= Y\n\nX //= Y\n\nAugmented assignment works on any type that supports the implied binary expression.\nFor example, here are two ways to add 1 to a name:\nAssignment Statements | 289\n\n\f>>> x = 1\n>>> x = x + 1\n>>> x\n2\n>>> x += 1\n>>> x\n3\n\n# Traditional\n# Augmented",
    "Table 11-2. Augmented assignment statements\nX += Y\n\nX &= Y\n\nX -= Y\n\nX |= Y\n\nX *= Y\n\nX ^= Y\n\nX /= Y\n\nX >>= Y\n\nX %= Y\n\nX <<= Y\n\nX **= Y\n\nX //= Y\n\nAugmented assignment works on any type that supports the implied binary expression.\nFor example, here are two ways to add 1 to a name:\nAssignment Statements | 289\n\n\f>>> x = 1\n>>> x = x + 1\n>>> x\n2\n>>> x += 1\n>>> x\n3\n\n# Traditional\n# Augmented\n\nWhen applied to a string, the augmented form performs concatenation instead. Thus,\nthe second line here is equivalent to typing the longer S = S + \"SPAM\":\n>>> S = \"spam\"\n>>> S += \"SPAM\"\n>>> S\n'spamSPAM'\n\n# Implied concatenation",
    "As shown in Table 11-2, there are analogous augmented assignment forms for every\nPython binary expression operator (i.e., each operator with values on the left and right\nside). For instance, X *= Y multiplies and assigns, X >>= Y shifts right and assigns, and\nso on. X //= Y (for floor division) was added in version 2.2.\nAugmented assignments have three advantages:*\n• There’s less for you to type. Need I say more?\n• The left side only has to be evaluated once. In X += Y, X may be a complicated object\nexpression. In the augmented form, it only has to be evaluated once. However, in\nthe long form, X = X + Y, X appears twice and must be run twice. Because of this,\naugmented assignments usually run faster.\n• The optimal technique is automatically chosen. That is, for objects that support\nin-place changes, the augmented forms automatically perform in-place change operations instead of slower copies.",
    "the long form, X = X + Y, X appears twice and must be run twice. Because of this,\naugmented assignments usually run faster.\n• The optimal technique is automatically chosen. That is, for objects that support\nin-place changes, the augmented forms automatically perform in-place change operations instead of slower copies.\nThe last point here requires a bit more explanation. For augmented assignments, inplace operations may be applied for mutable objects as an optimization. Recall that\nlists can be extended in a variety of ways. To add a single item to the end of a list, we\ncan concatenate or call append:\n>>> L = [1, 2]\n>>> L = L + [3]\n>>> L\n[1, 2, 3]\n>>> L.append(4)\n>>> L\n[1, 2, 3, 4]",
    "# Concatenate: slower\n# Faster, but in-place\n\n* C/C++ programmers take note: although Python now supports statements like X += Y, it still does not have\nC’s auto-increment/decrement operators (e.g., X++, −−X). These don’t quite map to the Python object model\nbecause Python has no notion of in-place changes to immutable objects like numbers.\n\n290 | Chapter 11: Assignments, Expressions, and Prints\n\n\fAnd to add a set of items to the end, we can either concatenate again or call the list\nextend method:†\n>>> L = L + [5, 6]\n>>> L\n[1, 2, 3, 4, 5, 6]\n>>> L.extend([7, 8])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8]\n\n# Concatenate: slower\n# Faster, but in-place",
    "290 | Chapter 11: Assignments, Expressions, and Prints\n\n\fAnd to add a set of items to the end, we can either concatenate again or call the list\nextend method:†\n>>> L = L + [5, 6]\n>>> L\n[1, 2, 3, 4, 5, 6]\n>>> L.extend([7, 8])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8]\n\n# Concatenate: slower\n# Faster, but in-place\n\nIn both cases, concatenation is less prone to the side effects of shared object references\nbut will generally run slower than the in-place equivalent. Concatenation operations\nmust create a new object, copy in the list on the left, and then copy in the list on the\nright. By contrast, in-place method calls simply add items at the end of a memory block.\nWhen we use augmented assignment to extend a list, we can forget these details—for\nexample, Python automatically calls the quicker extend method instead of using the\nslower concatenation operation implied by +:\n>>> L += [9, 10]\n# Mapped to L.extend([9, 10])\n>>> L\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
    "Augmented assignment and shared references\nThis behavior is usually what we want, but notice that it implies that the += is an inplace change for lists; thus, it is not exactly like + concatenation, which always makes\na new object. As for all shared reference cases, this difference might matter if other\nnames reference the object being changed:\n>>> L = [1, 2]\n>>> M = L\n>>> L = L + [3, 4]\n>>> L, M\n([1, 2, 3, 4], [1, 2])\n>>> L = [1, 2]\n>>> M = L\n>>> L += [3, 4]\n>>> L, M\n([1, 2, 3, 4], [1, 2, 3, 4])\n\n# L and M reference the same object\n# Concatenation makes a new object\n# Changes L but not M\n\n# But += really means extend\n# M sees the in-place change too!\n\nThis only matters for mutables like lists and dictionaries, and it is a fairly obscure case\n(at least, until it impacts your code!). As always, make copies of your mutable objects\nif you need to break the shared reference structure.",
    "# L and M reference the same object\n# Concatenation makes a new object\n# Changes L but not M\n\n# But += really means extend\n# M sees the in-place change too!\n\nThis only matters for mutables like lists and dictionaries, and it is a fairly obscure case\n(at least, until it impacts your code!). As always, make copies of your mutable objects\nif you need to break the shared reference structure.\n\n† As suggested in Chapter 6, we can also use slice assignment (e.g., L[len(L):] = [11,12,13]), but this works\nroughly the same as the simpler list extend method.\n\nAssignment Statements | 291",
    "Variable Name Rules\nNow that we’ve explored assignment statements, it’s time to get more formal about the\nuse of variable names. In Python, names come into existence when you assign values\nto them, but there are a few rules to follow when picking names for things in your\nprograms:\nSyntax: (underscore or letter) + (any number of letters, digits, or underscores)\nVariable names must start with an underscore or letter, which can be followed by\nany number of letters, digits, or underscores. _spam, spam, and Spam_1 are legal\nnames, but 1_Spam, spam$, and @#! are not.\nCase matters: SPAM is not the same as spam\nPython always pays attention to case in programs, both in names you create and\nin reserved words. For instance, the names X and x refer to two different variables.\nFor portability, case also matters in the names of imported module files, even on\nplatforms where the filesystems are case-insensitive.\nReserved words are off-limits",
    "Case matters: SPAM is not the same as spam\nPython always pays attention to case in programs, both in names you create and\nin reserved words. For instance, the names X and x refer to two different variables.\nFor portability, case also matters in the names of imported module files, even on\nplatforms where the filesystems are case-insensitive.\nReserved words are off-limits\nNames you define cannot be the same as words that mean special things in the\nPython language. For instance, if you try to use a variable name like class, Python\nwill raise a syntax error, but klass and Class work fine. Table 11-3 lists the words\nthat are currently reserved (and hence off-limits for names of your own) in Python.\nTable 11-3. Python 3.0 reserved words\nFalse",
    "class\n\nfinally\n\nis\n\nreturn\n\nNone\n\ncontinue\n\nfor\n\nlambda\n\ntry\n\nTrue\n\ndef\n\nfrom\n\nnonlocal\n\nwhile\n\nand\n\ndel\n\nglobal\n\nnot\n\nwith\n\nas\n\nelif\n\nif\n\nor\n\nyield\n\nassert\n\nelse\n\nimport\n\npass\n\nbreak\n\nexcept\n\nin\n\nraise\n\nTable 11-3 is specific to Python 3.0. In Python 2.6, the set of reserved words differs\nslightly:\n• print is a reserved word, because printing is a statement, not a built-in (more on\nthis later in this chapter).\n• exec is a reserved word, because it is a statement, not a built-in function.\n• nonlocal is not a reserved word because this statement is not available.\nIn older Pythons the story is also more or less the same, with a few variations:\n\n292 | Chapter 11: Assignments, Expressions, and Prints",
    "• with and as were not reserved until 2.6, when context managers were officially\nenabled.\n• yield was not reserved until Python 2.3, when generator functions were enabled.\n• yield morphed from statement to expression in 2.5, but it’s still a reserved word,\nnot a built-in function.\nAs you can see, most of Python’s reserved words are all lowercase. They are also all\ntruly reserved—unlike names in the built-in scope that you will meet in the next part\nof this book, you cannot redefine reserved words by assignment (e.g., and = 1 results\nin a syntax error).‡\nBesides being of mixed case, the first three entries in Table 11-3, True, False, and\nNone, are somewhat unusual in meaning—they also appear in the built-in scope of\nPython described in Chapter 17, and they are technically names assigned to objects.\nThey are truly reserved in all other senses, though, and cannot be used for any other",
    "in a syntax error).‡\nBesides being of mixed case, the first three entries in Table 11-3, True, False, and\nNone, are somewhat unusual in meaning—they also appear in the built-in scope of\nPython described in Chapter 17, and they are technically names assigned to objects.\nThey are truly reserved in all other senses, though, and cannot be used for any other\npurpose in your script other than that of the objects they represent. All the other reserved words are hardwired into Python’s syntax and can appear only in the specific\ncontexts for which they are intended.\nFurthermore, because module names in import statements become variables in your\nscripts, variable name constraints extend to your module filenames too. For instance,\nyou can code files called and.py and my-code.py and run them as top-level scripts, but\nyou cannot import them: their names without the “.py” extension become variables in\nyour code and so must follow all the variable rules just outlined. Reserved words are",
    "scripts, variable name constraints extend to your module filenames too. For instance,\nyou can code files called and.py and my-code.py and run them as top-level scripts, but\nyou cannot import them: their names without the “.py” extension become variables in\nyour code and so must follow all the variable rules just outlined. Reserved words are\noff-limits, and dashes won’t work, though underscores will. We’ll revisit this idea in\nPart V of this book.",
    "Python’s Deprecation Protocol\nIt is interesting to note how reserved word changes are gradually phased into the language. When a new feature might break existing code, Python normally makes it an\noption and begins issuing “deprecation” warnings one or more releases before the feature is officially enabled. The idea is that you should have ample time to notice the\nwarnings and update your code before migrating to the new release. This is not true\nfor major new releases like 3.0 (which breaks existing code freely), but it is generally\ntrue in other cases.\nFor example, yield was an optional extension in Python 2.2, but is a standard keyword\nas of 2.3. It is used in conjunction with generator functions. This was one of a small\nhandful of instances where Python broke with backward compatibility. Still, yield was\nphased in over time: it began generating deprecation warnings in 2.2 and was not enabled until 2.3.",
    "‡ In the Jython Java-based implementation of Python, though, user-defined variable names can sometimes be\nthe same as Python reserved words. See Chapter 2 for an overview of the Jython system.\n\nAssignment Statements | 293\n\n\fSimilarly, in Python 2.6, the words with and as become new reserved words for use in\ncontext managers (a newer form of exception handling). These two words are not reserved in 2.5, unless the context manager feature is turned on manually with a\nfrom__future__import (discussed later in this book). When used in 2.5, with and as\ngenerate warnings about the upcoming change—except in the version of IDLE in Python 2.5, which appears to have enabled this feature for you (that is, using these words\nas variable names does generate errors in 2.5, but only in its version of the IDLE GUI).",
    "Naming conventions\nBesides these rules, there is also a set of naming conventions—rules that are not required\nbut are followed in normal practice. For instance, because names with two leading and\ntrailing underscores (e.g., __name__) generally have special meaning to the Python interpreter, you should avoid this pattern for your own names. Here is a list of the conventions Python follows:\n• Names that begin with a single underscore (_X) are not imported by a from module\nimport * statement (described in Chapter 22).\n• Names that have two leading and trailing underscores (__X__) are system-defined\nnames that have special meaning to the interpreter.\n• Names that begin with two underscores and do not end with two more (__X) are\nlocalized (“mangled”) to enclosing classes (see the discussion of pseudoprivate\nattributes in Chapter 30).\n• The name that is just a single underscore (_) retains the result of the last expression\nwhen working interactively.",
    "names that have special meaning to the interpreter.\n• Names that begin with two underscores and do not end with two more (__X) are\nlocalized (“mangled”) to enclosing classes (see the discussion of pseudoprivate\nattributes in Chapter 30).\n• The name that is just a single underscore (_) retains the result of the last expression\nwhen working interactively.\nIn addition to these Python interpreter conventions, there are various other conventions\nthat Python programmers usually follow. For instance, later in the book we’ll see that\nclass names commonly start with an uppercase letter and module names with a lowercase letter, and that the name self, though not reserved, usually has a special role in\nclasses. In Chapter 17 we’ll also study another, larger category of names known as the\nbuilt-ins, which are predefined but not reserved (and so can be reassigned: open = 42\nworks, though sometimes you might wish it didn’t!).",
    "Names have no type, but objects do\nThis is mostly review, but remember that it’s crucial to keep Python’s distinction between names and objects clear. As described in Chapter 6, objects have a type (e.g.,\ninteger, list) and may be mutable or not. Names (a.k.a. variables), on the other hand,\nare always just references to objects; they have no notion of mutability and have no\nassociated type information, apart from the type of the object they happen to reference\nat a given point in time.\n\n294 | Chapter 11: Assignments, Expressions, and Prints\n\n\fThus, it’s OK to assign the same name to different kinds of objects at different times:\n>>> x = 0\n>>> x = \"Hello\"\n>>> x = [1, 2, 3]\n\n# x bound to an integer object\n# Now it's a string\n# And now it's a list",
    "In later examples, you’ll see that this generic nature of names can be a decided advantage\nin Python programming. In Chapter 17, you’ll also learn that names also live in something called a scope, which defines where they can be used; the place where you assign\na name determines where it is visible.§\nFor additional naming suggestions, see the previous section “Naming\nconventions” of Python’s semi-official style guide, known as PEP 8. This\nguide is available at http://www.python.org/dev/peps/pep-0008, or via a\nweb search for “Python PEP 8.” Technically, this document formalizes\ncoding standards for Python library code.\nThough useful, the usual caveats about coding standards apply here.\nFor one thing, PEP 8 comes with more detail than you are probably ready\nfor at this point in the book. And frankly, it has become more complex,\nrigid, and subjective than it needs to be—some of its suggestions are not\nat all universally accepted or followed by Python programmers doing",
    "coding standards for Python library code.\nThough useful, the usual caveats about coding standards apply here.\nFor one thing, PEP 8 comes with more detail than you are probably ready\nfor at this point in the book. And frankly, it has become more complex,\nrigid, and subjective than it needs to be—some of its suggestions are not\nat all universally accepted or followed by Python programmers doing\nreal work. Moreover, some of the most prominent companies using Python today have adopted coding standards of their own that differ.\nPEP 8 does codify useful rule-of-thumb Python knowledge, though, and\nit’s a great read for Python beginners, as long as you take its recommendations as guidelines, not gospel.",
    "Expression Statements\nIn Python, you can use an expression as a statement, too—that is, on a line by itself.\nBut because the result of the expression won’t be saved, it usually makes sense to do\nso only if the expression does something useful as a side effect. Expressions are commonly used as statements in two situations:\nFor calls to functions and methods\nSome functions and methods do lots of work without returning a value. Such\nfunctions are sometimes called procedures in other languages. Because they don’t\nreturn values that you might be interested in retaining, you can call these functions\nwith expression statements.",
    "§ If you’ve used a more restrictive language like C++, you may be interested to know that there is no notion\nof C++’s const declaration in Python; certain objects may be immutable, but names can always be assigned.\nPython also has ways to hide names in classes and modules, but they’re not the same as C++’s declarations\n(if hiding attributes matters to you, see the coverage of _X module names in Chapter 24, __X class names in\nChapter 30, and the Private and Public class decorators example in Chapter 38).\n\nExpression Statements | 295",
    "Expression Statements | 295\n\n\fFor printing values at the interactive prompt\nPython echoes back the results of expressions typed at the interactive command\nline. Technically, these are expression statements, too; they serve as a shorthand\nfor typing print statements.\nTable 11-4 lists some common expression statement forms in Python. Calls to functions\nand methods are coded with zero or more argument objects (really, expressions that\nevaluate to objects) in parentheses, after the function/method name.\nTable 11-4. Common Python expression statements\nOperation\n\nInterpretation\n\nspam(eggs, ham)\n\nFunction calls\n\nspam.ham(eggs)\n\nMethod calls\n\nspam\n\nPrinting variables in the interactive interpreter\n\nprint(a, b, c, sep='')\n\nPrinting operations in Python 3.0\n\nyield x ** 2\n\nYielding expression statements",
    "Interpretation\n\nspam(eggs, ham)\n\nFunction calls\n\nspam.ham(eggs)\n\nMethod calls\n\nspam\n\nPrinting variables in the interactive interpreter\n\nprint(a, b, c, sep='')\n\nPrinting operations in Python 3.0\n\nyield x ** 2\n\nYielding expression statements\n\nThe last two entries in Table 11-4 are somewhat special cases—as we’ll see later in this\nchapter, printing in Python 3.0 is a function call usually coded on a line by itself, and\nthe yield operation in generator functions (discussed in Chapter 20) is often coded as\na statement as well. Both are really just instances of expression statements.\nFor instance, though you normally run a print call on a line by itself as an expression\nstatement, it returns a value like any other function call (its return value is None, the\ndefault return value for functions that don’t return anything meaningful):\n>>> x = print('spam')\nspam\n>>> print(x)\nNone\n\n# print is a function call expression in 3.0\n# But it is coded as an expression statement",
    "# print is a function call expression in 3.0\n# But it is coded as an expression statement\n\nAlso keep in mind that although expressions can appear as statements in Python, statements cannot be used as expressions. For example, Python doesn’t allow you to embed\nassignment statements (=) in other expressions. The rationale for this is that it avoids\ncommon coding mistakes; you can’t accidentally change a variable by typing = when\nyou really mean to use the == equality test. You’ll see how to code around this when\nyou meet the Python while loop in Chapter 13.\n\nExpression Statements and In-Place Changes\nThis brings up a mistake that is common in Python work. Expression statements are\noften used to run list methods that change a list in-place:\n>>> L = [1, 2]\n>>> L.append(3)\n>>> L\n[1, 2, 3]\n\n# Append is an in-place change\n\n296 | Chapter 11: Assignments, Expressions, and Prints",
    "Expression Statements and In-Place Changes\nThis brings up a mistake that is common in Python work. Expression statements are\noften used to run list methods that change a list in-place:\n>>> L = [1, 2]\n>>> L.append(3)\n>>> L\n[1, 2, 3]\n\n# Append is an in-place change\n\n296 | Chapter 11: Assignments, Expressions, and Prints\n\n\fHowever, it’s not unusual for Python newcomers to code such an operation as an assignment statement instead, intending to assign L to the larger list:\n>>> L = L.append(4)\n>>> print(L)\nNone\n\n# But append returns None, not L\n# So we lose our list!",
    "# Append is an in-place change\n\n296 | Chapter 11: Assignments, Expressions, and Prints\n\n\fHowever, it’s not unusual for Python newcomers to code such an operation as an assignment statement instead, intending to assign L to the larger list:\n>>> L = L.append(4)\n>>> print(L)\nNone\n\n# But append returns None, not L\n# So we lose our list!\n\nThis doesn’t quite work, though. Calling an in-place change operation such as append,\nsort, or reverse on a list always changes the list in-place, but these methods do not\nreturn the list they have changed; instead, they return the None object. Thus, if you\nassign such an operation’s result back to the variable name, you effectively lose the list\n(and it is probably garbage collected in the process!).\nThe moral of the story is, don’t do this. We’ll revisit this phenomenon in the section\n“Common Coding Gotchas” on page 387 at the end of this part of the book because\nit can also appear in the context of some looping statements we’ll meet in later chapters.",
    "Print Operations\nIn Python, print prints things—it’s simply a programmer-friendly interface to the\nstandard output stream.\nTechnically, printing converts one or more objects to their textual representations, adds\nsome minor formatting, and sends the resulting text to either standard output or another file-like stream. In a bit more detail, print is strongly bound up with the notions\nof files and streams in Python:\nFile object methods\nIn Chapter 9, we learned about file object methods that write text (e.g.,\nfile.write(str)). Printing operations are similar, but more focused—whereas file\nwrite methods write strings to arbitrary files, print writes objects to the stdout\nstream by default, with some automatic formatting added. Unlike with file methods, there is no need to convert objects to strings when using print operations.\nStandard output stream\nThe standard output stream (often known as stdout) is simply a default place to",
    "write methods write strings to arbitrary files, print writes objects to the stdout\nstream by default, with some automatic formatting added. Unlike with file methods, there is no need to convert objects to strings when using print operations.\nStandard output stream\nThe standard output stream (often known as stdout) is simply a default place to\nsend a program’s text output. Along with the standard input and error streams,\nit’s one of three data connections created when your script starts. The standard\noutput stream is usually mapped to the window where you started your Python\nprogram, unless it’s been redirected to a file or pipe in your operating system’s shell.\nBecause the standard output stream is available in Python as the stdout file object\nin the built-in sys module (i.e., sys.stdout), it’s possible to emulate print with file\nwrite method calls. However, print is noticeably easier to use and makes it easy to\nprint text to other files and streams.",
    "Print Operations | 297\n\n\fPrinting is also one of the most visible places where Python 3.0 and 2.6 have diverged.\nIn fact, this divergence is usually the first reason that most 2.X code won’t run unchanged under 3.X. Specifically, the way you code print operations depends on which\nversion of Python you use:\n• In Python 3.X, printing is a built-in function, with keyword arguments for special\nmodes.\n• In Python 2.X, printing is a statement with specific syntax all its own.\nBecause this book covers both 3.0 and 2.6, we will look at each form in turn here. If\nyou are fortunate enough to be able to work with code written for just one version of\nPython, feel free to pick the section that is relevant to you; however, as your circumstances may change, it probably won’t hurt to be familiar with both cases.",
    "The Python 3.0 print Function\nStrictly speaking, printing is not a separate statement form in 3.0. Instead, it is simply\nan instance of the expression statement we studied in the preceding section.\nThe print built-in function is normally called on a line of its own, because it doesn’t\nreturn any value we care about (technically, it returns None). Because it is a normal\nfunction, though, printing in 3.0 uses standard function-call syntax, rather than a special\nstatement form. Because it provides special operation modes with keyword arguments,\nthis form is both more general and supports future enhancements better.\nBy comparison, Python 2.6 print statements have somewhat ad-hoc syntax to support\nextensions such as end-of-line suppression and target files. Further, the 2.6 statement\ndoes not support separator specification at all; in 2.6, you wind up building strings\nahead of time more often than you do in 3.0.",
    "Call format\nSyntactically, calls to the 3.0 print function have the following form:\nprint([object, ...][, sep=' '][, end='\\n'][, file=sys.stdout])\n\nIn this formal notation, items in square brackets are optional and may be omitted in a\ngiven call, and values after = give argument defaults. In English, this built-in function\nprints the textual representation of one or more objects separated by the string sep and\nfollowed by the string end to the stream file.\nThe sep, end, and file parts, if present, must be given as keyword arguments—that is,\nyou must use a special “name=value” syntax to pass the arguments by name instead of\nposition. Keyword arguments are covered in depth in Chapter 18, but they’re straightforward to use. The keyword arguments sent to this call may appear in any left-to-right\norder following the objects to be printed, and they control the print operation:\n\n298 | Chapter 11: Assignments, Expressions, and Prints",
    "• sep is a string inserted between each object’s text, which defaults to a single space\nif not passed; passing an empty string suppresses separators altogether.\n• end is a string added at the end of the printed text, which defaults to a \\n newline\ncharacter if not passed. Passing an empty string avoids dropping down to the next\noutput line at the end of the printed text—the next print will keep adding to the\nend of the current output line.\n• file specifies the file, standard stream, or other file-like object to which the text\nwill be sent; it defaults to the sys.stdout standard output stream if not passed. Any\nobject with a file-like write(string) method may be passed, but real files should\nbe already opened for output.\nThe textual representation of each object to be printed is obtained by passing the object\nto the str built-in call; as we’ve seen, this built-in returns a “user friendly” display string",
    "will be sent; it defaults to the sys.stdout standard output stream if not passed. Any\nobject with a file-like write(string) method may be passed, but real files should\nbe already opened for output.\nThe textual representation of each object to be printed is obtained by passing the object\nto the str built-in call; as we’ve seen, this built-in returns a “user friendly” display string\nfor any object.‖ With no arguments at all, the print function simply prints a newline\ncharacter to the standard output stream, which usually displays a blank line.",
    "The 3.0 print function in action\nPrinting in 3.0 is probably simpler than some of its details may imply. To illustrate,\nlet’s run some quick examples. The following prints a variety of object types to the\ndefault standard output stream, with the default separator and end-of-line formatting\nadded (these are the defaults because they are the most common use case):\nC:\\misc> c:\\python30\\python\n>>>\n>>> print()\n>>> x = 'spam'\n>>> y = 99\n>>> z = ['eggs']\n>>>\n>>> print(x, y, z)\nspam 99 ['eggs']\n\n# Display a blank line\n\n# Print 3 objects per defaults\n\nThere’s no need to convert objects to strings here, as would be required for file write\nmethods. By default, print calls add a space between the objects printed. To suppress\nthis, send an empty string to the sep keyword argument, or send an alternative separator\nof your choosing:\n>>> print(x, y, z, sep='')\nspam99['eggs']\n>>>\n>>> print(x, y, z, sep=', ')\nspam, 99, ['eggs']\n\n# Suppress separator\n# Custom separator",
    "# Suppress separator\n# Custom separator\n\n‖ Technically, printing uses the equivalent of str in the internal implementation of Python, but the effect is\nthe same. Besides this to-string conversion role, str is also the name of the string data type and can be used\nto decode Unicode strings from raw bytes with an extra encoding argument, as we’ll learn in Chapter 36; this\nlatter role is an advanced usage that we can safely ignore here.\n\nPrint Operations | 299\n\n\fAlso by default, print adds an end-of-line character to terminate the output line. You\ncan suppress this and avoid the line break altogether by passing an empty string to the\nend keyword argument, or you can pass a different terminator of your own (include a\n\\n character to break the line manually):\n>>> print(x, y, z, end='')\nspam 99 ['eggs']>>>\n>>>\n>>> print(x, y, z, end=''); print(x, y, z)\nspam 99 ['eggs']spam 99 ['eggs']\n>>> print(x, y, z, end='...\\n')\nspam 99 ['eggs']...\n>>>",
    "# Suppress line break\n# Two prints, same output line\n# Custom line end\n\nYou can also combine keyword arguments to specify both separators and end-of-line\nstrings—they may appear in any order but must appear after all the objects being\nprinted:\n>>> print(x, y, z, sep='...', end='!\\n')\nspam...99...['eggs']!\n>>> print(x, y, z, end='!\\n', sep='...')\nspam...99...['eggs']!\n\n# Multiple keywords\n# Order doesn't matter\n\nHere is how the file keyword argument is used—it directs the printed text to an open\noutput file or other compatible object for the duration of the single print (this is really\na form of stream redirection, a topic we will revisit later in this section):\n>>> print(x, y, z, sep='...', file=open('data.txt', 'w'))\n>>> print(x, y, z)\nspam 99 ['eggs']\n>>> print(open('data.txt').read())\nspam...99...['eggs']\n\n# Print to a file\n# Back to stdout\n# Display file text",
    "# Print to a file\n# Back to stdout\n# Display file text\n\nFinally, keep in mind that the separator and end-of-line options provided by print operations are just conveniences. If you need to display more specific formatting, don’t\nprint this way, Instead, build up a more complex string ahead of time or within the\nprint itself using the string tools we met in Chapter 7, and print the string all at once:\n>>> text = '%s: %-.4f, %05d' % ('Result', 3.14159, 42)\n>>> print(text)\nResult: 3.1416, 00042\n>>> print('%s: %-.4f, %05d' % ('Result', 3.14159, 42))\nResult: 3.1416, 00042\n\nAs we’ll see in the next section, almost everything we’ve just seen about the 3.0 print\nfunction also applies directly to 2.6 print statements—which makes sense, given that\nthe function was intended to both emulate and improve upon 2.6 printing support.",
    "As we’ll see in the next section, almost everything we’ve just seen about the 3.0 print\nfunction also applies directly to 2.6 print statements—which makes sense, given that\nthe function was intended to both emulate and improve upon 2.6 printing support.\n\nThe Python 2.6 print Statement\nAs mentioned earlier, printing in Python 2.6 uses a statement with unique and specific\nsyntax, rather than a built-in function. In practice, though, 2.6 printing is mostly a\nvariation on a theme; with the exception of separator strings (which are supported in\n300 | Chapter 11: Assignments, Expressions, and Prints\n\n\f3.0 but not 2.6), everything we can do with the 3.0 print function has a direct translation to the 2.6 print statement.",
    "3.0 but not 2.6), everything we can do with the 3.0 print function has a direct translation to the 2.6 print statement.\n\nStatement forms\nTable 11-5 lists the print statement’s forms in Python 2.6 and gives their Python 3.0\nprint function equivalents for reference. Notice that the comma is significant in\nprint statements—it separates objects to be printed, and a trailing comma suppresses\nthe end-of-line character normally added at the end of the printed text (not to be confused with tuple syntax!). The >> syntax, normally used as a bitwise right-shift operation, is used here as well, to specify a target output stream other than the sys.stdout\ndefault.\nTable 11-5. Python 2.6 print statement forms\nPython 2.6 statement\n\nPython 3.0 equivalent\n\nInterpretation\n\nprint x, y\n\nprint(x, y)\n\nPrint objects’ textual\nforms to sys.stdout;\nadd a space between the\nitems and an end-of-line\nat the end\n\nprint x, y,\n\nprint(x, y, end='')\n\nSame, but don’t add\nend-of-line at end of text\n\nprint >> afile, x, y",
    "Python 3.0 equivalent\n\nInterpretation\n\nprint x, y\n\nprint(x, y)\n\nPrint objects’ textual\nforms to sys.stdout;\nadd a space between the\nitems and an end-of-line\nat the end\n\nprint x, y,\n\nprint(x, y, end='')\n\nSame, but don’t add\nend-of-line at end of text\n\nprint >> afile, x, y\n\nprint(x, y, file=afile)\n\nSend text to\nmyfile.write, not to\nsys.stdout.write\n\nThe 2.6 print statement in action\nAlthough the 2.6 print statement has more unique syntax than the 3.0 function, it’s\nsimilarly easy to use. Let’s turn to some basic examples again. By default, the 2.6\nprint statement adds a space between the items separated by commas and adds a line\nbreak at the end of the current output line:\nC:\\misc> c:\\python26\\python\n>>>\n>>> x = 'a'\n>>> y = 'b'\n>>> print x, y\na b",
    "This formatting is just a default; you can choose to use it or not. To suppress the line\nbreak so you can add more text to the current line later, end your print statement with\na comma, as shown in the second line of Table 11-5 (the following is two statements\non one line, separated by a semicolon):\n>>> print x, y,; print x, y\na b a b\n\nPrint Operations | 301\n\n\fTo suppress the space between items, again, don’t print this way. Instead, build up an\noutput string using the string concatenation and formatting tools covered in Chapter 7, and print the string all at once:\n>>> print x + y\nab\n>>> print '%s...%s' % (x, y)\na...b\n\nAs you can see, apart from their special syntax for usage modes, 2.6 print statements\nare roughly as simple to use as 3.0’s function. The next section uncovers the way that\nfiles are specified in 2.6 prints.",
    "As you can see, apart from their special syntax for usage modes, 2.6 print statements\nare roughly as simple to use as 3.0’s function. The next section uncovers the way that\nfiles are specified in 2.6 prints.\n\nPrint Stream Redirection\nIn both Python 3.0 and 2.6, printing sends text to the standard output stream by default.\nHowever, it’s often useful to send it elsewhere—to a text file, for example, to save results\nfor later use or testing purposes. Although such redirection can be accomplished in\nsystem shells outside Python itself, it turns out to be just as easy to redirect a script’s\nstreams from within the script.\n\nThe Python “hello world” program\nLet’s start off with the usual (and largely pointless) language benchmark—the “hello\nworld” program. To print a “hello world” message in Python, simply print the string\nper your version’s print operation:\n>>> print('hello world')\nhello world\n\n# Print a string object in 3.0\n\n>>> print 'hello world'\nhello world",
    "The Python “hello world” program\nLet’s start off with the usual (and largely pointless) language benchmark—the “hello\nworld” program. To print a “hello world” message in Python, simply print the string\nper your version’s print operation:\n>>> print('hello world')\nhello world\n\n# Print a string object in 3.0\n\n>>> print 'hello world'\nhello world\n\n# Print a string object in 2.6\n\nBecause expression results are echoed on the interactive command line, you often don’t\neven need to use a print statement there—simply type the expressions you’d like to\nhave printed, and their results are echoed back:\n>>> 'hello world'\n'hello world'\n\n# Interactive echoes",
    "# Print a string object in 3.0\n\n>>> print 'hello world'\nhello world\n\n# Print a string object in 2.6\n\nBecause expression results are echoed on the interactive command line, you often don’t\neven need to use a print statement there—simply type the expressions you’d like to\nhave printed, and their results are echoed back:\n>>> 'hello world'\n'hello world'\n\n# Interactive echoes\n\nThis code isn’t exactly an earth-shattering piece of software mastery, but it serves to\nillustrate printing behavior. Really, the print operation is just an ergonomic feature of\nPython—it provides a simple interface to the sys.stdout object, with a bit of default\nformatting. In fact, if you enjoy working harder than you must, you can also code print\noperations this way:\n>>> import sys\n>>> sys.stdout.write('hello world\\n')\nhello world\n\n302 | Chapter 11: Assignments, Expressions, and Prints\n\n# Printing the hard way",
    "302 | Chapter 11: Assignments, Expressions, and Prints\n\n# Printing the hard way\n\n\fThis code explicitly calls the write method of sys.stdout—an attribute preset when\nPython starts up to an open file object connected to the output stream. The print\noperation hides most of those details, providing a simple tool for simple printing tasks.\n\nManual stream redirection\nSo, why did I just show you the hard way to print? The sys.stdout print equivalent\nturns out to be the basis of a common technique in Python. In general, print and\nsys.stdout are directly related as follows. This statement:\nprint(X, Y)\n\n# Or, in 2.6: print X, Y\n\nis equivalent to the longer:\nimport sys\nsys.stdout.write(str(X) + ' ' + str(Y) + '\\n')",
    "# Or, in 2.6: print X, Y\n\nis equivalent to the longer:\nimport sys\nsys.stdout.write(str(X) + ' ' + str(Y) + '\\n')\n\nwhich manually performs a string conversion with str, adds a separator and newline\nwith +, and calls the output stream’s write method. Which would you rather code? (He\nsays, hoping to underscore the programmer-friendly nature of prints....)\nObviously, the long form isn’t all that useful for printing by itself. However, it is useful\nto know that this is exactly what print operations do because it is possible to reassign sys.stdout to something different from the standard output stream. In other words,\nthis equivalence provides a way of making your print operations send their text to other\nplaces. For example:\nimport sys\nsys.stdout = open('log.txt', 'a')\n...\nprint(x, y, x)\n\n# Redirects prints to a file\n# Shows up in log.txt",
    "Here, we reset sys.stdout to a manually opened file named log.txt, located in the script’s\nworking directory and opened in append mode (so we add to its current content). After\nthe reset, every print operation anywhere in the program will write its text to the end\nof the file log.txt instead of to the original output stream. The print operations are\nhappy to keep calling sys.stdout’s write method, no matter what sys.stdout happens\nto refer to. Because there is just one sys module in your process, assigning\nsys.stdout this way will redirect every print anywhere in your program.\nIn fact, as this chapter’s upcoming sidebar about print and stdout will explain, you\ncan even reset sys.stdout to an object that isn’t a file at all, as long as it has the expected\ninterface: a method named write to receive the printed text string argument. When that\nobject is a class, printed text can be routed and processed arbitrarily per a write method\nyou code yourself.",
    "In fact, as this chapter’s upcoming sidebar about print and stdout will explain, you\ncan even reset sys.stdout to an object that isn’t a file at all, as long as it has the expected\ninterface: a method named write to receive the printed text string argument. When that\nobject is a class, printed text can be routed and processed arbitrarily per a write method\nyou code yourself.\nThis trick of resetting the output stream is primarily useful for programs originally\ncoded with print statements. If you know that output should go to a file to begin with,\nyou can always call file write methods instead. To redirect the output of a print-based",
    "Print Operations | 303\n\n\fprogram, though, resetting sys.stdout provides a convenient alternative to changing\nevery print statement or using system shell-based redirection syntax.\n\nAutomatic stream redirection\nThis technique of redirecting printed text by assigning sys.stdout is commonly used\nin practice. One potential problem with the last section’s code, though, is that there is\nno direct way to restore the original output stream should you need to switch back after\nprinting to a file. Because sys.stdout is just a normal file object, you can always save\nit and restore it if needed:#\nC:\\misc> c:\\python30\\python\n>>> import sys\n>>> temp = sys.stdout\n>>> sys.stdout = open('log.txt', 'a')\n>>> print('spam')\n>>> print(1, 2, 3)\n>>> sys.stdout.close()\n>>> sys.stdout = temp\n>>> print('back here')\nback here\n>>> print(open('log.txt').read())\nspam\n1 2 3",
    "# Save for restoring later\n# Redirect prints to a file\n# Prints go to file, not here\n# Flush output to disk\n# Restore original stream\n# Prints show up here again\n# Result of earlier prints\n\nAs you can see, though, manual saving and restoring of the original output stream like\nthis involves quite a bit of extra work. Because this crops up fairly often, a print extension is available to make it unnecessary.\nIn 3.0, the file keyword allows a single print call to send its text to a file’s write method,\nwithout actually resetting sys.stdout. Because the redirection is temporary, normal\nprint calls keep printing to the original output stream. In 2.6, a print statement that\nbegins with a >> followed by an output file object (or other compatible object) has the\nsame effect. For example, the following again sends printed text to a file named log.txt:\nlog = open('log.txt', 'a')\nprint(x, y, z, file=log)\nprint(a, b, c)\n\n# 3.0\n# Print to a file-like object\n# Print to original stdout",
    "# 3.0\n# Print to a file-like object\n# Print to original stdout\n\nlog = open('log.txt', 'a')\nprint >> log, x, y, z\nprint a, b, c\n\n# 2.6\n# Print to a file-like object\n# Print to original stdout\n\nThese redirected forms of print are handy if you need to print to both files and the\nstandard output stream in the same program. If you use these forms, however, be sure\n\n#In both 2.6 and 3.0 you may also be able to use the __stdout__ attribute in the sys module, which refers to\nthe original value sys.stdout had at program startup time. You still need to restore sys.stdout to\nsys.__stdout__ to go back to this original stream value, though. See the sys module documentation for more\ndetails.\n\n304 | Chapter 11: Assignments, Expressions, and Prints",
    "#In both 2.6 and 3.0 you may also be able to use the __stdout__ attribute in the sys module, which refers to\nthe original value sys.stdout had at program startup time. You still need to restore sys.stdout to\nsys.__stdout__ to go back to this original stream value, though. See the sys module documentation for more\ndetails.\n\n304 | Chapter 11: Assignments, Expressions, and Prints\n\n\fto give them a file object (or an object that has the same write method as a file object),\nnot a file’s name string. Here is the technique in action:\nC:\\misc> c:\\python30\\python\n>>> log = open('log.txt', 'w')\n>>> print(1, 2, 3, file=log)\n>>> print(4, 5, 6, file=log)\n>>> log.close()\n>>> print(7, 8, 9)\n7 8 9\n>>> print(open('log.txt').read())\n1 2 3\n4 5 6\n\n# 2.6: print >> log, 1, 2, 3\n# 2.6: print 7, 8, 9",
    "# 2.6: print >> log, 1, 2, 3\n# 2.6: print 7, 8, 9\n\nThese extended forms of print are also commonly used to print error messages to the\nstandard error stream, available to your script as the preopened file object\nsys.stderr. You can either use its file write methods and format the output manually,\nor print with redirection syntax:\n>>> import sys\n>>> sys.stderr.write(('Bad!' * 8) + '\\n')\nBad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!\n>>> print('Bad!' * 8, file=sys.stderr)\nBad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!\n\n# 2.6: print >> sys.stderr, 'Bad' * 8\n\nNow that you know all about print redirections, the equivalence between printing and\nfile write methods should be fairly obvious. The following interaction prints both ways\nin 3.0, then redirects the output to an external file to verify that the same text is printed:\n>>> X = 1; Y = 2\n>>> print(X, Y)\n1 2\n>>> import sys\n>>> sys.stdout.write(str(X) + ' ' + str(Y) + '\\n')\n1 2\n4\n>>> print(X, Y, file=open('temp1', 'w'))\n\n# Print: the easy way\n# Print: the hard way",
    "# Print: the easy way\n# Print: the hard way\n\n# Redirect text to file\n\n>>> open('temp2', 'w').write(str(X) + ' ' + str(Y) + '\\n') # Send to file manually\n4\n>>> print(open('temp1', 'rb').read())\n# Binary mode for bytes\nb'1 2\\r\\n'\n>>> print(open('temp2', 'rb').read())\nb'1 2\\r\\n'\n\nAs you can see, unless you happen to enjoy typing, print operations are usually the best\noption for displaying text. For another example of the equivalence between prints and\nfile writes, watch for a 3.0 print function emulation example in Chapter 18; it uses this\ncode pattern to provide a general 3.0 print function equivalent for use in Python 2.6.\n\nPrint Operations | 305",
    "As you can see, unless you happen to enjoy typing, print operations are usually the best\noption for displaying text. For another example of the equivalence between prints and\nfile writes, watch for a 3.0 print function emulation example in Chapter 18; it uses this\ncode pattern to provide a general 3.0 print function equivalent for use in Python 2.6.\n\nPrint Operations | 305\n\n\fVersion-Neutral Printing\nFinally, if you cannot restrict your work to Python 3.0 but still want your prints to be\ncompatible with 3.0, you have some options. For one, you can code 2.6 print statements and let 3.0’s 2to3 conversion script translate them to 3.0 function calls automatically. See the Python 3.0 documentation for more details about this script; it\nattempts to translate 2.X code to run under 3.0.\nAlternatively, you can code 3.0 print function calls in your 2.6 code, by enabling the\nfunction call variant with a statement like the following:\nfrom __future__ import print_function",
    "This statement changes 2.6 to support 3.0’s print functions exactly. This way, you can\nuse 3.0 print features and won’t have to change your prints if you later migrate to 3.0.\nAlso keep in mind that simple prints, like those in the first row of Table 11-5, work in\neither version of Python—because any expression may be enclosed in parentheses, we\ncan always pretend to be calling a 3.0 print function in 2.6 by adding outer parentheses.\nThe only downside to this is that it makes a tuple out of your printed objects if there\nare more than one—they will print with extra enclosing parentheses. In 3.0, for example, any number of objects may be listed in the call’s parentheses:\nC:\\misc> c:\\python30\\python\n>>> print('spam')\nspam\n>>> print('spam', 'ham', 'eggs')\nspam ham eggs\n\n# 3.0 print function call syntax\n# These are mutiple argments",
    "# 3.0 print function call syntax\n# These are mutiple argments\n\nThe first of these works the same in 2.6, but the second generates a tuple in the output:\nC:\\misc> c:\\python26\\python\n>>> print('spam')\nspam\n>>> print('spam', 'ham', 'eggs')\n('spam', 'ham', 'eggs')\n\n# 2.6 print statement, enclosing parens\n# This is really a tuple object!\n\nTo be truly portable, you can format the print string as a single object, using the string\nformatting expression or method call, or other string tools that we studied in Chapter 7:\n>>> print('%s %s %s' % ('spam', 'ham', 'eggs'))\nspam ham eggs\n>>> print('{0} {1} {2}'.format('spam', 'ham', 'eggs'))\nspam ham eggs\n\nOf course, if you can use 3.0 exclusively you can forget such mappings entirely, but\nmany Python programmers will at least encounter, if not write, 2.X code and systems\nfor some time to come.\n\n306 | Chapter 11: Assignments, Expressions, and Prints",
    "Of course, if you can use 3.0 exclusively you can forget such mappings entirely, but\nmany Python programmers will at least encounter, if not write, 2.X code and systems\nfor some time to come.\n\n306 | Chapter 11: Assignments, Expressions, and Prints\n\n\fI use Python 3.0 print function calls throughout this book. I’ll usually\nwarn you that the results may have extra enclosing parentheses in 2.6\nbecause multiple items are a tuple, but I sometimes don’t, so please\nconsider this note a blanket warning—if you see extra parentheses in\nyour printed text in 2.6, either drop the parentheses in your print statements, recode your prints using the version-neutral scheme outlined\nhere, or learn to love superfluous text.",
    "Why You Will Care: print and stdout\nThe equivalence between the print operation and writing to sys.stdout is important.\nIt makes it possible to reassign sys.stdout to any user-defined object that provides the\nsame write method as files. Because the print statement just sends text to the\nsys.stdout.write method, you can capture printed text in your programs by assigning\nsys.stdout to an object whose write method processes the text in arbitrary ways.\nFor instance, you can send printed text to a GUI window, or tee it off to multiple\ndestinations, by defining an object with a write method that does the required routing.\nYou’ll see an example of this trick when we study classes in Part VI of this book, but\nabstractly, it looks like this:\nclass FileFaker:\ndef write(self, string):\n# Do something with printed text in string\nimport sys\nsys.stdout = FileFaker()\nprint(someObjects)\n\n# Sends to class write method",
    "# Sends to class write method\n\nThis works because print is what we will call in the next part of this book a polymorphic operation—it doesn’t care what sys.stdout is, only that it has a method (i.e.,\ninterface) called write. This redirection to objects is made even simpler with the file\nkeyword argument in 3.0 and the >> extended form of print in 2.6, because we don’t\nneed to reset sys.stdout explicitly—normal prints will still be routed to the stdout\nstream:\nmyobj = FileFaker()\n# 3.0: Redirect to object for one print\nprint(someObjects, file=myobj) # Does not reset sys.stdout\nmyobj = FileFaker()\nprint >> myobj, someObjects\n\n# 2.6: same effect\n# Does not reset sys.stdout",
    "# 2.6: same effect\n# Does not reset sys.stdout\n\nPython’s built-in input function reads from the sys.stdin file, so you can intercept read\nrequests in a similar way, using classes that implement file-like read methods instead.\nSee the input and while loop example in Chapter 10 for more background on this.\nNotice that because printed text goes to the stdout stream, it’s the way to print HTML\nin CGI scripts used on the Web. It also enables you to redirect Python script input and\noutput at the operating system’s shell command line, as usual:\n\nPrint Operations | 307\n\n\fpython script.py < inputfile > outputfile\npython script.py | filterProgram\n\nPython’s print operation redirection tools are essentially pure-Python alternatives to\nthese shell syntax forms.",
    "Chapter Summary\nIn this chapter, we began our in-depth look at Python statements by exploring assignments, expressions, and print operations. Although these are generally simple to use,\nthey have some alternative forms that, while optional, are often convenient in practice:\naugmented assignment statements and the redirection form of print operations, for\nexample, allow us to avoid some manual coding work. Along the way, we also studied\nthe syntax of variable names, stream redirection techniques, and a variety of common\nmistakes to avoid, such as assigning the result of an append method call back to a\nvariable.\nIn the next chapter, we’ll continue our statement tour by filling in details about the\nif statement, Python’s main selection tool; there, we’ll also revisit Python’s syntax\nmodel in more depth and look at the behavior of Boolean expressions. Before we move\non, though, the end-of-chapter quiz will test your knowledge of what you’ve learned\nhere.",
    "Test Your Knowledge: Quiz\n1. Name three ways that you can assign three variables to the same value.\n2. Why might you need to care when assigning three variables to a mutable object?\n3. What’s wrong with saying L = L.sort()?\n4. How might you use the print operation to send text to an external file?\n\nTest Your Knowledge: Answers\n1. You can use multiple-target assignments (A = B = C = 0), sequence assignment\n(A, B, C = 0, 0, 0), or multiple assignment statements on three separate lines\n(A = 0, B = 0, and C = 0). With the latter technique, as introduced in Chapter 10,\nyou can also string the three separate statements together on the same line by\nseparating them with semicolons (A = 0; B = 0; C = 0).\n\n308 | Chapter 11: Assignments, Expressions, and Prints\n\n\f2. If you assign them this way:\nA = B = C = []\n\nall three names reference the same object, so changing it in-place from one (e.g.,\nA.append(99)) will affect the others. This is true only for in-place changes to mu-",
    "table objects like lists and dictionaries; for immutable objects such as numbers and\nstrings, this issue is irrelevant.\n3. The list sort method is like append in that it makes an in-place change to the subject\nlist—it returns None, not the list it changes. The assignment back to L sets L to\nNone, not to the sorted list. As we’ll see later in this part of the book, a newer builtin function, sorted, sorts any sequence and returns a new list with the sorting result;\nbecause this is not an in-place change, its result can be meaningfully assigned to a\nname.\n4. To print to a file for a single print operation, you can use 3.0’s print(X, file=F)\ncall form, use 2.6’s extended print >> file, X statement form, or assign\nsys.stdout to a manually opened file before the print and restore the original after.\nYou can also redirect all of a program’s printed text to a file with special syntax in\nthe system shell, but this is outside Python’s scope.\n\nTest Your Knowledge: Answers | 309\n\n\f\fCHAPTER 12",
    "Test Your Knowledge: Answers | 309\n\n\f\fCHAPTER 12\n\nif Tests and Syntax Rules\n\nThis chapter presents the Python if statement, which is the main statement used for\nselecting from alternative actions based on test results. Because this is our first in-depth\nlook at compound statements—statements that embed other statements—we will also\nexplore the general concepts behind the Python statement syntax model here in more\ndetail than we did in the introduction in Chapter 10. Because the if statement introduces the notion of tests, this chapter will also deal with Boolean expressions and fill\nin some details on truth tests in general.",
    "if Statements\nIn simple terms, the Python if statement selects actions to perform. It’s the primary\nselection tool in Python and represents much of the logic a Python program possesses.\nIt’s also our first compound statement. Like all compound Python statements, the if\nstatement may contain other statements, including other ifs. In fact, Python lets you\ncombine statements in a program sequentially (so that they execute one after another),\nand in an arbitrarily nested fashion (so that they execute only under certain conditions).",
    "General Format\nThe Python if statement is typical of if statements in most procedural languages. It\ntakes the form of an if test, followed by one or more optional elif (“else if”) tests and\na final optional else block. The tests and the else part each have an associated block\nof nested statements, indented under a header line. When the if statement runs, Python\nexecutes the block of code associated with the first test that evaluates to true, or the\nelse block if all tests prove false. The general form of an if statement looks like this:\nif <test1>:\n<statements1>\nelif <test2>:\n<statements2>\nelse:\n<statements3>\n\n# if test\n# Associated block\n# Optional elifs\n# Optional else\n\n311\n\n\fBasic Examples\nTo demonstrate, let’s look at a few simple examples of the if statement at work. All\nparts are optional, except the initial if test and its associated statements. Thus, in the\nsimplest case, the other parts are omitted:\n>>> if 1:\n...\nprint('true')\n...\ntrue",
    "# if test\n# Associated block\n# Optional elifs\n# Optional else\n\n311\n\n\fBasic Examples\nTo demonstrate, let’s look at a few simple examples of the if statement at work. All\nparts are optional, except the initial if test and its associated statements. Thus, in the\nsimplest case, the other parts are omitted:\n>>> if 1:\n...\nprint('true')\n...\ntrue\n\nNotice how the prompt changes to ... for continuation lines when typing interactively\nin the basic interface used here; in IDLE, you’ll simply drop down to an indented line\ninstead (hit Backspace to back up). A blank line (which you can get by pressing Enter\ntwice) terminates and runs the entire statement. Remember that 1 is Boolean true, so\nthis statement’s test always succeeds. To handle a false result, code the else:\n>>> if not 1:\n...\nprint('true')\n... else:\n...\nprint('false')\n...\nfalse",
    "Multiway Branching\nNow here’s an example of a more complex if statement, with all its optional parts\npresent:\n>>> x = 'killer rabbit'\n>>> if x == 'roger':\n...\nprint(\"how's jessica?\")\n... elif x == 'bugs':\n...\nprint(\"what's up doc?\")\n... else:\n...\nprint('Run away! Run away!')\n...\nRun away! Run away!",
    "This multiline statement extends from the if line through the else block. When it’s\nrun, Python executes the statements nested under the first test that is true, or the\nelse part if all tests are false (in this example, they are). In practice, both the elif and\nelse parts may be omitted, and there may be more than one statement nested in each\nsection. Note that the words if, elif, and else are associated by the fact that they line\nup vertically, with the same indentation.\nIf you’ve used languages like C or Pascal, you might be interested to know that there\nis no switch or case statement in Python that selects an action based on a variable’s\nvalue. Instead, multiway branching is coded either as a series of if/elif tests, as in the\nprior example, or by indexing dictionaries or searching lists. Because dictionaries and\nlists can be built at runtime, they’re sometimes more flexible than hardcoded if logic:\n\n312 | Chapter 12: if Tests and Syntax Rules",
    "312 | Chapter 12: if Tests and Syntax Rules\n\n\f>>> choice = 'ham'\n>>> print({'spam': 1.25,\n# A dictionary-based 'switch'\n...\n'ham':\n1.99,\n# Use has_key or get for default\n...\n'eggs': 0.99,\n...\n'bacon': 1.10}[choice])\n1.99\n\nAlthough it may take a few moments for this to sink in the first time you see it, this\ndictionary is a multiway branch—indexing on the key choice branches to one of a set\nof values, much like a switch in C. An almost equivalent but more verbose Python if\nstatement might look like this:\n>>> if choice == 'spam':\n...\nprint(1.25)\n... elif choice == 'ham':\n...\nprint(1.99)\n... elif choice == 'eggs':\n...\nprint(0.99)\n... elif choice == 'bacon':\n...\nprint(1.10)\n... else:\n...\nprint('Bad choice')\n...\n1.99",
    "Notice the else clause on the if here to handle the default case when no key matches.\nAs we saw in Chapter 8, dictionary defaults can be coded with in expressions, get\nmethod calls, or exception catching. All of the same techniques can be used here to\ncode a default action in a dictionary-based multiway branch. Here’s the get scheme at\nwork with defaults:\n>>> branch = {'spam': 1.25,\n...\n'ham': 1.99,\n...\n'eggs': 0.99}\n>>> print(branch.get('spam', 'Bad choice'))\n1.25\n>>> print(branch.get('bacon', 'Bad choice'))\nBad choice\n\nAn in membership test in an if statement can have the same default effect:\n>>> choice = 'bacon'\n>>> if choice in branch:\n...\nprint(branch[choice])\n... else:\n...\nprint('Bad choice')\n...\nBad choice",
    "An in membership test in an if statement can have the same default effect:\n>>> choice = 'bacon'\n>>> if choice in branch:\n...\nprint(branch[choice])\n... else:\n...\nprint('Bad choice')\n...\nBad choice\n\nDictionaries are good for associating values with keys, but what about the more complicated actions you can code in the statement blocks associated with if statements?\nIn Part IV, you’ll learn that dictionaries can also contain functions to represent more\ncomplex branch actions and implement general jump tables. Such functions appear as\n\nif Statements | 313",
    "Dictionaries are good for associating values with keys, but what about the more complicated actions you can code in the statement blocks associated with if statements?\nIn Part IV, you’ll learn that dictionaries can also contain functions to represent more\ncomplex branch actions and implement general jump tables. Such functions appear as\n\nif Statements | 313\n\n\fdictionary values, may be coded as function names or lambdas, and are called by adding\nparentheses to trigger their actions; stay tuned for more on this topic in Chapter 19.\nAlthough dictionary-based multiway branching is useful in programs that deal with\nmore dynamic data, most programmers will probably find that coding an if statement\nis the most straightforward way to perform multiway branching. As a rule of thumb in\ncoding, when in doubt, err on the side of simplicity and readability; it’s the “Pythonic”\nway.",
    "Python Syntax Rules\nI introduced Python’s syntax model in Chapter 10. Now that we’re stepping up to larger\nstatements like the if, this section reviews and expands on the syntax ideas introduced\nearlier. In general, Python has a simple, statement-based syntax. However, there are a\nfew properties you need to know about:\n• Statements execute one after another, until you say otherwise. Python normally runs statements in a file or nested block in order from first to last, but statements like if (and, as you’ll see, loops) cause the interpreter to jump around in\nyour code. Because Python’s path through a program is called the control flow,\nstatements such as if that affect it are often called control-flow statements.\n• Block and statement boundaries are detected automatically. As we’ve seen,\nthere are no braces or “begin/end” delimiters around blocks of code in Python;\ninstead, Python uses the indentation of statements under a header to group the",
    "your code. Because Python’s path through a program is called the control flow,\nstatements such as if that affect it are often called control-flow statements.\n• Block and statement boundaries are detected automatically. As we’ve seen,\nthere are no braces or “begin/end” delimiters around blocks of code in Python;\ninstead, Python uses the indentation of statements under a header to group the\nstatements in a nested block. Similarly, Python statements are not normally terminated with semicolons; rather, the end of a line usually marks the end of the\nstatement coded on that line.\n• Compound statements = header + “:” + indented statements. All compound\nstatements in Python follow the same pattern: a header line terminated with a\ncolon, followed by one or more nested statements, usually indented under the\nheader. The indented statements are called a block (or sometimes, a suite). In the\nif statement, the elif and else clauses are part of the if, but they are also header",
    "• Compound statements = header + “:” + indented statements. All compound\nstatements in Python follow the same pattern: a header line terminated with a\ncolon, followed by one or more nested statements, usually indented under the\nheader. The indented statements are called a block (or sometimes, a suite). In the\nif statement, the elif and else clauses are part of the if, but they are also header\nlines with nested blocks of their own.\n• Blank lines, spaces, and comments are usually ignored. Blank lines are ignored\nin files (but not at the interactive prompt, when they terminate compound statements). Spaces inside statements and expressions are almost always ignored\n(except in string literals, and when used for indentation). Comments are always\nignored: they start with a # character (not inside a string literal) and extend to the\nend of the current line.\n• Docstrings are ignored but are saved and displayed by tools. Python supports",
    "(except in string literals, and when used for indentation). Comments are always\nignored: they start with a # character (not inside a string literal) and extend to the\nend of the current line.\n• Docstrings are ignored but are saved and displayed by tools. Python supports\nan additional comment form called documentation strings (docstrings for short),\nwhich, unlike # comments, are retained at runtime for inspection. Docstrings are\nsimply strings that show up at the top of program files and some statements. Python",
    "314 | Chapter 12: if Tests and Syntax Rules\n\n\fignores their contents, but they are automatically attached to objects at runtime\nand may be displayed with documentation tools. Docstrings are part of Python’s\nlarger documentation strategy and are covered in the last chapter in this part of the\nbook.\nAs you’ve seen, there are no variable type declarations in Python; this fact alone makes\nfor a much simpler language syntax than what you may be used to. However, for most\nnew users the lack of the braces and semicolons used to mark blocks and statements\nin many other languages seems to be the most novel syntactic feature of Python, so let’s\nexplore what this means in more detail.",
    "Block Delimiters: Indentation Rules\nPython detects block boundaries automatically, by line indentation—that is, the empty\nspace to the left of your code. All statements indented the same distance to the right\nbelong to the same block of code. In other words, the statements within a block line\nup vertically, as in a column. The block ends when the end of the file or a lesser-indented\nline is encountered, and more deeply nested blocks are simply indented further to the\nright than the statements in the enclosing block.\nFor instance, Figure 12-1 demonstrates the block structure of the following code:\nx = 1\nif x:\ny = 2\nif y:\nprint('block2')\nprint('block1')\nprint('block0')\n\nFigure 12-1. Nested blocks of code: a nested block starts with a statement indented further to the right\nand ends with either a statement that is indented less, or the end of the file.\n\nPython Syntax Rules | 315",
    "Python Syntax Rules | 315\n\n\fThis code contains three blocks: the first (the top-level code of the file) is not indented\nat all, the second (within the outer if statement) is indented four spaces, and the third\n(the print statement under the nested if) is indented eight spaces.\nIn general, top-level (unnested) code must start in column 1. Nested blocks can start\nin any column; indentation may consist of any number of spaces and tabs, as long as\nit’s the same for all the statements in a given single block. That is, Python doesn’t care\nhow you indent your code; it only cares that it’s done consistently. Four spaces or one\ntab per indentation level are common conventions, but there is no absolute standard\nin the Python world.\nIndenting code is quite natural in practice. For example, the following (arguably silly)\ncode snippet demonstrates common indentation errors in Python code:\nx = 'SPAM'\nif 'rubbery' in 'shrubbery':\nprint(x * 8)\nx += 'NI'\nif x.endswith('NI'):\nx *= 2\nprint(x)",
    "# Error: first line indented\n# Error: unexpected indentation\n# Error: inconsistent indentation\n\nThe properly indented version of this code looks like the following—even for an artificial example like this, proper indentation makes the code’s intent much more\napparent:\nx = 'SPAM'\nif 'rubbery' in 'shrubbery':\nprint(x * 8)\nx += 'NI'\nif x.endswith('NI'):\nx *= 2\nprint(x)\n\n# Prints \"SPAMNISPAMNI\"",
    "It’s important to know that the only major place in Python where whitespace matters\nis where it’s used to the left of your code, for indentation; in most other contexts, space\ncan be coded or not. However, indentation is really part of Python syntax, not just a\nstylistic suggestion: all the statements within any given single block must be indented\nto the same level, or Python reports a syntax error. This is intentional—because you\ndon’t need to explicitly mark the start and end of a nested block of code, some of the\nsyntactic clutter found in other languages is unnecessary in Python.\nAs described in Chapter 10, making indentation part of the syntax model also enforces\nconsistency, a crucial component of readability in structured programming languages\nlike Python. Python’s syntax is sometimes described as “what you see is what you",
    "syntactic clutter found in other languages is unnecessary in Python.\nAs described in Chapter 10, making indentation part of the syntax model also enforces\nconsistency, a crucial component of readability in structured programming languages\nlike Python. Python’s syntax is sometimes described as “what you see is what you\nget”—the indentation of each line of code unambiguously tells readers what it is associated with. This uniform and consistent appearance makes Python code easier to\nmaintain and reuse.",
    "316 | Chapter 12: if Tests and Syntax Rules\n\n\fIndentation is more natural than the details might imply, and it makes your code reflect\nits logical structure. Consistently indented code always satisfies Python’s rules.\nMoreover, most text editors (including IDLE) make it easy to follow Python’s indentation model by automatically indenting code as you type it.",
    "Avoid mixing tabs and spaces: New error checking in 3.0\nOne rule of thumb: although you can use spaces or tabs to indent, it’s usually not a\ngood idea to mix the two within a block—use one or the other. Technically, tabs count\nfor enough spaces to move the current column number up to a multiple of 8, and your\ncode will work if you mix tabs and spaces consistently. However, such code can be\ndifficult to change. Worse, mixing tabs and spaces makes your code difficult to read—\ntabs may look very different in the next programmer’s editor than they do in yours.\nIn fact, Python 3.0 now issues an error, for these very reasons, when a script mixes tabs\nand spaces for indentation inconsistently within a block (that is, in a way that makes\nit dependent on a tab’s equivalent in spaces). Python 2.6 allows such scripts to run, but\nit has a -t command-line flag that will warn you about inconsistent tab usage and a",
    "In fact, Python 3.0 now issues an error, for these very reasons, when a script mixes tabs\nand spaces for indentation inconsistently within a block (that is, in a way that makes\nit dependent on a tab’s equivalent in spaces). Python 2.6 allows such scripts to run, but\nit has a -t command-line flag that will warn you about inconsistent tab usage and a\n-tt flag that will issue errors for such code (you can use these switches in a command\nline like python –t main.py in a system shell window). Python 3.0’s error case is equivalent to 2.6’s -tt switch.",
    "Statement Delimiters: Lines and Continuations\nA statement in Python normally ends at the end of the line on which it appears. When\na statement is too long to fit on a single line, though, a few special rules may be used\nto make it span multiple lines:\n• Statements may span multiple lines if you’re continuing an open syntactic\npair. Python lets you continue typing a statement on the next line if you’re coding\nsomething enclosed in a (), {}, or [] pair. For instance, expressions in parentheses\nand dictionary and list literals can span any number of lines; your statement doesn’t\nend until the Python interpreter reaches the line on which you type the closing part\nof the pair (a ), }, or ]). Continuation lines (lines 2 and beyond of the statement)\ncan start at any indentation level you like, but you should try to make them align\nvertically for readability if possible. This open pairs rule also covers set and dictionary comprehensions in Python 3.0.",
    "end until the Python interpreter reaches the line on which you type the closing part\nof the pair (a ), }, or ]). Continuation lines (lines 2 and beyond of the statement)\ncan start at any indentation level you like, but you should try to make them align\nvertically for readability if possible. This open pairs rule also covers set and dictionary comprehensions in Python 3.0.\n• Statements may span multiple lines if they end in a backslash. This is a somewhat outdated feature, but if a statement needs to span multiple lines, you can also\nadd a backslash (a \\ not embedded in a string literal or comment) at the end of the\nprior line to indicate you’re continuing on the next line. Because you can also\ncontinue by adding parentheses around most constructs, backslashes are almost\nnever used. This approach is error-prone: accidentally forgetting a \\ usually generates a syntax error and might even cause the next line to be silently mistaken to\nbe a new statement, with unexpected results.",
    "prior line to indicate you’re continuing on the next line. Because you can also\ncontinue by adding parentheses around most constructs, backslashes are almost\nnever used. This approach is error-prone: accidentally forgetting a \\ usually generates a syntax error and might even cause the next line to be silently mistaken to\nbe a new statement, with unexpected results.\nPython Syntax Rules | 317",
    "• Special rules for string literals. As we learned in Chapter 7, triple-quoted string\nblocks are designed to span multiple lines normally. We also learned in Chapter 7 that adjacent string literals are implicitly concatenated; when used in conjunction with the open pairs rule mentioned earlier, wrapping this construct in\nparentheses allows it to span multiple lines.\n• Other rules. There are a few other points to mention with regard to statement\ndelimiters. Although uncommon, you can terminate a statement with a\nsemicolon—this convention is sometimes used to squeeze more than one simple\n(noncompound) statement onto a single line. Also, comments and blank lines can\nappear anywhere in a file; comments (which begin with a # character) terminate at\nthe end of the line on which they appear.",
    "A Few Special Cases\nHere’s what a continuation line looks like using the open syntactic pairs rule. Delimited\nconstructs, such as lists in square brackets, can span across any number of lines:\nL = [\"Good\",\n\"Bad\",\n\"Ugly\"]\n\n# Open pairs may span lines\n\nThis also works for anything in parentheses (expressions, function arguments, function\nheaders, tuples, and generator expressions), as well as anything in curly braces (dictionaries and, in 3.0, set literals and set and dictionary comprehensions). Some of these\nare tools we’ll study in later chapters, but this rule naturally covers most constructs\nthat span lines in practice.\nIf you like using backslashes to continue lines, you can, but it’s not common practice\nin Python:\nif a == b and c == d and\nd == e and f == g:\nprint('olde')\n\n\\\n# Backslashes allow continuations...",
    "\\\n# Backslashes allow continuations...\n\nBecause any expression can be enclosed in parentheses, you can usually use the open\npairs technique instead if you need your code to span multiple lines—simply wrap a\npart of your statement in parentheses:\nif (a == b and c == d and\nd == e and e == f):\nprint('new')\n\n# But parentheses usually do too\n\nIn fact, backslashes are frowned on, because they’re too easy to not notice and too easy\nto omit altogether. In the following, x is assigned 10 with the backslash, as intended; if\nthe backslash is accidentally omitted, though, x is assigned 6 instead, and no error is\nreported (the +4 is a valid expression statement by itself).\n\n318 | Chapter 12: if Tests and Syntax Rules\n\n\fIn a real program with a more complex assignment, this could be the source of a very\nnasty bug:*\nx = 1 + 2 + 3 \\\n+4\n\n# Omitting the \\ makes this very different",
    "318 | Chapter 12: if Tests and Syntax Rules\n\n\fIn a real program with a more complex assignment, this could be the source of a very\nnasty bug:*\nx = 1 + 2 + 3 \\\n+4\n\n# Omitting the \\ makes this very different\n\nAs another special case, Python allows you to write more than one noncompound\nstatement (i.e., statements without nested statements) on the same line, separated by\nsemicolons. Some coders use this form to save program file real estate, but it usually\nmakes for more readable code if you stick to one statement per line for most of your\nwork:\nx = 1; y = 2; print(x)\n\n# More than one simple statement",
    "# More than one simple statement\n\nAs we learned in Chapter 7, triple-quoted string literals span lines too. In addition, if\ntwo string literals appear next to each other, they are concatenated as if a + had been\nadded between them—when used in conjunction with the open pairs rule, wrapping\nin parentheses allows this form to span multiple lines. For example, the first of the\nfollowing inserts newline characters at line breaks and assigns S to '\\naaaa\\nbbbb\n\\ncccc', and the second implicitly concatenates and assigns S to 'aaaabbbbcccc'; comments are ignored in the second form, but included in the string in the first:\nS = \"\"\"\naaaa\nbbbb\ncccc\"\"\"\nS = ('aaaa'\n'bbbb'\n'cccc')\n\n# Comments here are ignored\n\nFinally, Python lets you move a compound statement’s body up to the header line,\nprovided the body is just a simple (noncompound) statement. You’ll most often see\nthis used for simple if statements with a single test and action:\nif 1: print('hello')\n\n# Simple statement on header line",
    "# Comments here are ignored\n\nFinally, Python lets you move a compound statement’s body up to the header line,\nprovided the body is just a simple (noncompound) statement. You’ll most often see\nthis used for simple if statements with a single test and action:\nif 1: print('hello')\n\n# Simple statement on header line\n\nYou can combine some of these special cases to write code that is difficult to read, but\nI don’t recommend it; as a rule of thumb, try to keep each statement on a line of its\nown, and indent all but the simplest of blocks. Six months down the road, you’ll be\nhappy you did.\n\n* Frankly, it’s surprising that this wasn’t removed in Python 3.0, given some of its other changes! (See\nTable P-2 of the Preface for a list of 3.0 removals; some seem fairly innocuous in comparison with the dangers\ninherent in backslash continuations.) Then again, this book’s goal is Python instruction, not populist outrage,\nso the best advice I can give is simply: don’t do this.",
    "* Frankly, it’s surprising that this wasn’t removed in Python 3.0, given some of its other changes! (See\nTable P-2 of the Preface for a list of 3.0 removals; some seem fairly innocuous in comparison with the dangers\ninherent in backslash continuations.) Then again, this book’s goal is Python instruction, not populist outrage,\nso the best advice I can give is simply: don’t do this.\n\nPython Syntax Rules | 319",
    "Python Syntax Rules | 319\n\n\fTruth Tests\nThe notions of comparison, equality, and truth values were introduced in Chapter 9.\nBecause the if statement is the first statement we’ve looked at that actually uses test\nresults, we’ll expand on some of these ideas here. In particular, Python’s Boolean operators are a bit different from their counterparts in languages like C. In Python:\n• Any nonzero number or nonempty object is true.\n• Zero numbers, empty objects, and the special object None are considered false.\n• Comparisons and equality tests are applied recursively to data structures.\n• Comparisons and equality tests return True or False (custom versions of 1 and 0).\n• Boolean and and or operators return a true or false operand object.\nIn short, Boolean operators are used to combine the results of other tests. There are\nthree Boolean expression operators in Python:\nX and Y\n\nIs true if both X and Y are true\nX or Y\n\nIs true if either X or Y is true\nnot X",
    "Is true if both X and Y are true\nX or Y\n\nIs true if either X or Y is true\nnot X\n\nIs true if X is false (the expression returns True or False)\nHere, X and Y may be any truth value, or any expression that returns a truth value (e.g.,\nan equality test, range comparison, and so on). Boolean operators are typed out as\nwords in Python (instead of C’s &&, ||, and !). Also, Boolean and and or operators return\na true or false object in Python, not the values True or False. Let’s look at a few examples\nto see how this works:\n>>> 2 < 3, 3 < 2\n(True, False)\n\n# Less-than: return True or False (1 or 0)",
    "# Less-than: return True or False (1 or 0)\n\nMagnitude comparisons such as these return True or False as their truth results, which,\nas we learned in Chapters 5 and 9, are really just custom versions of the integers 1 and\n0 (they print themselves differently but are otherwise the same).\nOn the other hand, the and and or operators always return an object—either the object\non the left side of the operator or the object on the right. If we test their results in if or\nother statements, they will be as expected (remember, every object is inherently true\nor false), but we won’t get back a simple True or False.\n\n320 | Chapter 12: if Tests and Syntax Rules",
    "320 | Chapter 12: if Tests and Syntax Rules\n\n\fFor or tests, Python evaluates the operand objects from left to right and returns the first\none that is true. Moreover, Python stops at the first true operand it finds. This is usually\ncalled short-circuit evaluation, as determining a result short-circuits (terminates) the\nrest of the expression:\n>>> 2 or 3, 3 or 2\n(2, 3)\n>>> [] or 3\n3\n>>> [] or {}\n{}\n\n# Return left operand if true\n# Else, return right operand (true or false)\n\nIn the first line of the preceding example, both operands (2 and 3) are true (i.e., are\nnonzero), so Python always stops and returns the one on the left. In the other two tests,\nthe left operand is false (an empty object), so Python simply evaluates and returns the\nobject on the right (which may happen to have either a true or a false value when tested).\nand operations also stop as soon as the result is known; however, in this case Python",
    "evaluates the operands from left to right and stops at the first false object:\n>>> 2 and 3, 3 and 2\n(3, 2)\n>>> [] and {}\n[]\n>>> 3 and []\n[]\n\n# Return left operand if false\n# Else, return right operand (true or false)",
    "Here, both operands are true in the first line, so Python evaluates both sides and returns\nthe object on the right. In the second test, the left operand is false ([]), so Python stops\nand returns it as the test result. In the last test, the left side is true (3), so Python evaluates\nand returns the object on the right (which happens to be a false []).\nThe end result of all this is the same as in C and most other languages—you get a value\nthat is logically true or false if tested in an if or while. However, in Python Booleans\nreturn either the left or the right object, not a simple integer flag.\nThis behavior of and and or may seem esoteric at first glance, but see this chapter’s\nsidebar “Why You Will Care: Booleans” on page 323 for examples of how it is sometimes used to advantage in coding by Python programmers. The next section also shows\na common way to leverage this behavior, and its replacement in more recent versions\nof Python.",
    "The if/else Ternary Expression\nOne common role for the prior section’s Boolean operators is to code an expression\nthat runs the same as an if statement. Consider the following statement, which sets\nA to either Y or Z, based on the truth value of X:\n\nThe if/else Ternary Expression | 321\n\n\fif X:\nA = Y\nelse:\nA = Z\n\nSometimes, though, the items involved in such a statement are so simple that it seems\nlike overkill to spread them across four lines. At other times, we may want to nest such\na construct in a larger statement instead of assigning its result to a variable. For these\nreasons (and, frankly, because the C language has a similar tool†), Python 2.5 introduced a new expression format that allows us to say the same thing in one expression:\nA = Y if X else Z",
    "This expression has the exact same effect as the preceding four-line if statement, but\nit’s simpler to code. As in the statement equivalent, Python runs expression Y only if\nX turns out to be true, and runs expression Z only if X turns out to be false. That is, it\nshort-circuits, just like the Boolean operators described in the prior section. Here are\nsome examples of it in action:\n>>> A = 't' if 'spam' else 'f'\n>>> A\n't'\n>>> A = 't' if '' else 'f'\n>>> A\n'f'\n\n# Nonempty is true\n\nPrior to Python 2.5 (and after 2.5, if you insist), the same effect can often be achieved\nby a careful combination of the and and or operators, because they return either the\nobject on the left side or the object on the right:\nA = ((X and Y) or Z)",
    "This works, but there is a catch—you have to be able to assume that Y will be Boolean\ntrue. If that is the case, the effect is the same: the and runs first and returns Y if X is true;\nif it’s not, the or simply returns Z. In other words, we get “if X then Y else Z.”\nThis and/or combination also seems to require a “moment of great clarity” to understand the first time you see it, and it’s no longer required as of 2.5—use the equivalent\nand more robust and mnemonic Y if X else Z instead if you need this as an expression,\nor use a full if statement if the parts are nontrivial.\nAs a side note, using the following expression in Python is similar because the bool\nfunction will translate X into the equivalent of integer 1 or 0, which can then be used to\npick true and false values from a list:\nA = [Z, Y][bool(X)]",
    "† In fact, Python’s X if Y else Z has a slightly different order than C’s Y ? X : Z. This was reportedly done\nin response to analysis of common use patterns in Python code. According to rumor, this order was also\nchosen in part to discourage ex-C programmers from overusing it! Remember, simple is better than complex,\nin Python and elsewhere.\n\n322 | Chapter 12: if Tests and Syntax Rules\n\n\fFor example:\n>>> ['f', 't'][bool('')]\n'f'\n>>> ['f', 't'][bool('spam')]\n't'",
    "322 | Chapter 12: if Tests and Syntax Rules\n\n\fFor example:\n>>> ['f', 't'][bool('')]\n'f'\n>>> ['f', 't'][bool('spam')]\n't'\n\nHowever, this isn’t exactly the same, because Python will not short-circuit—it will\nalways run both Z and Y, regardless of the value of X. Because of such complexities,\nyou’re better off using the simpler and more easily understood if/else expression as\nof Python 2.5 and later. Again, though, you should use even that sparingly, and only if\nits parts are all fairly simple; otherwise, you’re better off coding the full if statement\nform to make changes easier in the future. Your coworkers will be happy you did.\nStill, you may see the and/or version in code written prior to 2.5 (and in code written\nby C programmers who haven’t quite let go of their dark coding pasts...).",
    "Why You Will Care: Booleans\nOne common way to use the somewhat unusual behavior of Python Boolean operators\nis to select from a set of objects with an or. A statement such as this:\nX = A or B or C or None\n\nsets X to the first nonempty (that is, true) object among A, B, and C, or to None if all of\nthem are empty. This works because the or operator returns one of its two objects, and\nit turns out to be a fairly common coding paradigm in Python: to select a nonempty\nobject from among a fixed-size set, simply string them together in an or expression. In\nsimpler form, this is also commonly used to designate a default—the following sets X\nto A if A is true (or nonempty), and to default otherwise:\nX = A or default\n\nIt’s also important to understand short-circuit evaluation because expressions on the\nright of a Boolean operator might call functions that perform substantial or important\nwork, or have side effects that won’t happen if the short-circuit rule takes effect:\nif f1() or f2(): ...",
    "It’s also important to understand short-circuit evaluation because expressions on the\nright of a Boolean operator might call functions that perform substantial or important\nwork, or have side effects that won’t happen if the short-circuit rule takes effect:\nif f1() or f2(): ...\n\nHere, if f1 returns a true (or nonempty) value, Python will never run f2. To guarantee\nthat both functions will be run, call them before the or:\ntmp1, tmp2 = f1(), f2()\nif tmp1 or tmp2: ...",
    "Here, if f1 returns a true (or nonempty) value, Python will never run f2. To guarantee\nthat both functions will be run, call them before the or:\ntmp1, tmp2 = f1(), f2()\nif tmp1 or tmp2: ...\n\nYou’ve already seen another application of this behavior in this chapter: because of the\nway Booleans work, the expression ((A and B) or C) can be used to emulate an if/\nelse statement—almost (see this chapter’s discussion of this form for details).\nWe met additional Boolean use cases in prior chapters. As we saw in Chapter 9, because\nall objects are inherently true or false, it’s common and easier in Python to test an object\ndirectly ( if X:) than to compare it to an empty value (if X != '':). For a string, the\ntwo tests are equivalent. As we also saw in Chapter 5, the preset Booleans values True\nand False are the same as the integers 1 and 0 and are useful for initializing variables\nThe if/else Ternary Expression | 323",
    "(X = False), for loop tests (while True:), and for displaying results at the interactive\nprompt.\nAlso watch for the discussion of operator overloading in Part VI: when we define new\nobject types with classes, we can specify their Boolean nature with either the __bool__ or\n__len__ methods (__bool__ is named __nonzero__ in 2.6). The latter of these is tried if\nthe former is absent and designates false by returning a length of zero—an empty object\nis considered false.",
    "Chapter Summary\nIn this chapter, we studied the Python if statement. Additionally, because this was our\nfirst compound and logical statement, we reviewed Python’s general syntax rules and\nexplored the operation of truth tests in more depth than we were able to previously.\nAlong the way, we also looked at how to code multiway branching in Python and\nlearned about the if/else expression introduced in Python 2.5.\nThe next chapter continues our look at procedural statements by expanding on the\nwhile and for loops. There, we’ll learn about alternative ways to code loops in Python,\nsome of which may be better than others. Before that, though, here is the usual chapter\nquiz.\n\nTest Your Knowledge: Quiz\n1. How might you code a multiway branch in Python?\n2. How can you code an if/else statement as an expression in Python?\n3. How can you make a single statement span many lines?\n4. What do the words True and False mean?",
    "Test Your Knowledge: Quiz\n1. How might you code a multiway branch in Python?\n2. How can you code an if/else statement as an expression in Python?\n3. How can you make a single statement span many lines?\n4. What do the words True and False mean?\n\nTest Your Knowledge: Answers\n1. An if statement with multiple elif clauses is often the most straightforward way\nto code a multiway branch, though not necessarily the most concise. Dictionary\nindexing can often achieve the same result, especially if the dictionary contains\ncallable functions coded with def statements or lambda expressions.\n2. In Python 2.5 and later, the expression form Y if X else Z returns Y if X is true, or\nZ otherwise; it’s the same as a four-line if statement. The and/or combination\n(((X and Y) or Z)) can work the same way, but it’s more obscure and requires that\nthe Y part be true.\n\n324 | Chapter 12: if Tests and Syntax Rules",
    "324 | Chapter 12: if Tests and Syntax Rules\n\n\f3. Wrap up the statement in an open syntactic pair ((), [], or {}), and it can span as\nmany lines as you like; the statement ends when Python sees the closing (right) half\nof the pair, and lines 2 and beyond of the statement can begin at any indentation\nlevel.\n4. True and False are just custom versions of the integers 1 and 0, respectively: they\nalways stand for Boolean true and false values in Python. They’re available for use\nin truth tests and variable initialization and are printed for expression results at the\ninteractive prompt.\n\nTest Your Knowledge: Answers | 325\n\n\f\fCHAPTER 13\n\nwhile and for Loops",
    "This chapter concludes our tour of Python procedural statements by presenting the\nlanguage’s two main looping constructs—statements that repeat an action over and\nover. The first of these, the while statement, provides a way to code general loops. The\nsecond, the for statement, is designed for stepping through the items in a sequence\nobject and running a block of code for each.\nWe’ve seen both of these informally already, but we’ll fill in additional usage details\nhere. While we’re at it, we’ll also study a few less prominent statements used within\nloops, such as break and continue, and cover some built-ins commonly used with loops,\nsuch as range, zip, and map.\nAlthough the while and for statements covered here are the primary syntax provided\nfor coding repeated actions, there are additional looping operations and concepts in\nPython. Because of that, the iteration story is continued in the next chapter, where we’ll",
    "loops, such as break and continue, and cover some built-ins commonly used with loops,\nsuch as range, zip, and map.\nAlthough the while and for statements covered here are the primary syntax provided\nfor coding repeated actions, there are additional looping operations and concepts in\nPython. Because of that, the iteration story is continued in the next chapter, where we’ll\nexplore the related ideas of Python’s iteration protocol (used by the for loop) and list\ncomprehensions (a close cousin to the for loop). Later chapters explore even more exotic\niteration tools such as generators, filter, and reduce. For now, though, let’s keep things\nsimple.",
    "while Loops\nPython’s while statement is the most general iteration construct in the language. In\nsimple terms, it repeatedly executes a block of (normally indented) statements as long\nas a test at the top keeps evaluating to a true value. It is called a “loop” because control\nkeeps looping back to the start of the statement until the test becomes false. When the\ntest becomes false, control passes to the statement that follows the while block. The\nnet effect is that the loop’s body is executed repeatedly while the test at the top is true;\nif the test is false to begin with, the body never runs.\n\n327",
    "327\n\n\fGeneral Format\nIn its most complex form, the while statement consists of a header line with a test\nexpression, a body of one or more indented statements, and an optional else part that\nis executed if control exits the loop without a break statement being encountered. Python keeps evaluating the test at the top and executing the statements nested in the\nloop body until the test returns a false value:\nwhile <test>:\n<statements1>\nelse:\n<statements2>\n\n# Loop test\n# Loop body\n# Optional else\n# Run if didn't exit loop with break",
    "# Loop test\n# Loop body\n# Optional else\n# Run if didn't exit loop with break\n\nExamples\nTo illustrate, let’s look at a few simple while loops in action. The first, which consists\nof a print statement nested in a while loop, just prints a message forever. Recall that\nTrue is just a custom version of the integer 1 and always stands for a Boolean true value;\nbecause the test is always true, Python keeps executing the body forever, or until you\nstop its execution. This sort of behavior is usually called an infinite loop:\n>>> while True:\n...\nprint('Type Ctrl-C to stop me!')\n\nThe next example keeps slicing off the first character of a string until the string is empty\nand hence false. It’s typical to test an object directly like this instead of using the more\nverbose equivalent (while x != '':). Later in this chapter, we’ll see other ways to step\nmore directly through the items in a string with a for loop.\n>>> x = 'spam'\n>>> while x:\n...\nprint(x, end=' ')\n...\nx = x[1:]\n...\nspam pam am m",
    "# While x is not empty\n# Strip first character off x\n\nNote the end=' ' keyword argument used here to place all outputs on the same line\nseparated by a space; see Chapter 11 if you’ve forgotten why this works as it does. The\nfollowing code counts from the value of a up to, but not including, b. We’ll see an easier\nway to do this with a Python for loop and the built-in range function later:\n>>> a=0; b=10\n>>> while a < b:\n...\nprint(a, end=' ')\n...\na += 1\n...\n0 1 2 3 4 5 6 7 8 9\n\n# One way to code counter loops\n# Or, a = a + 1\n\nFinally, notice that Python doesn’t have what some languages call a “do until” loop\nstatement. However, we can simulate one with a test and break at the bottom of the\nloop body:\n\n328 | Chapter 13: while and for Loops\n\n\fwhile True:\n...loop body...\nif exitTest(): break\n\nTo fully understand how this structure works, we need to move on to the next section\nand learn more about the break statement.",
    "Finally, notice that Python doesn’t have what some languages call a “do until” loop\nstatement. However, we can simulate one with a test and break at the bottom of the\nloop body:\n\n328 | Chapter 13: while and for Loops\n\n\fwhile True:\n...loop body...\nif exitTest(): break\n\nTo fully understand how this structure works, we need to move on to the next section\nand learn more about the break statement.\n\nbreak, continue, pass, and the Loop else\nNow that we’ve seen a few Python loops in action, it’s time to take a look at two simple\nstatements that have a purpose only when nested inside loops—the break and\ncontinue statements. While we’re looking at oddballs, we will also study the loop\nelse clause here, because it is intertwined with break, and Python’s empty placeholder\nstatement, the pass (which is not tied to loops per se, but falls into the general category\nof simple one-word statements). In Python:\nbreak\n\nJumps out of the closest enclosing loop (past the entire loop statement)\ncontinue",
    "Jumps out of the closest enclosing loop (past the entire loop statement)\ncontinue\n\nJumps to the top of the closest enclosing loop (to the loop’s header line)\npass\n\nDoes nothing at all: it’s an empty statement placeholder\nLoop else block\n\nRuns if and only if the loop is exited normally (i.e., without hitting a break)\n\nGeneral Loop Format\nFactoring in break and continue statements, the general format of the while loop looks\nlike this:\nwhile <test1>:\n<statements1>\nif <test2>: break\nif <test3>: continue\nelse:\n<statements2>\n\n# Exit loop now, skip else\n# Go to top of loop now, to test1\n# Run if we didn't hit a 'break'\n\nbreak and continue statements can appear anywhere inside the while (or for) loop’s\nbody, but they are usually coded further nested in an if test to take action in response\n\nto some condition.\nLet’s turn to a few simple examples to see how these statements come together in\npractice.\n\nbreak, continue, pass, and the Loop else | 329",
    "break and continue statements can appear anywhere inside the while (or for) loop’s\nbody, but they are usually coded further nested in an if test to take action in response\n\nto some condition.\nLet’s turn to a few simple examples to see how these statements come together in\npractice.\n\nbreak, continue, pass, and the Loop else | 329\n\n\fpass\nSimple things first: the pass statement is a no-operation placeholder that is used when\nthe syntax requires a statement, but you have nothing useful to say. It is often used to\ncode an empty body for a compound statement. For instance, if you want to code an\ninfinite loop that does nothing each time through, do it with a pass:\nwhile True: pass\n\n# Type Ctrl-C to stop me!",
    "# Type Ctrl-C to stop me!\n\nBecause the body is just an empty statement, Python gets stuck in this loop. pass is\nroughly to statements as None is to objects—an explicit nothing. Notice that here the\nwhile loop’s body is on the same line as the header, after the colon; as with if statements, this only works if the body isn’t a compound statement.\nThis example does nothing forever. It probably isn’t the most useful Python program\never written (unless you want to warm up your laptop computer on a cold winter’s\nday!); frankly, though, I couldn’t think of a better pass example at this point in the book.\nWe’ll see other places where pass makes more sense later—for instance, to ignore exceptions caught by try statements, and to define empty class objects with attributes\nthat behave like “structs” and “records” in other languages. A pass is also sometime\ncoded to mean “to be filled in later,” to stub out the bodies of functions temporarily:\ndef func1():\npass\n\n# Add real code here later",
    "# Add real code here later\n\ndef func2():\npass\n\nWe can’t leave the body empty without getting a syntax error, so we say pass instead.\nVersion skew note: Python 3.0 (but not 2.6) allows ellipses coded\nas ... (literally, three consecutive dots) to appear any place an expression can. Because ellipses do nothing by themselves, this can serve as\nan alternative to the pass statement, especially for code to be filled in\nlater—a sort of Python “TBD”:\ndef func1():\n...\n\n# Alternative to pass\n\ndef func2():\n...\nfunc1()\n\n# Does nothing if called\n\nEllipses can also appear on the same line as a statement header and may\nbe used to initialize variable names if no specific type is required:\ndef func1(): ...\ndef func2(): ...\n\n# Works on same line too\n\n>>> X = ...\n\n# Alternative to None\n\n330 | Chapter 13: while and for Loops\n\n\f>>> X\nEllipsis",
    "# Alternative to pass\n\ndef func2():\n...\nfunc1()\n\n# Does nothing if called\n\nEllipses can also appear on the same line as a statement header and may\nbe used to initialize variable names if no specific type is required:\ndef func1(): ...\ndef func2(): ...\n\n# Works on same line too\n\n>>> X = ...\n\n# Alternative to None\n\n330 | Chapter 13: while and for Loops\n\n\f>>> X\nEllipsis\n\nThis notation is new in Python 3.0 (and goes well beyond the original\nintent of ... in slicing extensions), so time will tell if it becomes widespread enough to challenge pass and None in these roles.",
    "# Works on same line too\n\n>>> X = ...\n\n# Alternative to None\n\n330 | Chapter 13: while and for Loops\n\n\f>>> X\nEllipsis\n\nThis notation is new in Python 3.0 (and goes well beyond the original\nintent of ... in slicing extensions), so time will tell if it becomes widespread enough to challenge pass and None in these roles.\n\ncontinue\nThe continue statement causes an immediate jump to the top of a loop. It also sometimes lets you avoid statement nesting. The next example uses continue to skip odd\nnumbers. This code prints all even numbers less than 10 and greater than or equal to\n0. Remember, 0 means false and % is the remainder of division operator, so this loop\ncounts down to 0, skipping numbers that aren’t multiples of 2 (it prints 8 6 4 2 0):\nx = 10\nwhile x:\nx = x−1\nif x % 2 != 0: continue\nprint(x, end=' ')\n\n# Or, x -= 1\n# Odd? -- skip print",
    "# Or, x -= 1\n# Odd? -- skip print\n\nBecause continue jumps to the top of the loop, you don’t need to nest the print statement inside an if test; the print is only reached if the continue is not run. If this sounds\nsimilar to a “goto” in other languages, it should. Python has no “goto” statement, but\nbecause continue lets you jump about in a program, many of the warnings about readability and maintainability you may have heard about goto apply. continue should\nprobably be used sparingly, especially when you’re first getting started with Python.\nFor instance, the last example might be clearer if the print were nested under the if:\nx = 10\nwhile x:\nx = x−1\nif x % 2 == 0:\nprint(x, end=' ')\n\n# Even? -- print",
    "# Even? -- print\n\nbreak\nThe break statement causes an immediate exit from a loop. Because the code that follows it in the loop is not executed if the break is reached, you can also sometimes avoid\nnesting by including a break. For example, here is a simple interactive loop (a variant\nof a larger example we studied in Chapter 10) that inputs data with input (known as\nraw_input in Python 2.6) and exits when the user enters “stop” for the name request:\n>>> while True:\n...\nname = input('Enter name:')\n...\nif name == 'stop': break\n...\nage = input('Enter age: ')\n...\nprint('Hello', name, '=>', int(age) ** 2)\n...\nEnter name:mel\nEnter age: 40\n\nbreak, continue, pass, and the Loop else | 331\n\n\fHello mel => 1600\nEnter name:bob\nEnter age: 30\nHello bob => 900\nEnter name:stop",
    "break, continue, pass, and the Loop else | 331\n\n\fHello mel => 1600\nEnter name:bob\nEnter age: 30\nHello bob => 900\nEnter name:stop\n\nNotice how this code converts the age input to an integer with int before raising it to\nthe second power; as you’ll recall, this is necessary because input returns user input as\na string. In Chapter 35, you’ll see that input also raises an exception at end-of-file (e.g.,\nif the user types Ctrl-Z or Ctrl-D); if this matters, wrap input in try statements.\n\nLoop else\nWhen combined with the loop else clause, the break statement can often eliminate the\nneed for the search status flags used in other languages. For instance, the following\npiece of code determines whether a positive integer y is prime by searching for factors\ngreater than 1:\nx = y // 2\nwhile x > 1:\nif y % x == 0:\nprint(y, 'has factor', x)\nbreak\nx -= 1\nelse:\nprint(y, 'is prime')\n\n# For some y > 1\n# Remainder\n# Skip else\n# Normal exit",
    "Rather than setting a flag to be tested when the loop is exited, it inserts a break where\na factor is found. This way, the loop else clause can assume that it will be executed\nonly if no factor is found; if you don’t hit the break, the number is prime.\nThe loop else clause is also run if the body of the loop is never executed, as you don’t\nrun a break in that event either; in a while loop, this happens if the test in the header\nis false to begin with. Thus, in the preceding example you still get the “is prime” message\nif x is initially less than or equal to 1 (for instance, if y is 2).\nThis example determines primes, but only informally so. Numbers less\nthan 2 are not considered prime by the strict mathematical definition.\nTo be really picky, this code also fails for negative numbers and succeeds\nfor floating-point numbers with no decimal digits. Also note that its\ncode must use // instead of / in Python 3.0 because of the migration",
    "This example determines primes, but only informally so. Numbers less\nthan 2 are not considered prime by the strict mathematical definition.\nTo be really picky, this code also fails for negative numbers and succeeds\nfor floating-point numbers with no decimal digits. Also note that its\ncode must use // instead of / in Python 3.0 because of the migration\nof / to “true division,” as described in Chapter 5 (we need the initial\ndivision to truncate remainders, not retain them!). If you want to experiment with this code, be sure to see the exercise at the end of\nPart IV, which wraps it in a function for reuse.",
    "332 | Chapter 13: while and for Loops\n\n\fMore on the loop else\nBecause the loop else clause is unique to Python, it tends to perplex some newcomers.\nIn general terms, the loop else provides explicit syntax for a common coding scenario—\nit is a coding structure that lets us catch the “other” way out of a loop, without setting\nand checking flags or conditions.\nSuppose, for instance, that we are writing a loop to search a list for a value, and we\nneed to know whether the value was found after we exit the loop. We might code such\na task this way:\nfound = False\nwhile x and not found:\nif match(x[0]):\nprint('Ni')\nfound = True\nelse:\nx = x[1:]\nif not found:\nprint('not found')\n\n# Value at front?\n\n# Slice off front and repeat",
    "# Value at front?\n\n# Slice off front and repeat\n\nHere, we initialize, set, and later test a flag to determine whether the search succeeded\nor not. This is valid Python code, and it does work; however, this is exactly the sort of\nstructure that the loop else clause is there to handle. Here’s an else equivalent:\nwhile x:\nif match(x[0]):\nprint('Ni')\nbreak\nx = x[1:]\nelse:\nprint('Not found')\n\n# Exit when x empty\n# Exit, go around else\n# Only here if exhausted x",
    "# Exit when x empty\n# Exit, go around else\n# Only here if exhausted x\n\nThis version is more concise. The flag is gone, and we’ve replaced the if test at the loop\nend with an else (lined up vertically with the word while). Because the break inside the\nmain part of the while exits the loop and goes around the else, this serves as a more\nstructured way to catch the search-failure case.\nSome readers might have noticed that the prior example’s else clause could be replaced\nwith a test for an empty x after the loop (e.g., if not x:). Although that’s true in this\nexample, the else provides explicit syntax for this coding pattern (it’s more obviously\na search-failure clause here), and such an explicit empty test may not apply in some\ncases. The loop else becomes even more useful when used in conjunction with the\nfor loop—the topic of the next section—because sequence iteration is not under your\ncontrol.\n\nbreak, continue, pass, and the Loop else | 333",
    "break, continue, pass, and the Loop else | 333\n\n\fWhy You Will Care: Emulating C while Loops\nThe section on expression statements in Chapter 11 stated that Python doesn’t allow\nstatements such as assignments to appear in places where it expects an expression. That\nmeans this common C language coding pattern won’t work in Python:\nwhile ((x = next()) != NULL) {...process x...}\n\nC assignments return the value assigned, but Python assignments are just statements,\nnot expressions. This eliminates a notorious class of C errors (you can’t accidentally\ntype = in Python when you mean ==). If you need similar behavior, though, there are at\nleast three ways to get the same effect in Python while loops without embedding assignments in loop tests. You can move the assignment into the loop body with a break:\nwhile True:\nx = next()\nif not x: break\n...process x...\n\nor move the assignment into the loop with tests:\nx = True\nwhile x:\nx = next()\nif x:\n...process x...",
    "or move the assignment into the loop with tests:\nx = True\nwhile x:\nx = next()\nif x:\n...process x...\n\nor move the first assignment outside the loop:\nx = next()\nwhile x:\n...process x...\nx = next()\n\nOf these three coding patterns, the first may be considered by some to be the least\nstructured, but it also seems to be the simplest and is the most commonly used. A simple\nPython for loop may replace some C loops as well.\n\nfor Loops\nThe for loop is a generic sequence iterator in Python: it can step through the items in\nany ordered sequence object. The for statement works on strings, lists, tuples, other\nbuilt-in iterables, and new objects that we’ll see how to create later with classes. We\nmet it in brief when studying sequence object types; let’s expand on its usage more\nformally here.",
    "for Loops\nThe for loop is a generic sequence iterator in Python: it can step through the items in\nany ordered sequence object. The for statement works on strings, lists, tuples, other\nbuilt-in iterables, and new objects that we’ll see how to create later with classes. We\nmet it in brief when studying sequence object types; let’s expand on its usage more\nformally here.\n\nGeneral Format\nThe Python for loop begins with a header line that specifies an assignment target (or\ntargets), along with the object you want to step through. The header is followed by a\nblock of (normally indented) statements that you want to repeat:\n334 | Chapter 13: while and for Loops\n\n\ffor <target> in <object>:\n<statements>\nelse:\n<statements>\n\n# Assign object items to target\n# Repeated loop body: use target\n# If we didn't hit a 'break'",
    "When Python runs a for loop, it assigns the items in the sequence object to the target\none by one and executes the loop body for each. The loop body typically uses the\nassignment target to refer to the current item in the sequence as though it were a cursor\nstepping through the sequence.\nThe name used as the assignment target in a for header line is usually a (possibly new)\nvariable in the scope where the for statement is coded. There’s not much special about\nit; it can even be changed inside the loop’s body, but it will automatically be set to the\nnext item in the sequence when control returns to the top of the loop again. After the\nloop this variable normally still refers to the last item visited, which is the last item in\nthe sequence unless the loop exits with a break statement.\nThe for statement also supports an optional else block, which works exactly as it does\nin a while loop—it’s executed if the loop exits without running into a break statement",
    "loop this variable normally still refers to the last item visited, which is the last item in\nthe sequence unless the loop exits with a break statement.\nThe for statement also supports an optional else block, which works exactly as it does\nin a while loop—it’s executed if the loop exits without running into a break statement\n(i.e., if all items in the sequence have been visited). The break and continue statements\nintroduced earlier also work the same in a for loop as they do in a while. The for loop’s\ncomplete format can be described this way:\nfor <target> in <object>:\n<statements>\nif <test>: break\nif <test>: continue\nelse:\n<statements>",
    "# Assign object items to target\n# Exit loop now, skip else\n# Go to top of loop now\n# If we didn't hit a 'break'\n\nExamples\nLet’s type a few for loops interactively now, so you can see how they are used in practice.\n\nBasic usage\nAs mentioned earlier, a for loop can step across any kind of sequence object. In our\nfirst example, for instance, we’ll assign the name x to each of the three items in a list in\nturn, from left to right, and the print statement will be executed for each. Inside the\nprint statement (the loop body), the name x refers to the current item in the list:\n>>> for x in [\"spam\", \"eggs\", \"ham\"]:\n...\nprint(x, end=' ')\n...\nspam eggs ham\n\nThe next two examples compute the sum and product of all the items in a list. Later in\nthis chapter and later in the book we’ll meet tools that apply operations such as + and\n* to items in a list automatically, but it’s usually just as easy to use a for:\n\nfor Loops | 335",
    "The next two examples compute the sum and product of all the items in a list. Later in\nthis chapter and later in the book we’ll meet tools that apply operations such as + and\n* to items in a list automatically, but it’s usually just as easy to use a for:\n\nfor Loops | 335\n\n\f>>> sum = 0\n>>> for x in [1, 2, 3, 4]:\n...\nsum = sum + x\n...\n>>> sum\n10\n>>> prod = 1\n>>> for item in [1, 2, 3, 4]: prod *= item\n...\n>>> prod\n24\n\nOther data types\nAny sequence works in a for, as it’s a generic tool. For example, for loops work on\nstrings and tuples:\n>>> S = \"lumberjack\"\n>>> T = (\"and\", \"I'm\", \"okay\")\n>>> for x in S: print(x, end=' ')\n...\nl u m b e r j a c k\n\n# Iterate over a string\n\n>>> for x in T: print(x, end=' ')\n...\nand I'm okay\n\n# Iterate over a tuple\n\nIn fact, as we’ll in the next chapter when we explore the notion of “iterables,” for loops\ncan even work on some objects that are not sequences—files and dictionaries work, too!",
    "# Iterate over a string\n\n>>> for x in T: print(x, end=' ')\n...\nand I'm okay\n\n# Iterate over a tuple\n\nIn fact, as we’ll in the next chapter when we explore the notion of “iterables,” for loops\ncan even work on some objects that are not sequences—files and dictionaries work, too!\n\nTuple assignment in for loops\nIf you’re iterating through a sequence of tuples, the loop target itself can actually be a\ntuple of targets. This is just another case of the tuple-unpacking assignment we studied\nin Chapter 11 at work. Remember, the for loop assigns items in the sequence object\nto the target, and assignment works the same everywhere:\n>>> T = [(1, 2), (3, 4), (5, 6)]\n>>> for (a, b) in T:\n...\nprint(a, b)\n...\n1 2\n3 4\n5 6\n\n# Tuple assignment at work",
    "# Tuple assignment at work\n\nHere, the first time through the loop is like writing (a,b) = (1,2), the second time is\nlike writing (a,b) = (3,4), and so on. The net effect is to automatically unpack the\ncurrent tuple on each iteration.\nThis form is commonly used in conjunction with the zip call we’ll meet later in this\nchapter to implement parallel traversals. It also makes regular appearances in conjunction with SQL databases in Python, where query result tables are returned as sequences\n\n336 | Chapter 13: while and for Loops",
    "336 | Chapter 13: while and for Loops\n\n\fof sequences like the list used here—the outer list is the database table, the nested tuples\nare the rows within the table, and tuple assignment extracts columns.\nTuples in for loops also come in handy to iterate through both keys and values in\ndictionaries using the items method, rather than looping through the keys and indexing\nto fetch the values manually:\n>>> D = {'a': 1, 'b': 2, 'c': 3}\n>>> for key in D:\n...\nprint(key, '=>', D[key])\n...\na => 1\nc => 3\nb => 2\n\n# Use dict keys iterator and index\n\n>>> list(D.items())\n[('a', 1), ('c', 3), ('b', 2)]\n>>> for (key, value) in D.items():\n...\nprint(key, '=>', value)\n...\na => 1\nc => 3\nb => 2\n\n# Iterate over both keys and values",
    "# Use dict keys iterator and index\n\n>>> list(D.items())\n[('a', 1), ('c', 3), ('b', 2)]\n>>> for (key, value) in D.items():\n...\nprint(key, '=>', value)\n...\na => 1\nc => 3\nb => 2\n\n# Iterate over both keys and values\n\nIt’s important to note that tuple assignment in for loops isn’t a special case; any assignment target works syntactically after the word for. Although we can always assign\nmanually within the loop to unpack:\n>>> T\n[(1, 2), (3, 4), (5, 6)]\n>>> for both in T:\n...\na, b = both\n...\nprint(a, b)\n...\n1 2\n3 4\n5 6\n\n# Manual assignment equivalent\n\nTuples in the loop header save us an extra step when iterating through sequences of\nsequences. As suggested in Chapter 11, even nested structures may be automatically\nunpacked this way in a for:\n>>> ((a, b), c) = ((1, 2), 3)\n>>> a, b, c\n(1, 2, 3)\n\n# Nested sequences work too\n\n>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)\n...\n1 2 3\n4 5 6\n\nfor Loops | 337",
    "Tuples in the loop header save us an extra step when iterating through sequences of\nsequences. As suggested in Chapter 11, even nested structures may be automatically\nunpacked this way in a for:\n>>> ((a, b), c) = ((1, 2), 3)\n>>> a, b, c\n(1, 2, 3)\n\n# Nested sequences work too\n\n>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)\n...\n1 2 3\n4 5 6\n\nfor Loops | 337\n\n\fBut this is no special case—the for loop simply runs the sort of assignment we ran just\nbefore it, on each iteration. Any nested sequence structure may be unpacked this way,\njust because sequence assignment is so generic:\n>>> for ((a, b), c) in [([1, 2], 3), ['XY', 6]]: print(a, b, c)\n...\n1 2 3\nX Y 6",
    "Python 3.0 extended sequence assignment in for loops\nIn fact, because the loop variable in a for loop can really be any assignment target, we\ncan also use Python 3.0’s extended sequence-unpacking assignment syntax here to\nextract items and sections of sequences within sequences. Really, this isn’t a special\ncase either, but simply a new assignment form in 3.0 (as discussed in Chapter 11);\nbecause it works in assignment statements, it automatically works in for loops.\nConsider the tuple assignment form introduced in the prior section. A tuple of values\nis assigned to a tuple of names on each iteration, exactly like a simple assignment\nstatement:\n>>> a, b, c = (1, 2, 3)\n>>> a, b, c\n(1, 2, 3)\n\n# Tuple assignment\n\n>>> for (a, b, c) in [(1, 2, 3), (4, 5, 6)]:\n...\nprint(a, b, c)\n...\n1 2 3\n4 5 6\n\n# Used in for loop",
    "# Tuple assignment\n\n>>> for (a, b, c) in [(1, 2, 3), (4, 5, 6)]:\n...\nprint(a, b, c)\n...\n1 2 3\n4 5 6\n\n# Used in for loop\n\nIn Python 3.0, because a sequence can be assigned to a more general set of names with\na starred name to collect multiple items, we can use the same syntax to extract parts of\nnested sequences in the for loop:\n>>> a, *b, c = (1, 2, 3, 4)\n>>> a, b, c\n(1, [2, 3], 4)\n\n# Extended seq assignment\n\n>>> for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:\n...\nprint(a, b, c)\n...\n1 [2, 3] 4\n5 [6, 7] 8\n\nIn practice, this approach might be used to pick out multiple columns from rows of\ndata represented as nested sequences. In Python 2.X starred names aren’t allowed, but\nyou can achieve similar effects by slicing. The only difference is that slicing returns a\ntype-specific result, whereas starred names always are assigned lists:\n>>> for all in [(1, 2, 3, 4), (5, 6, 7, 8)]:\n...\na, b, c = all[0], all[1:3], all[3]\n...\nprint(a, b, c)\n\n338 | Chapter 13: while and for Loops",
    "338 | Chapter 13: while and for Loops\n\n# Manual slicing in 2.6\n\n\f...\n1 (2, 3) 4\n5 (6, 7) 8\n\nSee Chapter 11 for more on this assignment form.\n\nNested for loops\nNow let’s look at a for loop that’s a bit more sophisticated than those we’ve seen so\nfar. The next example illustrates statement nesting and the loop else clause in a for.\nGiven a list of objects (items) and a list of keys (tests), this code searches for each key\nin the objects list and reports on the search’s outcome:\n>>> items = [\"aaa\", 111, (4, 5), 2.01]\n>>> tests = [(4, 5), 3.14]\n>>>\n>>> for key in tests:\n...\nfor item in items:\n...\nif item == key:\n...\nprint(key, \"was found\")\n...\nbreak\n...\nelse:\n...\nprint(key, \"not found!\")\n...\n(4, 5) was found\n3.14 not found!\n\n# A set of objects\n# Keys to search for\n# For all keys\n# For all items\n# Check for match",
    "# A set of objects\n# Keys to search for\n# For all keys\n# For all items\n# Check for match\n\nBecause the nested if runs a break when a match is found, the loop else clause can\nassume that if it is reached, the search has failed. Notice the nesting here. When this\ncode runs, there are two loops going at the same time: the outer loop scans the keys\nlist, and the inner loop scans the items list for each key. The nesting of the loop else\nclause is critical; it’s indented to the same level as the header line of the inner for loop,\nso it’s associated with the inner loop, not the if or the outer for.\nNote that this example is easier to code if we employ the in operator to test membership.\nBecause in implicitly scans an object looking for a match (at least logically), it replaces\nthe inner loop:\n>>> for key in tests:\n...\nif key in items:\n...\nprint(key, \"was found\")\n...\nelse:\n...\nprint(key, \"not found!\")\n...\n(4, 5) was found\n3.14 not found!\n\n# For all keys\n# Let Python check for a match",
    "# For all keys\n# Let Python check for a match\n\nIn general, it’s a good idea to let Python do as much of the work as possible (as in this\nsolution) for the sake of brevity and performance.\nThe next example performs a typical data-structure task with a for—collecting common items in two sequences (strings). It’s roughly a simple set intersection routine;\nafter the loop runs, res refers to a list that contains all the items found in seq1 and seq2:\nfor Loops | 339\n\n\f>>> seq1 = \"spam\"\n>>> seq2 = \"scam\"\n>>>\n>>> res = []\n>>> for x in seq1:\n...\nif x in seq2:\n...\nres.append(x)\n...\n>>> res\n['s', 'a', 'm']\n\n# Start empty\n# Scan first sequence\n# Common item?\n# Add to result end\n\nUnfortunately, this code is equipped to work only on two specific variables: seq1 and\nseq2. It would be nice if this loop could somehow be generalized into a tool you could\nuse more than once. As you’ll see, that simple idea leads us to functions, the topic of\nthe next part of the book.",
    "# Start empty\n# Scan first sequence\n# Common item?\n# Add to result end\n\nUnfortunately, this code is equipped to work only on two specific variables: seq1 and\nseq2. It would be nice if this loop could somehow be generalized into a tool you could\nuse more than once. As you’ll see, that simple idea leads us to functions, the topic of\nthe next part of the book.\n\nWhy You Will Care: File Scanners\nIn general, loops come in handy anywhere you need to repeat an operation or process\nsomething more than once. Because files contain multiple characters and lines, they\nare one of the more typical use cases for loops. To load a file’s contents into a string all\nat once, you simply call the file object’s read method:\nfile = open('test.txt', 'r')\nprint(file.read())\n\n# Read contents into a string",
    "# Read contents into a string\n\nBut to load a file in smaller pieces, it’s common to code either a while loop with breaks\non end-of-file, or a for loop. To read by characters, either of the following codings will\nsuffice:\nfile = open('test.txt')\nwhile True:\nchar = file.read(1)\nif not char: break\nprint(char)\n\n# Read by character\n\nfor char in open('test.txt').read():\nprint(char)\n\nThe for loop here also processes each character, but it loads the file into memory all at\nonce (and assumes it fits!). To read by lines or blocks instead, you can use while loop\ncode like this:\nfile = open('test.txt')\nwhile True:\nline = file.readline()\nif not line: break\nprint(line, end='')\n\n# Read line by line\n\nfile = open('test.txt', 'rb')\nwhile True:\nchunk = file.read(10)\nif not chunk: break\nprint(chunk)\n\n# Read byte chunks: up to 10 bytes\n\n340 | Chapter 13: while and for Loops\n\n# Line already has a \\n",
    "# Read line by line\n\nfile = open('test.txt', 'rb')\nwhile True:\nchunk = file.read(10)\nif not chunk: break\nprint(chunk)\n\n# Read byte chunks: up to 10 bytes\n\n340 | Chapter 13: while and for Loops\n\n# Line already has a \\n\n\n\fYou typically read binary data in blocks. To read text files line by line, though, the\nfor loop tends to be easiest to code and the quickest to run:\nfor line in open('test.txt').readlines():\nprint(line, end='')\nfor line in open('test.txt'):\nprint(line, end='')\n\n# Use iterators: best text input mode",
    "The file readlines method loads a file all at once into a line-string list, and the last\nexample here relies on file iterators to automatically read one line on each loop iteration\n(iterators are covered in detail in Chapter 14). See the library manual for more on the\ncalls used here. The last example here is generally the best option for text files—besides\nits simplicity, it works for arbitrarily large files and doesn’t load the entire file into\nmemory all at once. The iterator version may be the quickest, but I/O performance is\nless clear-cut in Python 3.0.\nIn some 2.X Python code, you may also see the name open replaced with file and the\nfile object’s older xreadlines method used to achieve the same effect as the file’s automatic line iterator (it’s like readlines but doesn’t load the file into memory all at once).\nBoth file and xreadlines are removed in Python 3.0, because they are redundant; you\nshouldn’t use them in 2.6 either, but they may pop up in older code and resources.",
    "file object’s older xreadlines method used to achieve the same effect as the file’s automatic line iterator (it’s like readlines but doesn’t load the file into memory all at once).\nBoth file and xreadlines are removed in Python 3.0, because they are redundant; you\nshouldn’t use them in 2.6 either, but they may pop up in older code and resources.\nWatch for more on reading files in Chapter 36; as we’ll see there, text and binary files\nhave slightly different semantics in 3.0.",
    "Loop Coding Techniques\nThe for loop subsumes most counter-style loops. It’s generally simpler to code and\nquicker to run than a while, so it’s the first tool you should reach for whenever you\nneed to step through a sequence. But there are also situations where you will need to\niterate in more specialized ways. For example, what if you need to visit every second\nor third item in a list, or change the list along the way? How about traversing more than\none sequence in parallel, in the same for loop?\nYou can always code such unique iterations with a while loop and manual indexing,\nbut Python provides two built-ins that allow you to specialize the iteration in a for:\n• The built-in range function produces a series of successively higher integers, which\ncan be used as indexes in a for.\n• The built-in zip function returns a series of parallel-item tuples, which can be used\nto traverse multiple sequences in a for.",
    "but Python provides two built-ins that allow you to specialize the iteration in a for:\n• The built-in range function produces a series of successively higher integers, which\ncan be used as indexes in a for.\n• The built-in zip function returns a series of parallel-item tuples, which can be used\nto traverse multiple sequences in a for.\nBecause for loops typically run quicker than while-based counter loops, it’s to your\nadvantage to use tools like these that allow you to use for when possible. Let’s look at\neach of these built-ins in turn.",
    "Loop Coding Techniques | 341\n\n\fCounter Loops: while and range\nThe range function is really a general tool that can be used in a variety of contexts.\nAlthough it’s used most often to generate indexes in a for, you can use it anywhere you\nneed a list of integers. In Python 3.0, range is an iterator that generates items on demand,\nso we need to wrap it in a list call to display its results all at once (more on iterators\nin Chapter 14):\n>>> list(range(5)), list(range(2, 5)), list(range(0, 10, 2))\n([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8])",
    "With one argument, range generates a list of integers from zero up to but not including\nthe argument’s value. If you pass in two arguments, the first is taken as the lower bound.\nAn optional third argument can give a step; if it is used, Python adds the step to each\nsuccessive integer in the result (the step defaults to 1). Ranges can also be nonpositive\nand nonascending, if you want them to be:\n>>> list(range(−5, 5))\n[−5, −4, −3, −2, −1, 0, 1, 2, 3, 4]\n>>> list(range(5, −5, −1))\n[5, 4, 3, 2, 1, 0, −1, −2, −3, −4]\n\nAlthough such range results may be useful all by themselves, they tend to come in most\nhandy within for loops. For one thing, they provide a simple way to repeat an action\na specific number of times. To print three lines, for example, use a range to generate\nthe appropriate number of integers; for loops force results from range automatically in\n3.0, so we don’t need list here:\n>>> for i in range(3):\n...\nprint(i, 'Pythons')\n...\n0 Pythons\n1 Pythons\n2 Pythons",
    "range is also commonly used to iterate over a sequence indirectly. The easiest and fastest\nway to step through a sequence exhaustively is always with a simple for, as Python\n\nhandles most of the details for you:\n>>> X = 'spam'\n>>> for item in X: print(item, end=' ')\n...\ns p a m\n\n# Simple iteration\n\nInternally, the for loop handles the details of the iteration automatically when used\nthis way. If you really need to take over the indexing logic explicitly, you can do it with\na while loop:\n>>> i = 0\n>>> while i < len(X):\n...\nprint(X[i], end=' ')\n...\ni += 1\n\n342 | Chapter 13: while and for Loops\n\n# while loop iteration\n\n\f...\ns p a m",
    "# Simple iteration\n\nInternally, the for loop handles the details of the iteration automatically when used\nthis way. If you really need to take over the indexing logic explicitly, you can do it with\na while loop:\n>>> i = 0\n>>> while i < len(X):\n...\nprint(X[i], end=' ')\n...\ni += 1\n\n342 | Chapter 13: while and for Loops\n\n# while loop iteration\n\n\f...\ns p a m\n\nYou can also do manual indexing with a for, though, if you use range to generate a list\nof indexes to iterate through. It’s a multistep process, but it’s sufficient to generate\noffsets, rather than the items at those offsets:\n>>> X\n'spam'\n>>> len(X)\n# Length of string\n4\n>>> list(range(len(X)))\n# All legal offsets into X\n[0, 1, 2, 3]\n>>>\n>>> for i in range(len(X)): print(X[i], end=' ') # Manual for indexing\n...\ns p a m\n\nNote that because this example is stepping over a list of offsets into X, not the actual\nitems of X, we need to index back into X within the loop to fetch each item.",
    "Note that because this example is stepping over a list of offsets into X, not the actual\nitems of X, we need to index back into X within the loop to fetch each item.\n\nNonexhaustive Traversals: range and Slices\nThe last example in the prior section works, but it’s not the fastest option. It’s also\nmore work than we need to do. Unless you have a special indexing requirement, you’re\nalways better off using the simple for loop form in Python—as a general rule, use for\ninstead of while whenever possible, and don’t use range calls in for loops except as a\nlast resort. This simpler solution is better:\n>>> for item in X: print(item)\n...\n\n# Simple iteration\n\nHowever, the coding pattern used in the prior example does allow us to do more specialized sorts of traversals. For instance, we can skip items as we go:\n>>> S = 'abcdefghijk'\n>>> list(range(0, len(S), 2))\n[0, 2, 4, 6, 8, 10]\n>>> for i in range(0, len(S), 2): print(S[i], end=' ')\n...\na c e g i k",
    "# Simple iteration\n\nHowever, the coding pattern used in the prior example does allow us to do more specialized sorts of traversals. For instance, we can skip items as we go:\n>>> S = 'abcdefghijk'\n>>> list(range(0, len(S), 2))\n[0, 2, 4, 6, 8, 10]\n>>> for i in range(0, len(S), 2): print(S[i], end=' ')\n...\na c e g i k\n\nHere, we visit every second item in the string S by stepping over the generated range\nlist. To visit every third item, change the third range argument to be 3, and so on. In\neffect, using range this way lets you skip items in loops while still retaining the simplicity\nof the for loop construct.\nStill, this is probably not the ideal best-practice technique in Python today. If you really\nwant to skip items in a sequence, the extended three-limit form of the slice expression, presented in Chapter 7, provides a simpler route to the same goal. To visit every\nsecond character in S, for example, slice with a stride of 2:\n\nLoop Coding Techniques | 343",
    "Loop Coding Techniques | 343\n\n\f>>> S = 'abcdefghijk'\n>>> for c in S[::2]: print(c, end=' ')\n...\na c e g i k\n\nThe result is the same, but substantially easier for you to write and for others to read.\nThe only real advantage to using range here instead is that it does not copy the string\nand does not create a list in 3.0; for very large strings, it may save memory.\n\nChanging Lists: range\nAnother common place where you may use the range and for combination is in loops\nthat change a list as it is being traversed. Suppose, for example, that you need to add 1\nto every item in a list. You can try this with a simple for loop, but the result probably\nwon’t be exactly what you want:\n>>> L = [1, 2, 3, 4, 5]\n>>> for x in L:\n...\nx += 1\n...\n>>> L\n[1, 2, 3, 4, 5]\n>>> x\n6",
    "This doesn’t quite work—it changes the loop variable x, not the list L. The reason is\nsomewhat subtle. Each time through the loop, x refers to the next integer already pulled\nout of the list. In the first iteration, for example, x is integer 1. In the next iteration, the\nloop body sets x to a different object, integer 2, but it does not update the list where 1\noriginally came from.\nTo really change the list as we march across it, we need to use indexes so we can assign\nan updated value to each position as we go. The range/len combination can produce\nthe required indexes for us:\n>>> L = [1, 2, 3, 4, 5]\n>>> for i in range(len(L)):\n...\nL[i] += 1\n...\n>>> L\n[2, 3, 4, 5, 6]\n\n# Add one to each item in L\n# Or L[i] = L[i] + 1",
    "# Add one to each item in L\n# Or L[i] = L[i] + 1\n\nWhen coded this way, the list is changed as we proceed through the loop. There is no\nway to do the same with a simple for x in L:-style loop, because such a loop iterates\nthrough actual items, not list positions. But what about the equivalent while loop? Such\na loop requires a bit more work on our part, and likely runs more slowly:\n>>> i = 0\n>>> while i < len(L):\n...\nL[i] += 1\n\n344 | Chapter 13: while and for Loops\n\n\f...\ni += 1\n...\n>>> L\n[3, 4, 5, 6, 7]\n\nHere again, though, the range solution may not be ideal either. A list comprehension\nexpression of the form:\n[x+1 for x in L]\n\nwould do similar work, albeit without changing the original list in-place (we could\nassign the expression’s new list object result back to L, but this would not update any\nother references to the original list). Because this is such a central looping concept, we’ll\nsave a complete exploration of list comprehensions for the next chapter.",
    "would do similar work, albeit without changing the original list in-place (we could\nassign the expression’s new list object result back to L, but this would not update any\nother references to the original list). Because this is such a central looping concept, we’ll\nsave a complete exploration of list comprehensions for the next chapter.\n\nParallel Traversals: zip and map\nAs we’ve seen, the range built-in allows us to traverse sequences with for in a nonexhaustive fashion. In the same spirit, the built-in zip function allows us to use for loops\nto visit multiple sequences in parallel. In basic operation, zip takes one or more sequences as arguments and returns a series of tuples that pair up parallel items taken\nfrom those sequences. For example, suppose we’re working with two lists:\n>>> L1 = [1,2,3,4]\n>>> L2 = [5,6,7,8]",
    "To combine the items in these lists, we can use zip to create a list of tuple pairs (like\nrange, zip is an iterable object in 3.0, so we must wrap it in a list call to display all its\nresults at once—more on iterators in the next chapter):\n>>> zip(L1, L2)\n<zip object at 0x026523C8>\n>>> list(zip(L1, L2))\n[(1, 5), (2, 6), (3, 7), (4, 8)]\n\n# list() required in 3.0, not 2.6\n\nSuch a result may be useful in other contexts as well, but when wedded with the for\nloop, it supports parallel iterations:\n>>> for (x, y) in zip(L1, L2):\n...\nprint(x, y, '--', x+y)\n...\n1 5 -- 6\n2 6 -- 8\n3 7 -- 10\n4 8 -- 12\n\nHere, we step over the result of the zip call—that is, the pairs of items pulled from the\ntwo lists. Notice that this for loop again uses the tuple assignment form we met earlier\nto unpack each tuple in the zip result. The first time through, it’s as though we ran the\nassignment statement (x, y) = (1, 5).\n\nLoop Coding Techniques | 345",
    "Loop Coding Techniques | 345\n\n\fThe net effect is that we scan both L1 and L2 in our loop. We could achieve a similar\neffect with a while loop that handles indexing manually, but it would require more\ntyping and would likely run more slowly than the for/zip approach.\nStrictly speaking, the zip function is more general than this example suggests. For instance, it accepts any type of sequence (really, any iterable object, including files), and\nit accepts more than two arguments. With three arguments, as in the following example, it builds a list of three-item tuples with items from each sequence, essentially projecting by columns (technically, we get an N-ary tuple for N arguments):\n>>> T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9)\n>>> T3\n(7, 8, 9)\n>>> list(zip(T1, T2, T3))\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)]",
    "Moreover, zip truncates result tuples at the length of the shortest sequence when the\nargument lengths differ. In the following, we zip together two strings to pick out characters in parallel, but the result has only as many tuples as the length of the shortest\nsequence:\n>>> S1 = 'abc'\n>>> S2 = 'xyz123'\n>>>\n>>> list(zip(S1, S2))\n[('a', 'x'), ('b', 'y'), ('c', 'z')]\n\nmap equivalence in Python 2.6\nIn Python 2.X, the related built-in map function pairs items from sequences in a similar\nfashion, but it pads shorter sequences with None if the argument lengths differ instead\nof truncating to the shortest length:\n>>> S1 = 'abc'\n>>> S2 = 'xyz123'\n>>> map(None, S1, S2)\n# 2.X only\n[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None,'3')]",
    "map equivalence in Python 2.6\nIn Python 2.X, the related built-in map function pairs items from sequences in a similar\nfashion, but it pads shorter sequences with None if the argument lengths differ instead\nof truncating to the shortest length:\n>>> S1 = 'abc'\n>>> S2 = 'xyz123'\n>>> map(None, S1, S2)\n# 2.X only\n[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None,'3')]\n\nThis example is using a degenerate form of the map built-in, which is no longer supported\nin 3.0. Normally, map takes a function and one or more sequence arguments and collects\nthe results of calling the function with parallel items taken from the sequence(s). We’ll\nstudy map in detail in Chapters 19 and 20, but as a brief example, the following maps\nthe built-in ord function across each item in a string and collects the results (like zip,\nmap is a value generator in 3.0 and so must be passed to list to collect all its results at\nonce):\n>>> list(map(ord, 'spam'))\n[115, 112, 97, 109]",
    "346 | Chapter 13: while and for Loops\n\n\fThis works the same as the following loop statement, but is often quicker:\n>>> res = []\n>>> for c in 'spam': res.append(ord(c))\n>>> res\n[115, 112, 97, 109]\n\nVersion skew note: The degenerate form of map using a function argument of None is no longer supported in Python 3.0, because it largely\noverlaps with zip (and was, frankly, a bit at odds with map’s functionapplication purpose). In 3.0, either use zip or write loop code to pad\nresults yourself. We’ll see how to do this in Chapter 20, after we’ve had\na chance to study some additional iteration concepts.",
    "Dictionary construction with zip\nIn Chapter 8, I suggested that the zip call used here can also be handy for generating\ndictionaries when the sets of keys and values must be computed at runtime. Now that\nwe’re becoming proficient with zip, I’ll explain how it relates to dictionary construction. As you’ve learned, you can always create a dictionary by coding a dictionary literal,\nor by assigning to keys over time:\n>>> D1 = {'spam':1, 'eggs':3, 'toast':5}\n>>> D1\n{'toast': 5, 'eggs': 3, 'spam': 1}\n>>> D1 = {}\n>>> D1['spam'] = 1\n>>> D1['eggs'] = 3\n>>> D1['toast'] = 5\n\nWhat to do, though, if your program obtains dictionary keys and values in lists at\nruntime, after you’ve coded your script? For example, say you had the following keys\nand values lists:\n>>> keys = ['spam', 'eggs', 'toast']\n>>> vals = [1, 3, 5]",
    "What to do, though, if your program obtains dictionary keys and values in lists at\nruntime, after you’ve coded your script? For example, say you had the following keys\nand values lists:\n>>> keys = ['spam', 'eggs', 'toast']\n>>> vals = [1, 3, 5]\n\nOne solution for turning those lists into a dictionary would be to zip the lists and step\nthrough them in parallel with a for loop:\n>>> list(zip(keys, vals))\n[('spam', 1), ('eggs', 3), ('toast', 5)]\n>>> D2 = {}\n>>> for (k, v) in zip(keys, vals): D2[k] = v\n...\n>>> D2\n{'toast': 5, 'eggs': 3, 'spam': 1}\n\nLoop Coding Techniques | 347\n\n\fIt turns out, though, that in Python 2.2 and later you can skip the for loop altogether\nand simply pass the zipped keys/values lists to the built-in dict constructor call:\n>>> keys = ['spam', 'eggs', 'toast']\n>>> vals = [1, 3, 5]\n>>> D3 = dict(zip(keys, vals))\n>>> D3\n{'toast': 5, 'eggs': 3, 'spam': 1}",
    "Loop Coding Techniques | 347\n\n\fIt turns out, though, that in Python 2.2 and later you can skip the for loop altogether\nand simply pass the zipped keys/values lists to the built-in dict constructor call:\n>>> keys = ['spam', 'eggs', 'toast']\n>>> vals = [1, 3, 5]\n>>> D3 = dict(zip(keys, vals))\n>>> D3\n{'toast': 5, 'eggs': 3, 'spam': 1}\n\nThe built-in name dict is really a type name in Python (you’ll learn more about type\nnames, and subclassing them, in Chapter 31). Calling it achieves something like a listto-dictionary conversion, but it’s really an object construction request. In the next\nchapter we’ll explore a related but richer concept, the list comprehension, which builds\nlists in a single expression; we’ll also revisit 3.0 dictionary comprehensions an alternative\nto the dict cal for zipped key/value pairs.",
    "Generating Both Offsets and Items: enumerate\nEarlier, we discussed using range to generate the offsets of items in a string, rather than\nthe items at those offsets. In some programs, though, we need both: the item to use,\nplus an offset as we go. Traditionally, this was coded with a simple for loop that also\nkept a counter of the current offset:\n>>> S = 'spam'\n>>> offset = 0\n>>> for item in S:\n...\nprint(item, 'appears at offset', offset)\n...\noffset += 1\n...\ns appears at offset 0\np appears at offset 1\na appears at offset 2\nm appears at offset 3\n\nThis works, but in recent Python releases a new built-in named enumerate does the job\nfor us:\n>>> S = 'spam'\n>>> for (offset, item) in enumerate(S):\n...\nprint(item, 'appears at offset', offset)\n...\ns appears at offset 0\np appears at offset 1\na appears at offset 2\nm appears at offset 3",
    "This works, but in recent Python releases a new built-in named enumerate does the job\nfor us:\n>>> S = 'spam'\n>>> for (offset, item) in enumerate(S):\n...\nprint(item, 'appears at offset', offset)\n...\ns appears at offset 0\np appears at offset 1\na appears at offset 2\nm appears at offset 3\n\nThe enumerate function returns a generator object—a kind of object that supports the\niteration protocol that we will study in the next chapter and will discuss in more detail\nin the next part of the book. In short, it has a __next__ method called by the next builtin function, which returns an (index, value) tuple each time through the loop. We can\nunpack these tuples with tuple assignment in the for loop (much like using zip):\n348 | Chapter 13: while and for Loops\n\n\f>>> E = enumerate(S)\n>>> E\n<enumerate object at 0x02765AA8>\n>>> next(E)\n(0, 's')\n>>> next(E)\n(1, 'p')\n>>> next(E)\n(2, 'a')",
    ">>> E = enumerate(S)\n>>> E\n<enumerate object at 0x02765AA8>\n>>> next(E)\n(0, 's')\n>>> next(E)\n(1, 'p')\n>>> next(E)\n(2, 'a')\n\nAs usual, we don’t normally see this machinery because iteration contexts—\nincluding list comprehensions, the subject of Chapter 14—run the iteration protocol\nautomatically:\n>>> [c * i for (i, c) in enumerate(S)]\n['', 'p', 'aa', 'mmm']\n\nTo fully understand iteration concepts like enumerate, zip, and list comprehensions,\nwe need to move on to the next chapter for a more formal dissection.",
    "Chapter Summary\nIn this chapter, we explored Python’s looping statements as well as some concepts\nrelated to looping in Python. We looked at the while and for loop statements in depth,\nand we learned about their associated else clauses. We also studied the break and\ncontinue statements, which have meaning only inside loops, and met several built-in\ntools commonly used in for loops, including range, zip, map, and enumerate (although\ntheir roles as iterators in Python 3.0 won’t be fully uncovered until the next chapter).\nIn the next chapter, we continue the iteration story by discussing list comprehensions\nand the iteration protocol in Python—concepts strongly related to for loops. There,\nwe’ll also explain some of the subtleties of iterable tools we met here, such as range and\nzip. As always, though, before moving on let’s exercise what you’ve picked up here\nwith a quiz.",
    "Test Your Knowledge: Quiz\n1. What are the main functional differences between a while and a for?\n2. What’s the difference between break and continue?\n3. When is a loop’s else clause executed?\n4. How can you code a counter-based loop in Python?\n5. What can a range be used for in a for loop?\n\nTest Your Knowledge: Quiz | 349",
    "Test Your Knowledge: Answers\n1. The while loop is a general looping statement, but the for is designed to iterate\nacross items in a sequence (really, iterable). Although the while can imitate the\nfor with counter loops, it takes more code and might run slower.\n2. The break statement exits a loop immediately (you wind up below the entire\nwhile or for loop statement), and continue jumps back to the top of the loop (you\nwind up positioned just before the test in while or the next item fetch in for).\n3. The else clause in a while or for loop will be run once as the loop is exiting, if the\nloop exits normally (without running into a break statement). A break exits the\nloop immediately, skipping the else part on the way out (if there is one).\n4. Counter loops can be coded with a while statement that keeps track of the index\nmanually, or with a for loop that uses the range built-in function to generate successive integer offsets. Neither is the preferred way to work in Python, if you need",
    "loop immediately, skipping the else part on the way out (if there is one).\n4. Counter loops can be coded with a while statement that keeps track of the index\nmanually, or with a for loop that uses the range built-in function to generate successive integer offsets. Neither is the preferred way to work in Python, if you need\nto simply step across all the items in a sequence. Instead, use a simple for loop\ninstead, without range or counters, whenever possible; it will be easier to code and\nusually quicker to run.\n5. The range built-in can be used in a for to implement a fixed number of repetitions,\nto scan by offsets instead of items at offsets, to skip successive items as you go, and\nto change a list while stepping across it. None of these roles requires range, and\nmost have alternatives—scanning actual items, three-limit slices, and list comprehensions are often better solutions today (despite the natural inclinations of ex-C\nprogrammers to want to count things!).",
    "350 | Chapter 13: while and for Loops\n\n\fCHAPTER 14\n\nIterations and Comprehensions, Part 1",
    "In the prior chapter we met Python’s two looping statements, while and for. Although\nthey can handle most repetitive tasks programs need to perform, the need to iterate\nover sequences is so common and pervasive that Python provides additional tools to\nmake it simpler and more efficient. This chapter begins our exploration of these tools.\nSpecifically, it presents the related concepts of Python’s iteration protocol—a methodcall model used by the for loop—and fills in some details on list comprehensions—a\nclose cousin to the for loop that applies an expression to items in an iterable.\nBecause both of these tools are related to both the for loop and functions, we’ll take a\ntwo-pass approach to covering them in this book: this chapter introduces the basics in\nthe context of looping tools, serving as something of continuation of the prior chapter,\nand a later chapter (Chapter 20) revisits them in the context of function-based tools.",
    "Because both of these tools are related to both the for loop and functions, we’ll take a\ntwo-pass approach to covering them in this book: this chapter introduces the basics in\nthe context of looping tools, serving as something of continuation of the prior chapter,\nand a later chapter (Chapter 20) revisits them in the context of function-based tools.\nIn this chapter, we’ll also sample additional iteration tools in Python and touch on the\nnew iterators available in Python 3.0.\nOne note up front: some of the concepts presented in these chapters may seem advanced at first glance. With practice, though, you’ll find that these tools are useful and\npowerful. Although never strictly required, because they’ve become commonplace in\nPython code, a basic understanding can also help if you must read programs written\nby others.",
    "Iterators: A First Look\nIn the preceding chapter, I mentioned that the for loop can work on any sequence type\nin Python, including lists, tuples, and strings, like this:\n>>> for x in [1, 2, 3, 4]: print(x ** 2, end=' ')\n...\n1 4 9 16\n>>> for x in (1, 2, 3, 4): print(x ** 3, end=' ')\n...\n1 8 27 64\n\n351\n\n\f>>> for x in 'spam': print(x * 2, end=' ')\n...\nss pp aa mm",
    "351\n\n\f>>> for x in 'spam': print(x * 2, end=' ')\n...\nss pp aa mm\n\nActually, the for loop turns out to be even more generic than this—it works on any\niterable object. In fact, this is true of all iteration tools that scan objects from left to right\nin Python, including for loops, the list comprehensions we’ll study in this chapter, in\nmembership tests, the map built-in function, and more.\nThe concept of “iterable objects” is relatively recent in Python, but it has come to\npermeate the language’s design. It’s essentially a generalization of the notion of sequences—an object is considered iterable if it is either a physically stored sequence or\nan object that produces one result at a time in the context of an iteration tool like a\nfor loop. In a sense, iterable objects include both physical sequences and virtual\nsequences computed on demand.*",
    "The Iteration Protocol: File Iterators\nOne of the easiest ways to understand what this means is to look at how it works with\na built-in type such as the file. Recall from Chapter 9 that open file objects have a\nmethod called readline, which reads one line of text from a file at a time—each time\nwe call the readline method, we advance to the next line. At the end of the file, an\nempty string is returned, which we can detect to break out of the loop:\n>>> f = open('script1.py')\n>>> f.readline()\n'import sys\\n'\n>>> f.readline()\n'print(sys.path)\\n'\n>>> f.readline()\n'x = 2\\n'\n>>> f.readline()\n'print(2 ** 33)\\n'\n>>> f.readline()\n''\n\n# Read a 4-line script file in this directory\n# readline loads one line on each call\n\n# Returns empty string at end-of-file",
    "# Read a 4-line script file in this directory\n# readline loads one line on each call\n\n# Returns empty string at end-of-file\n\nHowever, files also have a method named __next__ that has a nearly identical effect—\nit returns the next line from a file each time it is called. The only noticeable difference\nis that __next__ raises a built-in StopIteration exception at end-of-file instead of returning an empty string:\n>>> f = open('script1.py')\n>>> f.__next__()\n'import sys\\n'\n>>> f.__next__()\n'print(sys.path)\\n'\n\n# __next__ loads one line on each call too\n# But raises an exception at end-of-file\n\n* Terminology in this topic tends to be a bit loose. This text uses the terms “iterable” and “iterator”\ninterchangeably to refer to an object that supports iteration in general. Sometimes the term “iterable” refers\nto an object that supports iter and “iterator” refers to an object return by iter that supports next(I), but\nthat convention is not universal in either the Python world or this book.",
    "* Terminology in this topic tends to be a bit loose. This text uses the terms “iterable” and “iterator”\ninterchangeably to refer to an object that supports iteration in general. Sometimes the term “iterable” refers\nto an object that supports iter and “iterator” refers to an object return by iter that supports next(I), but\nthat convention is not universal in either the Python world or this book.\n\n352 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f>>> f.__next__()\n'x = 2\\n'\n>>> f.__next__()\n'print(2 ** 33)\\n'\n>>> f.__next__()\nTraceback (most recent call last):\n...more exception text omitted...\nStopIteration",
    "This interface is exactly what we call the iteration protocol in Python. Any object with\na __next__ method to advance to a next result, which raises StopIteration at the end\nof the series of results, is considered iterable in Python. Any such object may also be\nstepped through with a for loop or other iteration tool, because all iteration tools normally work internally by calling __next__ on each iteration and catching the\nStopIteration exception to determine when to exit.\nThe net effect of this magic is that, as mentioned in Chapter 9, the best way to read a\ntext file line by line today is to not read it at all—instead, allow the for loop to automatically call __next__ to advance to the next line on each iteration. The file object’s\niterator will do the work of automatically loading lines as you go. The following, for\nexample, reads a file line by line, printing the uppercase version of each line along the\nway, without ever explicitly reading from the file at all:",
    "iterator will do the work of automatically loading lines as you go. The following, for\nexample, reads a file line by line, printing the uppercase version of each line along the\nway, without ever explicitly reading from the file at all:\n>>> for line in open('script1.py'):\n...\nprint(line.upper(), end='')\n...\nIMPORT SYS\nPRINT(SYS.PATH)\nX = 2\nPRINT(2 ** 33)",
    "# Use file iterators to read by lines\n# Calls __next__, catches StopIteration\n\nNotice that the print uses end='' here to suppress adding a \\n, because line strings\nalready have one (without this, our output would be double-spaced). This is considered\nthe best way to read text files line by line today, for three reasons: it’s the simplest to\ncode, might be the quickest to run, and is the best in terms of memory usage. The older,\noriginal way to achieve the same effect with a for loop is to call the file readlines method\nto load the file’s content into memory as a list of line strings:\n>>> for line in open('script1.py').readlines():\n...\nprint(line.upper(), end='')\n...\nIMPORT SYS\nPRINT(SYS.PATH)\nX = 2\nPRINT(2 ** 33)",
    "This readlines technique still works, but it is not considered the best practice today\nand performs poorly in terms of memory usage. In fact, because this version really does\nload the entire file into memory all at once, it will not even work for files too big to fit\ninto the memory space available on your computer. By contrast, because it reads one\nline at a time, the iterator-based version is immune to such memory-explosion issues.\n\nIterators: A First Look | 353\n\n\fThe iterator version might run quicker too, though this can vary per release (Python\n3.0 made this advantage less clear-cut by rewriting I/O libraries to support Unicode\ntext and be less system-dependent).\nAs mentioned in the prior chapter’s sidebar, “Why You Will Care: File Scanners” on page 340, it’s also possible to read a file line by line with a while loop:\n>>> f = open('script1.py')\n>>> while True:\n...\nline = f.readline()\n...\nif not line: break\n...\nprint(line.upper(), end='')\n...\n...same output...",
    "However, this may run slower than the iterator-based for loop version, because iterators run at C language speed inside Python, whereas the while loop version runs Python\nbyte code through the Python virtual machine. Any time we trade Python code for C\ncode, speed tends to increase. This is not an absolute truth, though, especially in Python\n3.0; we’ll see timing techniques later in this book for measuring the relative speed of\nalternatives like these.\n\nManual Iteration: iter and next\nTo support manual iteration code (with less typing), Python 3.0 also provides a builtin function, next, that automatically calls an object’s __next__ method. Given an iterable object X, the call next(X) is the same as X.__next__(), but noticeably simpler. With\nfiles, for instance, either form may be used:\n>>> f = open('script1.py')\n>>> f.__next__()\n'import sys\\n'\n>>> f.__next__()\n'print(sys.path)\\n'\n>>> f = open('script1.py')\n>>> next(f)\n'import sys\\n'\n>>> next(f)\n'print(sys.path)\\n'",
    "# Call iteration method directly\n\n# next built-in calls __next__\n\nTechnically, there is one more piece to the iteration protocol. When the for loop begins,\nit obtains an iterator from the iterable object by passing it to the iter built-in function;\nthe object returned by iter has the required next method. This becomes obvious if we\nlook at how for loops internally process built-in sequence types such as lists:\n>>> L = [1, 2, 3]\n>>> I = iter(L)\n>>> I.next()\n1\n>>> I.next()\n2\n\n# Obtain an iterator object\n# Call next to advance to next item\n\n354 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f>>> I.next()\n3\n>>> I.next()\nTraceback (most recent call last):\n...more omitted...\nStopIteration\n\nThis initial step is not required for files, because a file object is its own iterator. That\nis, files have their own __next__ method and so do not need to return a different object\nthat does:\n>>> f = open('script1.py')\n>>> iter(f) is f\nTrue\n>>> f.__next__()\n'import sys\\n'",
    ">>> I.next()\n3\n>>> I.next()\nTraceback (most recent call last):\n...more omitted...\nStopIteration\n\nThis initial step is not required for files, because a file object is its own iterator. That\nis, files have their own __next__ method and so do not need to return a different object\nthat does:\n>>> f = open('script1.py')\n>>> iter(f) is f\nTrue\n>>> f.__next__()\n'import sys\\n'\n\nLists, and many other built-in objects, are not their own iterators because they support\nmultiple open iterations. For such objects, we must call iter to start iterating:\n>>> L = [1, 2, 3]\n>>> iter(L) is L\nFalse\n>>> L.__next__()\nAttributeError: 'list' object has no attribute '__next__'\n>>> I = iter(L)\n>>> I.__next__()\n1\n>>> next(I)\n2\n\n# Same as I.__next__()",
    "Lists, and many other built-in objects, are not their own iterators because they support\nmultiple open iterations. For such objects, we must call iter to start iterating:\n>>> L = [1, 2, 3]\n>>> iter(L) is L\nFalse\n>>> L.__next__()\nAttributeError: 'list' object has no attribute '__next__'\n>>> I = iter(L)\n>>> I.__next__()\n1\n>>> next(I)\n2\n\n# Same as I.__next__()\n\nAlthough Python iteration tools call these functions automatically, we can use them to\napply the iteration protocol manually, too. The following interaction demonstrates the\nequivalence between automatic and manual iteration:†\n>>> L = [1, 2, 3]\n>>>\n>>> for X in L:\n...\nprint(X ** 2, end=' ')\n...\n1 4 9\n\n# Automatic iteration\n# Obtains iter, calls __next__, catches exceptions\n\n>>> I = iter(L)\n\n# Manual iteration: what for loops usually do",
    "† Technically speaking, the for loop calls the internal equivalent of I.__next__, instead of the next(I) used\nhere. There is rarely any difference between the two, but as we’ll see in the next section, there are some builtin objects in 3.0 (such as os.popen results) that support the former and not the latter, but may be still be\niterated across in for loops. Your manual iterations can generally use either call scheme. If you care for the\nfull story, in 3.0 os.popen results have been reimplemented with the subprocess module and a wrapper class,\nwhose __getattr__ method is no longer called in 3.0 for implicit __next__ fetches made by the next built-in,\nbut is called for explicit fetches by name—a 3.0 change issue we’ll confront in Chapters 37 and 38, which\napparently burns some standard library code too! Also in 3.0, the related 2.6 calls os.popen2/3/4 are no longer\navailable; use subprocess.Popen with appropriate arguments instead (see the Python 3.0 library manual for",
    "but is called for explicit fetches by name—a 3.0 change issue we’ll confront in Chapters 37 and 38, which\napparently burns some standard library code too! Also in 3.0, the related 2.6 calls os.popen2/3/4 are no longer\navailable; use subprocess.Popen with appropriate arguments instead (see the Python 3.0 library manual for\nthe new required code).",
    "Iterators: A First Look | 355\n\n\f>>> while True:\n...\ntry:\n...\nX = next(I)\n...\nexcept StopIteration:\n...\nbreak\n...\nprint(X ** 2, end=' ')\n...\n1 4 9\n\n# try statement catches exceptions\n# Or call I.__next__",
    "# try statement catches exceptions\n# Or call I.__next__\n\nTo understand this code, you need to know that try statements run an action and catch\nexceptions that occur while the action runs (we’ll explore exceptions in depth in\nPart VII). I should also note that for loops and other iteration contexts can sometimes\nwork differently for user-defined classes, repeatedly indexing an object instead of running the iteration protocol. We’ll defer that story until we study class operator overloading in Chapter 29.\nVersion skew note: In Python 2.6, the iteration method is named\nX.next() instead of X.__next__(). For portability, the next(X) built-in\nfunction is available in Python 2.6 too (but not earlier), and calls 2.6’s\nX.next() instead of 3.0’s X.__next__(). Iteration works the same in 2.6\nin all other ways, though; simply use X.next() or next(X) for manual\niterations, instead of 3.0’s X.__next__(). Prior to 2.6, use manual\nX.next() calls instead of next(X).",
    "Other Built-in Type Iterators\nBesides files and physical sequences like lists, other types have useful iterators as well.\nThe classic way to step through the keys of a dictionary, for example, is to request its\nkeys list explicitly:\n>>> D = {'a':1, 'b':2, 'c':3}\n>>> for key in D.keys():\n...\nprint(key, D[key])\n...\na 1\nc 3\nb 2\n\nIn recent versions of Python, though, dictionaries have an iterator that automatically\nreturns one key at a time in an iteration context:\n>>> I = iter(D)\n>>> next(I)\n'a'\n>>> next(I)\n'c'\n>>> next(I)\n'b'\n>>> next(I)\nTraceback (most recent call last):\n\n356 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f...more omitted...\nStopIteration\n\nThe net effect is that we no longer need to call the keys method to step through dictionary keys—the for loop will use the iteration protocol to grab one key each time\nthrough:\n>>> for key in D:\n...\nprint(key, D[key])\n...\na 1\nc 3\nb 2",
    "356 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f...more omitted...\nStopIteration\n\nThe net effect is that we no longer need to call the keys method to step through dictionary keys—the for loop will use the iteration protocol to grab one key each time\nthrough:\n>>> for key in D:\n...\nprint(key, D[key])\n...\na 1\nc 3\nb 2\n\nWe can’t delve into their details here, but other Python object types also support the\niterator protocol and thus may be used in for loops too. For instance, shelves (an accessby-key filesystem for Python objects) and the results from os.popen (a tool for reading\nthe output of shell commands) are iterable as well:\n>>> import os\n>>> P = os.popen('dir')\n>>> P.__next__()\n' Volume in drive C is SQ004828V03\\n'\n>>> P.__next__()\n' Volume Serial Number is 08BE-3CD4\\n'\n>>> next(P)\nTypeError: _wrap_close object is not an iterator",
    "Notice that popen objects support a P.next() method in Python 2.6. In 3.0, they support\nthe P.__next__() method, but not the next(P) built-in; since the latter is defined to call\nthe former, it’s not clear if this behavior will endure in future releases (as described in\nan earlier footnote, this appears to be an implementation issue). This is only an issue\nfor manual iteration, though; if you iterate over these objects automatically with for\nloops and other iteration contexts (described in the next sections), they return successive lines in either Python version.\nThe iteration protocol also is the reason that we’ve had to wrap some results in a\nlist call to see their values all at once. Objects that are iterable return results one at a\ntime, not in a physical list:\n>>> R = range(5)\n>>> R\nrange(0, 5)\n>>> I = iter(R)\n>>> next(I)\n0\n>>> next(I)\n1\n>>> list(range(5))\n[0, 1, 2, 3, 4]\n\n# Ranges are iterables in 3.0\n# Use iteration protocol to produce results",
    "# Ranges are iterables in 3.0\n# Use iteration protocol to produce results\n\n# Or use list to collect all results at once\n\nIterators: A First Look | 357\n\n\fNow that you have a better understanding of this protocol, you should be able to see\nhow it explains why the enumerate tool introduced in the prior chapter works the way\nit does:\n>>> E = enumerate('spam')\n# enumerate is an iterable too\n>>> E\n<enumerate object at 0x0253F508>\n>>> I = iter(E)\n>>> next(I)\n# Generate results with iteration protocol\n(0, 's')\n>>> next(I)\n# Or use list to force generation to run\n(1, 'p')\n>>> list(enumerate('spam'))\n[(0, 's'), (1, 'p'), (2, 'a'), (3, 'm')]\n\nWe don’t normally see this machinery because for loops run it for us automatically to\nstep through results. In fact, everything that scans left-to-right in Python employs the\niteration protocol in the same way—including the topic of the next section.",
    "We don’t normally see this machinery because for loops run it for us automatically to\nstep through results. In fact, everything that scans left-to-right in Python employs the\niteration protocol in the same way—including the topic of the next section.\n\nList Comprehensions: A First Look\nNow that we’ve seen how the iteration protocol works, let’s turn to a very common use\ncase. Together with for loops, list comprehensions are one of the most prominent\ncontexts in which the iteration protocol is applied.\nIn the previous chapter, we learned how to use range to change a list as we step across\nit:\n>>> L = [1, 2, 3, 4, 5]\n>>> for i in range(len(L)):\n...\nL[i] += 10\n...\n>>> L\n[11, 12, 13, 14, 15]",
    "This works, but as I mentioned there, it may not be the optimal “best-practice” approach in Python. Today, the list comprehension expression makes many such prior\nuse cases obsolete. Here, for example, we can replace the loop with a single expression\nthat produces the desired result list:\n>>> L = [x + 10 for x in L]\n>>> L\n[21, 22, 23, 24, 25]\n\nThe net result is the same, but it requires less coding on our part and is likely to run\nsubstantially faster. The list comprehension isn’t exactly the same as the for loop statement version because it makes a new list object (which might matter if there are multiple\nreferences to the original list), but it’s close enough for most applications and is a common and convenient enough approach to merit a closer look here.\n\n358 | Chapter 14: Iterations and Comprehensions, Part 1",
    "358 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\fList Comprehension Basics\nWe met the list comprehension briefly in Chapter 4. Syntactically, its syntax is derived\nfrom a construct in set theory notation that applies an operation to each item in a set,\nbut you don’t have to know set theory to use this tool. In Python, most people find that\na list comprehension simply looks like a backward for loop.\nTo get a handle on the syntax, let’s dissect the prior section’s example in more detail:\n>>> L = [x + 10 for x in L]",
    "List comprehensions are written in square brackets because they are ultimately a way\nto construct a new list. They begin with an arbitrary expression that we make up, which\nuses a loop variable that we make up (x + 10). That is followed by what you should\nnow recognize as the header of a for loop, which names the loop variable, and an\niterable object (for x in L).\nTo run the expression, Python executes an iteration across L inside the interpreter,\nassigning x to each item in turn, and collects the results of running the items through\nthe expression on the left side. The result list we get back is exactly what the list comprehension says—a new list containing x + 10, for every x in L.\nTechnically speaking, list comprehensions are never really required because we can\nalways build up a list of expression results manually with for loops that append results\nas we go:\n>>> res = []\n>>> for x in L:\n...\nres.append(x + 10)\n...\n>>> res\n[21, 22, 23, 24, 25]",
    "In fact, this is exactly what the list comprehension does internally.\nHowever, list comprehensions are more concise to write, and because this code pattern\nof building up result lists is so common in Python work, they turn out to be very handy\nin many contexts. Moreover, list comprehensions can run much faster than manual\nfor loop statements (often roughly twice as fast) because their iterations are performed\nat C language speed inside the interpreter, rather than with manual Python code; especially for larger data sets, there is a major performance advantage to using them.\n\nUsing List Comprehensions on Files\nLet’s work through another common use case for list comprehensions to explore them\nin more detail. Recall that the file object has a readlines method that loads the file into\na list of line strings all at once:\n>>> f = open('script1.py')\n>>> lines = f.readlines()\n\nList Comprehensions: A First Look | 359",
    "Using List Comprehensions on Files\nLet’s work through another common use case for list comprehensions to explore them\nin more detail. Recall that the file object has a readlines method that loads the file into\na list of line strings all at once:\n>>> f = open('script1.py')\n>>> lines = f.readlines()\n\nList Comprehensions: A First Look | 359\n\n\f>>> lines\n['import sys\\n', 'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n']",
    "List Comprehensions: A First Look | 359\n\n\f>>> lines\n['import sys\\n', 'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n']\n\nThis works, but the lines in the result all include the newline character (\\n) at the end.\nFor many programs, the newline character gets in the way—we have to be careful to\navoid double-spacing when printing, and so on. It would be nice if we could get rid of\nthese newlines all at once, wouldn’t it?\nAny time we start thinking about performing an operation on each item in a sequence,\nwe’re in the realm of list comprehensions. For example, assuming the variable lines is\nas it was in the prior interaction, the following code does the job by running each line\nin the list through the string rstrip method to remove whitespace on the right side (a\nline[:−1] slice would work, too, but only if we can be sure all lines are properly\nterminated):\n>>> lines = [line.rstrip() for line in lines]\n>>> lines\n['import sys', 'print(sys.path)', 'x = 2', 'print(2 ** 33)']",
    "This works as planned. Because list comprehensions are an iteration context just like\nfor loop statements, though, we don’t even have to open the file ahead of time. If we\nopen it inside the expression, the list comprehension will automatically use the iteration\nprotocol we met earlier in this chapter. That is, it will read one line from the file at a\ntime by calling the file’s next method, run the line through the rstrip expression, and\nadd it to the result list. Again, we get what we ask for—the rstrip result of a line, for\nevery line in the file:\n>>> lines = [line.rstrip() for line in open('script1.py')]\n>>> lines\n['import sys', 'print(sys.path)', 'x = 2', 'print(2 ** 33)']",
    "This expression does a lot implicitly, but we’re getting a lot of work for free here—\nPython scans the file and builds a list of operation results automatically. It’s also an\nefficient way to code this operation: because most of this work is done inside the Python\ninterpreter, it is likely much faster than an equivalent for statement. Again, especially\nfor large files, the speed advantages of list comprehensions can be significant.\nBesides their efficiency, list comprehensions are also remarkably expressive. In our\nexample, we can run any string operation on a file’s lines as we iterate. Here’s the list\ncomprehension equivalent to the file iterator uppercase example we met earlier, along\nwith a few others (the method chaining in the second of these examples works because\nstring methods return a new string, to which we can apply another string method):\n>>> [line.upper() for line in open('script1.py')]\n['IMPORT SYS\\n', 'PRINT(SYS.PATH)\\n', 'X = 2\\n', 'PRINT(2 ** 33)\\n']",
    "comprehension equivalent to the file iterator uppercase example we met earlier, along\nwith a few others (the method chaining in the second of these examples works because\nstring methods return a new string, to which we can apply another string method):\n>>> [line.upper() for line in open('script1.py')]\n['IMPORT SYS\\n', 'PRINT(SYS.PATH)\\n', 'X = 2\\n', 'PRINT(2 ** 33)\\n']\n>>> [line.rstrip().upper() for line in open('script1.py')]\n['IMPORT SYS', 'PRINT(SYS.PATH)', 'X = 2', 'PRINT(2 ** 33)']\n>>> [line.split() for line in open('script1.py')]\n[['import', 'sys'], ['print(sys.path)'], ['x', '=', '2'], ['print(2', '**','33)']]",
    "360 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f>>> [line.replace(' ', '!') for line in open('script1.py')]\n['import!sys\\n', 'print(sys.path)\\n', 'x!=!2\\n', 'print(2!**!33)\\n']\n>>> [('sys' in line, line[0]) for line in open('script1.py')]\n[(True, 'i'), (True, 'p'), (False, 'x'), (False, 'p')]\n\nExtended List Comprehension Syntax\nIn fact, list comprehensions can be even more advanced in practice. As one particularly\nuseful extension, the for loop nested in the expression can have an associated if clause\nto filter out of the result items for which the test is not true.\nFor example, suppose we want to repeat the prior section’s file-scanning example, but\nwe need to collect only lines that begin with the letter p (perhaps the first character on\neach line is an action code of some sort). Adding an if filter clause to our expression\ndoes the trick:\n>>> lines = [line.rstrip() for line in open('script1.py') if line[0] == 'p']\n>>> lines\n['print(sys.path)', 'print(2 ** 33)']",
    "Here, the if clause checks each line read from the file to see whether its first character\nis p; if not, the line is omitted from the result list. This is a fairly big expression, but it’s\neasy to understand if we translate it to its simple for loop statement equivalent. In\ngeneral, we can always translate a list comprehension to a for statement by appending\nas we go and further indenting each successive part:\n>>> res = []\n>>> for line in open('script1.py'):\n...\nif line[0] == 'p':\n...\nres.append(line.rstrip())\n...\n>>> res\n['print(sys.path)', 'print(2 ** 33)']",
    "This for statement equivalent works, but it takes up four lines instead of one and\nprobably runs substantially slower.\nList comprehensions can become even more complex if we need them to—for instance,\nthey may contain nested loops, coded as a series of for clauses. In fact, their full syntax\nallows for any number of for clauses, each of which can have an optional associated\nif clause (we’ll be more formal about their syntax in Chapter 20).\nFor example, the following builds a list of the concatenation of x + y for every x in one\nstring and every y in another. It effectively collects the permutation of the characters in\ntwo strings:\n>>> [x + y for x in 'abc' for y in 'lmn']\n['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']\n\nList Comprehensions: A First Look | 361",
    "List Comprehensions: A First Look | 361\n\n\fAgain, one way to understand this expression is to convert it to statement form by\nindenting its parts. The following is an equivalent, but likely slower, alternative way to\nachieve the same effect:\n>>> res = []\n>>> for x in 'abc':\n...\nfor y in 'lmn':\n...\nres.append(x + y)\n...\n>>> res\n['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']\n\nBeyond this complexity level, though, list comprehension expressions can often become too compact for their own good. In general, they are intended for simple types\nof iterations; for more involved work, a simpler for statement structure will probably\nbe easier to understand and modify in the future. As usual in programming, if something\nis difficult for you to understand, it’s probably not a good idea.\nWe’ll revisit list comprehensions in Chapter 20, in the context of functional programming tools; as we’ll see, they turn out to be just as related to functions as they are to\nlooping statements.",
    "Other Iteration Contexts\nLater in the book, we’ll see that user-defined classes can implement the iteration protocol too. Because of this, it’s sometimes important to know which built-in tools make\nuse of it—any tool that employs the iteration protocol will automatically work on any\nbuilt-in type or user-defined class that provides it.\nSo far, I’ve been demonstrating iterators in the context of the for loop statement, because this part of the book is focused on statements. Keep in mind, though, that every\ntool that scans from left to right across objects uses the iteration protocol. This includes\nthe for loops we’ve seen:\n>>> for line in open('script1.py'):\n...\nprint(line.upper(), end='')\n...\nIMPORT SYS\nPRINT(SYS.PATH)\nX = 2\nPRINT(2 ** 33)\n\n# Use file iterators",
    "# Use file iterators\n\nHowever, list comprehensions, the in membership test, the map built-in function, and\nother built-ins such as the sorted and zip calls also leverage the iteration protocol.\nWhen applied to a file, all of these use the file object’s iterator automatically to scan\nline by line:\n>>> uppers = [line.upper() for line in open('script1.py')]\n>>> uppers\n['IMPORT SYS\\n', 'PRINT(SYS.PATH)\\n', 'X = 2\\n', 'PRINT(2 ** 33)\\n']\n\n362 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f>>> map(str.upper, open('script1.py'))\n<map object at 0x02660710>\n\n# map is an iterable in 3.0\n\n>>> list( map(str.upper, open('script1.py')) )\n['IMPORT SYS\\n', 'PRINT(SYS.PATH)\\n', 'X = 2\\n', 'PRINT(2 ** 33)\\n']\n>>> 'y = 2\\n' in open('script1.py')\nFalse\n>>> 'x = 2\\n' in open('script1.py')\nTrue",
    "We introduced the map call used here in the preceding chapter; it’s a built-in that applies\na function call to each item in the passed-in iterable object. map is similar to a list comprehension but is more limited because it requires a function instead of an arbitrary\nexpression. It also returns an iterable object itself in Python 3.0, so we must wrap it in\na list call to force it to give us all its values at once; more on this change later in this\nchapter. Because map, like the list comprehension, is related to both for loops and\nfunctions, we’ll also explore both again in Chapters 19 and 20.\nPython includes various additional built-ins that process iterables, too: sorted sorts\nitems in an iterable, zip combines items from iterables, enumerate pairs items in an\niterable with relative positions, filter selects items for which a function is true, and\nreduce runs pairs of items in an iterable through a function. All of these accept iterables,",
    "Python includes various additional built-ins that process iterables, too: sorted sorts\nitems in an iterable, zip combines items from iterables, enumerate pairs items in an\niterable with relative positions, filter selects items for which a function is true, and\nreduce runs pairs of items in an iterable through a function. All of these accept iterables,\nand zip, enumerate, and filter also return an iterable in Python 3.0, like map. Here they\nare in action running the file’s iterator automatically to scan line by line:\n>>> sorted(open('script1.py'))\n['import sys\\n', 'print(2 ** 33)\\n', 'print(sys.path)\\n', 'x = 2\\n']\n>>> list(zip(open('script1.py'), open('script1.py')))\n[('import sys\\n', 'import sys\\n'), ('print(sys.path)\\n', 'print(sys.path)\\n'),\n('x = 2\\n', 'x = 2\\n'), ('print(2 ** 33)\\n', 'print(2 ** 33)\\n')]\n>>> list(enumerate(open('script1.py')))\n[(0, 'import sys\\n'), (1, 'print(sys.path)\\n'), (2, 'x = 2\\n'),\n(3, 'print(2 ** 33)\\n')]\n>>> list(filter(bool, open('script1.py')))",
    ">>> list(zip(open('script1.py'), open('script1.py')))\n[('import sys\\n', 'import sys\\n'), ('print(sys.path)\\n', 'print(sys.path)\\n'),\n('x = 2\\n', 'x = 2\\n'), ('print(2 ** 33)\\n', 'print(2 ** 33)\\n')]\n>>> list(enumerate(open('script1.py')))\n[(0, 'import sys\\n'), (1, 'print(sys.path)\\n'), (2, 'x = 2\\n'),\n(3, 'print(2 ** 33)\\n')]\n>>> list(filter(bool, open('script1.py')))\n['import sys\\n', 'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n']\n>>> import functools, operator\n>>> functools.reduce(operator.add, open('script1.py'))\n'import sys\\nprint(sys.path)\\nx = 2\\nprint(2 ** 33)\\n'",
    "All of these are iteration tools, but they have unique roles. We met zip and enumerate\nin the prior chapter; filter and reduce are in Chapter 19’s functional programming\ndomain, so we’ll defer details for now.\nWe first saw the sorted function used here at work in Chapter 4, and we used it for\ndictionaries in Chapter 8. sorted is a built-in that employs the iteration protocol—it’s\nlike the original list sort method, but it returns the new sorted list as a result and runs\n\nOther Iteration Contexts | 363",
    "Other Iteration Contexts | 363\n\n\fon any iterable object. Notice that, unlike map and others, sorted returns an actual\nlist in Python 3.0 instead of an iterable.\nOther built-in functions support the iteration protocol as well (but frankly, are harder\nto cast in interesting examples related to files). For example, the sum call computes the\nsum of all the numbers in any iterable; the any and all built-ins return True if any or\nall items in an iterable are True, respectively; and max and min return the largest and\nsmallest item in an iterable, respectively. Like reduce, all of the tools in the following\nexamples accept any iterable as an argument and use the iteration protocol to scan it,\nbut return a single result:\n>>> sum([3, 2, 4, 1, 5, 0])\n15\n>>> any(['spam', '', 'ni'])\nTrue\n>>> all(['spam', '', 'ni'])\nFalse\n>>> max([3, 2, 5, 1, 4])\n5\n>>> min([3, 2, 5, 1, 4])\n1\n\n# sum expects numbers only",
    "# sum expects numbers only\n\nStrictly speaking, the max and min functions can be applied to files as well—they automatically use the iteration protocol to scan the file and pick out the lines with the highest\nand lowest string values, respectively (though I’ll leave valid use cases to your\nimagination):\n>>> max(open('script1.py'))\n'x = 2\\n'\n>>> min(open('script1.py'))\n'import sys\\n'\n\n# Line with max/min string value",
    "# Line with max/min string value\n\nInterestingly, the iteration protocol is even more pervasive in Python today than the\nexamples so far have demonstrated—everything in Python’s built-in toolset that scans\nan object from left to right is defined to use the iteration protocol on the subject object.\nThis even includes more esoteric tools such as the list and tuple built-in functions\n(which build new objects from iterables), the string join method (which puts a substring between strings contained in an iterable), and even sequence assignments. Consequently, all of these will also work on an open file and automatically read one line at\na time:\n>>> list(open('script1.py'))\n['import sys\\n', 'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n']\n>>> tuple(open('script1.py'))\n('import sys\\n', 'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n')\n>>> '&&'.join(open('script1.py'))\n'import sys\\n&&print(sys.path)\\n&&x = 2\\n&&print(2 ** 33)\\n'\n>>> a, b, c, d = open('script1.py')\n>>> a, d",
    "364 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\f('import sys\\n', 'print(2 ** 33)\\n')\n>>> a, *b = open('script1.py')\n# 3.0 extended form\n>>> a, b\n('import sys\\n', ['print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n'])\n\nEarlier, we saw that the built-in dict call accepts an iterable zip result, too. For that\nmatter, so does the set call, as well as the new set and dictionary comprehension expressions in Python 3.0, which we met in Chapters 4, 5, and 8:\n>>> set(open('script1.py'))\n{'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n', 'import sys\\n'}\n>>> {line for line in open('script1.py')}\n{'print(sys.path)\\n', 'x = 2\\n', 'print(2 ** 33)\\n', 'import sys\\n'}\n>>> {ix: line for ix, line in enumerate(open('script1.py'))}\n{0: 'import sys\\n', 1: 'print(sys.path)\\n', 2: 'x = 2\\n', 3: 'print(2 ** 33)\\n'}",
    "In fact, both set and dictionary comprehensions support the extended syntax of list\ncomprehensions we met earlier in this chapter, including if tests:\n>>> {line for line in open('script1.py') if line[0] == 'p'}\n{'print(sys.path)\\n', 'print(2 ** 33)\\n'}\n>>> {ix: line for (ix, line) in enumerate(open('script1.py')) if line[0] == 'p'}\n{1: 'print(sys.path)\\n', 3: 'print(2 ** 33)\\n'}",
    "Like the list comprehension, both of these scan the file line by line and pick out lines\nthat begin with the letter “p.” They also happen to build sets and dictionaries in the\nend, but we get a lot of work “for free” by combining file iteration and comprehension\nsyntax.\nThere’s one last iteration context that’s worth mentioning, although it’s a bit of a preview: in Chapter 18, we’ll learn that a special *arg form can be used in function calls\nto unpack a collection of values into individual arguments. As you can probably predict\nby now, this accepts any iterable, too, including files (see Chapter 18 for more details\non the call syntax):\n>>> def f(a, b, c, d): print(a, b, c, d, sep='&')\n...\n>>> f(1, 2, 3, 4)\n1&2&3&4\n>>> f(*[1, 2, 3, 4])\n# Unpacks into arguments\n1&2&3&4\n>>> f(*open('script1.py'))\nimport sys\n&print(sys.path)\n&x = 2\n&print(2 ** 33)\n\n# Iterates by lines too!",
    "# Iterates by lines too!\n\nIn fact, because this argument-unpacking syntax in calls accepts iterables, it’s also possible to use the zip built-in to unzip zipped tuples, by making prior or nested zip results\n\nOther Iteration Contexts | 365\n\n\farguments for another zip call (warning: you probably shouldn’t read the following\nexample if you plan to operate heavy machinery anytime soon!):\n>>> X = (1, 2)\n>>> Y = (3, 4)\n>>>\n>>> list(zip(X, Y))\n[(1, 3), (2, 4)]\n>>>\n>>> A, B = zip(*zip(X, Y))\n>>> A\n(1, 2)\n>>> B\n(3, 4)\n\n# Zip tuples: returns an iterable\n# Unzip a zip!\n\nStill other tools in Python, such as the range built-in and dictionary view objects, return\niterables instead of processing them. To see how these have been absorbed into the\niteration protocol in Python 3.0 as well, we need to move on to the next section.",
    "New Iterables in Python 3.0\nOne of the fundamental changes in Python 3.0 is that it has a stronger emphasis on\niterators than 2.X. In addition to the iterators associated with built-in types such as files\nand dictionaries, the dictionary methods keys, values, and items return iterable objects\nin Python 3.0, as do the built-in functions range, map, zip, and filter. As shown in the\nprior section, the last three of these functions both return iterators and process them.\nAll of these tools produce results on demand in Python 3.0, instead of constructing\nresult lists as they do in 2.6.\nAlthough this saves memory space, it can impact your coding styles in some contexts.\nIn various places in this book so far, for example, we’ve had to wrap up various function\nand method call results in a list(...) call in order to force them to produce all their\nresults at once:\n>>> zip('abc', 'xyz')\n<zip object at 0x02E66710>\n\n# An iterable in Python 3.0 (a list in 2.6)",
    "# An iterable in Python 3.0 (a list in 2.6)\n\n>>> list(zip('abc', 'xyz'))\n[('a', 'x'), ('b', 'y'), ('c', 'z')]\n\n# Force list of results in 3.0 to display\n\nThis isn’t required in 2.6, because functions like zip return lists of results. In 3.0,\nthough, they return iterable objects, producing results on demand. This means extra\ntyping is required to display the results at the interactive prompt (and possibly in some\nother contexts), but it’s an asset in larger programs—delayed evaluation like this conserves memory and avoids pauses while large result lists are computed. Let’s take a\nquick look at some of the new 3.0 iterables in action.\n\n366 | Chapter 14: Iterations and Comprehensions, Part 1",
    "366 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\fThe range Iterator\nWe studied the range built-in’s basic behavior in the prior chapter. In 3.0, it returns an\niterator that generates numbers in the range on demand, instead of building the result\nlist in memory. This subsumes the older 2.X xrange (see the upcoming version skew\nnote), and you must use list(range(...)) to force an actual range list if one is needed\n(e.g., to display results):\nC:\\\\misc> c:\\python30\\python\n>>> R = range(10)\n>>> R\nrange(0, 10)\n\n# range returns an iterator, not a list\n\n>>> I = iter(R)\n>>> next(I)\n0\n>>> next(I)\n1\n>>> next(I)\n2\n\n# Make an iterator from the range\n# Advance to next result\n# What happens in for loops, comprehensions, etc.\n\n>>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# To force a list if required",
    "# range returns an iterator, not a list\n\n>>> I = iter(R)\n>>> next(I)\n0\n>>> next(I)\n1\n>>> next(I)\n2\n\n# Make an iterator from the range\n# Advance to next result\n# What happens in for loops, comprehensions, etc.\n\n>>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# To force a list if required\n\nUnlike the list returned by this call in 2.X, range objects in 3.0 support only iteration,\nindexing, and the len function. They do not support any other sequence operations\n(use list(...) if you require more list tools):\n>>> len(R)\n10\n>>> R[0]\n0\n>>> R[-1]\n9\n\n# range also does len and indexing, but no others\n\n>>> next(I)\n3\n>>> I.__next__()\n4\n\n# Continue taking from iterator, where left off\n# .next() becomes .__next__(), but use new next()",
    "# range also does len and indexing, but no others\n\n>>> next(I)\n3\n>>> I.__next__()\n4\n\n# Continue taking from iterator, where left off\n# .next() becomes .__next__(), but use new next()\n\nVersion skew note: Python 2.X also has a built-in called xrange, which\nis like range but produces items on demand instead of building a list of\nresults in memory all at once. Since this is exactly what the new iteratorbased range does in Python 3.0, xrange is no longer available in 3.0—it\nhas been subsumed. You may still see it in 2.X code, though, especially\nsince range builds result lists there and so is not as efficient in its memory\nusage. As noted in a sidebar in the prior chapter, the file.xread\nlines() method used to minimize memory use in 2.X has been dropped\nin Python 3.0 for similar reasons, in favor of file iterators.\n\nNew Iterables in Python 3.0 | 367",
    "New Iterables in Python 3.0 | 367\n\n\fThe map, zip, and filter Iterators\nLike range, the map, zip, and filter built-ins also become iterators in 3.0 to conserve\nspace, rather than producing a result list all at once in memory. All three not only\nprocess iterables, as in 2.X, but also return iterable results in 3.0. Unlike range, though,\nthey are their own iterators—after you step through their results once, they are exhausted. In other words, you can’t have multiple iterators on their results that maintain\ndifferent positions in those results.\nHere is the case for the map built-in we met in the prior chapter. As with other iterators,\nyou can force a list with list(...) if you really need one, but the default behavior can\nsave substantial space in memory for large result sets:\n>>> M = map(abs, (-1, 0, 1))\n>>> M\n<map object at 0x0276B890>\n>>> next(M)\n1\n>>> next(M)\n0\n>>> next(M)\n1\n>>> next(M)\nStopIteration\n\n# map returns an iterator, not a list\n\n>>> for x in M: print(x)\n...",
    "# map returns an iterator, not a list\n\n>>> for x in M: print(x)\n...\n\n# map iterator is now empty: one pass only\n\n>>> M = map(abs, (-1, 0, 1))\n>>> for x in M: print(x)\n...\n1\n0\n1\n>>> list(map(abs, (-1, 0, 1)))\n[1, 0, 1]\n\n# Make a new iterator to scan again\n# Iteration contexts auto call next()\n\n# Use iterator manually: exhausts results\n# These do not support len() or indexing\n\n# Can force a real list if needed\n\nThe zip built-in, introduced in the prior chapter, returns iterators that work the same\nway:\n>>> Z = zip((1, 2, 3), (10, 20, 30))\n>>> Z\n<zip object at 0x02770EE0>\n\n# zip is the same: a one-pass iterator\n\n>>> list(Z)\n[(1, 10), (2, 20), (3, 30)]\n>>> for pair in Z: print(pair)\n...\n>>> Z = zip((1, 2, 3), (10, 20, 30))\n>>> for pair in Z: print(pair)\n...\n(1, 10)\n\n368 | Chapter 14: Iterations and Comprehensions, Part 1\n\n# Exhausted after one pass\n\n# Iterator used automatically or manually\n\n\f(2, 20)\n(3, 30)\n>>> Z = zip((1, 2, 3), (10, 20, 30))\n>>> next(Z)\n(1, 10)\n>>> next(Z)\n(2, 20)",
    ">>> list(Z)\n[(1, 10), (2, 20), (3, 30)]\n>>> for pair in Z: print(pair)\n...\n>>> Z = zip((1, 2, 3), (10, 20, 30))\n>>> for pair in Z: print(pair)\n...\n(1, 10)\n\n368 | Chapter 14: Iterations and Comprehensions, Part 1\n\n# Exhausted after one pass\n\n# Iterator used automatically or manually\n\n\f(2, 20)\n(3, 30)\n>>> Z = zip((1, 2, 3), (10, 20, 30))\n>>> next(Z)\n(1, 10)\n>>> next(Z)\n(2, 20)\n\nThe filter built-in, which we’ll study in the next part of this book, is also analogous.\nIt returns items in an iterable for which a passed-in function returns True (as we’ve\nlearned, in Python True includes nonempty objects):\n>>> filter(bool, ['spam', '', 'ni'])\n<filter object at 0x0269C6D0>\n>>> list(filter(bool, ['spam', '', 'ni']))\n['spam', 'ni']\n\nLike most of the tools discussed in this section, filter both accepts an iterable to\nprocess and returns an iterable to generate results in 3.0.",
    "Like most of the tools discussed in this section, filter both accepts an iterable to\nprocess and returns an iterable to generate results in 3.0.\n\nMultiple Versus Single Iterators\nIt’s interesting to see how the range object differs from the built-ins described in this\nsection—it supports len and indexing, it is not its own iterator (you make one with\niter when iterating manually), and it supports multiple iterators over its result that\nremember their positions independently:\n>>> R = range(3)\n# range allows multiple iterators\n>>> next(R)\nTypeError: range object is not an iterator\n>>> I1 = iter(R)\n>>> next(I1)\n0\n>>> next(I1)\n1\n>>> I2 = iter(R)\n>>> next(I2)\n0\n>>> next(I1)\n2\n\n# Two iterators on one range\n# I1 is at a different spot than I2\n\nBy contrast, zip, map, and filter do not support multiple active iterators on the same\nresult:\n>>> Z = zip((1, 2, 3), (10, 11, 12))\n>>> I1 = iter(Z)\n>>> I2 = iter(Z)\n>>> next(I1)\n(1, 10)\n>>> next(I1)\n(2, 11)\n>>> next(I2)\n\n# Two iterators on one zip",
    "# Two iterators on one range\n# I1 is at a different spot than I2\n\nBy contrast, zip, map, and filter do not support multiple active iterators on the same\nresult:\n>>> Z = zip((1, 2, 3), (10, 11, 12))\n>>> I1 = iter(Z)\n>>> I2 = iter(Z)\n>>> next(I1)\n(1, 10)\n>>> next(I1)\n(2, 11)\n>>> next(I2)\n\n# Two iterators on one zip\n\n# I2 is at same spot as I1!\n\nNew Iterables in Python 3.0 | 369\n\n\f(3, 12)\n>>> M = map(abs, (-1, 0, 1))\n>>> I1 = iter(M); I2 = iter(M)\n>>> print(next(I1), next(I1), next(I1))\n1 0 1\n>>> next(I2)\nStopIteration\n\n# Ditto for map (and filter)\n\n>>> R = range(3)\n>>> I1, I2 = iter(R), iter(R)\n>>> [next(I1), next(I1), next(I1)]\n[0 1 2]\n>>> next(I2)\n0\n\n# But range allows many iterators",
    "# I2 is at same spot as I1!\n\nNew Iterables in Python 3.0 | 369\n\n\f(3, 12)\n>>> M = map(abs, (-1, 0, 1))\n>>> I1 = iter(M); I2 = iter(M)\n>>> print(next(I1), next(I1), next(I1))\n1 0 1\n>>> next(I2)\nStopIteration\n\n# Ditto for map (and filter)\n\n>>> R = range(3)\n>>> I1, I2 = iter(R), iter(R)\n>>> [next(I1), next(I1), next(I1)]\n[0 1 2]\n>>> next(I2)\n0\n\n# But range allows many iterators\n\nWhen we code our own iterable objects with classes later in the book (Chapter 29),\nwe’ll see that multiple iterators are usually supported by returning new objects for the\niter call; a single iterator generally means an object returns itself. In Chapter 20, we’ll\nalso find that generator functions and expressions behave like map and zip instead of\nrange in this regard, supporting a single active iteration. In that chapter, we’ll see some\nsubtle implications of one-shot iterators in loops that attempt to scan multiple times.",
    "Dictionary View Iterators\nAs we saw briefly in Chapter 8, in Python 3.0 the dictionary keys, values, and items\nmethods return iterable view objects that generate result items one at a time, instead\nof producing result lists all at once in memory. View items maintain the same physical\nordering as that of the dictionary and reflect changes made to the underlying dictionary.\nNow that we know more about iterators, here’s the rest of the story:\n>>> D = dict(a=1, b=2, c=3)\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> K = D.keys()\n>>> K\n<dict_keys object at 0x026D83C0>\n\n# A view object in 3.0, not a list\n\n>>> next(K)\n# Views are not iterators themselves\nTypeError: dict_keys object is not an iterator\n>>> I = iter(K)\n>>> next(I)\n'a'\n>>> next(I)\n'c'\n\n# Views have an iterator,\n# which can be used manually\n# but does not support len(), index\n\n>>> for k in D.keys(): print(k, end=' ')\n...\na c b\n\n# All iteration contexts use auto\n\n370 | Chapter 14: Iterations and Comprehensions, Part 1",
    ">>> next(K)\n# Views are not iterators themselves\nTypeError: dict_keys object is not an iterator\n>>> I = iter(K)\n>>> next(I)\n'a'\n>>> next(I)\n'c'\n\n# Views have an iterator,\n# which can be used manually\n# but does not support len(), index\n\n>>> for k in D.keys(): print(k, end=' ')\n...\na c b\n\n# All iteration contexts use auto\n\n370 | Chapter 14: Iterations and Comprehensions, Part 1\n\n\fAs for all iterators, you can always force a 3.0 dictionary view to build a real list by\npassing it to the list built-in. However, this usually isn’t required except to display\nresults interactively or to apply list operations like indexing:\n>>> K = D.keys()\n>>> list(K)\n['a', 'c', 'b']\n>>> V = D.values()\n>>> V\n<dict_values object at 0x026D8260>\n>>> list(V)\n[1, 3, 2]\n\n# Can still force a real list if needed\n# Ditto for values() and items() views\n\n>>> list(D.items())\n[('a', 1), ('c', 3), ('b', 2)]\n>>> for (k, v) in D.items(): print(k, v, end=' ')\n...\na 1 c 3 b 2",
    "# Can still force a real list if needed\n# Ditto for values() and items() views\n\n>>> list(D.items())\n[('a', 1), ('c', 3), ('b', 2)]\n>>> for (k, v) in D.items(): print(k, v, end=' ')\n...\na 1 c 3 b 2\n\nIn addition, 3.0 dictionaries still have iterators themselves, which return successive\nkeys. Thus, it’s not often necessary to call keys directly in this context:\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> I = iter(D)\n>>> next(I)\n'a'\n>>> next(I)\n'c'\n\n# Dictionaries still have own iterator\n# Returns next key on each iteration\n\n>>> for key in D: print(key, end=' ')\n...\na c b\n\n# Still no need to call keys() to iterate\n# But keys is an iterator in 3.0 too!",
    "# Dictionaries still have own iterator\n# Returns next key on each iteration\n\n>>> for key in D: print(key, end=' ')\n...\na c b\n\n# Still no need to call keys() to iterate\n# But keys is an iterator in 3.0 too!\n\nFinally, remember again that because keys no longer returns a list, the traditional coding\npattern for scanning a dictionary by sorted keys won’t work in 3.0. Instead, convert\nkeys views first with a list call, or use the sorted call on either a keys view or the\ndictionary itself, as follows:\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> for k in sorted(D.keys())): print(k, D[k], end=' ')\n...\na 1 b 2 c 3\n>>> D\n{'a': 1, 'c': 3, 'b': 2}\n>>> for k in sorted(D): print(k, D[k], end=' ')\n...\na 1 b 2 c 3\n\n# Best practice key sorting\n\nNew Iterables in Python 3.0 | 371",
    "# Best practice key sorting\n\nNew Iterables in Python 3.0 | 371\n\n\fOther Iterator Topics\nWe’ll learn more about both list comprehensions and iterators in Chapter 20, in conjunction with functions, and again in Chapter 29 when we study classes. As you’ll see\nlater:\n• User-defined functions can be turned into iterable generator functions, with\nyield statements.\n• List comprehensions morph into iterable generator expressions when coded in\nparentheses.\n• User-defined classes are made iterable with __iter__ or __getitem__ operator\noverloading.\nIn particular, user-defined iterators defined with classes allow arbitrary objects and\noperations to be used in any of the iteration contexts we’ve met here.",
    "Chapter Summary\nIn this chapter, we explored concepts related to looping in Python. We took our first\nsubstantial look at the iteration protocol in Python—a way for nonsequence objects to\ntake part in iteration loops—and at list comprehensions. As we saw, a list comprehension is an expression similar to a for loop that applies another expression to all the\nitems in any iterable object. Along the way, we also saw other built-in iteration tools\nat work and studied recent iteration additions in Python 3.0.\nThis wraps up our tour of specific procedural statements and related tools. The next\nchapter closes out this part of the book by discussing documentation options for Python\ncode; documentation is also part of the general syntax model, and it’s an important\ncomponent of well-written programs. In the next chapter, we’ll also dig into a set of\nexercises for this part of the book before we turn our attention to larger structures such",
    "chapter closes out this part of the book by discussing documentation options for Python\ncode; documentation is also part of the general syntax model, and it’s an important\ncomponent of well-written programs. In the next chapter, we’ll also dig into a set of\nexercises for this part of the book before we turn our attention to larger structures such\nas functions. As usual, though, let’s first exercise what we’ve learned here with a quiz.",
    "Test Your Knowledge: Quiz\n1. How are for loops and iterators related?\n2. How are for loops and list comprehensions related?\n3. Name four iteration contexts in the Python language.\n4. What is the best way to read line by line from a text file today?\n5. What sort of weapons would you expect to see employed by the Spanish\nInquisition?\n\n372 | Chapter 14: Iterations and Comprehensions, Part 1",
    "Test Your Knowledge: Answers\n1. The for loop uses the iteration protocol to step through items in the object across\nwhich it is iterating. It calls the object’s __next__ method (run by the next built-in)\non each iteration and catches the StopIteration exception to determine when to\nstop looping. Any object that supports this model works in a for loop and in other\niteration contexts.\n2. Both are iteration tools. List comprehensions are a concise and efficient way to\nperform a common for loop task: collecting the results of applying an expression\nto all items in an iterable object. It’s always possible to translate a list comprehension to a for loop, and part of the list comprehension expression looks like the\nheader of a for loop syntactically.\n3. Iteration contexts in Python include the for loop; list comprehensions; the map\nbuilt-in function; the in membership test expression; and the built-in functions",
    "to all items in an iterable object. It’s always possible to translate a list comprehension to a for loop, and part of the list comprehension expression looks like the\nheader of a for loop syntactically.\n3. Iteration contexts in Python include the for loop; list comprehensions; the map\nbuilt-in function; the in membership test expression; and the built-in functions\nsorted, sum, any, and all. This category also includes the list and tuple built-ins,\nstring join methods, and sequence assignments, all of which use the iteration protocol (the __next__ method) to step across iterable objects one item at a time.\n4. The best way to read lines from a text file today is to not read it explicitly at all:\ninstead, open the file within an iteration context such as a for loop or list comprehension, and let the iteration tool automatically scan one line at a time by\nrunning the file’s next method on each iteration. This approach is generally best",
    "4. The best way to read lines from a text file today is to not read it explicitly at all:\ninstead, open the file within an iteration context such as a for loop or list comprehension, and let the iteration tool automatically scan one line at a time by\nrunning the file’s next method on each iteration. This approach is generally best\nin terms of coding simplicity, execution speed, and memory space requirements.\n5. I’ll accept any of the following as correct answers: fear, intimidation, nice red uniforms, a comfy chair, and soft pillows.",
    "Test Your Knowledge: Answers | 373\n\n\f\fCHAPTER 15\n\nThe Documentation Interlude\n\nThis part of the book concludes with a look at techniques and tools used for\ndocumenting Python code. Although Python code is designed to be readable, a few\nwell-placed human-readable comments can do much to help others understand the\nworkings of your programs. Python includes syntax and tools to make documentation\neasier.\nAlthough this is something of a tools-related concept, the topic is presented here partly\nbecause it involves Python’s syntax model, and partly as a resource for readers struggling to understand Python’s toolset. For the latter purpose, I’ll expand here on documentation pointers first given in Chapter 4. As usual, in addition to the chapter quiz\nthis concluding chapter ends with some warnings about common pitfalls and a set of\nexercises for this part of the text.",
    "Python Documentation Sources\nBy this point in the book, you’re probably starting to realize that Python comes with\nan amazing amount of prebuilt functionality—built-in functions and exceptions, predefined object attributes and methods, standard library modules, and more. And we’ve\nreally only scratched the surface of each of these categories.\nOne of the first questions that bewildered beginners often ask is: how do I find information on all the built-in tools? This section provides hints on the various documentation sources available in Python. It also presents documentation strings (docstrings)\nand the PyDoc system that makes use of them. These topics are somewhat peripheral\nto the core language itself, but they become essential knowledge as soon as your code\nreaches the level of the examples and exercises in this part of the book.\nAs summarized in Table 15-1, there are a variety of places to look for information on",
    "and the PyDoc system that makes use of them. These topics are somewhat peripheral\nto the core language itself, but they become essential knowledge as soon as your code\nreaches the level of the examples and exercises in this part of the book.\nAs summarized in Table 15-1, there are a variety of places to look for information on\nPython, with generally increasing verbosity. Because documentation is such a crucial\ntool in practical programming, we’ll explore each of these categories in the sections\nthat follow.",
    "375\n\n\fTable 15-1. Python documentation sources\nForm\n\nRole\n\n# comments\n\nIn-file documentation\n\nThe dir function\n\nLists of attributes available in objects\n\nDocstrings: __doc__\n\nIn-file documentation attached to objects\n\nPyDoc: The help function\n\nInteractive help for objects\n\nPyDoc: HTML reports\n\nModule documentation in a browser\n\nThe standard manual set\n\nOfficial language and library descriptions\n\nWeb resources\n\nOnline tutorials, examples, and so on\n\nPublished books\n\nCommercially available reference texts",
    "PyDoc: The help function\n\nInteractive help for objects\n\nPyDoc: HTML reports\n\nModule documentation in a browser\n\nThe standard manual set\n\nOfficial language and library descriptions\n\nWeb resources\n\nOnline tutorials, examples, and so on\n\nPublished books\n\nCommercially available reference texts\n\n# Comments\nHash-mark comments are the most basic way to document your code. Python simply\nignores all the text following a # (as long as it’s not inside a string literal), so you can\nfollow this character with words and descriptions meaningful to programmers. Such\ncomments are accessible only in your source files, though; to code comments that are\nmore widely available, you’ll need to use docstrings.\nIn fact, current best practice generally dictates that docstrings are best for larger functional documentation (e.g., “my file does this”), and # comments are best limited to\nsmaller code documentation (e.g., “this strange expression does that”). More on docstrings in a moment.",
    "The dir Function\nThe built-in dir function is an easy way to grab a list of all the attributes available inside\nan object (i.e., its methods and simpler data items). It can be called on any object that\nhas attributes. For example, to find out what’s available in the standard library’s sys\nmodule, import it and pass it to dir (these results are from Python 3.0; they might vary\nslightly on 2.6):\n>>> import sys\n>>> dir(sys)\n['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__',\n'__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames',\n'_getframe', 'api_version', 'argv', 'builtin_module_names', 'byteorder',\n'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle',\n'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable',\n'exit', 'flags', 'float_info', 'getcheckinterval', 'getdefaultencoding',\n...more names omitted...]",
    "Only some of the many names are displayed here; run these statements on your machine\nto see the full list.\n\n376 | Chapter 15: The Documentation Interlude\n\n\fTo find out what attributes are provided in built-in object types, run dir on a literal (or\nexisting instance) of the desired type. For example, to see list and string attributes, you\ncan pass empty objects:\n>>> dir([])\n['__add__', '__class__', '__contains__', ...more...\n'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove',\n'reverse', 'sort']\n>>> dir('')\n['__add__', '__class__', '__contains__', ...more...\n'capitalize', 'center', 'count', 'encode', 'endswith', 'expandtabs',\n'find', 'format', 'index', 'isalnum', 'isalpha', 'isdecimal',\n'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable',\n'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', '\nmaketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust',\n...more names omitted...]",
    "dir results for any built-in type include a set of attributes that are related to the imple-\n\nmentation of that type (technically, operator overloading methods); they all begin and\nend with double underscores to make them distinct, and you can safely ignore them at\nthis point in the book.\nIncidentally, you can achieve the same effect by passing a type name to dir instead of\na literal:\n>>> dir(str) == dir('')\nTrue\n>>> dir(list) == dir([])\nTrue\n\n# Same result as prior example",
    "mentation of that type (technically, operator overloading methods); they all begin and\nend with double underscores to make them distinct, and you can safely ignore them at\nthis point in the book.\nIncidentally, you can achieve the same effect by passing a type name to dir instead of\na literal:\n>>> dir(str) == dir('')\nTrue\n>>> dir(list) == dir([])\nTrue\n\n# Same result as prior example\n\nThis works because names like str and list that were once type converter functions\nare actually names of types in Python today; calling one of these invokes its constructor\nto generate an instance of that type. I’ll have more to say about constructors and operator overloading methods when we discuss classes in Part VI.\nThe dir function serves as a sort of memory-jogger—it provides a list of attribute names,\nbut it does not tell you anything about what those names mean. For such extra information, we need to move on to the next documentation source.",
    "Docstrings: __doc__\nBesides # comments, Python supports documentation that is automatically attached to\nobjects and retained at runtime for inspection. Syntactically, such comments are coded\nas strings at the tops of module files and function and class statements, before any other\nexecutable code (# comments are OK before them). Python automatically stuffs the\nstrings, known as docstrings, into the __doc__ attributes of the corresponding objects.\n\nPython Documentation Sources | 377",
    "Python Documentation Sources | 377\n\n\fUser-defined docstrings\nFor example, consider the following file, docstrings.py. Its docstrings appear at the\nbeginning of the file and at the start of a function and a class within it. Here, I’ve used\ntriple-quoted block strings for multiline comments in the file and the function, but any\nsort of string will work. We haven’t studied the def or class statements in detail yet,\nso ignore everything about them except the strings at their tops:\n\"\"\"\nModule documentation\nWords Go Here\n\"\"\"\nspam = 40\ndef square(x):\n\"\"\"\nfunction documentation\ncan we have your liver then?\n\"\"\"\nreturn x ** 2\n# square\nclass Employee:\n\"class documentation\"\npass\nprint(square(4))\nprint(square.__doc__)",
    "The whole point of this documentation protocol is that your comments are retained\nfor inspection in __doc__ attributes after the file is imported. Thus, to display the docstrings associated with the module and its objects, we simply import the file and print\ntheir __doc__ attributes, where Python has saved the text:\n>>> import docstrings\n16\nfunction documentation\ncan we have your liver then?\n>>> print(docstrings.__doc__)\nModule documentation\nWords Go Here\n>>> print(docstrings.square.__doc__)\nfunction documentation\ncan we have your liver then?\n>>> print(docstrings.Employee.__doc__)\nclass documentation\n\n378 | Chapter 15: The Documentation Interlude",
    "378 | Chapter 15: The Documentation Interlude\n\n\fNote that you will generally want to use print to print docstrings; otherwise, you’ll get\na single string with embedded newline characters.\nYou can also attach docstrings to methods of classes (covered in Part VI), but because\nthese are just def statements nested in class statements, they’re not a special case. To\nfetch the docstring of a method function inside a class within a module, you would\nsimply extend the path to go through the class: module.class.method.__doc__ (we’ll see\nan example of method docstrings in Chapter 28).",
    "Docstring standards\nThere is no broad standard about what should go into the text of a docstring (although\nsome companies have internal standards). There have been various markup language\nand template proposals (e.g., HTML or XML), but they don’t seem to have caught on\nin the Python world. And frankly, convincing Python programmers to document their\ncode using handcoded HTML is probably not going to happen in our lifetimes!\nDocumentation tends to have a low priority amongst programmers in general. Usually,\nif you get any comments in a file at all, you count yourself lucky. I strongly encourage\nyou to document your code liberally, though—it really is an important part of wellwritten programs. The point here is that there is presently no standard on the structure\nof docstrings; if you want to use them, anything goes today.",
    "Built-in docstrings\nAs it turns out, built-in modules and objects in Python use similar techniques to attach\ndocumentation above and beyond the attribute lists returned by dir. For example, to\nsee an actual human-readable description of a built-in module, import it and print its\n__doc__ string:\n>>> import sys\n>>> print(sys.__doc__)\nThis module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\nDynamic objects:\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n...more text omitted...",
    "Functions, classes, and methods within built-in modules have attached descriptions in\ntheir __doc__ attributes as well:\n>>> print(sys.getrefcount.__doc__)\ngetrefcount(object) -> integer\nReturn the reference count of object. The count returned is generally\none higher than you might expect, because it includes the (temporary)\n...more text omitted...\n\nPython Documentation Sources | 379\n\n\fYou can also read about built-in functions via their docstrings:\n>>> print(int.__doc__)\nint(x[, base]) -> integer\nConvert a string or number to an integer, if possible. A floating\npoint argument will be truncated towards zero (this does not include a\n...more text omitted...\n>>> print(map.__doc__)\nmap(func, *iterables) --> map object\nMake an iterator that computes the function using arguments from\neach of the iterables. Stops when the shortest iterable is exhausted.",
    "You can get a wealth of information about built-in tools by inspecting their docstrings\nthis way, but you don’t have to—the help function, the topic of the next section, does\nthis automatically for you.",
    "PyDoc: The help Function\nThe docstring technique proved to be so useful that Python now ships with a tool that\nmakes docstrings even easier to display. The standard PyDoc tool is Python code that\nknows how to extract docstrings and associated structural information and format\nthem into nicely arranged reports of various types. Additional tools for extracting and\nformatting docstrings are available in the open source domain (including tools that may\nsupport structured text—search the Web for pointers), but Python ships with PyDoc\nin its standard library.\nThere are a variety of ways to launch PyDoc, including command-line script options\n(see the Python library manual for details). Perhaps the two most prominent PyDoc\ninterfaces are the built-in help function and the PyDoc GUI/HTML interface. The\nhelp function invokes PyDoc to generate a simple textual report (which looks much\nlike a “manpage” on Unix-like systems):\n>>> import sys\n>>> help(sys.getrefcount)",
    "(see the Python library manual for details). Perhaps the two most prominent PyDoc\ninterfaces are the built-in help function and the PyDoc GUI/HTML interface. The\nhelp function invokes PyDoc to generate a simple textual report (which looks much\nlike a “manpage” on Unix-like systems):\n>>> import sys\n>>> help(sys.getrefcount)\nHelp on built-in function getrefcount in module sys:\ngetrefcount(...)\ngetrefcount(object) -> integer\nReturn the reference count of object. The count returned is generally\none higher than you might expect, because it includes the (temporary)\n...more omitted...",
    "Note that you do not have to import sys in order to call help, but you do have to import\nsys to get help on sys; it expects an object reference to be passed in. For larger objects\nsuch as modules and classes, the help display is broken down into multiple sections, a\nfew of which are shown here. Run this interactively to see the full report:\n\n380 | Chapter 15: The Documentation Interlude\n\n\f>>> help(sys)\nHelp on built-in module sys:\nNAME\n\nsys\n\nFILE\n\n(built-in)\n\nMODULE DOCS\nhttp://docs.python.org/library/sys\nDESCRIPTION\nThis module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n...more omitted...\nFUNCTIONS\n__displayhook__ = displayhook(...)\ndisplayhook(object) -> None\nPrint an object to sys.stdout and also save it in builtins.\n...more omitted...\nDATA",
    "FILE\n\n(built-in)\n\nMODULE DOCS\nhttp://docs.python.org/library/sys\nDESCRIPTION\nThis module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\n...more omitted...\nFUNCTIONS\n__displayhook__ = displayhook(...)\ndisplayhook(object) -> None\nPrint an object to sys.stdout and also save it in builtins.\n...more omitted...\nDATA\n\n__stderr__ = <io.TextIOWrapper object at 0x0236E950>\n__stdin__ = <io.TextIOWrapper object at 0x02366550>\n__stdout__ = <io.TextIOWrapper object at 0x02366E30>\n...more omitted...",
    "Some of the information in this report is docstrings, and some of it (e.g., function call\npatterns) is structural information that PyDoc gleans automatically by inspecting objects’ internals, when available. You can also use help on built-in functions, methods,\nand types. To get help for a built-in type, use the type name (e.g., dict for dictionary,\nstr for string, list for list). You’ll get a large display that describes all the methods\navailable for that type:\n>>> help(dict)\nHelp on class dict in module builtins:\nclass dict(object)\n| dict() -> new empty dictionary.\n| dict(mapping) -> new dictionary initialized from a mapping object's\n...more omitted...\n>>> help(str.replace)\nHelp on method_descriptor:\nreplace(...)\nS.replace (old, new[, count]) -> str\nReturn a copy of S with all occurrences of substring\n...more omitted...\n>>> help(ord)\n\nPython Documentation Sources | 381",
    "Python Documentation Sources | 381\n\n\fHelp on built-in function ord in module builtins:\nord(...)\nord(c) -> integer\nReturn the integer ordinal of a one-character string.\n\nFinally, the help function works just as well on your modules as it does on built-ins.\nHere it is reporting on the docstrings.py file we coded earlier. Again, some of this is\ndocstrings, and some is information automatically extracted by inspecting objects’\nstructures:\n>>> import docstrings\n>>> help(docstrings.square)\nHelp on function square in module docstrings:\nsquare(x)\nfunction documentation\ncan we have your liver then?\n>>> help(docstrings.Employee)\nHelp on class Employee in module docstrings:\nclass Employee(builtins.object)\n| class documentation\n|\n| Data descriptors defined here:\n...more omitted...\n>>> help(docstrings)\nHelp on module docstrings:\nNAME\n\ndocstrings\n\nFILE\n\nc:\\misc\\docstrings.py",
    "docstrings\n\nFILE\n\nc:\\misc\\docstrings.py\n\nDESCRIPTION\nModule documentation\nWords Go Here\nCLASSES\nbuiltins.object\nEmployee\nclass Employee(builtins.object)\n| class documentation\n|\n| Data descriptors defined here:\n...more omitted...\nFUNCTIONS\nsquare(x)\nfunction documentation\n\n382 | Chapter 15: The Documentation Interlude\n\n\fcan we have your liver then?\nDATA\n\nspam = 40",
    "PyDoc: HTML Reports\nThe help function is nice for grabbing documentation when working interactively. For\na more grandiose display, however, PyDoc also provides a GUI interface (a simple but\nportable Python/tkinter script) and can render its report in HTML page format, viewable in any web browser. In this mode, PyDoc can run locally or as a remote server in\nclient/server mode; reports contain automatically created hyperlinks that allow you to\nclick your way through the documentation of related components in your application.\nTo start PyDoc in this mode, you generally first launch the search engine GUI captured\nin Figure 15-1. You can start this either by selecting the “Module Docs” item in Python’s\nStart button menu on Windows, or by launching the pydoc.py script in Python’s standard library directory: Lib on Windows (run pydoc.py with a -g command-line argument). Enter the name of a module you’re interested in, and press the Enter key; PyDoc",
    "in Figure 15-1. You can start this either by selecting the “Module Docs” item in Python’s\nStart button menu on Windows, or by launching the pydoc.py script in Python’s standard library directory: Lib on Windows (run pydoc.py with a -g command-line argument). Enter the name of a module you’re interested in, and press the Enter key; PyDoc\nwill march down your module import search path (sys.path) looking for references to\nthe requested module.",
    "Figure 15-1. The Pydoc top-level search engine GUI: type the name of a module you want\ndocumentation for, press Enter, select the module, and then press “go to selected” (or omit the module\nname and press “open browser” to see all available modules).\n\nOnce you’ve found a promising entry, select it and click “go to selected.” PyDoc will\nspawn a web browser on your machine to display the report rendered in HTML format.\nFigure 15-2 shows the information PyDoc displays for the built-in glob module.\nNotice the hyperlinks in the Modules section of this page—you can click these to jump\nto the PyDoc pages for related (imported) modules. For larger pages, PyDoc also generates hyperlinks to sections within the page.\nPython Documentation Sources | 383\n\n\fFigure 15-2. When you find a module in the Figure 15-1 GUI (such as this built-in standard library\nmodule) and press “go to selected,” the module’s documentation is rendered in HTML and displayed\nin a web browser window like this one.",
    "Like the help function interface, the GUI interface works on user-defined modules as\nwell as built-ins. Figure 15-3 shows the page generated for our docstrings.py module file.\nPyDoc can be customized and launched in various ways we won’t cover here; see its\nentry in Python’s standard library manual for more details. The main thing to take away\nfrom this section is that PyDoc essentially gives you implementation reports “for\nfree”—if you are good about using docstrings in your files, PyDoc does all the work of\ncollecting and formatting them for display. PyDoc only helps for objects like functions\nand modules, but it provides an easy way to access a middle level of documentation for\nsuch tools—its reports are more useful than raw attribute lists, and less exhaustive than\nthe standard manuals.\nCool PyDoc trick of the day: If you leave the module name empty in the top input field\nof the window in Figure 15-1 and press the “open browser” button, PyDoc will produce",
    "and modules, but it provides an easy way to access a middle level of documentation for\nsuch tools—its reports are more useful than raw attribute lists, and less exhaustive than\nthe standard manuals.\nCool PyDoc trick of the day: If you leave the module name empty in the top input field\nof the window in Figure 15-1 and press the “open browser” button, PyDoc will produce\na web page containing a hyperlink to every module you can possibly import on your\ncomputer. This includes Python standard library modules, modules of third-party\n384 | Chapter 15: The Documentation Interlude",
    "Figure 15-3. PyDoc can serve up documentation pages for both built-in and user-coded modules. Here\nis the page for a user-defined module, showing all its documentation strings (docstrings) extracted\nfrom the source file.\n\nextensions you may have installed, user-defined modules on your import search path,\nand even statically or dynamically linked-in C-coded modules. Such information is hard\nto come by otherwise without writing code that inspects a set of module sources.\nPyDoc can also be run to save the HTML documentation for a module in a file for later\nviewing or printing; see its documentation for pointers. Also, note that PyDoc might\nnot work well if run on scripts that read from standard input—PyDoc imports the target\nmodule to inspect its contents, and there may be no connection for standard input text\nwhen it is run in GUI mode. Modules that can be imported without immediate input\nrequirements will always work under PyDoc, though.\n\nPython Documentation Sources | 385",
    "The Standard Manual Set\nFor the complete and most up-to-date description of the language and its toolset, Python’s standard manuals stand ready to serve. Python’s manuals ship in HTML and\nother formats, and they are installed with the Python system on Windows—they are\navailable in your Start button’s menu for Python, and they can also be opened from the\nHelp menu within IDLE. You can also fetch the manual set separately from http://www\n.python.org in a variety of formats, or read them online at that site (follow the Documentation link). On Windows, the manuals are a compiled help file to support\nsearches, and the online versions at the Python website include a web-based search\npage.\nWhen opened, the Windows format of the manuals displays a root page like that in\nFigure 15-4. The two most important entries here are most likely the Library Reference\n(which documents built-in types, functions, exceptions, and standard library modules)",
    "searches, and the online versions at the Python website include a web-based search\npage.\nWhen opened, the Windows format of the manuals displays a root page like that in\nFigure 15-4. The two most important entries here are most likely the Library Reference\n(which documents built-in types, functions, exceptions, and standard library modules)\nand the Language Reference (which provides a formal description of language-level\ndetails). The tutorial listed on this page also provides a brief introduction for\nnewcomers.",
    "Figure 15-4. Python’s standard manual set, available online at http://www.python.org, from IDLE’s\nHelp menu, and in the Windows Start button menu. It’s a searchable help file on Windows, and there\nis a search engine for the online version. Of these, the Library Reference is the one you’ll want to use\nmost of the time.\n\n386 | Chapter 15: The Documentation Interlude\n\n\fWeb Resources\nAt the official Python website (http://www.python.org), you’ll find links to various Python resources, some of which cover special topics or domains. Click the Documentation link to access an online tutorial and the Beginners Guide to Python. The site also\nlists non-English Python resources.\nYou will find numerous Python wikis, blogs, websites, and a host of other resources\non the Web today. To sample the online community, try searching for a term like\n“Python programming” in Google.",
    "Published Books\nAs a final resource, you can choose from a large collection of reference books for Python.\nBear in mind that books tend to lag behind the cutting edge of Python changes, partly\nbecause of the work involved in writing, and partly because of the natural delays built\ninto the publishing cycle. Usually, by the time a book comes out, it’s three or more\nmonths behind the current Python state. Unlike standard manuals, books are also generally not free.\nStill, for many, the convenience and quality of a professionally published text is worth\nthe cost. Moreover, Python changes so slowly that books are usually still relevant years\nafter they are published, especially if their authors post updates on the Web. See the\nPreface for pointers to other Python books.",
    "Common Coding Gotchas\nBefore the programming exercises for this part of the book, let’s run through some of\nthe most common mistakes beginners make when coding Python statements and programs. Many of these are warnings I’ve thrown out earlier in this part of the book,\ncollected here for ease of reference. You’ll learn to avoid these pitfalls once you’ve\ngained a bit of Python coding experience, but a few words now might help you avoid\nfalling into some of these traps initially:\n• Don’t forget the colons. Always remember to type a : at the end of compound\nstatement headers (the first line of an if, while, for, etc.). You’ll probably forget\nat first (I did, and so have most of my 3,000 Python students over the years), but\nyou can take some comfort from the fact that it will soon become an unconscious\nhabit.\n• Start in column 1. Be sure to start top-level (unnested) code in column 1. That\nincludes unnested code typed into module files, as well as unnested code typed at",
    "at first (I did, and so have most of my 3,000 Python students over the years), but\nyou can take some comfort from the fact that it will soon become an unconscious\nhabit.\n• Start in column 1. Be sure to start top-level (unnested) code in column 1. That\nincludes unnested code typed into module files, as well as unnested code typed at\nthe interactive prompt.",
    "Common Coding Gotchas | 387",
    "• Blank lines matter at the interactive prompt. Blank lines in compound statements are always ignored in module files, but when you’re typing code at the\ninteractive prompt, they end the statement. In other words, blank lines tell the\ninteractive command line that you’ve finished a compound statement; if you want\nto continue, don’t hit the Enter key at the ... prompt (or in IDLE) until you’re\nreally done.\n• Indent consistently. Avoid mixing tabs and spaces in the indentation of a block,\nunless you know what your text editor does with tabs. Otherwise, what you see in\nyour editor may not be what Python sees when it counts tabs as a number of spaces.\nThis is true in any block-structured language, not just Python—if the next programmer has her tabs set differently, she will not understand the structure of your\ncode. It’s safer to use all tabs or all spaces for each block.\n• Don’t code C in Python. A reminder for C/C++ programmers: you don’t need to",
    "your editor may not be what Python sees when it counts tabs as a number of spaces.\nThis is true in any block-structured language, not just Python—if the next programmer has her tabs set differently, she will not understand the structure of your\ncode. It’s safer to use all tabs or all spaces for each block.\n• Don’t code C in Python. A reminder for C/C++ programmers: you don’t need to\ntype parentheses around tests in if and while headers (e.g., if (X==1):). You can,\nif you like (any expression can be enclosed in parentheses), but they are fully superfluous in this context. Also, do not terminate all your statements with semicolons; it’s technically legal to do this in Python as well, but it’s totally useless unless\nyou’re placing more than one statement on a single line (the end of a line normally\nterminates a statement). And remember, don’t embed assignment statements in\nwhile loop tests, and don’t use {} around blocks (indent your nested code blocks\nconsistently instead).",
    "you’re placing more than one statement on a single line (the end of a line normally\nterminates a statement). And remember, don’t embed assignment statements in\nwhile loop tests, and don’t use {} around blocks (indent your nested code blocks\nconsistently instead).\n• Use simple for loops instead of while or range. Another reminder: a simple\nfor loop (e.g., for x in seq:) is almost always simpler to code and quicker to run\nthan a while- or range-based counter loop. Because Python handles indexing internally for a simple for, it can sometimes be twice as fast as the equivalent\nwhile. Avoid the temptation to count things in Python!\n• Beware of mutables in assignments. I mentioned this in Chapter 11: you need\nto be careful about using mutables in a multiple-target assignment (a = b = []),\nas well as in an augmented assignment (a += [1, 2]). In both cases, in-place\nchanges may impact other variables. See Chapter 11 for details.",
    "while. Avoid the temptation to count things in Python!\n• Beware of mutables in assignments. I mentioned this in Chapter 11: you need\nto be careful about using mutables in a multiple-target assignment (a = b = []),\nas well as in an augmented assignment (a += [1, 2]). In both cases, in-place\nchanges may impact other variables. See Chapter 11 for details.\n• Don’t expect results from functions that change objects in-place. We encountered this one earlier, too: in-place change operations like the list.append and\nlist.sort methods introduced in Chapter 8 do not return values (other than\nNone), so you should call them without assigning the result. It’s not uncommon for\nbeginners to say something like mylist = mylist.append(X) to try to get the result\nof an append, but what this actually does is assign mylist to None, not to the modified\nlist (in fact, you’ll lose your reference to the list altogether).\nA more devious example of this pops up in Python 2.X code when trying to step",
    "None), so you should call them without assigning the result. It’s not uncommon for\nbeginners to say something like mylist = mylist.append(X) to try to get the result\nof an append, but what this actually does is assign mylist to None, not to the modified\nlist (in fact, you’ll lose your reference to the list altogether).\nA more devious example of this pops up in Python 2.X code when trying to step\nthrough dictionary items in a sorted fashion. It’s fairly common to see code like\nfor k in D.keys().sort():. This almost works—the keys method builds a keys\nlist, and the sort method orders it—but because the sort method returns None, the\nloop fails because it is ultimately a loop over None (a nonsequence). This fails even\n388 | Chapter 15: The Documentation Interlude",
    "sooner in Python 3.0, because dictionary keys are views, not lists! To code this\ncorrectly, either use the newer sorted built-in function, which returns the sorted\nlist, or split the method calls out to statements: Ks = list(D.keys()), then\nKs.sort(), and finally, for k in Ks:. This, by the way, is one case where you’ll still\nwant to call the keys method explicitly for looping, instead of relying on the dictionary iterators—iterators do not sort.\n• Always use parentheses to call a function. You must add parentheses after a\nfunction name to call it, whether it takes arguments or not (e.g., use function(),\nnot function). In Part IV, we’ll see that functions are simply objects that have a\nspecial operation—a call that you trigger with the parentheses.\nIn classes, this problem seems to occur most often with files; it’s common to see\nbeginners type file.close to close a file, rather than file.close(). Because it’s",
    "function name to call it, whether it takes arguments or not (e.g., use function(),\nnot function). In Part IV, we’ll see that functions are simply objects that have a\nspecial operation—a call that you trigger with the parentheses.\nIn classes, this problem seems to occur most often with files; it’s common to see\nbeginners type file.close to close a file, rather than file.close(). Because it’s\nlegal to reference a function without calling it, the first version with no parentheses\nsucceeds silently, but it does not close the file!\n• Don’t use extensions or paths in imports and reloads. Omit directory paths\nand file suffixes in import statements (e.g., say import mod, not import mod.py). (We\ndiscussed module basics in Chapter 3 and will continue studying modules in\nPart V.) Because modules may have other suffixes besides .py (.pyc, for instance),\nhardcoding a particular suffix is not only illegal syntax, but doesn’t make sense.",
    "and file suffixes in import statements (e.g., say import mod, not import mod.py). (We\ndiscussed module basics in Chapter 3 and will continue studying modules in\nPart V.) Because modules may have other suffixes besides .py (.pyc, for instance),\nhardcoding a particular suffix is not only illegal syntax, but doesn’t make sense.\nAny platform-specific directory path syntax comes from module search path settings, not the import statement.",
    "Chapter Summary\nThis chapter took us on a tour of program documentation—both documentation we\nwrite ourselves for our own programs, and documentation available for built-in tools.\nWe met docstrings, explored the online and manual resources for Python reference,\nand learned how PyDoc’s help function and web page interface provide extra sources\nof documentation. Because this is the last chapter in this part of the book, we also\nreviewed common coding mistakes to help you avoid them.\nIn the next part of this book, we’ll start applying what we already know to larger program constructs: functions. Before moving on, however, be sure to work through the\nset of lab exercises for this part of the book that appear at the end of this chapter. And\neven before that, let’s run through this chapter’s quiz.\n\nTest Your Knowledge: Quiz\n1. When should you use documentation strings instead of hash-mark comments?\n2. Name three ways you can view documentation strings.\n\nTest Your Knowledge: Quiz | 389",
    "Test Your Knowledge: Quiz\n1. When should you use documentation strings instead of hash-mark comments?\n2. Name three ways you can view documentation strings.\n\nTest Your Knowledge: Quiz | 389\n\n\f3. How can you obtain a list of the available attributes in an object?\n4. How can you get a list of all available modules on your computer?\n5. Which Python book should you purchase after this one?",
    "Test Your Knowledge: Answers\n1. Documentation strings (docstrings) are considered best for larger, functional documentation, describing the use of modules, functions, classes, and methods in your\ncode. Hash-mark comments are today best limited to micro-documentation about\narcane expressions or statements. This is partly because docstrings are easier to\nfind in a source file, but also because they can be extracted and displayed by the\nPyDoc system.\n2. You can see docstrings by printing an object’s __doc__ attribute, by passing it to\nPyDoc’s help function, and by selecting modules in PyDoc’s GUI search engine in\nclient/server mode. Additionally, PyDoc can be run to save a module’s documentation in an HTML file for later viewing or printing.\n3. The built-in dir(X) function returns a list of all the attributes attached to any object.\n4. Run the PyDoc GUI interface, leave the module name blank, and select “open\nbrowser”; this opens a web page containing a link to every module available to",
    "client/server mode. Additionally, PyDoc can be run to save a module’s documentation in an HTML file for later viewing or printing.\n3. The built-in dir(X) function returns a list of all the attributes attached to any object.\n4. Run the PyDoc GUI interface, leave the module name blank, and select “open\nbrowser”; this opens a web page containing a link to every module available to\nyour programs.\n5. Mine, of course. (Seriously, the Preface lists a few recommended follow-up books,\nboth for reference and for application tutorials.)",
    "Test Your Knowledge: Part III Exercises\nNow that you know how to code basic program logic, the following exercises will ask\nyou to implement some simple tasks with statements. Most of the work is in exercise\n4, which lets you explore coding alternatives. There are always many ways to arrange\nstatements, and part of learning Python is learning which arrangements work better\nthan others.\nSee Part III in Appendix B for the solutions.\n1. Coding basic loops.\na. Write a for loop that prints the ASCII code of each character in a string named\nS. Use the built-in function ord(character) to convert each character to an\nASCII integer. (Test it interactively to see how it works.)\nb. Next, change your loop to compute the sum of the ASCII codes of all the\ncharacters in a string.\n\n390 | Chapter 15: The Documentation Interlude",
    "390 | Chapter 15: The Documentation Interlude\n\n\fc. Finally, modify your code again to return a new list that contains the ASCII\ncodes of each character in the string. Does the expression map(ord, S) have a\nsimilar effect? (Hint: see Chapter 14.)\n2. Backslash characters. What happens on your machine when you type the following\ncode interactively?\nfor i in range(50):\nprint('hello %d\\n\\a' % i)",
    "Beware that if it’s run outside of the IDLE interface this example may beep at you,\nso you may not want to run it in a crowded lab. IDLE prints odd characters instead\nof beeping (see the backslash escape characters in Table 7-2).\n3. Sorting dictionaries. In Chapter 8, we saw that dictionaries are unordered collections. Write a for loop that prints a dictionary’s items in sorted (ascending) order.\n(Hint: use the dictionary keys and list sort methods, or the newer sorted built-in\nfunction.)\n4. Program logic alternatives. Consider the following code, which uses a while loop\nand found flag to search a list of powers of 2 for the value of 2 raised to the fifth\npower (32). It’s stored in a module file called power.py.\nL = [1, 2, 4, 8, 16, 32, 64]\nX = 5\nfound = False\ni = 0\nwhile not found and i < len(L):\nif 2 ** X == L[i]:\nfound = True\nelse:\ni = i+1\nif found:\nprint('at index', i)\nelse:\nprint(X, 'not found')\nC:\\book\\tests> python power.py\nat index 5",
    "As is, the example doesn’t follow normal Python coding techniques. Follow the\nsteps outlined here to improve it (for all the transformations, you may either type\nyour code interactively or store it in a script file run from the system command\nline—using a file makes this exercise much easier):\na. First, rewrite this code with a while loop else clause to eliminate the found flag\nand final if statement.\nb. Next, rewrite the example to use a for loop with an else clause, to eliminate\nthe explicit list-indexing logic. (Hint: to get the index of an item, use the list\nindex method—L.index(X) returns the offset of the first X in list L.)\n\nTest Your Knowledge: Part III Exercises | 391",
    "Test Your Knowledge: Part III Exercises | 391\n\n\fc. Next, remove the loop completely by rewriting the example with a simple in\noperator membership expression. (See Chapter 8 for more details, or type this\nto test: 2 in [1,2,3].)\nd. Finally, use a for loop and the list append method to generate the powers-of-2\nlist (L) instead of hardcoding a list literal.\nDeeper thoughts:\ne. Do you think it would improve performance to move the 2 ** X expression\noutside the loops? How would you code that?\nf. As we saw in exercise 1, Python includes a map(function, list) tool that can\ngenerate a powers-of-2 list, too: map(lambda x: 2 ** x, range(7)). Try typing\nthis code interactively; we’ll meet lambda more formally in Chapter 19.\n\n392 | Chapter 15: The Documentation Interlude\n\n\fPART IV\n\nFunctions\n\n\f\fCHAPTER 16\n\nFunction Basics",
    "In Part III, we looked at basic procedural statements in Python. Here, we’ll move on to\nexplore a set of additional statements that we can use to create functions of our own.\nIn simple terms, a function is a device that groups a set of statements so they can be run\nmore than once in a program. Functions also can compute a result value and let us\nspecify parameters that serve as function inputs, which may differ each time the code\nis run. Coding an operation as a function makes it a generally useful tool, which we\ncan use in a variety of contexts.\nMore fundamentally, functions are the alternative to programming by cutting and\npasting—rather than having multiple redundant copies of an operation’s code, we can\nfactor it into a single function. In so doing, we reduce our future work radically: if the\noperation must be changed later, we only have one copy to update, not many.\nFunctions are the most basic program structure Python provides for maximizing code",
    "pasting—rather than having multiple redundant copies of an operation’s code, we can\nfactor it into a single function. In so doing, we reduce our future work radically: if the\noperation must be changed later, we only have one copy to update, not many.\nFunctions are the most basic program structure Python provides for maximizing code\nreuse and minimizing code redundancy. As we’ll see, functions are also a design tool\nthat lets us split complex systems into manageable parts. Table 16-1 summarizes the\nprimary function-related tools we’ll study in this part of the book.\nTable 16-1. Function-related statements and expressions\nStatement",
    "Examples\n\nCalls\n\nmyfunc('spam', 'eggs', meat=ham)\n\ndef,\nreturn\n\ndef adder(a, b=1, *c):\nreturn a + b + c[0]\n\nglobal\n\ndef changer():\nglobal x; x = 'new'\n\nnonlocal\n\ndef changer():\nnonlocal x; x = 'new'\n\nyield\n\ndef squares(x):\nfor i in range(x): yield i ** 2\n\nlambda\n\nfuncs = [lambda x: x**2, lambda x: x*3]\n\n395",
    "Why Use Functions?\nBefore we get into the details, let’s establish a clear picture of what functions are all\nabout. Functions are a nearly universal program-structuring device. You may have\ncome across them before in other languages, where they may have been called subroutines or procedures. As a brief introduction, functions serve two primary development\nroles:\nMaximizing code reuse and minimizing redundancy\nAs in most programming languages, Python functions are the simplest way to\npackage logic you may wish to use in more than one place and more than one time.\nUp until now, all the code we’ve been writing has run immediately. Functions allow\nus to group and generalize code to be used arbitrarily many times later. Because\nthey allow us to code an operation in a single place and use it in many places,\nPython functions are the most basic factoring tool in the language: they allow us\nto reduce code redundancy in our programs, and thereby reduce maintenance\neffort.",
    "us to group and generalize code to be used arbitrarily many times later. Because\nthey allow us to code an operation in a single place and use it in many places,\nPython functions are the most basic factoring tool in the language: they allow us\nto reduce code redundancy in our programs, and thereby reduce maintenance\neffort.\nProcedural decomposition\nFunctions also provide a tool for splitting systems into pieces that have well-defined\nroles. For instance, to make a pizza from scratch, you would start by mixing the\ndough, rolling it out, adding toppings, baking it, and so on. If you were programming a pizza-making robot, functions would help you divide the overall “make\npizza” task into chunks—one function for each subtask in the process. It’s easier\nto implement the smaller tasks in isolation than it is to implement the entire process\nat once. In general, functions are about procedure—how to do something, rather",
    "pizza” task into chunks—one function for each subtask in the process. It’s easier\nto implement the smaller tasks in isolation than it is to implement the entire process\nat once. In general, functions are about procedure—how to do something, rather\nthan what you’re doing it to. We’ll see why this distinction matters in Part VI, when\nwe start making new object with classes.\nIn this part of the book, we’ll explore the tools used to code functions in Python: function basics, scope rules, and argument passing, along with a few related concepts such\nas generators and functional tools. Because its importance begins to become more apparent at this level of coding, we’ll also revisit the notion of polymorphism introduced\nearlier in the book. As you’ll see, functions don’t imply much new syntax, but they do\nlead us to some bigger programming ideas.",
    "Coding Functions\nAlthough it wasn’t made very formal, we’ve already used some functions in earlier\nchapters. For instance, to make a file object, we called the built-in open function; similarly, we used the len built-in function to ask for the number of items in a collection\nobject.\nIn this chapter, we will explore how to write new functions in Python. Functions we\nwrite behave the same way as the built-ins we’ve already seen: they are called in\n\n396 | Chapter 16: Function Basics",
    "expressions, are passed values, and return results. But writing new functions requires\nthe application of a few additional ideas that haven’t yet been introduced. Moreover,\nfunctions behave very differently in Python than they do in compiled languages like C.\nHere is a brief introduction to the main concepts behind Python functions, all of which\nwe will study in this part of the book:\n• def is executable code. Python functions are written with a new statement, the\ndef. Unlike functions in compiled languages such as C, def is an executable statement—your function does not exist until Python reaches and runs the def. In fact,\nit’s legal (and even occasionally useful) to nest def statements inside if statements,\nwhile loops, and even other defs. In typical operation, def statements are coded in\nmodule files and are naturally run to generate functions when a module file is first\nimported.\n• def creates an object and assigns it to a name. When Python reaches and runs",
    "it’s legal (and even occasionally useful) to nest def statements inside if statements,\nwhile loops, and even other defs. In typical operation, def statements are coded in\nmodule files and are naturally run to generate functions when a module file is first\nimported.\n• def creates an object and assigns it to a name. When Python reaches and runs\na def statement, it generates a new function object and assigns it to the function’s\nname. As with all assignments, the function name becomes a reference to the function object. There’s nothing magic about the name of a function—as you’ll see,\nthe function object can be assigned to other names, stored in a list, and so on.\nFunction objects may also have arbitrary user-defined attributes attached to them\nto record data.\n• lambda creates an object but returns it as a result. Functions may also be created\nwith the lambda expression, a feature that allows us to in-line function definitions",
    "the function object can be assigned to other names, stored in a list, and so on.\nFunction objects may also have arbitrary user-defined attributes attached to them\nto record data.\n• lambda creates an object but returns it as a result. Functions may also be created\nwith the lambda expression, a feature that allows us to in-line function definitions\nin places where a def statement won’t work syntactically (this is a more advanced\nconcept that we’ll defer until Chapter 19).\n• return sends a result object back to the caller. When a function is called, the\ncaller stops until the function finishes its work and returns control to the caller.\nFunctions that compute a value send it back to the caller with a return statement;\nthe returned value becomes the result of the function call.\n• yield sends a result object back to the caller, but remembers where it left\noff. Functions known as generators may also use the yield statement to send back",
    "caller stops until the function finishes its work and returns control to the caller.\nFunctions that compute a value send it back to the caller with a return statement;\nthe returned value becomes the result of the function call.\n• yield sends a result object back to the caller, but remembers where it left\noff. Functions known as generators may also use the yield statement to send back\na value and suspend their state such that they may be resumed later, to produce a\nseries of results over time. This is another advanced topic covered later in this part\nof the book.\n• global declares module-level variables that are to be assigned. By default, all\nnames assigned in a function are local to that function and exist only while the\nfunction runs. To assign a name in the enclosing module, functions need to list it\nin a global statement. More generally, names are always looked up in scopes—\nplaces where variables are stored—and assignments bind names to scopes.",
    "• global declares module-level variables that are to be assigned. By default, all\nnames assigned in a function are local to that function and exist only while the\nfunction runs. To assign a name in the enclosing module, functions need to list it\nin a global statement. More generally, names are always looked up in scopes—\nplaces where variables are stored—and assignments bind names to scopes.\n• nonlocal declares enclosing function variables that are to be assigned. Similarly, the nonlocal statement added in Python 3.0 allows a function to assign a\nname that exists in the scope of a syntactically enclosing def statement. This allows",
    "Coding Functions | 397",
    "enclosing functions to serve as a place to retain state—information remembered\nwhen a function is called—without using shared global names.\n• Arguments are passed by assignment (object reference). In Python, arguments\nare passed to functions by assignment (which, as we’ve learned, means by object\nreference). As you’ll see, in Python’s model the caller and function share objects\nby references, but there is no name aliasing. Changing an argument name within\na function does not also change the corresponding name in the caller, but changing\npassed-in mutable objects can change objects shared by the caller.\n• Arguments, return values, and variables are not declared. As with everything\nin Python, there are no type constraints on functions. In fact, nothing about a\nfunction needs to be declared ahead of time: you can pass in arguments of any type,\nreturn any kind of object, and so on. As one consequence, a single function can",
    "passed-in mutable objects can change objects shared by the caller.\n• Arguments, return values, and variables are not declared. As with everything\nin Python, there are no type constraints on functions. In fact, nothing about a\nfunction needs to be declared ahead of time: you can pass in arguments of any type,\nreturn any kind of object, and so on. As one consequence, a single function can\noften be applied to a variety of object types—any objects that sport a compatible\ninterface (methods and expressions) will do, regardless of their specific types.\nIf some of the preceding words didn’t sink in, don’t worry—we’ll explore all of these\nconcepts with real code in this part of the book. Let’s get started by expanding on some\nof these ideas and looking at a few examples.",
    "def Statements\nThe def statement creates a function object and assigns it to a name. Its general format\nis as follows:\ndef <name>(arg1, arg2,... argN):\n<statements>\n\nAs with all compound Python statements, def consists of a header line followed by a\nblock of statements, usually indented (or a simple statement after the colon). The\nstatement block becomes the function’s body—that is, the code Python executes each\ntime the function is called.\nThe def header line specifies a function name that is assigned the function object, along\nwith a list of zero or more arguments (sometimes called parameters) in parentheses.\nThe argument names in the header are assigned to the objects passed in parentheses at\nthe point of call.\nFunction bodies often contain a return statement:\ndef <name>(arg1, arg2,... argN):\n...\nreturn <value>",
    "The Python return statement can show up anywhere in a function body; it ends the\nfunction call and sends a result back to the caller. The return statement consists of an\nobject expression that gives the function’s result. The return statement is optional; if\nit’s not present, the function exits when the control flow falls off the end of the function\n\n398 | Chapter 16: Function Basics\n\n\fbody. Technically, a function without a return statement returns the None object automatically, but this return value is usually ignored.\nFunctions may also contain yield statements, which are designed to produce a series\nof values over time, but we’ll defer discussion of these until we survey generator topics\nin Chapter 20.",
    "398 | Chapter 16: Function Basics\n\n\fbody. Technically, a function without a return statement returns the None object automatically, but this return value is usually ignored.\nFunctions may also contain yield statements, which are designed to produce a series\nof values over time, but we’ll defer discussion of these until we survey generator topics\nin Chapter 20.\n\ndef Executes at Runtime\nThe Python def is a true executable statement: when it runs, it creates a new function\nobject and assigns it to a name. (Remember, all we have in Python is runtime; there is\nno such thing as a separate compile time.) Because it’s a statement, a def can appear\nanywhere a statement can—even nested in other statements. For instance, although\ndefs normally are run when the module enclosing them is imported, it’s also completely\nlegal to nest a function def inside an if statement to select between alternative\ndefinitions:\nif test:\ndef func():\n...\nelse:\ndef func():\n...\n...\nfunc()",
    "# Define func this way\n# Or else this way\n# Call the version selected and built\n\nOne way to understand this code is to realize that the def is much like an = statement:\nit simply assigns a name at runtime. Unlike in compiled languages such as C, Python\nfunctions do not need to be fully defined before the program runs. More generally,\ndefs are not evaluated until they are reached and run, and the code inside defs is not\nevaluated until the functions are later called.\nBecause function definition happens at runtime, there’s nothing special about the\nfunction name. What’s important is the object to which it refers:\nothername = func\nothername()\n\n# Assign function object\n# Call func again",
    "# Assign function object\n# Call func again\n\nHere, the function was assigned to a different name and called through the new name.\nLike everything else in Python, functions are just objects; they are recorded explicitly\nin memory at program execution time. In fact, besides calls, functions allow arbitrary\nattributes to be attached to record information for later use:\ndef func(): ...\nfunc()\nfunc.attr = value\n\n# Create function object\n# Call object\n# Attach attributes\n\nCoding Functions | 399\n\n\fA First Example: Definitions and Calls\nApart from such runtime concepts (which tend to seem most unique to programmers\nwith backgrounds in traditional compiled languages), Python functions are straightforward to use. Let’s code a first real example to demonstrate the basics. As you’ll see,\nthere are two sides to the function picture: a definition (the def that creates a function)\nand a call (an expression that tells Python to run the function’s body).",
    "Definition\nHere’s a definition typed interactively that defines a function called times, which returns the product of its two arguments:\n>>> def times(x, y):\n...\nreturn x * y\n...\n\n# Create and assign function\n# Body executed when called\n\nWhen Python reaches and runs this def, it creates a new function object that packages\nthe function’s code and assigns the object to the name times. Typically, such a statement is coded in a module file and runs when the enclosing file is imported; for something this small, though, the interactive prompt suffices.\n\nCalls\nAfter the def has run, you can call (run) the function in your program by adding\nparentheses after the function’s name. The parentheses may optionally contain one or\nmore object arguments, to be passed (assigned) to the names in the function’s header:\n>>> times(2, 4)\n8\n\n# Arguments in parentheses",
    "Calls\nAfter the def has run, you can call (run) the function in your program by adding\nparentheses after the function’s name. The parentheses may optionally contain one or\nmore object arguments, to be passed (assigned) to the names in the function’s header:\n>>> times(2, 4)\n8\n\n# Arguments in parentheses\n\nThis expression passes two arguments to times. As mentioned previously, arguments\nare passed by assignment, so in this case the name x in the function header is assigned\nthe value 2, y is assigned the value 4, and the function’s body is run. For this function,\nthe body is just a return statement that sends back the result as the value of the call\nexpression. The returned object was printed here interactively (as in most languages,\n2 * 4 is 8 in Python), but if we needed to use it later we could instead assign it to a\nvariable. For example:\n>>> x = times(3.14, 4)\n>>> x\n12.56\n\n# Save the result object",
    "# Save the result object\n\nNow, watch what happens when the function is called a third time, with very different\nkinds of objects passed in:\n>>> times('Ni', 4)\n'NiNiNiNi'\n\n400 | Chapter 16: Function Basics\n\n# Functions are \"typeless\"\n\n\fThis time, our function means something completely different (Monty Python reference\nagain intended). In this third call, a string and an integer are passed to x and y, instead\nof two numbers. Recall that * works on both numbers and sequences; because we never\ndeclare the types of variables, arguments, or return values in Python, we can use\ntimes to either multiply numbers or repeat sequences.\nIn other words, what our times function means and does depends on what we pass into\nit. This is a core idea in Python (and perhaps the key to using the language well), which\nwe’ll explore in the next section.",
    "Polymorphism in Python\nAs we just saw, the very meaning of the expression x * y in our simple times function\ndepends completely upon the kinds of objects that x and y are—thus, the same function\ncan perform multiplication in one instance and repetition in another. Python leaves it\nup to the objects to do something reasonable for the syntax. Really, * is just a dispatch\nmechanism that routes control to the objects being processed.\nThis sort of type-dependent behavior is known as polymorphism, a term we first met\nin Chapter 4 that essentially means that the meaning of an operation depends on the\nobjects being operated upon. Because it’s a dynamically typed language, polymorphism\nruns rampant in Python. In fact, every operation is a polymorphic operation in Python:\nprinting, indexing, the * operator, and much more.\nThis is deliberate, and it accounts for much of the language’s conciseness and flexibility.",
    "in Chapter 4 that essentially means that the meaning of an operation depends on the\nobjects being operated upon. Because it’s a dynamically typed language, polymorphism\nruns rampant in Python. In fact, every operation is a polymorphic operation in Python:\nprinting, indexing, the * operator, and much more.\nThis is deliberate, and it accounts for much of the language’s conciseness and flexibility.\nA single function, for instance, can generally be applied to a whole category of object\ntypes automatically. As long as those objects support the expected interface (a.k.a.\nprotocol), the function can process them. That is, if the objects passed into a function\nhave the expected methods and expression operators, they are plug-and-play compatible with the function’s logic.\nEven in our simple times function, this means that any two objects that support a * will\nwork, no matter what they may be, and no matter when they are coded. This function",
    "protocol), the function can process them. That is, if the objects passed into a function\nhave the expected methods and expression operators, they are plug-and-play compatible with the function’s logic.\nEven in our simple times function, this means that any two objects that support a * will\nwork, no matter what they may be, and no matter when they are coded. This function\nwill work on two numbers (performing multiplication), or a string and a number (performing repetition), or any other combination of objects supporting the expected\ninterface—even class-based objects we have not even coded yet.\nMoreover, if the objects passed in do not support this expected interface, Python will\ndetect the error when the * expression is run and raise an exception automatically. It’s\ntherefore pointless to code error checking ourselves. In fact, doing so would limit our\nfunction’s utility, as it would be restricted to work only on objects whose types we test\nfor.",
    "Moreover, if the objects passed in do not support this expected interface, Python will\ndetect the error when the * expression is run and raise an exception automatically. It’s\ntherefore pointless to code error checking ourselves. In fact, doing so would limit our\nfunction’s utility, as it would be restricted to work only on objects whose types we test\nfor.\nThis turns out to be a crucial philosophical difference between Python and statically\ntyped languages like C++ and Java: in Python, your code is not supposed to care about\nspecific data types. If it does, it will be limited to working on just the types you anticipated when you wrote it, and it will not support other compatible object types that\nA First Example: Definitions and Calls | 401",
    "may be coded in the future. Although it is possible to test for types with tools like the\ntype built-in function, doing so breaks your code’s flexibility. By and large, we code to\nobject interfaces in Python, not data types.\nOf course, this polymorphic model of programming means we have to test our code to\ndetect errors, rather than providing type declarations a compiler can use to detect some\ntypes of errors for us ahead of time. In exchange for an initial bit of testing, though, we\nradically reduce the amount of code we have to write and radically increase our code’s\nflexibility. As you’ll learn, it’s a net win in practice.",
    "A Second Example: Intersecting Sequences\nLet’s look at a second function example that does something a bit more useful than\nmultiplying arguments and further illustrates function basics.\nIn Chapter 13, we coded a for loop that collected items held in common in two strings.\nWe noted there that the code wasn’t as useful as it could be because it was set up to\nwork only on specific variables and could not be rerun later. Of course, we could copy\nthe code and paste it into each place where it needs to be run, but this solution is neither\ngood nor general—we’d still have to edit each copy to support different sequence\nnames, and changing the algorithm would then require changing multiple copies.",
    "Definition\nBy now, you can probably guess that the solution to this dilemma is to package the\nfor loop inside a function. Doing so offers a number of advantages:\n• Putting the code in a function makes it a tool that you can run as many times as\nyou like.\n• Because callers can pass in arbitrary arguments, functions are general enough to\nwork on any two sequences (or other iterables) you wish to intersect.\n• When the logic is packaged in a function, you only have to change code in one\nplace if you ever need to change the way the intersection works.\n• Coding the function in a module file means it can be imported and reused by any\nprogram run on your machine.\nIn effect, wrapping the code in a function makes it a general intersection utility:\ndef intersect(seq1, seq2):\nres = []\nfor x in seq1:\nif x in seq2:\nres.append(x)\nreturn res\n\n# Start empty\n# Scan seq1\n# Common item?\n# Add to end",
    "# Start empty\n# Scan seq1\n# Common item?\n# Add to end\n\nThe transformation from the simple code of Chapter 13 to this function is straightforward; we’ve just nested the original logic under a def header and made the objects on\n402 | Chapter 16: Function Basics\n\n\fwhich it operates passed-in parameter names. Because this function computes a result,\nwe’ve also added a return statement to send a result object back to the caller.\n\nCalls\nBefore you can call a function, you have to make it. To do this, run its def statement,\neither by typing it interactively or by coding it in a module file and importing the file.\nOnce you’ve run the def, you can call the function by passing any two sequence objects\nin parentheses:\n>>> s1 = \"SPAM\"\n>>> s2 = \"SCAM\"\n>>> intersect(s1, s2)\n['S', 'A', 'M']\n\n# Strings",
    "# Strings\n\nHere, we’ve passed in two strings, and we get back a list containing the characters in\ncommon. The algorithm the function uses is simple: “for every item in the first argument, if that item is also in the second argument, append the item to the result.” It’s a\nlittle shorter to say that in Python than in English, but it works out the same.\nTo be fair, our intersect function is fairly slow (it executes nested loops), isn’t really\nmathematical intersection (there may be duplicates in the result), and isn’t required at\nall (as we’ve seen, Python’s set data type provides a built-in intersection operation).\nIndeed, the function could be replaced with a single list comprehension expression, as\nit exhibits the classic loop collector code pattern:\n>>> [x for x in s1 if x in s2]\n['S', 'A', 'M']\n\nAs a function basics example, though, it does the job—this single piece of code can\napply to an entire range of object types, as the next section explains.",
    "As a function basics example, though, it does the job—this single piece of code can\napply to an entire range of object types, as the next section explains.\n\nPolymorphism Revisited\nLike all functions in Python, intersect is polymorphic. That is, it works on arbitrary\ntypes, as long as they support the expected object interface:\n>>> x = intersect([1, 2, 3], (1, 4))\n>>> x\n[1]\n\n# Mixed types\n# Saved result object",
    "Polymorphism Revisited\nLike all functions in Python, intersect is polymorphic. That is, it works on arbitrary\ntypes, as long as they support the expected object interface:\n>>> x = intersect([1, 2, 3], (1, 4))\n>>> x\n[1]\n\n# Mixed types\n# Saved result object\n\nThis time, we passed in different types of objects to our function—a list and a tuple\n(mixed types)—and it still picked out the common items. Because you don’t have to\nspecify the types of arguments ahead of time, the intersect function happily iterates\nthrough any kind of sequence objects you send it, as long as they support the expected\ninterfaces.\nFor intersect, this means that the first argument has to support the for loop, and the\nsecond has to support the in membership test. Any two such objects will work, regardless of their specific types—that includes physically stored sequences like strings\nA Second Example: Intersecting Sequences | 403",
    "and lists; all the iterable objects we met in Chapter 14, including files and dictionaries;\nand even any class-based objects we code that apply operator overloading techniques\n(we’ll discuss these later in the book).*\nHere again, if we pass in objects that do not support these interfaces (e.g., numbers),\nPython will automatically detect the mismatch and raise an exception for us—which\nis exactly what we want, and the best we could do on our own if we coded explicit type\ntests. By not coding type tests and allowing Python to detect the mismatches for us, we\nboth reduce the amount of code we need to write and increase our code’s flexibility.",
    "Local Variables\nProbably the most interesting part of this example is its names. It turns out that the\nvariable res inside intersect is what in Python is called a local variable—a name that\nis visible only to code inside the function def and that exists only while the function\nruns. In fact, because all names assigned in any way inside a function are classified as\nlocal variables by default, nearly all the names in intersect are local variables:\n• res is obviously assigned, so it is a local variable.\n• Arguments are passed by assignment, so seq1 and seq2 are, too.\n• The for loop assigns items to a variable, so the name x is also local.\nAll these local variables appear when the function is called and disappear when the\nfunction exits—the return statement at the end of intersect sends back the result\nobject, but the name res goes away. To fully explore the notion of locals, though, we\nneed to move on to Chapter 17.",
    "Chapter Summary\nThis chapter introduced the core ideas behind function definition—the syntax and\noperation of the def and return statements, the behavior of function call expressions,\nand the notion and benefits of polymorphism in Python functions. As we saw, a def\nstatement is executable code that creates a function object at runtime; when the function is later called, objects are passed into it by assignment (recall that assignment\nmeans object reference in Python, which, as we learned in Chapter 6, really means\npointer internally), and computed values are sent back by return. We also began",
    "* This code will always work if we intersect files’ contents obtained with file.readlines(). It may not work\nto intersect lines in open input files directly, though, depending on the file object’s implementation of the\nin operator or general iteration. Files must generally be rewound (e.g., with a file.seek(0) or another\nopen) after they have been read to end-of-file once. As we’ll see in Chapter 29 when we study operator\noverloading, classes implement the in operator either by providing the specific __contains__ method or by\nsupporting the general iteration protocol with the __iter__ or older __getitem__ methods; if coded, classes\ncan define what iteration means for their data.\n\n404 | Chapter 16: Function Basics\n\n\fexploring the concepts of local variables and scopes in this chapter, but we’ll save all\nthe details on those topics for Chapter 17. First, though, a quick quiz.",
    "404 | Chapter 16: Function Basics\n\n\fexploring the concepts of local variables and scopes in this chapter, but we’ll save all\nthe details on those topics for Chapter 17. First, though, a quick quiz.\n\nTest Your Knowledge: Quiz\n1. What is the point of coding functions?\n2. At what time does Python create a function?\n3. What does a function return if it has no return statement in it?\n4. When does the code nested inside the function definition statement run?\n5. What’s wrong with checking the types of objects passed into a function?",
    "Test Your Knowledge: Answers\n1. Functions are the most basic way of avoiding code redundancy in Python—factoring code into functions means that we have only one copy of an operation’s code\nto update in the future. Functions are also the basic unit of code reuse in Python—\nwrapping code in functions makes it a reusable tool, callable in a variety of programs. Finally, functions allow us to divide a complex system into manageable\nparts, each of which may be developed individually.\n2. A function is created when Python reaches and runs the def statement; this statement creates a function object and assigns it the function’s name. This normally\nhappens when the enclosing module file is imported by another module (recall that\nimports run the code in a file from top to bottom, including any defs), but it can\nalso occur when a def is typed interactively or nested in other statements, such as\nifs.\n3. A function returns the None object by default if the control flow falls off the end of",
    "happens when the enclosing module file is imported by another module (recall that\nimports run the code in a file from top to bottom, including any defs), but it can\nalso occur when a def is typed interactively or nested in other statements, such as\nifs.\n3. A function returns the None object by default if the control flow falls off the end of\nthe function body without running into a return statement. Such functions are\nusually called with expression statements, as assigning their None results to variables is generally pointless.\n4. The function body (the code nested inside the function definition statement) is run\nwhen the function is later called with a call expression. The body runs anew each\ntime the function is called.\n5. Checking the types of objects passed into a function effectively breaks the function’s flexibility, constraining the function to work on specific types only. Without\nsuch checks, the function would likely be able to process an entire range of object",
    "when the function is later called with a call expression. The body runs anew each\ntime the function is called.\n5. Checking the types of objects passed into a function effectively breaks the function’s flexibility, constraining the function to work on specific types only. Without\nsuch checks, the function would likely be able to process an entire range of object\ntypes—any objects that support the interface expected by the function will work.\n(The term interface means the set of methods and expression operators the function’s code runs.)",
    "Test Your Knowledge: Answers | 405\n\n\f\fCHAPTER 17\n\nScopes\n\nChapter 16 introduced basic function definitions and calls. As we saw, Python’s basic\nfunction model is simple to use, but even simple function examples quickly led us to\nquestions about the meaning of variables in our code. This chapter moves on to present\nthe details behind Python’s scopes—the places where variables are defined and looked\nup. As we’ll see, the place where a name is assigned in our code is crucial to determining\nwhat the name means. We’ll also find that scope usage can have a major impact on\nprogram maintenance effort; overuse of globals, for example, is a generally bad thing.",
    "Python Scope Basics\nNow that you’re ready to start writing your own functions, we need to get more formal\nabout what names mean in Python. When you use a name in a program, Python creates,\nchanges, or looks up the name in what is known as a namespace—a place where names\nlive. When we talk about the search for a name’s value in relation to code, the term\nscope refers to a namespace: that is, the location of a name’s assignment in your code\ndetermines the scope of the name’s visibility to your code.\nJust about everything related to names, including scope classification, happens at assignment time in Python. As we’ve seen, names in Python spring into existence when\nthey are first assigned values, and they must be assigned before they are used. Because\nnames are not declared ahead of time, Python uses the location of the assignment of a\nname to associate it with (i.e., bind it to) a particular namespace. In other words, the",
    "they are first assigned values, and they must be assigned before they are used. Because\nnames are not declared ahead of time, Python uses the location of the assignment of a\nname to associate it with (i.e., bind it to) a particular namespace. In other words, the\nplace where you assign a name in your source code determines the namespace it will\nlive in, and hence its scope of visibility.\nBesides packaging code, functions add an extra namespace layer to your programs—\nby default, all names assigned inside a function are associated with that function’s\nnamespace, and no other. This means that:\n• Names defined inside a def can only be seen by the code within that def. You cannot\neven refer to such names from outside the function.",
    "407",
    "• Names defined inside a def do not clash with variables outside the def, even if the\nsame names are used elsewhere. A name X assigned outside a given def (i.e., in a\ndifferent def or at the top level of a module file) is a completely different variable\nfrom a name X assigned inside that def.\nIn all cases, the scope of a variable (where it can be used) is always determined by where\nit is assigned in your source code and has nothing to do with which functions call which.\nIn fact, as we’ll learn in this chapter, variables may be assigned in three different places,\ncorresponding to three different scopes:\n• If a variable is assigned inside a def, it is local to that function.\n• If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n• If a variable is assigned outside all defs, it is global to the entire file.",
    "In fact, as we’ll learn in this chapter, variables may be assigned in three different places,\ncorresponding to three different scopes:\n• If a variable is assigned inside a def, it is local to that function.\n• If a variable is assigned in an enclosing def, it is nonlocal to nested functions.\n• If a variable is assigned outside all defs, it is global to the entire file.\nWe call this lexical scoping because variable scopes are determined entirely by the locations of the variables in the source code of your program files, not by function calls.\nFor example, in the following module file, the X = 99 assignment creates a global variable named X (visible everywhere in this file), but the X = 88 assignment creates a\nlocal variable X (visible only within the def statement):\nX = 99\ndef func():\nX = 88",
    "Even though both variables are named X, their scopes make them different. The net\neffect is that function scopes help to avoid name clashes in your programs and help to\nmake functions more self-contained program units.",
    "Scope Rules\nBefore we started writing functions, all the code we wrote was at the top level of a\nmodule (i.e., not nested in a def), so the names we used either lived in the module itself\nor were built-ins predefined by Python (e.g., open). Functions provide nested namespaces (scopes) that localize the names they use, such that names inside a function\nwon’t clash with those outside it (in a module or another function). Again, functions\ndefine a local scope, and modules define a global scope. The two scopes are related as\nfollows:\n• The enclosing module is a global scope. Each module is a global scope—that\nis, a namespace in which variables created (assigned) at the top level of the module\nfile live. Global variables become attributes of a module object to the outside world\nbut can be used as simple variables within a module file.\n• The global scope spans a single file only. Don’t be fooled by the word “global”",
    "follows:\n• The enclosing module is a global scope. Each module is a global scope—that\nis, a namespace in which variables created (assigned) at the top level of the module\nfile live. Global variables become attributes of a module object to the outside world\nbut can be used as simple variables within a module file.\n• The global scope spans a single file only. Don’t be fooled by the word “global”\nhere—names at the top level of a file are only global to code within that single file.\nThere is really no notion of a single, all-encompassing global file-based scope in",
    "408 | Chapter 17: Scopes",
    "Python. Instead, names are partitioned into modules, and you must always import\na module explicitly if you want to be able to use the names its file defines. When\nyou hear “global” in Python, think “module.”\n• Each call to a function creates a new local scope. Every time you call a function,\nyou create a new local scope—that is, a namespace in which the names created\ninside that function will usually live. You can think of each def statement (and\nlambda expression) as defining a new local scope, but because Python allows functions to call themselves to loop (an advanced technique known as recursion), the\nlocal scope in fact technically corresponds to a function call—in other words, each\ncall creates a new local namespace. Recursion is useful when processing structures\nwhose shapes can’t be predicted ahead of time.\n• Assigned names are local unless declared global or nonlocal. By default, all\nthe names assigned inside a function definition are put in the local scope (the",
    "local scope in fact technically corresponds to a function call—in other words, each\ncall creates a new local namespace. Recursion is useful when processing structures\nwhose shapes can’t be predicted ahead of time.\n• Assigned names are local unless declared global or nonlocal. By default, all\nthe names assigned inside a function definition are put in the local scope (the\nnamespace associated with the function call). If you need to assign a name that\nlives at the top level of the module enclosing the function, you can do so by declaring it in a global statement inside the function. If you need to assign a name\nthat lives in an enclosing def, as of Python 3.0 you can do so by declaring it in a\nnonlocal statement.\n• All other names are enclosing function locals, globals, or built-ins. Names\nnot assigned a value in the function definition are assumed to be enclosing scope",
    "that lives in an enclosing def, as of Python 3.0 you can do so by declaring it in a\nnonlocal statement.\n• All other names are enclosing function locals, globals, or built-ins. Names\nnot assigned a value in the function definition are assumed to be enclosing scope\nlocals (in an enclosing def), globals (in the enclosing module’s namespace), or builtins (in the predefined __builtin__ module Python provides).\nThere are a few subtleties to note here. First, keep in mind that code typed at the\ninteractive command prompt follows these same rules. You may not know it yet, but\ncode run interactively is really entered into a built-in module called __main__; this\nmodule works just like a module file, but results are echoed as you go. Because of this,\ninteractively created names live in a module, too, and thus follow the normal scope\nrules: they are global to the interactive session. You’ll learn more about modules in the\nnext part of this book.",
    "code run interactively is really entered into a built-in module called __main__; this\nmodule works just like a module file, but results are echoed as you go. Because of this,\ninteractively created names live in a module, too, and thus follow the normal scope\nrules: they are global to the interactive session. You’ll learn more about modules in the\nnext part of this book.\nAlso note that any type of assignment within a function classifies a name as local. This\nincludes = statements, module names in import, function names in def, function argument names, and so on. If you assign a name in any way within a def, it will become a\nlocal to that function.\nConversely, in-place changes to objects do not classify names as locals; only actual name\nassignments do. For instance, if the name L is assigned to a list at the top level of a\nmodule, a statement L = X within a function will classify L as a local, but L.append(X)",
    "local to that function.\nConversely, in-place changes to objects do not classify names as locals; only actual name\nassignments do. For instance, if the name L is assigned to a list at the top level of a\nmodule, a statement L = X within a function will classify L as a local, but L.append(X)\nwill not. In the latter case, we are changing the list object that L references, not L itself—\nL is found in the global scope as usual, and Python happily modifies it without requiring\na global (or nonlocal) declaration. As usual, it helps to keep the distinction between\nnames and objects clear: changing an object is not an assignment to a name.",
    "Python Scope Basics | 409",
    "Name Resolution: The LEGB Rule\nIf the prior section sounds confusing, it really boils down to three simple rules. With a\ndef statement:\n• Name references search at most four scopes: local, then enclosing functions (if\nany), then global, then built-in.\n• Name assignments create or change local names by default.\n• global and nonlocal declarations map assigned names to enclosing module and\nfunction scopes.\nIn other words, all names assigned inside a function def statement (or a lambda, an\nexpression we’ll meet later) are locals by default. Functions can freely use names assigned in syntactically enclosing functions and the global scope, but they must declare\nsuch nonlocals and globals in order to change them.\nPython’s name-resolution scheme is sometimes called the LEGB rule, after the scope\nnames:\n• When you use an unqualified name inside a function, Python searches up to four\nscopes—the local (L) scope, then the local scopes of any enclosing (E) defs and",
    "such nonlocals and globals in order to change them.\nPython’s name-resolution scheme is sometimes called the LEGB rule, after the scope\nnames:\n• When you use an unqualified name inside a function, Python searches up to four\nscopes—the local (L) scope, then the local scopes of any enclosing (E) defs and\nlambdas, then the global (G) scope, and then the built-in (B) scope—and stops at\nthe first place the name is found. If the name is not found during this search, Python\nreports an error. As we learned in Chapter 6, names must be assigned before they\ncan be used.\n• When you assign a name in a function (instead of just referring to it in an expression), Python always creates or changes the name in the local scope, unless it’s\ndeclared to be global or nonlocal in that function.\n• When you assign a name outside any function (i.e., at the top level of a module\nfile, or at the interactive prompt), the local scope is the same as the global scope—\nthe module’s namespace.",
    "declared to be global or nonlocal in that function.\n• When you assign a name outside any function (i.e., at the top level of a module\nfile, or at the interactive prompt), the local scope is the same as the global scope—\nthe module’s namespace.\nFigure 17-1 illustrates Python’s four scopes. Note that the second scope lookup layer,\nE—the scopes of enclosing defs or lambdas—can technically correspond to more than\none lookup layer. This case only comes into play when you nest functions within functions, and it is addressed by the nonlocal statement.*\nAlso keep in mind that these rules apply only to simple variable names (e.g., spam). In\nParts V and VI, we’ll see that qualified attribute names (e.g., object.spam) live in particular objects and follow a completely different set of lookup rules than those",
    "* The scope lookup rule was called the “LGB rule” in the first edition of this book. The enclosing def “E” layer\nwas added later in Python to obviate the task of passing in enclosing scope names explicitly with default\narguments—a topic usually of marginal interest to Python beginners that we’ll defer until later in this chapter.\nSince this scope is addressed by the nonlocal statement in Python 3.0, I suppose the lookup rule might now\nbe better named “LNGB,” but backward compatibility matters in books, too!\n\n410 | Chapter 17: Scopes",
    "410 | Chapter 17: Scopes\n\n\fFigure 17-1. The LEGB scope lookup rule. When a variable is referenced, Python searches for it in\nthis order: in the local scope, in any enclosing functions’ local scopes, in the global scope, and finally\nin the built-in scope. The first occurrence wins. The place in your code where a variable is assigned\nusually determines its scope. In Python 3, nonlocal declarations can also force names to be mapped\nto enclosing function scopes, whether assigned or not.\n\ncovered here. References to attribute names following periods (.) search one or more\nobjects, not scopes, and may invoke something called “inheritance”; more on this in\nPart VI of this book.\n\nScope Example\nLet’s look at a larger example that demonstrates scope ideas. Suppose we wrote the\nfollowing code in a module file:\n# Global scope\nX = 99\n\n# X and func assigned in module: global\n\ndef func(Y):\n# Local scope\nZ = X + Y\nreturn Z\n\n# Y and Z assigned in function: locals\n\nfunc(1)",
    "Scope Example\nLet’s look at a larger example that demonstrates scope ideas. Suppose we wrote the\nfollowing code in a module file:\n# Global scope\nX = 99\n\n# X and func assigned in module: global\n\ndef func(Y):\n# Local scope\nZ = X + Y\nreturn Z\n\n# Y and Z assigned in function: locals\n\nfunc(1)\n\n# func in module: result=100\n\n# X is a global\n\nThis module and the function it contains use a number of names to do their business.\nUsing Python’s scope rules, we can classify the names as follows:\nGlobal names: X, func\nX is global because it’s assigned at the top level of the module file; it can be referenced inside the function without being declared global. func is global for the same\nreason; the def statement assigns a function object to the name func at the top level\nof the module.\n\nPython Scope Basics | 411",
    "Python Scope Basics | 411\n\n\fLocal names: Y, Z\nY and Z are local to the function (and exist only while the function runs) because\nthey are both assigned values in the function definition: Z by virtue of the = statement, and Y because arguments are always passed by assignment.\nThe whole point behind this name-segregation scheme is that local variables serve as\ntemporary names that you need only while a function is running. For instance, in the\npreceding example, the argument Y and the addition result Z exist only inside the function; these names don’t interfere with the enclosing module’s namespace (or any other\nfunction, for that matter).\nThe local/global distinction also makes functions easier to understand, as most of the\nnames a function uses appear in the function itself, not at some arbitrary place in a\nmodule. Also, because you can be sure that local names will not be changed by some\nremote function in your program, they tend to make programs easier to debug and\nmodify.",
    "The Built-in Scope\nWe’ve been talking about the built-in scope in the abstract, but it’s a bit simpler than\nyou may think. Really, the built-in scope is just a built-in module called builtins, but\nyou have to import builtins to query built-ins because the name builtins is not itself\nbuilt-in....\nNo, I’m serious! The built-in scope is implemented as a standard library module named\nbuiltins, but that name itself is not placed in the built-in scope, so you have to import\nit in order to inspect it. Once you do, you can run a dir call to see which names are\npredefined. In Python 3.0:\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis',\n...many more names omitted...\n'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set',\n'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple',\n'type', 'vars', 'zip']",
    "The names in this list constitute the built-in scope in Python; roughly the first half are\nbuilt-in exceptions, and the second half are built-in functions. Also in this list are the\nspecial names None, True, and False, though they are treated as reserved words. Because\nPython automatically searches this module last in its LEGB lookup, you get all the\nnames in this list “for free;” that is, you can use them without importing any modules.\nThus, there are really two ways to refer to a built-in function—by taking advantage of\nthe LEGB rule, or by manually importing the builtins module:\n>>> zip\n<class 'zip'>\n\n412 | Chapter 17: Scopes\n\n# The normal way\n\n\f>>> import builtins\n>>> builtins.zip\n<class 'zip'>\n\n# The hard way",
    "412 | Chapter 17: Scopes\n\n# The normal way\n\n\f>>> import builtins\n>>> builtins.zip\n<class 'zip'>\n\n# The hard way\n\nThe second of these approaches is sometimes useful in advanced work. The careful\nreader might also notice that because the LEGB lookup procedure takes the first occurrence of a name that it finds, names in the local scope may override variables of the\nsame name in both the global and built-in scopes, and global names may override builtins. A function can, for instance, create a local variable called open by assigning to it:\ndef hider():\nopen = 'spam'\n...\nopen('data.txt')\n\n# Local variable, hides built-in\n# This won't open a file now in this scope!",
    "# Local variable, hides built-in\n# This won't open a file now in this scope!\n\nHowever, this will hide the built-in function called open that lives in the built-in (outer)\nscope. It’s also usually a bug, and a nasty one at that, because Python will not issue a\nwarning message about it (there are times in advanced programming where you may\nreally want to replace a built-in name by redefining it in your code).\nFunctions can similarly hide global variables of the same name with locals:\nX = 88\n\n# Global X\n\ndef func():\nX = 99\n\n# Local X: hides global\n\nfunc()\nprint(X)\n\n# Prints 88: unchanged",
    "Here, the assignment within the function creates a local X that is a completely different\nvariable from the global X in the module outside the function. Because of this, there is\nno way to change a name outside a function without adding a global (or nonlocal)\ndeclaration to the def, as described in the next section.\nVersion skew note: Actually, the tongue twisting gets a bit worse. The\nPython 3.0 builtins module used here is named __builtin__ in Python\n2.6. And just for fun, the name __builtins__ (with the “s”) is preset in\nmost global scopes, including the interactive session, to reference the\nmodule known as builtins (a.k.a. __builtin__ in 2.6).\nThat is, after importing builtins, __builtins__ is builtins is True in\n3.0, and __builtins__ is __builtin__ is True in 2.6. The net effect is\nthat we can inspect the built-in scope by simply running\ndir(__builtins__) with no import in both 3.0 and 2.6, but we are advised to use builtins for real work in 3.0. Who said documenting this",
    "module known as builtins (a.k.a. __builtin__ in 2.6).\nThat is, after importing builtins, __builtins__ is builtins is True in\n3.0, and __builtins__ is __builtin__ is True in 2.6. The net effect is\nthat we can inspect the built-in scope by simply running\ndir(__builtins__) with no import in both 3.0 and 2.6, but we are advised to use builtins for real work in 3.0. Who said documenting this\nstuff was easy?",
    "Python Scope Basics | 413",
    "Breaking the Universe in Python 2.6\nHere’s another thing you can do in Python that you probably shouldn’t—because the\nnames True and False in 2.6 are just variables in the built-in scope and are not reserved,\nit’s possible to reassign them with a statement like True = False. Don’t worry, you\nwon’t actually break the logical consistency of the universe in so doing! This statement\nmerely redefines the word True for the single scope in which it appears. All other scopes\nstill find the originals in the built-in scope.\nFor more fun, though, in Python 2.6 you could say __builtin__.True = False, to reset\nTrue to False for the entire Python process. Alas, this type of assignment has been\ndisallowed in Python 3.0, because True and False are treated as actual reserved words,\njust like None. In 2.6, though, it sends IDLE into a strange panic state that resets the\nuser code process.\nThis technique can be useful, however, both to illustrate the underlying namespace",
    "True to False for the entire Python process. Alas, this type of assignment has been\ndisallowed in Python 3.0, because True and False are treated as actual reserved words,\njust like None. In 2.6, though, it sends IDLE into a strange panic state that resets the\nuser code process.\nThis technique can be useful, however, both to illustrate the underlying namespace\nmodel and for tool writers who must change built-ins such as open to customized functions. Also, note that third-party tools such as PyChecker will warn about common\nprogramming mistakes, including accidental assignment to built-in names (this is\nknown as “shadowing” a built-in in PyChecker).",
    "The global Statement\nThe global statement and its nonlocal cousin are the only things that are remotely like\ndeclaration statements in Python. They are not type or size declarations, though; they\nare namespace declarations. The global statement tells Python that a function plans to\nchange one or more global names—i.e., names that live in the enclosing module’s scope\n(namespace).\nWe’ve talked about global in passing already. Here’s a summary:\n• Global names are variables assigned at the top level of the enclosing module file.\n• Global names must be declared only if they are assigned within a function.\n• Global names may be referenced within a function without being declared.\nIn other words, global allows us to change names that live outside a def at the top level\nof a module file. As we’ll see later, the nonlocal statement is almost identical but applies\nto names in the enclosing def’s local scope, rather than names in the enclosing module.",
    "• Global names may be referenced within a function without being declared.\nIn other words, global allows us to change names that live outside a def at the top level\nof a module file. As we’ll see later, the nonlocal statement is almost identical but applies\nto names in the enclosing def’s local scope, rather than names in the enclosing module.\nThe global statement consists of the keyword global, followed by one or more names\nseparated by commas. All the listed names will be mapped to the enclosing module’s\nscope when assigned or referenced within the function body. For instance:\nX = 88",
    "# Global X\n\ndef func():\nglobal X\nX = 99\n\n# Global X: outside def\n\n414 | Chapter 17: Scopes\n\n\ffunc()\nprint(X)\n\n# Prints 99\n\nWe’ve added a global declaration to the example here, such that the X inside the def\nnow refers to the X outside the def; they are the same variable this time. Here is a slightly\nmore involved example of global at work:\ny, z = 1, 2\ndef all_global():\nglobal x\nx = y + z\n\n# Global variables in module\n# Declare globals assigned\n# No need to declare y, z: LEGB rule",
    "func()\nprint(X)\n\n# Prints 99\n\nWe’ve added a global declaration to the example here, such that the X inside the def\nnow refers to the X outside the def; they are the same variable this time. Here is a slightly\nmore involved example of global at work:\ny, z = 1, 2\ndef all_global():\nglobal x\nx = y + z\n\n# Global variables in module\n# Declare globals assigned\n# No need to declare y, z: LEGB rule\n\nHere, x, y, and z are all globals inside the function all_global. y and z are global because\nthey aren’t assigned in the function; x is global because it was listed in a global statement\nto map it to the module’s scope explicitly. Without the global here, x would be considered local by virtue of the assignment.\nNotice that y and z are not declared global; Python’s LEGB lookup rule finds them in\nthe module automatically. Also, notice that x might not exist in the enclosing module\nbefore the function runs; in this case, the assignment in the function creates x in the\nmodule.",
    "Minimize Global Variables\nBy default, names assigned in functions are locals, so if you want to change names\noutside functions you have to write extra code (e.g., global statements). This is by\ndesign—as is common in Python, you have to say more to do the potentially “wrong”\nthing. Although there are times when globals are useful, variables assigned in a def are\nlocal by default because that is normally the best policy. Changing globals can lead to\nwell-known software engineering problems: because the variables’ values are\ndependent on the order of calls to arbitrarily distant functions, programs can become\ndifficult to debug.\nConsider this module file, for example:\nX = 99\ndef func1():\nglobal X\nX = 88\ndef func2():\nglobal X\nX = 77",
    "Now, imagine that it is your job to modify or reuse this module file. What will the value\nof X be here? Really, that question has no meaning unless it’s qualified with a point of\nreference in time—the value of X is timing-dependent, as it depends on which function\nwas called last (something we can’t tell from this file alone).\n\nThe global Statement | 415",
    "The net effect is that to understand this code, you have to trace the flow of control\nthrough the entire program. And, if you need to reuse or modify the code, you have to\nkeep the entire program in your head all at once. In this case, you can’t really use one\nof these functions without bringing along the other. They are dependent on (that is,\ncoupled with) the global variable. This is the problem with globals—they generally\nmake code more difficult to understand and use than code consisting of self-contained\nfunctions that rely on locals.\nOn the other hand, short of using object-oriented programming and classes, global\nvariables are probably the most straightforward way to retain shared state information\n(information that a function needs to remember for use the next time it is called) in\nPython—local variables disappear when the function returns, but globals do not. Other\ntechniques, such as default mutable arguments and enclosing function scopes, can",
    "variables are probably the most straightforward way to retain shared state information\n(information that a function needs to remember for use the next time it is called) in\nPython—local variables disappear when the function returns, but globals do not. Other\ntechniques, such as default mutable arguments and enclosing function scopes, can\nachieve this, too, but they are more complex than pushing values out to the global scope\nfor retention.\nSome programs designate a single module to collect globals; as long as this is expected,\nit is not as harmful. In addition, programs that use multithreading to do parallel processing in Python commonly depend on global variables—they become shared memory\nbetween functions running in parallel threads, and so act as a communication device.†\nFor now, though, especially if you are relatively new to programming, avoid the temptation to use globals whenever you can—try to communicate with passed-in arguments",
    "between functions running in parallel threads, and so act as a communication device.†\nFor now, though, especially if you are relatively new to programming, avoid the temptation to use globals whenever you can—try to communicate with passed-in arguments\nand return values instead. Six months from now, both you and your coworkers will be\nhappy you did.",
    "Minimize Cross-File Changes\nHere’s another scope-related issue: although we can change variables in another file\ndirectly, we usually shouldn’t. Module files were introduced in Chapter 3 and are covered in more depth in the next part of this book. To illustrate their relationship to\nscopes, consider these two module files:\n# first.py\nX = 99\n\n# This code doesn't know about second.py\n\n# second.py\nimport first\nprint(first.X)\nfirst.X = 88\n\n# Okay: references a name in another file\n# But changing it can be too subtle and implicit",
    "# This code doesn't know about second.py\n\n# second.py\nimport first\nprint(first.X)\nfirst.X = 88\n\n# Okay: references a name in another file\n# But changing it can be too subtle and implicit\n\n† Multithreading runs function calls in parallel with the rest of the program and is supported by Python’s\nstandard library modules _thread, threading, and queue (thread, threading, and Queue in Python 2.6). Because\nall threaded functions run in the same process, global scopes often serve as shared memory between them.\nThreading is commonly used for long-running tasks in GUIs, to implement nonblocking operations in general\nand to leverage CPU capacity. It is also beyond this book’s scope; see the Python library manual, as well as\nthe follow-up texts listed in the Preface (such as O’Reilly’s Programming Python), for more details.\n\n416 | Chapter 17: Scopes",
    "The first defines a variable X, which the second prints and then changes by assignment.\nNotice that we must import the first module into the second file to get to its variable\nat all—as we’ve learned, each module is a self-contained namespace (package of variables), and we must import one module to see inside it from another. That’s the main\npoint about modules: by segregating variables on a per-file basis, they avoid name\ncollisions across files.\nReally, though, in terms of this chapter’s topic, the global scope of a module file becomes the attribute namespace of the module object once it is imported—importers\nautomatically have access to all of the file’s global variables, because a file’s global scope\nmorphs into an object’s attribute namespace when it is imported.\nAfter importing the first module, the second module prints its variable and then assigns\nit a new value. Referencing the module’s variable to print it is fine—this is how modules",
    "automatically have access to all of the file’s global variables, because a file’s global scope\nmorphs into an object’s attribute namespace when it is imported.\nAfter importing the first module, the second module prints its variable and then assigns\nit a new value. Referencing the module’s variable to print it is fine—this is how modules\nare linked together into a larger system normally. The problem with the assignment,\nhowever, is that it is far too implicit: whoever’s charged with maintaining or reusing\nthe first module probably has no clue that some arbitrarily far-removed module on the\nimport chain can change X out from under him at runtime. In fact, the second module\nmay be in a completely different directory, and so difficult to notice at all.\nAlthough such cross-file variable changes are always possible in Python, they are usually\nmuch more subtle than you will want. Again, this sets up too strong a coupling between",
    "import chain can change X out from under him at runtime. In fact, the second module\nmay be in a completely different directory, and so difficult to notice at all.\nAlthough such cross-file variable changes are always possible in Python, they are usually\nmuch more subtle than you will want. Again, this sets up too strong a coupling between\nthe two files—because they are both dependent on the value of the variable X, it’s\ndifficult to understand or reuse one file without the other. Such implicit cross-file dependencies can lead to inflexible code at best, and outright bugs at worst.\nHere again, the best prescription is generally to not do this—the best way to communicate across file boundaries is to call functions, passing in arguments and getting back\nreturn values. In this specific case, we would probably be better off coding an accessor\nfunction to manage the change:\n# first.py\nX = 99\ndef setX(new):\nglobal X\nX = new\n# second.py\nimport first\nfirst.setX(88)",
    "This requires more code and may seem like a trivial change, but it makes a huge difference in terms of readability and maintainability—when a person reading the first\nmodule by itself sees a function, that person will know that it is a point of interface and\nwill expect the change to the X. In other words, it removes the element of surprise that\nis rarely a good thing in software projects. Although we cannot prevent cross-file\nchanges from happening, common sense dictates that they should be minimized unless\nwidely accepted across the program.\nThe global Statement | 417",
    "Other Ways to Access Globals\nInterestingly, because global-scope variables morph into the attributes of a loaded\nmodule object, we can emulate the global statement by importing the enclosing module\nand assigning to its attributes, as in the following example module file. Code in this file\nimports the enclosing module, first by name, and then by indexing the sys.modules\nloaded modules table (more on this table in Chapter 21):\n# thismod.py\nvar = 99\n\n# Global variable == module attribute\n\ndef local():\nvar = 0\n\n# Change local var\n\ndef glob1():\nglobal var\nvar += 1\n\n# Declare global (normal)\n# Change global var\n\ndef glob2():\nvar = 0\nimport thismod\nthismod.var += 1\n\n# Change local var\n# Import myself\n# Change global var\n\ndef glob3():\nvar = 0\nimport sys\nglob = sys.modules['thismod']\nglob.var += 1\n\n# Change local var\n# Import system table\n# Get module object (or use __name__)\n# Change global var\n\ndef test():\nprint(var)\nlocal(); glob1(); glob2(); glob3()\nprint(var)",
    "def glob2():\nvar = 0\nimport thismod\nthismod.var += 1\n\n# Change local var\n# Import myself\n# Change global var\n\ndef glob3():\nvar = 0\nimport sys\nglob = sys.modules['thismod']\nglob.var += 1\n\n# Change local var\n# Import system table\n# Get module object (or use __name__)\n# Change global var\n\ndef test():\nprint(var)\nlocal(); glob1(); glob2(); glob3()\nprint(var)\n\nWhen run, this adds 3 to the global variable (only the first function does not impact it):\n>>> import thismod\n>>> thismod.test()\n99\n102\n>>> thismod.var\n102\n\nThis works, and it illustrates the equivalence of globals to module attributes, but it’s\nmuch more work than using the global statement to make your intentions explicit.\nAs we’ve seen, global allows us to change names in a module outside a function. It has\na cousin named nonlocal that can be used to change names in enclosing functions, too,\nbut to understand how that can be useful, we first need to explore enclosing functions\nin general.\n\n418 | Chapter 17: Scopes",
    "418 | Chapter 17: Scopes\n\n\fScopes and Nested Functions\nSo far, I’ve omitted one part of Python’s scope rules on purpose, because it’s relatively\nrare to encounter it in practice. However, it’s time to take a deeper look at the letter\nE in the LEGB lookup rule. The E layer is fairly new (it was added in Python 2.2); it\ntakes the form of the local scopes of any and all enclosing function defs. Enclosing\nscopes are sometimes also called statically nested scopes. Really, the nesting is a lexical\none—nested scopes correspond to physically and syntactically nested code structures\nin your program’s source code.",
    "Nested Scope Details\nWith the addition of nested function scopes, variable lookup rules become slightly more\ncomplex. Within a function:\n• A reference (X) looks for the name X first in the current local scope (function); then\nin the local scopes of any lexically enclosing functions in your source code, from\ninner to outer; then in the current global scope (the module file); and finally in the\nbuilt-in scope (the module builtins). global declarations make the search begin\nin the global (module file) scope instead.\n• An assignment (X = value) creates or changes the name X in the current local scope,\nby default. If X is declared global within the function, the assignment creates or\nchanges the name X in the enclosing module’s scope instead. If, on the other hand,\nX is declared nonlocal within the function, the assignment changes the name X in\nthe closest enclosing function’s local scope.\nNotice that the global declaration still maps variables to the enclosing module. When",
    "by default. If X is declared global within the function, the assignment creates or\nchanges the name X in the enclosing module’s scope instead. If, on the other hand,\nX is declared nonlocal within the function, the assignment changes the name X in\nthe closest enclosing function’s local scope.\nNotice that the global declaration still maps variables to the enclosing module. When\nnested functions are present, variables in enclosing functions may be referenced, but\nthey require nonlocal declarations to be changed.",
    "Nested Scope Examples\nTo clarify the prior section’s points, let’s illustrate with some real code. Here is what\nan enclosing function scope looks like:\nX = 99\ndef f1():\nX = 88\ndef f2():\nprint(X)\nf2()\nf1()\n\n# Global scope name: not used\n# Enclosing def local\n# Reference made in nested def\n# Prints 88: enclosing def local\n\nFirst off, this is legal Python code: the def is simply an executable statement, which can\nappear anywhere any other statement can—including nested in another def. Here, the\n\nScopes and Nested Functions | 419",
    "Scopes and Nested Functions | 419\n\n\fnested def runs while a call to the function f1 is running; it generates a function and\nassigns it to the name f2, a local variable within f1’s local scope. In a sense, f2 is a\ntemporary function that lives only during the execution of (and is visible only to code\nin) the enclosing f1.\nBut notice what happens inside f2: when it prints the variable X, it refers to the X that\nlives in the enclosing f1 function’s local scope. Because functions can access names in\nall physically enclosing def statements, the X in f2 is automatically mapped to the X in\nf1, by the LEGB lookup rule.\nThis enclosing scope lookup works even if the enclosing function has already returned.\nFor example, the following code defines a function that makes and returns another\nfunction:\ndef f1():\nX = 88\ndef f2():\nprint(X)\nreturn f2\n\n# Remembers X in enclosing def scope\n# Return f2 but don't call it\n\naction = f1()\naction()\n\n# Make, return function\n# Call it now: prints 88",
    "# Remembers X in enclosing def scope\n# Return f2 but don't call it\n\naction = f1()\naction()\n\n# Make, return function\n# Call it now: prints 88\n\nIn this code, the call to action is really running the function we named f2 when f1 ran.\nf2 remembers the enclosing scope’s X in f1, even though f1 is no longer active.",
    "# Make, return function\n# Call it now: prints 88\n\nIn this code, the call to action is really running the function we named f2 when f1 ran.\nf2 remembers the enclosing scope’s X in f1, even though f1 is no longer active.\n\nFactory functions\nDepending on whom you ask, this sort of behavior is also sometimes called a closure\nor factory function. These terms refer to a function object that remembers values in\nenclosing scopes regardless of whether those scopes are still present in memory. Although classes (described in Part VI of this book) are usually best at remembering state\nbecause they make it explicit with attribute assignments, such functions provide an\nalternative.\nFor instance, factory functions are sometimes used by programs that need to generate\nevent handlers on the fly in response to conditions at runtime (e.g., user inputs that\ncannot be anticipated). Look at the following function, for example:\n>>> def maker(N):\n...\ndef action(X):\n...\nreturn X ** N\n...\nreturn action\n...",
    "# Make and return action\n# action retains N from enclosing scope\n\nThis defines an outer function that simply generates and returns a nested function,\nwithout calling it. If we call the outer function:\n>>> f = maker(2)\n>>> f\n<function action at 0x014720B0>\n\n420 | Chapter 17: Scopes\n\n# Pass 2 to N\n\n\fwhat we get back is a reference to the generated nested function—the one created by\nrunning the nested def. If we now call what we got back from the outer function:\n>>> f(3)\n9\n>>> f(4)\n16\n\n# Pass 3 to X, N remembers 2: 3 ** 2\n# 4 ** 2",
    "420 | Chapter 17: Scopes\n\n# Pass 2 to N\n\n\fwhat we get back is a reference to the generated nested function—the one created by\nrunning the nested def. If we now call what we got back from the outer function:\n>>> f(3)\n9\n>>> f(4)\n16\n\n# Pass 3 to X, N remembers 2: 3 ** 2\n# 4 ** 2\n\nit invokes the nested function—the one called action within maker. The most unusual\npart of this is that the nested function remembers integer 2, the value of the variable N\nin maker, even though maker has returned and exited by the time we call action. In effect,\nN from the enclosing local scope is retained as state information attached to action, and\nwe get back its argument squared.\nIf we now call the outer function again, we get back a new nested function with different\nstate information attached. That is, we get the argument cubed instead of squared, but\nthe original still squares as before:\n>>> g = maker(3)\n>>> g(3)\n27\n>>> f(3)\n9\n\n# g remembers 3, f remembers 2\n# 3 ** 3\n# 3 ** 2",
    "This works because each call to a factory function like this gets its own set of state\ninformation. In our case, the function we assign to name g remembers 3, and f remembers 2, because each has its own state information retained by the variable N in maker.\nThis is an advanced technique that you’re unlikely to see very often in most code, except\namong programmers with backgrounds in functional programming languages. On the\nother hand, enclosing scopes are often employed by lambda function-creation expressions (discussed later in this chapter)—because they are expressions, they are almost\nalways nested within a def. Moreover, function nesting is commonly used for decorators (explored in Chapter 38)—in some cases, it’s the most reasonable coding pattern.\nAs a general rule, classes are better at “memory” like this because they make the state\nretention explicit in attributes. Short of using classes, though, globals, enclosing scope",
    "always nested within a def. Moreover, function nesting is commonly used for decorators (explored in Chapter 38)—in some cases, it’s the most reasonable coding pattern.\nAs a general rule, classes are better at “memory” like this because they make the state\nretention explicit in attributes. Short of using classes, though, globals, enclosing scope\nreferences like these, and default arguments are the main ways that Python functions\ncan retain state information. To see how they compete, Chapter 18 provides complete\ncoverage of defaults, but the next section gives enough of an introduction to get us\nstarted.",
    "Retaining enclosing scopes’ state with defaults\nIn earlier versions of Python, the sort of code in the prior section failed because nested\ndefs did not do anything about scopes—a reference to a variable within f2 would search\nonly the local (f2), then global (the code outside f1), and then built-in scopes. Because\nit skipped the scopes of enclosing functions, an error would result. To work around\nthis, programmers typically used default argument values to pass in and remember the\nobjects in an enclosing scope:\nScopes and Nested Functions | 421\n\n\fdef f1():\nx = 88\ndef f2(x=x):\nprint(x)\nf2()\n\n# Remember enclosing scope X with defaults\n\nf1()\n\n# Prints 88",
    "This code works in all Python releases, and you’ll still see this pattern in some existing\nPython code. In short, the syntax arg = val in a def header means that the argument\narg will default to the value val if no real value is passed to arg in a call.\nIn the modified f2 here, the x=x means that the argument x will default to the value of\nx in the enclosing scope—because the second x is evaluated before Python steps into\nthe nested def, it still refers to the x in f1. In effect, the default remembers what x was\nin f1 (i.e., the object 88).\nThat’s fairly complex, and it depends entirely on the timing of default value evaluations.\nIn fact, the nested scope lookup rule was added to Python to make defaults unnecessary\nfor this role—today, Python automatically remembers any values required in the enclosing scope for use in nested defs.\nOf course, the best prescription for most code is simply to avoid nesting defs within",
    "That’s fairly complex, and it depends entirely on the timing of default value evaluations.\nIn fact, the nested scope lookup rule was added to Python to make defaults unnecessary\nfor this role—today, Python automatically remembers any values required in the enclosing scope for use in nested defs.\nOf course, the best prescription for most code is simply to avoid nesting defs within\ndefs, as it will make your programs much simpler. The following is an equivalent of\nthe prior example that banishes the notion of nesting. Notice the forward reference in\nthis code—it’s OK to call a function defined after the function that calls it, as long as\nthe second def runs before the first function is actually called. Code inside a def is never\nevaluated until the function is actually called:\n>>> def f1():\n...\nx = 88\n...\nf2(x)\n...\n>>> def f2(x):\n...\nprint(x)\n...\n>>> f1()\n88",
    "# Pass x along instead of nesting\n# Forward reference okay\n\nIf you avoid nesting this way, you can almost forget about the nested scopes concept\nin Python, unless you need to code in the factory function style discussed earlier—at\nleast, for def statements. lambdas, which almost naturally appear nested in defs, often\nrely on nested scopes, as the next section explains.\n\nNested scopes and lambdas\nWhile they’re rarely used in practice for defs themselves, you are more likely to care\nabout nested function scopes when you start coding lambda expressions. We won’t\ncover lambda in depth until Chapter 19, but in short, it’s an expression that generates\na new function to be called later, much like a def statement. Because it’s an expression,\n\n422 | Chapter 17: Scopes",
    "Nested scopes and lambdas\nWhile they’re rarely used in practice for defs themselves, you are more likely to care\nabout nested function scopes when you start coding lambda expressions. We won’t\ncover lambda in depth until Chapter 19, but in short, it’s an expression that generates\na new function to be called later, much like a def statement. Because it’s an expression,\n\n422 | Chapter 17: Scopes\n\n\fthough, it can be used in places that def cannot, such as within list and dictionary\nliterals.\nLike a def, a lambda expression introduces a new local scope for the function it creates.\nThanks to the enclosing scopes lookup layer, lambdas can see all the variables that live\nin the functions in which they are coded. Thus, the following code works, but only\nbecause the nested scope rules are applied:\ndef func():\nx = 4\naction = (lambda n: x ** n)\nreturn action\nx = func()\nprint(x(2))\n\n# x remembered from enclosing def\n\n# Prints 16, 4 ** 2",
    "# x remembered from enclosing def\n\n# Prints 16, 4 ** 2\n\nPrior to the introduction of nested function scopes, programmers used defaults to pass\nvalues from an enclosing scope into lambdas, just as for defs. For instance, the following\nworks on all Python releases:\ndef func():\nx = 4\naction = (lambda n, x=x: x ** n)\nreturn action\n\n# Pass x in manually\n\nBecause lambdas are expressions, they naturally (and even normally) nest inside enclosing defs. Hence, they are perhaps the biggest beneficiaries of the addition of enclosing function scopes in the lookup rules; in most cases, it is no longer necessary to\npass values into lambdas with defaults.",
    "Scopes versus defaults with loop variables\nThere is one notable exception to the rule I just gave: if a lambda or def defined within\na function is nested inside a loop, and the nested function references an enclosing scope\nvariable that is changed by that loop, all functions generated within the loop will have\nthe same value—the value the referenced variable had in the last loop iteration.\nFor instance, the following attempts to build up a list of functions that each remember\nthe current variable i from the enclosing scope:\n>>> def makeActions():\n...\nacts = []\n...\nfor i in range(5):\n...\nacts.append(lambda x: i ** x)\n...\nreturn acts\n...\n>>> acts = makeActions()\n>>> acts[0]\n<function <lambda> at 0x012B16B0>\n\n# Tries to remember each i\n# All remember same last i!\n\nThis doesn’t quite work, though—because the enclosing scope variable is looked up\nwhen the nested functions are later called, they all effectively remember the same value\n\nScopes and Nested Functions | 423",
    "# Tries to remember each i\n# All remember same last i!\n\nThis doesn’t quite work, though—because the enclosing scope variable is looked up\nwhen the nested functions are later called, they all effectively remember the same value\n\nScopes and Nested Functions | 423\n\n\f(the value the loop variable had on the last loop iteration). That is, we get back 4 to the\npower of 2 for each function in the list, because i is the same in all of them:\n# All are 4 ** 2, value of last i\n\n>>> acts[0](2)\n16\n>>> acts[2](2)\n16\n>>> acts[4](2)\n16\n\n# This should be 2 ** 2\n# This should be 4 ** 2",
    "Scopes and Nested Functions | 423\n\n\f(the value the loop variable had on the last loop iteration). That is, we get back 4 to the\npower of 2 for each function in the list, because i is the same in all of them:\n# All are 4 ** 2, value of last i\n\n>>> acts[0](2)\n16\n>>> acts[2](2)\n16\n>>> acts[4](2)\n16\n\n# This should be 2 ** 2\n# This should be 4 ** 2\n\nThis is the one case where we still have to explicitly retain enclosing scope values with\ndefault arguments, rather than enclosing scope references. That is, to make this sort of\ncode work, we must pass in the current value of the enclosing scope’s variable with a\ndefault. Because defaults are evaluated when the nested function is created (not when\nit’s later called), each remembers its own value for i:\n>>> def makeActions():\n...\nacts = []\n...\nfor i in range(5):\n...\nacts.append(lambda x, i=i: i ** x)\n...\nreturn acts\n...\n>>> acts = makeActions()\n>>> acts[0](2)\n0\n>>> acts[2](2)\n4\n>>> acts[4](2)\n16\n\n# Use defaults instead\n# Remember current i",
    "# Use defaults instead\n# Remember current i\n\n# 0 ** 2\n# 2 ** 2\n# 4 ** 2\n\nThis is a fairly obscure case, but it can come up in practice, especially in code that\ngenerates callback handler functions for a number of widgets in a GUI (e.g., buttonpress handlers). We’ll talk more about defaults in Chapter 18 and lambdas in Chapter 19, so you may want to return and review this section later.‡\n\nArbitrary scope nesting\nBefore ending this discussion, I should note that scopes may nest arbitrarily, but only\nenclosing function def statements (not classes, described in Part VI) are searched:\n>>> def f1():\n...\nx = 99\n...\ndef f2():\n...\ndef f3():\n...\nprint(x)\n...\nf3()\n\n# Found in f1's local scope!",
    "Arbitrary scope nesting\nBefore ending this discussion, I should note that scopes may nest arbitrarily, but only\nenclosing function def statements (not classes, described in Part VI) are searched:\n>>> def f1():\n...\nx = 99\n...\ndef f2():\n...\ndef f3():\n...\nprint(x)\n...\nf3()\n\n# Found in f1's local scope!\n\n‡ In the section “Function Gotchas” on page 518 at the end of this part of the book, we’ll also see that there\nis an issue with using mutable objects like lists and dictionaries for default arguments (e.g., def f(a=[]))—\nbecause defaults are implemented as single objects attached to functions, mutable defaults retain state from\ncall to call, rather then being initialized anew on each call. Depending on whom you ask, this is either\nconsidered a feature that supports state retention, or a strange wart on the language. More on this at the end\nof Chapter 20.\n\n424 | Chapter 17: Scopes\n\n\f...\nf2()\n...\n>>> f1()\n99",
    "424 | Chapter 17: Scopes\n\n\f...\nf2()\n...\n>>> f1()\n99\n\nPython will search the local scopes of all enclosing defs, from inner to outer, after the\nreferencing function’s local scope and before the module’s global scope or built-ins.\nHowever, this sort of code is even less likely to pop up in practice. In Python, we say\nflat is better than nested—except in very limited contexts, your life (and the lives of your\ncoworkers) will generally be better if you minimize nested function definitions.",
    "The nonlocal Statement\nIn the prior section we explored the way that nested functions can reference variables\nin an enclosing function’s scope, even if that function has already returned. It turns out\nthat, as of Python 3.0, we can also change such enclosing scope variables, as long as we\ndeclare them in nonlocal statements. With this statement, nested defs can have both\nread and write access to names in enclosing functions.\nThe nonlocal statement is a close cousin to global, covered earlier. Like global,\nnonlocal declares that a name will be changed in an enclosing scope. Unlike global,\nthough, nonlocal applies to a name in an enclosing function’s scope, not the global\nmodule scope outside all defs. Also unlike global, nonlocal names must already exist\nin the enclosing function’s scope when declared—they can exist only in enclosing\nfunctions and cannot be created by a first assignment in a nested def.",
    "though, nonlocal applies to a name in an enclosing function’s scope, not the global\nmodule scope outside all defs. Also unlike global, nonlocal names must already exist\nin the enclosing function’s scope when declared—they can exist only in enclosing\nfunctions and cannot be created by a first assignment in a nested def.\nIn other words, nonlocal both allows assignment to names in enclosing function scopes\nand limits scope lookups for such names to enclosing defs. The net effect is a more\ndirect and reliable implementation of changeable scope information, for programs that\ndo not desire or need classes with attributes.",
    "nonlocal Basics\nPython 3.0 introduces a new nonlocal statement, which has meaning only inside a\nfunction:\ndef func():\nnonlocal name1, name2, ...\n\nThis statement allows a nested function to change one or more names defined in a\nsyntactically enclosing function’s scope. In Python 2.X (including 2.6), when one function def is nested in another, the nested function can reference any of the names defined\nby assignment in the enclosing def’s scope, but it cannot change them. In 3.0, declaring\nthe enclosing scopes’ names in a nonlocal statement enables nested functions to assign\nand thus change such names as well.\nThis provides a way for enclosing functions to provide writeable state information,\nremembered when the nested function is later called. Allowing the state to change\nThe nonlocal Statement | 425",
    "makes it more useful to the nested function (imagine a counter in the enclosing scope,\nfor instance). In 2.X, programmers usually achieve similar goals by using classes or\nother schemes. Because nested functions have become a more common coding pattern\nfor state retention, though, nonlocal makes it more generally applicable.\nBesides allowing names in enclosing defs to be changed, the nonlocal statement also\nforces the issue for references—just like the global statement, nonlocal causes searches\nfor the names listed in the statement to begin in the enclosing defs’ scopes, not in the\nlocal scope of the declaring function. That is, nonlocal also means “skip my local scope\nentirely.”\nIn fact, the names listed in a nonlocal must have been previously defined in an enclosing\ndef when the nonlocal is reached, or an error is raised. The net effect is much like global:\nglobal means the names reside in the enclosing module, and nonlocal means they reside",
    "local scope of the declaring function. That is, nonlocal also means “skip my local scope\nentirely.”\nIn fact, the names listed in a nonlocal must have been previously defined in an enclosing\ndef when the nonlocal is reached, or an error is raised. The net effect is much like global:\nglobal means the names reside in the enclosing module, and nonlocal means they reside\nin an enclosing def. nonlocal is even more strict, though—scope search is restricted to\nonly enclosing defs. That is, nonlocal names can appear only in enclosing defs, not in\nthe module’s global scope or built-in scopes outside the defs.\nThe addition of nonlocal does not alter name reference scope rules in general; they still\nwork as before, per the “LEGB” rule described earlier. The nonlocal statement mostly\nserves to allow names in enclosing scopes to be changed rather than just referenced.\nHowever, global and nonlocal statements do both restrict the lookup rules somewhat,\nwhen coded in a function:",
    "The addition of nonlocal does not alter name reference scope rules in general; they still\nwork as before, per the “LEGB” rule described earlier. The nonlocal statement mostly\nserves to allow names in enclosing scopes to be changed rather than just referenced.\nHowever, global and nonlocal statements do both restrict the lookup rules somewhat,\nwhen coded in a function:\n• global makes scope lookup begin in the enclosing module’s scope and allows\nnames there to be assigned. Scope lookup continues on to the built-in scope if the\nname does not exist in the module, but assignments to global names always create\nor change them in the module’s scope.\n• nonlocal restricts scope lookup to just enclosing defs, requires that the names already exist there, and allows them to be assigned. Scope lookup does not continue\non to the global or built-in scopes.\nIn Python 2.6, references to enclosing def scope names are allowed, but not assignment.",
    "or change them in the module’s scope.\n• nonlocal restricts scope lookup to just enclosing defs, requires that the names already exist there, and allows them to be assigned. Scope lookup does not continue\non to the global or built-in scopes.\nIn Python 2.6, references to enclosing def scope names are allowed, but not assignment.\nHowever, you can still use classes with explicit attributes to achieve the same changeable state information effect as nonlocals (and you may be better off doing so in some\ncontexts); globals and function attributes can sometimes accomplish similar goals as\nwell. More on this in a moment; first, let’s turn to some working code to make this\nmore concrete.",
    "nonlocal in Action\nOn to some examples, all run in 3.0. References to enclosing def scopes work as they\ndo in 2.6. In the following, tester builds and returns the function nested, to be called\nlater, and the state reference in nested maps the local scope of tester using the normal\nscope lookup rules:\n\n426 | Chapter 17: Scopes\n\n\fC:\\\\misc>c:\\python30\\python\n>>> def tester(start):\n...\nstate = start\n...\ndef nested(label):\n...\nprint(label, state)\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\nspam 0\n>>> F('ham')\nham 0\n\n# Referencing nonlocals works normally\n# Remembers state in enclosing scope\n\nChanging a name in an enclosing def’s scope is not allowed by default, though; this is\nthe normal case in 2.6 as well:\n>>> def tester(start):\n...\nstate = start\n...\ndef nested(label):\n...\nprint(label, state)\n...\nstate += 1\n# Cannot change by default (or in 2.6)\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\nUnboundLocalError: local variable 'state' referenced before assignment",
    "Changing a name in an enclosing def’s scope is not allowed by default, though; this is\nthe normal case in 2.6 as well:\n>>> def tester(start):\n...\nstate = start\n...\ndef nested(label):\n...\nprint(label, state)\n...\nstate += 1\n# Cannot change by default (or in 2.6)\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\nUnboundLocalError: local variable 'state' referenced before assignment\n\nUsing nonlocal for changes\nNow, under 3.0, if we declare state in the tester scope as nonlocal within nested, we\nget to change it inside the nested function, too. This works even though tester has\nreturned and exited by the time we call the returned nested function through the name\nF:\n>>> def tester(start):\n...\nstate = start\n...\ndef nested(label):\n...\nnonlocal state\n...\nprint(label, state)\n...\nstate += 1\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\nspam 0\n>>> F('ham')\nham 1\n>>> F('eggs')\neggs 2",
    "# Each call gets its own state\n# Remembers state in enclosing scope\n# Allowed to change it if nonlocal\n\n# Increments state on each call\n\nAs usual with enclosing scope references, we can call the tester factory function multiple times to get multiple copies of its state in memory. The state object in the enclosing\nscope is essentially attached to the nested function object returned; each call makes a\n\nThe nonlocal Statement | 427\n\n\fnew, distinct state object, such that updating one function’s state won’t impact the\nother. The following continues the prior listing’s interaction:\n>>> G = tester(42)\n>>> G('spam')\nspam 42\n\n# Make a new tester that starts at 42\n\n>>> G('eggs')\neggs 43\n\n# My state information updated to 43\n\n>>> F('bacon')\nbacon 3\n\n# But F's is where it left off: at 3\n# Each call has different state information",
    "# Make a new tester that starts at 42\n\n>>> G('eggs')\neggs 43\n\n# My state information updated to 43\n\n>>> F('bacon')\nbacon 3\n\n# But F's is where it left off: at 3\n# Each call has different state information\n\nBoundary cases\nThere are a few things to watch out for. First, unlike the global statement, nonlocal\nnames really must have previously been assigned in an enclosing def’s scope when a\nnonlocal is evaluated, or else you’ll get an error—you cannot create them dynamically\nby assigning them anew in the enclosing scope:\n>>> def tester(start):\n...\ndef nested(label):\n...\nnonlocal state\n# Nonlocals must already exist in enclosing def!\n...\nstate = 0\n...\nprint(label, state)\n...\nreturn nested\n...\nSyntaxError: no binding for nonlocal 'state' found\n>>> def tester(start):\n...\ndef nested(label):\n...\nglobal state\n...\nstate = 0\n...\nprint(label, state)\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('abc')\nabc 0\n>>> state\n0",
    "# Globals don't have to exist yet when declared\n# This creates the name in the module now\n\nSecond, nonlocal restricts the scope lookup to just enclosing defs; nonlocals are not\nlooked up in the enclosing module’s global scope or the built-in scope outside all\ndefs, even if they are already there:\n>>> spam = 99\n>>> def tester():\n...\ndef nested():\n...\nnonlocal spam\n# Must be in a def, not the module!\n...\nprint('Current=', spam)\n...\nspam += 1\n...\nreturn nested\n...\nSyntaxError: no binding for nonlocal 'spam' found\n\n428 | Chapter 17: Scopes\n\n\fThese restrictions make sense once you realize that Python would not otherwise generally know which enclosing scope to create a brand new name in. In the prior listing,\nshould spam be assigned in tester, or the module outside? Because this is ambiguous,\nPython must resolve nonlocals at function creation time, not function call time.",
    "Why nonlocal?\nGiven the extra complexity of nested functions, you might wonder what the fuss is\nabout. Although it’s difficult to see in our small examples, state information becomes\ncrucial in many programs. There are a variety of ways to “remember” information\nacross function and method calls in Python. While there are tradeoffs for all,\nnonlocal does improve this story for enclosing scope references—the nonlocal statement allows multiple copies of changeable state to be retained in memory and addresses\nsimple state-retention needs where classes may not be warranted.\nAs we saw in the prior section, the following code allows state to be retained and\nmodified in an enclosing scope. Each call to tester creates a little self-contained package\nof changeable information, whose names do not clash with any other part of the\nprogram:\ndef tester(start):\nstate = start\ndef nested(label):\nnonlocal state\nprint(label, state)\nstate += 1\nreturn nested",
    "# Each call gets its own state\n# Remembers state in enclosing scope\n# Allowed to change it if nonlocal\n\nF = tester(0)\nF('spam')\n\nUnfortunately, this code only works in Python 3.0. If you are using Python 2.6, other\noptions are available, depending on your goals. The next two sections present some\nalternatives.\n\nShared state with globals\nOne usual prescription for achieving the nonlocal effect in 2.6 and earlier is to simply\nmove the state out to the global scope (the enclosing module):\n>>> def tester(start):\n...\nglobal state\n...\nstate = start\n...\ndef nested(label):\n...\nglobal state\n...\nprint(label, state)\n...\nstate += 1\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\n\n# Move it out to the module to change it\n# global allows changes in module scope\n\n# Each call increments shared global state\n\nThe nonlocal Statement | 429\n\n\fspam 0\n>>> F('eggs')\neggs 1",
    "# Move it out to the module to change it\n# global allows changes in module scope\n\n# Each call increments shared global state\n\nThe nonlocal Statement | 429\n\n\fspam 0\n>>> F('eggs')\neggs 1\n\nThis works in this case, but it requires global declarations in both functions and is\nprone to name collisions in the global scope (what if “state” is already being used?). A\nworse, and more subtle, problem is that it only allows for a single shared copy of the\nstate information in the module scope—if we call tester again, we’ll wind up resetting\nthe module’s state variable, such that prior calls will see their state overwritten:\n>>> G = tester(42)\n>>> G('toast')\ntoast 42\n\n# Resets state's single copy in global scope\n\n>>> G('bacon')\nbacon 43\n>>> F('ham')\nham 44\n\n# Oops -- my counter has been overwritten!\n\nAs shown earlier, when using nonlocal instead of global, each call to tester remembers\nits own unique copy of the state object.",
    "State with classes (preview)\nThe other prescription for changeable state information in 2.6 and earlier is to use\nclasses with attributes to make state information access more explicit than the implicit\nmagic of scope lookup rules. As an added benefit, each instance of a class gets a fresh\ncopy of the state information, as a natural byproduct of Python’s object model.\nWe haven’t explored classes in detail yet, but as a brief preview, here is a reformulation\nof the tester/nested functions used earlier as a class—state is recorded in objects explicitly as they are created. To make sense of this code, you need to know that a def\nwithin a class like this works exactly like a def outside of a class, except that the\nfunction’s self argument automatically receives the implied subject of the call (an instance object created by calling the class itself):\n>>> class tester:\n...\ndef __init__(self, start):\n...\nself.state = start\n...\ndef nested(self, label):\n...\nprint(label, self.state)\n...",
    "within a class like this works exactly like a def outside of a class, except that the\nfunction’s self argument automatically receives the implied subject of the call (an instance object created by calling the class itself):\n>>> class tester:\n...\ndef __init__(self, start):\n...\nself.state = start\n...\ndef nested(self, label):\n...\nprint(label, self.state)\n...\nself.state += 1\n...\n>>> F = tester(0)\n>>> F.nested('spam')\nspam 0\n>>> F.nested('ham')\nham 1",
    "# Class-based alternative (see Part VI)\n# On object construction,\n# save state explicitly in new object\n\n>>> G = tester(42)\n>>> G.nested('toast')\ntoast 42\n\n# Each instance gets new copy of state\n# Changing one does not impact others\n\n430 | Chapter 17: Scopes\n\n# Reference state explicitly\n# Changes are always allowed\n# Create instance, invoke __init__\n# F is passed to self\n\n\f>>> G.nested('bacon')\nbacon 43\n>>> F.nested('eggs')\neggs 2\n>>> F.state\n3\n\n# F's state is where it left off\n# State may be accessed outside class",
    "# Each instance gets new copy of state\n# Changing one does not impact others\n\n430 | Chapter 17: Scopes\n\n# Reference state explicitly\n# Changes are always allowed\n# Create instance, invoke __init__\n# F is passed to self\n\n\f>>> G.nested('bacon')\nbacon 43\n>>> F.nested('eggs')\neggs 2\n>>> F.state\n3\n\n# F's state is where it left off\n# State may be accessed outside class\n\nWith just slightly more magic, which we’ll delve into later in this book, we could also\nmake our class look like a callable function using operator overloading. __call__ intercepts direct calls on an instance, so we don’t need to call a named method:\n>>> class tester:\n...\ndef __init__(self, start):\n...\nself.state = start\n...\ndef __call__(self, label):\n...\nprint(label, self.state)\n...\nself.state += 1\n...\n>>> H = tester(99)\n>>> H('juice')\njuice 99\n>>> H('pancakes')\npancakes 100\n\n# Intercept direct instance calls\n# So .nested() not required\n\n# Invokes __call__",
    "# Invokes __call__\n\nDon’t sweat the details in this code too much at this point in the book; we’ll explore\nclasses in depth in Part VI and will look at specific operator overloading tools like\n__call__ in Chapter 29, so you may wish to file this code away for future reference.\nThe point here is that classes can make state information more obvious, by leveraging\nexplicit attribute assignment instead of scope lookups.\nWhile using classes for state information is generally a good rule of thumb to follow,\nthey might be overkill in cases like this, where state is a single counter. Such trivial state\ncases are more common than you might think; in such contexts, nested defs are sometimes more lightweight than coding classes, especially if you’re not familiar with OOP\nyet. Moreover, there are some scenarios in which nested defs may actually work better\nthan classes (see the description of method decorators in Chapter 38 for an example\nthat is far beyond this chapter’s scope).",
    "State with function attributes\nAs a final state-retention option, we can also sometimes achieve the same effect as\nnonlocals with function attributes—user-defined names attached to functions directly.\nHere’s a final version of our example based on this technique—it replaces a nonlocal\nwith an attribute attached to the nested function. Although this scheme may not be as\nintuitive to some, it also allows the state variable to be accessed outside the nested\nfunction (with nonlocals, we can only see state variables within the nested def):\n>>> def tester(start):\n...\ndef nested(label):\n...\nprint(label, nested.state)\n...\nnested.state += 1\n\n# nested is in enclosing scope\n# Change attr, not nested itself\n\nThe nonlocal Statement | 431\n\n\f...\nnested.state = start\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\nspam 0\n>>> F('ham')\nham 1\n>>> F.state\n2\n>>>\n>>> G = tester(42)\n>>> G('eggs')\neggs 42\n>>> F('ham')\nham 2\n\n# Initial state after func defined\n\n# F is a 'nested' with state attached",
    "# nested is in enclosing scope\n# Change attr, not nested itself\n\nThe nonlocal Statement | 431\n\n\f...\nnested.state = start\n...\nreturn nested\n...\n>>> F = tester(0)\n>>> F('spam')\nspam 0\n>>> F('ham')\nham 1\n>>> F.state\n2\n>>>\n>>> G = tester(42)\n>>> G('eggs')\neggs 42\n>>> F('ham')\nham 2\n\n# Initial state after func defined\n\n# F is a 'nested' with state attached\n\n# Can access state outside functions too\n# G has own state, doesn't overwrite F's",
    "# Initial state after func defined\n\n# F is a 'nested' with state attached\n\n# Can access state outside functions too\n# G has own state, doesn't overwrite F's\n\nThis code relies on the fact that the function name nested is a local variable in the\ntester scope enclosing nested; as such, it can be referenced freely inside nested. This\ncode also relies on the fact that changing an object in-place is not an assignment to a\nname; when it increments nested.state, it is changing part of the object nested references, not the name nested itself. Because we’re not really assigning a name in the\nenclosing scope, no nonlocal is needed.\nAs you can see, globals, nonlocals, classes, and function attributes all offer\nstate-retention options. Globals only support shared data, classes require a basic\nknowledge of OOP, and both classes and function attributes allow state to be accessed\noutside the nested function itself. As usual, the best tool for your program depends\nupon your program’s goals.",
    "Chapter Summary\nIn this chapter, we studied one of two key concepts related to functions: scopes (how\nvariables are looked up when they are used). As we learned, variables are considered\nlocal to the function definitions in which they are assigned, unless they are specifically\ndeclared to be global or nonlocal. We also studied some more advanced scope concepts\nhere, including nested function scopes and function attributes. Finally, we looked at\nsome general design ideas, such as the need to avoid globals and cross-file changes.\nIn the next chapter, we’re going to continue our function tour with the second key\nfunction-related concept: argument passing. As we’ll find, arguments are passed into\na function by assignment, but Python also provides tools that allow functions to be\nflexible in how items are passed. Before we move on, let’s take this chapter’s quiz to\nreview the scope concepts we’ve covered here.\n\n432 | Chapter 17: Scopes",
    "432 | Chapter 17: Scopes\n\n\fTest Your Knowledge: Quiz\n1. What is the output of the following code, and why?\n>>> X = 'Spam'\n>>> def func():\n...\nprint(X)\n...\n>>> func()\n\n2. What is the output of this code, and why?\n>>> X = 'Spam'\n>>> def func():\n...\nX = 'NI!'\n...\n>>> func()\n>>> print(X)\n\n3. What does this code print, and why?\n>>> X = 'Spam'\n>>> def func():\n...\nX = 'NI'\n...\nprint(X)\n...\n>>> func()\n>>> print(X)\n\n4. What output does this code produce? Why?\n>>> X = 'Spam'\n>>> def func():\n...\nglobal X\n...\nX = 'NI'\n...\n>>> func()\n>>> print(X)\n\n5. What about this code—what’s the output, and why?\n>>> X = 'Spam'\n>>> def func():\n...\nX = 'NI'\n...\ndef nested():\n...\nprint(X)\n...\nnested()\n...\n>>> func()\n>>> X\n\nTest Your Knowledge: Quiz | 433\n\n\f6. How about this example: what is its output in Python 3.0, and why?\n>>> def func():\n...\nX = 'NI'\n...\ndef nested():\n...\nnonlocal X\n...\nX = 'Spam'\n...\nnested()\n...\nprint(X)\n...\n>>> func()",
    "5. What about this code—what’s the output, and why?\n>>> X = 'Spam'\n>>> def func():\n...\nX = 'NI'\n...\ndef nested():\n...\nprint(X)\n...\nnested()\n...\n>>> func()\n>>> X\n\nTest Your Knowledge: Quiz | 433\n\n\f6. How about this example: what is its output in Python 3.0, and why?\n>>> def func():\n...\nX = 'NI'\n...\ndef nested():\n...\nnonlocal X\n...\nX = 'Spam'\n...\nnested()\n...\nprint(X)\n...\n>>> func()\n\n7. Name three or more ways to retain state information in a Python function.",
    "Test Your Knowledge: Answers\n1. The output here is 'Spam', because the function references a global variable in the\nenclosing module (because it is not assigned in the function, it is considered global).\n2. The output here is 'Spam' again because assigning the variable inside the function\nmakes it a local and effectively hides the global of the same name. The print statement finds the variable unchanged in the global (module) scope.\n3. It prints 'NI' on one line and 'Spam' on another, because the reference to the variable within the function finds the assigned local and the reference in the print\nstatement finds the global.\n4. This time it just prints 'NI' because the global declaration forces the variable assigned inside the function to refer to the variable in the enclosing global scope.\n5. The output in this case is again 'NI' on one line and 'Spam' on another, because",
    "statement finds the global.\n4. This time it just prints 'NI' because the global declaration forces the variable assigned inside the function to refer to the variable in the enclosing global scope.\n5. The output in this case is again 'NI' on one line and 'Spam' on another, because\nthe print statement in the nested function finds the name in the enclosing function’s local scope, and the print at the end finds the variable in the global scope.\n6. This example prints 'Spam', because the nonlocal statement (available in Python\n3.0 but not 2.6) means that the assignment to X inside the nested function changes\nX in the enclosing function’s local scope. Without this statement, this assignment\nwould classify X as local to the nested function, making it a different variable; the\ncode would then print 'NI' instead.\n7. Although the values of local variables go away when a function returns, you can\nmake a Python function retain state information by using shared global variables,",
    "X in the enclosing function’s local scope. Without this statement, this assignment\nwould classify X as local to the nested function, making it a different variable; the\ncode would then print 'NI' instead.\n7. Although the values of local variables go away when a function returns, you can\nmake a Python function retain state information by using shared global variables,\nenclosing function scope references within nested functions, or using default argument values. Function attributes can sometimes allow state to be attached to the\nfunction itself, instead of looked up in scopes. Another alternative, using OOP with\nclasses, sometimes supports state retention better than any of the scope-based\ntechniques because it makes it explicit with attribute assignments; we’ll explore\nthis option in Part VI.",
    "434 | Chapter 17: Scopes\n\n\fCHAPTER 18\n\nArguments\n\nChapter 17 explored the details behind Python’s scopes—the places where variables\nare defined and looked up. As we learned, the place where a name is defined in our\ncode determines much of its meaning. This chapter continues the function story by\nstudying the concepts in Python argument passing—the way that objects are sent to\nfunctions as inputs. As we’ll see, arguments (a.k.a. parameters) are assigned to names\nin a function, but they have more to do with object references than with variable scopes.\nWe’ll also find that Python provides extra tools, such as keywords, defaults, and arbitrary argument collectors, that allow for wide flexibility in the way arguments are sent\nto a function.",
    "Argument-Passing Basics\nEarlier in this part of the book, I noted that arguments are passed by assignment. This\nhas a few ramifications that aren’t always obvious to beginners, which I’ll expand on\nin this section. Here is a rundown of the key points in passing arguments to functions:\n• Arguments are passed by automatically assigning objects to local variable\nnames. Function arguments—references to (possibly) shared objects sent by the\ncaller—are just another instance of Python assignment at work. Because references\nare implemented as pointers, all arguments are, in effect, passed by pointer. Objects\npassed as arguments are never automatically copied.\n• Assigning to argument names inside a function does not affect the caller.\nArgument names in the function header become new, local names when the function runs, in the scope of the function. There is no aliasing between function argument names and variable names in the scope of the caller.",
    "passed as arguments are never automatically copied.\n• Assigning to argument names inside a function does not affect the caller.\nArgument names in the function header become new, local names when the function runs, in the scope of the function. There is no aliasing between function argument names and variable names in the scope of the caller.\n• Changing a mutable object argument in a function may impact the caller.\nOn the other hand, as arguments are simply assigned to passed-in objects, functions can change passed-in mutable objects in place, and the results may affect the\ncaller. Mutable arguments can be input and output for functions.",
    "435",
    "For more details on references, see Chapter 6; everything we learned there also applies\nto function arguments, though the assignment to argument names is automatic and\nimplicit.\nPython’s pass-by-assignment scheme isn’t quite the same as C++’s reference parameters option, but it turns out to be very similar to the C language’s argument-passing\nmodel in practice:\n• Immutable arguments are effectively passed “by value.” Objects such as integers and strings are passed by object reference instead of by copying, but because\nyou can’t change immutable objects in-place anyhow, the effect is much like making a copy.\n• Mutable arguments are effectively passed “by pointer.” Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointers—mutable objects can be changed in-place in the function,\nmuch like C arrays.\nOf course, if you’ve never used C, Python’s argument-passing mode will seem simpler",
    "• Mutable arguments are effectively passed “by pointer.” Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointers—mutable objects can be changed in-place in the function,\nmuch like C arrays.\nOf course, if you’ve never used C, Python’s argument-passing mode will seem simpler\nstill—it involves just the assignment of objects to names, and it works the same whether\nthe objects are mutable or not.",
    "Arguments and Shared References\nTo illustrate argument-passing properties at work, consider the following code:\n>>> def f(a):\n...\na = 99\n...\n>>> b = 88\n>>> f(b)\n>>> print(b)\n88\n\n# a is assigned to (references) passed object\n# Changes local variable a only\n# a and b both reference same 88 initially\n# b is not changed",
    "In this example the variable a is assigned the object 88 at the moment the function is\ncalled with f(b), but a lives only within the called function. Changing a inside the\nfunction has no effect on the place where the function is called; it simply resets the local\nvariable a to a completely different object.\nThat’s what is meant by a lack of name aliasing—assignment to an argument name\ninside a function (e.g., a=99) does not magically change a variable like b in the scope of\nthe function call. Argument names may share passed objects initially (they are essentially pointers to those objects), but only temporarily, when the function is first called.\nAs soon as an argument name is reassigned, this relationship ends.\nAt least, that’s the case for assignment to argument names themselves. When arguments\nare passed mutable objects like lists and dictionaries, we also need to be aware that inplace changes to such objects may live on after a function exits, and hence impact callers.",
    "As soon as an argument name is reassigned, this relationship ends.\nAt least, that’s the case for assignment to argument names themselves. When arguments\nare passed mutable objects like lists and dictionaries, we also need to be aware that inplace changes to such objects may live on after a function exits, and hence impact callers.\nHere’s an example that demonstrates this behavior:",
    "436 | Chapter 18: Arguments\n\n\f>>> def changer(a, b):\n...\na = 2\n...\nb[0] = 'spam'\n...\n>>> X = 1\n>>> L = [1, 2]\n>>> changer(X, L)\n>>> X, L\n(1, ['spam', 2])\n\n# Arguments assigned references to objects\n# Changes local name's value only\n# Changes shared object in-place\n# Caller\n# Pass immutable and mutable objects\n# X is unchanged, L is different!",
    "In this code, the changer function assigns values to argument a itself, and to a component of the object referenced by argument b. These two assignments within the function\nare only slightly different in syntax but have radically different results:\n• Because a is a local variable name in the function’s scope, the first assignment has\nno effect on the caller—it simply changes the local variable a to reference a completely different object, and does not change the binding of the name X in the caller’s\nscope. This is the same as in the prior example.\n• Argument b is a local variable name, too, but it is passed a mutable object (the list\nthat L references in the caller’s scope). As the second assignment is an in-place\nobject change, the result of the assignment to b[0] in the function impacts the value\nof L after the function returns.\nReally, the second assignment statement in changer doesn’t change b—it changes part",
    "• Argument b is a local variable name, too, but it is passed a mutable object (the list\nthat L references in the caller’s scope). As the second assignment is an in-place\nobject change, the result of the assignment to b[0] in the function impacts the value\nof L after the function returns.\nReally, the second assignment statement in changer doesn’t change b—it changes part\nof the object that b currently references. This in-place change impacts the caller only\nbecause the changed object outlives the function call. The name L hasn’t changed\neither—it still references the same, changed object—but it seems as though L differs\nafter the call because the value it references has been modified within the function.\nFigure 18-1 illustrates the name/object bindings that exist immediately after the function has been called, and before its code has run.\nIf this example is still confusing, it may help to notice that the effect of the automatic",
    "either—it still references the same, changed object—but it seems as though L differs\nafter the call because the value it references has been modified within the function.\nFigure 18-1 illustrates the name/object bindings that exist immediately after the function has been called, and before its code has run.\nIf this example is still confusing, it may help to notice that the effect of the automatic\nassignments of the passed-in arguments is the same as running a series of simple assignment statements. In terms of the first argument, the assignment has no effect on\nthe caller:\n>>> X = 1\n>>> a = X\n>>> a = 2\n>>> print(X)\n1",
    "# They share the same object\n# Resets 'a' only, 'X' is still 1\n\nThe assignment through the second argument does affect a variable at the call, though,\nbecause it is an in-place object change:\n>>> L = [1, 2]\n>>> b = L\n>>> b[0] = 'spam'\n>>> print(L)\n['spam', 2]\n\n# They share the same object\n# In-place change: 'L' sees the change too\n\nArgument-Passing Basics | 437\n\n\fFigure 18-1. References: arguments. Because arguments are passed by assignment, argument names\nin the function may share objects with variables in the scope of the call. Hence, in-place changes to\nmutable arguments in a function can impact the caller. Here, a and b in the function initially reference\nthe objects referenced by variables X and L when the function is first called. Changing the list through\nvariable b makes L appear different after the call returns.",
    "If you recall our discussions about shared mutable objects in Chapters 6 and 9, you’ll\nrecognize the phenomenon at work: changing a mutable object in-place can impact\nother references to that object. Here, the effect is to make one of the arguments work\nlike both an input and an output of the function.",
    "Avoiding Mutable Argument Changes\nThis behavior of in-place changes to mutable arguments isn’t a bug—it’s simply the\nway argument passing works in Python. Arguments are passed to functions by reference\n(a.k.a. pointer) by default because that is what we normally want. It means we can pass\nlarge objects around our programs without making multiple copies along the way, and\nwe can easily update these objects as we go. In fact, as we’ll see in Part VI, Python’s\nclass model depends upon changing a passed-in “self” argument in-place, to update\nobject state.\nIf we don’t want in-place changes within functions to impact objects we pass to them,\nthough, we can simply make explicit copies of mutable objects, as we learned in Chapter 6. For function arguments, we can always copy the list at the point of call:\nL = [1, 2]\nchanger(X, L[:])\n\n# Pass a copy, so our 'L' does not change",
    "# Pass a copy, so our 'L' does not change\n\nWe can also copy within the function itself, if we never want to change passed-in objects, regardless of how the function is called:\ndef changer(a, b):\nb = b[:]\n\n438 | Chapter 18: Arguments\n\n# Copy input list so we don't impact caller\n\n\fa = 2\nb[0] = 'spam'\n\n# Changes our list copy only\n\nBoth of these copying schemes don’t stop the function from changing the object—they\njust prevent those changes from impacting the caller. To really prevent changes, we can\nalways convert to immutable objects to force the issue. Tuples, for example, throw an\nexception when changes are attempted:\nL = [1, 2]\nchanger(X, tuple(L))\n\n# Pass a tuple, so changes are errors",
    "This scheme uses the built-in tuple function, which builds a new tuple out of all the\nitems in a sequence (really, any iterable). It’s also something of an extreme—because\nit forces the function to be written to never change passed-in arguments, this solution\nmight impose more limitations on the function than it should, and so should generally\nbe avoided (you never know when changing arguments might come in handy for other\ncalls in the future). Using this technique will also make the function lose the ability to\ncall any list-specific methods on the argument, including methods that do not change\nthe object in-place.\nThe main point to remember here is that functions might update mutable objects like\nlists and dictionaries passed into them. This isn’t necessarily a problem if it’s expected,\nand often serves useful purposes. Moreover, functions that change passed-in mutable\nobjects in place are probably designed and intended to do so—the change is likely part",
    "the object in-place.\nThe main point to remember here is that functions might update mutable objects like\nlists and dictionaries passed into them. This isn’t necessarily a problem if it’s expected,\nand often serves useful purposes. Moreover, functions that change passed-in mutable\nobjects in place are probably designed and intended to do so—the change is likely part\nof a well-defined API that you shouldn’t violate by making copies.\nHowever, you do have to be aware of this property—if objects change out from under\nyou unexpectedly, check whether a called function might be responsible, and make\ncopies when objects are passed if needed.",
    "Simulating Output Parameters\nWe’ve already discussed the return statement and used it in a few examples. Here’s\nanother way to use this statement: because return can send back any sort of object, it\ncan return multiple values by packaging them in a tuple or other collection type. In fact,\nalthough Python doesn’t support what some languages label “call-by-reference” argument passing, we can usually simulate it by returning tuples and assigning the results\nback to the original argument names in the caller:\n>>> def multiple(x, y):\n...\nx = 2\n...\ny = [3, 4]\n...\nreturn x, y\n...\n>>> X = 1\n>>> L = [1, 2]\n>>> X, L = multiple(X, L)\n>>> X, L\n(2, [3, 4])\n\n# Changes local names only\n# Return new values in a tuple\n\n# Assign results to caller's names\n\nArgument-Passing Basics | 439",
    "# Changes local names only\n# Return new values in a tuple\n\n# Assign results to caller's names\n\nArgument-Passing Basics | 439\n\n\fIt looks like the code is returning two values here, but it’s really just one—a two-item\ntuple with the optional surrounding parentheses omitted. After the call returns, we can\nuse tuple assignment to unpack the parts of the returned tuple. (If you’ve forgotten why\nthis works, flip back to “Tuples” on page 225 in Chapter 4, Chapter 9, and “Assignment\nStatements” on page 279 in Chapter 11.) The net effect of this coding pattern is to\nsimulate the output parameters of other languages by explicit assignments. X and L\nchange after the call, but only because the code said so.\nUnpacking arguments in Python 2.X: The preceding example unpacks a\ntuple returned by the function with tuple assignment. In Python 2.6, it’s\nalso possible to automatically unpack tuples in arguments passed to a\nfunction. In 2.6, a function defined by this header:\ndef f((a, (b, c))):",
    "can be called with tuples that match the expected structure:\nf((1, (2, 3))) assigns a, b, and c to 1, 2, and 3, respectively. Naturally,\nthe passed tuple can also be an object created before the call (f(T)). This\ndef syntax is no longer supported in Python 3.0. Instead, code this\nfunction as:\ndef f(T): (a, (b, c)) = T",
    "to unpack in an explicit assignment statement. This explicit form works\nin both 3.0 and 2.6. Argument unpacking is an obscure and rarely used\nfeature in Python 2.X. Moreover, a function header in 2.6 supports only\nthe tuple form of sequence assignment; more general sequence assignments (e.g., def f((a, [b, c])):) fail on syntax errors in 2.6 as well and\nrequire the explicit assignment form.\nTuple unpacking argument syntax is also disallowed by 3.0 in lambda\nfunction argument lists: see the sidebar “Why You Will Care: List Comprehensions and map” on page 491 for an example. Somewhat asymmetrically, tuple unpacking assignment is still automatic in 3.0 for loops\ntargets, though; see Chapter 13 for examples.",
    "Special Argument-Matching Modes\nAs we’ve just seen, arguments are always passed by assignment in Python; names in the\ndef header are assigned to passed-in objects. On top of this model, though, Python\nprovides additional tools that alter the way the argument objects in a call are\nmatched with argument names in the header prior to assignment. These tools are all\noptional, but they allow us to write functions that support more flexible calling patterns, and you may encounter some libraries that require them.\n\n440 | Chapter 18: Arguments\n\n\fBy default, arguments are matched by position, from left to right, and you must pass\nexactly as many arguments as there are argument names in the function header.\nHowever, you can also specify matching by name, default values, and collectors for\nextra arguments.",
    "The Basics\nBefore we go into the syntactic details, I want to stress that these special modes are\noptional and only have to do with matching objects to names; the underlying passing\nmechanism after the matching takes place is still assignment. In fact, some of these\ntools are intended more for people writing libraries than for application developers.\nBut because you may stumble across these modes even if you don’t code them yourself,\nhere’s a synopsis of the available tools:\nPositionals: matched from left to right\nThe normal case, which we’ve mostly been using so far, is to match passed argument values to argument names in a function header by position, from left to right.\nKeywords: matched by argument name\nAlternatively, callers can specify which argument in the function is to receive a\nvalue by using the argument’s name in the call, with the name=value syntax.\nDefaults: specify values for arguments that aren’t passed",
    "Keywords: matched by argument name\nAlternatively, callers can specify which argument in the function is to receive a\nvalue by using the argument’s name in the call, with the name=value syntax.\nDefaults: specify values for arguments that aren’t passed\nFunctions themselves can specify default values for arguments to receive if the call\npasses too few values, again using the name=value syntax.\nVarargs collecting: collect arbitrarily many positional or keyword arguments\nFunctions can use special arguments preceded with one or two * characters to\ncollect an arbitrary number of extra arguments (this feature is often referred to as\nvarargs, after the varargs feature in the C language, which also supports variablelength argument lists).\nVarargs unpacking: pass arbitrarily many positional or keyword arguments\nCallers can also use the * syntax to unpack argument collections into discrete,\nseparate arguments. This is the inverse of a * in a function header—in the header",
    "varargs, after the varargs feature in the C language, which also supports variablelength argument lists).\nVarargs unpacking: pass arbitrarily many positional or keyword arguments\nCallers can also use the * syntax to unpack argument collections into discrete,\nseparate arguments. This is the inverse of a * in a function header—in the header\nit means collect arbitrarily many arguments, while in the call it means pass arbitrarily many arguments.\nKeyword-only arguments: arguments that must be passed by name\nIn Python 3.0 (but not 2.6), functions can also specify arguments that must be\npassed by name with keyword arguments, not by position. Such arguments are\ntypically used to define configuration options in addition to actual arguments.",
    "Special Argument-Matching Modes | 441\n\n\fMatching Syntax\nTable 18-1 summarizes the syntax that invokes the special argument-matching modes.\nTable 18-1. Function argument-matching forms\nSyntax\n\nLocation\n\nInterpretation\n\nfunc(value)\n\nCaller\n\nNormal argument: matched by position\n\nfunc(name=value)\n\nCaller\n\nKeyword argument: matched by name\n\nfunc(*sequence)\n\nCaller\n\nPass all objects in sequence as individual positional arguments\n\nfunc(**dict)\n\nCaller\n\nPass all key/value pairs in dict as individual keyword arguments\n\ndef func(name)\n\nFunction\n\nNormal argument: matches any passed value by position or name\n\ndef func(name=value)\n\nFunction\n\nDefault argument value, if not passed in the call\n\ndef func(*name)\n\nFunction\n\nMatches and collects remaining positional arguments in a tuple\n\ndef func(**name)\n\nFunction\n\nMatches and collects remaining keyword arguments in a dictionary\n\ndef func(*args, name)\n\nFunction\n\nArguments that must be passed by keyword only in calls (3.0)\n\ndef func(*, name=value)",
    "These special matching modes break down into function calls and definitions as\nfollows:\n• In a function call (the first four rows of the table), simple values are matched by\nposition, but using the name=value form tells Python to match by name to arguments instead; these are called keyword arguments. Using a *sequence or **dict in\na call allows us to package up arbitrarily many positional or keyword objects in\nsequences and dictionaries, respectively, and unpack them as separate, individual\narguments when they are passed to the function.\n• In a function header (the rest of the table), a simple name is matched by position or\nname depending on how the caller passes it, but the name=value form specifies a\ndefault value. The *name form collects any extra unmatched positional arguments\nin a tuple, and the **name form collects extra keyword arguments in a dictionary.\nIn Python 3.0 and later, any normal or defaulted argument names following a",
    "name depending on how the caller passes it, but the name=value form specifies a\ndefault value. The *name form collects any extra unmatched positional arguments\nin a tuple, and the **name form collects extra keyword arguments in a dictionary.\nIn Python 3.0 and later, any normal or defaulted argument names following a\n*name or a bare * are keyword-only arguments and must be passed by keyword in\ncalls.\nOf these, keyword arguments and defaults are probably the most commonly used in\nPython code. We’ve informally used both of these earlier in this book:\n• We’ve already used keywords to specify options to the 3.0 print function, but they\nare more general—keywords allow us to label any argument with its name, to make\ncalls more informational.",
    "442 | Chapter 18: Arguments\n\n\f• We met defaults earlier, too, as a way to pass in values from the enclosing function’s\nscope, but they are also more general—they allow us to make any argument optional, providing its default value in a function definition.\nAs we’ll see, the combination of defaults in a function header and keywords in a call\nfurther allows us to pick and choose which defaults to override.\nIn short, special argument-matching modes let you be fairly liberal about how many\narguments must be passed to a function. If a function specifies defaults, they are used\nif you pass too few arguments. If a function uses the * variable argument list forms, you\ncan pass too many arguments; the * names collect the extra arguments in data structures\nfor processing in the function.",
    "The Gritty Details\nIf you choose to use and combine the special argument-matching modes, Python will\nask you to follow these ordering rules:\n• In a function call, arguments must appear in this order: any positional arguments\n(value), followed by a combination of any keyword arguments (name=value) and\nthe *sequence form, followed by the **dict form.\n• In a function header, arguments must appear in this order: any normal arguments\n(name), followed by any default arguments (name=value), followed by the *name (or\n* in 3.0) form if present, followed by any name or name=value keyword-only arguments (in 3.0), followed by the **name form.\nIn both the call and header, the **arg form must appear last if present. If you mix\narguments in any other order, you will get a syntax error because the combinations can\nbe ambiguous. The steps that Python internally carries out to match arguments before\nassignment can roughly be described as follows:\n1. Assign nonkeyword arguments by position.",
    "In both the call and header, the **arg form must appear last if present. If you mix\narguments in any other order, you will get a syntax error because the combinations can\nbe ambiguous. The steps that Python internally carries out to match arguments before\nassignment can roughly be described as follows:\n1. Assign nonkeyword arguments by position.\n2. Assign keyword arguments by matching names.\n3. Assign extra nonkeyword arguments to *name tuple.\n4. Assign extra keyword arguments to **name dictionary.\n5. Assign default values to unassigned arguments in header.\nAfter this, Python checks to make sure each argument is passed just one value; if not,\nan error is raised. When all matching is complete, Python assigns argument names to\nthe objects passed to them.",
    "Special Argument-Matching Modes | 443\n\n\fThe actual matching algorithm Python uses is a bit more complex (it must also account\nfor keyword-only arguments in 3.0, for instance), so we’ll defer to Python’s standard\nlanguage manual for a more exact description. It’s not required reading, but tracing\nPython’s matching algorithm may help you to understand some convoluted cases, especially when modes are mixed.\nIn Python 3.0, argument names in a function header can also have annotation values, specified as name:value (or name:value=default when\ndefaults are present). This is simply additional syntax for arguments and\ndoes not augment or change the argument-ordering rules described\nhere. The function itself can also have an annotation value, given as\ndef f()->value. See the discussion of function annotation in Chapter 19 for more details.",
    "Keyword and Default Examples\nThis is all simpler in code than the preceding descriptions may imply. If you don’t use\nany special matching syntax, Python matches names by position from left to right, like\nmost other languages. For instance, if you define a function that requires three arguments, you must call it with three arguments:\n>>> def f(a, b, c): print(a, b, c)\n...\n\nHere, we pass them by position—a is matched to 1, b is matched to 2, and so on (this\nworks the same in Python 3.0 and 2.6, but extra tuple parentheses are displayed in 2.6\nbecause we’re using 3.0 print calls):\n>>> f(1, 2, 3)\n1 2 3\n\nKeywords\nIn Python, though, you can be more specific about what goes where when you call a\nfunction. Keyword arguments allow us to match by name, instead of by position:\n>>> f(c=3, b=2, a=1)\n1 2 3",
    "Keywords\nIn Python, though, you can be more specific about what goes where when you call a\nfunction. Keyword arguments allow us to match by name, instead of by position:\n>>> f(c=3, b=2, a=1)\n1 2 3\n\nThe c=3 in this call, for example, means send 3 to the argument named c. More formally,\nPython matches the name c in the call to the argument named c in the function definition’s header, and then passes the value 3 to that argument. The net effect of this call\nis the same as that of the prior call, but notice that the left-to-right order of the arguments no longer matters when keywords are used because arguments are matched by\nname, not by position. It’s even possible to combine positional and keyword arguments\nin a single call. In this case, all positionals are matched first from left to right in the\nheader, before keywords are matched by name:\n\n444 | Chapter 18: Arguments\n\n\f>>> f(1, c=3, b=2)\n1 2 3",
    "444 | Chapter 18: Arguments\n\n\f>>> f(1, c=3, b=2)\n1 2 3\n\nWhen most people see this the first time, they wonder why one would use such a tool.\nKeywords typically have two roles in Python. First, they make your calls a bit more selfdocumenting (assuming that you use better argument names than a, b, and c). For\nexample, a call of this form:\nfunc(name='Bob', age=40, job='dev')\n\nis much more meaningful than a call with three naked values separated by commas—\nthe keywords serve as labels for the data in the call. The second major use of keywords\noccurs in conjunction with defaults, which we turn to next.\n\nDefaults\nWe talked about defaults in brief earlier, when discussing nested function scopes. In\nshort, defaults allow us to make selected function arguments optional; if not passed a\nvalue, the argument is assigned its default before the function runs. For example, here\nis a function that requires one argument and defaults two:\n>>> def f(a, b=2, c=3): print(a, b, c)\n...",
    "Defaults\nWe talked about defaults in brief earlier, when discussing nested function scopes. In\nshort, defaults allow us to make selected function arguments optional; if not passed a\nvalue, the argument is assigned its default before the function runs. For example, here\nis a function that requires one argument and defaults two:\n>>> def f(a, b=2, c=3): print(a, b, c)\n...\n\nWhen we call this function, we must provide a value for a, either by position or by\nkeyword; however, providing values for b and c is optional. If we don’t pass values to\nb and c, they default to 2 and 3, respectively:\n>>> f(1)\n1 2 3\n>>> f(a=1)\n1 2 3\n\nIf we pass two values, only c gets its default, and with three values, no defaults are used:\n>>> f(1, 4)\n1 4 3\n>>> f(1, 4, 5)\n1 4 5\n\nFinally, here is how the keyword and default features interact. Because they subvert the\nnormal left-to-right positional mapping, keywords allow us to essentially skip over\narguments with defaults:\n>>> f(1, c=6)\n1 2 6",
    "If we pass two values, only c gets its default, and with three values, no defaults are used:\n>>> f(1, 4)\n1 4 3\n>>> f(1, 4, 5)\n1 4 5\n\nFinally, here is how the keyword and default features interact. Because they subvert the\nnormal left-to-right positional mapping, keywords allow us to essentially skip over\narguments with defaults:\n>>> f(1, c=6)\n1 2 6\n\nHere, a gets 1 by position, c gets 6 by keyword, and b, in between, defaults to 2.\nBe careful not to confuse the special name=value syntax in a function header and a\nfunction call; in the call it means a match-by-name keyword argument, while in the\nheader it specifies a default for an optional argument. In both cases, this is not an\nassignment statement (despite its appearance); it is special syntax for these two contexts, which modifies the default argument-matching mechanics.\nSpecial Argument-Matching Modes | 445",
    "Combining keywords and defaults\nHere is a slightly larger example that demonstrates keywords and defaults in action. In\nthe following, the caller must always pass at least two arguments (to match spam and\neggs), but the other two are optional. If they are omitted, Python assigns toast and\nham to the defaults specified in the header:\ndef func(spam, eggs, toast=0, ham=0):\nprint((spam, eggs, toast, ham))\n\n# First 2 required\n\nfunc(1, 2)\nfunc(1, ham=1, eggs=0)\nfunc(spam=1, eggs=0)\nfunc(toast=1, eggs=2, spam=3)\nfunc(1, 2, 3, 4)\n\n# Output: (1, 2, 0, 0)\n# Output: (1, 0, 0, 1)\n# Output: (1, 0, 0, 0)\n# Output: (3, 2, 1, 0)\n# Output: (1, 2, 3, 4)",
    "# First 2 required\n\nfunc(1, 2)\nfunc(1, ham=1, eggs=0)\nfunc(spam=1, eggs=0)\nfunc(toast=1, eggs=2, spam=3)\nfunc(1, 2, 3, 4)\n\n# Output: (1, 2, 0, 0)\n# Output: (1, 0, 0, 1)\n# Output: (1, 0, 0, 0)\n# Output: (3, 2, 1, 0)\n# Output: (1, 2, 3, 4)\n\nNotice again that when keyword arguments are used in the call, the order in which the\narguments are listed doesn’t matter; Python matches by name, not by position. The\ncaller must supply values for spam and eggs, but they can be matched by position or by\nname. Again, keep in mind that the form name=value means different things in the call\nand the def: a keyword in the call and a default in the header.\n\nArbitrary Arguments Examples\nThe last two matching extensions, * and **, are designed to support functions that take\nany number of arguments. Both can appear in either the function definition or a function call, and they have related purposes in the two locations.",
    "Arbitrary Arguments Examples\nThe last two matching extensions, * and **, are designed to support functions that take\nany number of arguments. Both can appear in either the function definition or a function call, and they have related purposes in the two locations.\n\nCollecting arguments\nThe first use, in the function definition, collects unmatched positional arguments into\na tuple:\n>>> def f(*args): print(args)\n...\n\nWhen this function is called, Python collects all the positional arguments into a new\ntuple and assigns the variable args to that tuple. Because it is a normal tuple object, it\ncan be indexed, stepped through with a for loop, and so on:\n>>> f()\n()\n>>> f(1)\n(1,)\n>>> f(1, 2, 3, 4)\n(1, 2, 3, 4)",
    "When this function is called, Python collects all the positional arguments into a new\ntuple and assigns the variable args to that tuple. Because it is a normal tuple object, it\ncan be indexed, stepped through with a for loop, and so on:\n>>> f()\n()\n>>> f(1)\n(1,)\n>>> f(1, 2, 3, 4)\n(1, 2, 3, 4)\n\nThe ** feature is similar, but it only works for keyword arguments—it collects them\ninto a new dictionary, which can then be processed with normal dictionary tools. In a\nsense, the ** form allows you to convert from keywords to dictionaries, which you can\nthen step through with keys calls, dictionary iterators, and the like:\n\n446 | Chapter 18: Arguments\n\n\f>>> def f(**args): print(args)\n...\n>>> f()\n{}\n>>> f(a=1, b=2)\n{'a': 1, 'b': 2}",
    "446 | Chapter 18: Arguments\n\n\f>>> def f(**args): print(args)\n...\n>>> f()\n{}\n>>> f(a=1, b=2)\n{'a': 1, 'b': 2}\n\nFinally, function headers can combine normal arguments, the *, and the ** to implement wildly flexible call signatures. For instance, in the following, 1 is passed to a by\nposition, 2 and 3 are collected into the pargs positional tuple, and x and y wind up in\nthe kargs keyword dictionary:\n>>> def f(a, *pargs, **kargs): print(a, pargs, kargs)\n...\n>>> f(1, 2, 3, x=1, y=2)\n1 (2, 3) {'y': 2, 'x': 1}\n\nIn fact, these features can be combined in even more complex ways that may seem\nambiguous at first glance—an idea we will revisit later in this chapter. First, though,\nlet’s see what happens when * and ** are coded in function calls instead of definitions.",
    "In fact, these features can be combined in even more complex ways that may seem\nambiguous at first glance—an idea we will revisit later in this chapter. First, though,\nlet’s see what happens when * and ** are coded in function calls instead of definitions.\n\nUnpacking arguments\nIn recent Python releases, we can use the * syntax when we call a function, too. In this\ncontext, its meaning is the inverse of its meaning in the function definition—it unpacks\na collection of arguments, rather than building a collection of arguments. For example,\nwe can pass four arguments to a function in a tuple and let Python unpack them into\nindividual arguments:\n>>> def func(a, b, c, d): print(a, b, c, d)\n...\n>>> args = (1, 2)\n>>> args += (3, 4)\n>>> func(*args)\n1 2 3 4\n\nSimilarly, the ** syntax in a function call unpacks a dictionary of key/value pairs into\nseparate keyword arguments:\n>>> args = {'a': 1, 'b': 2, 'c': 3}\n>>> args['d'] = 4\n>>> func(**args)\n1 2 3 4",
    "Similarly, the ** syntax in a function call unpacks a dictionary of key/value pairs into\nseparate keyword arguments:\n>>> args = {'a': 1, 'b': 2, 'c': 3}\n>>> args['d'] = 4\n>>> func(**args)\n1 2 3 4\n\nAgain, we can combine normal, positional, and keyword arguments in the call in very\nflexible ways:\n>>> func(*(1, 2), **{'d': 4, 'c': 4})\n1 2 4 4\n>>> func(1, *(2, 3), **{'d': 4})\n1 2 3 4\n>>> func(1, c=3, *(2,), **{'d': 4})\n\nSpecial Argument-Matching Modes | 447\n\n\f1 2 3 4\n>>> func(1, *(2, 3), d=4)\n1 2 3 4\n>>> f(1, *(2,), c=3, **{'d':4})\n1 2 3 4",
    "This sort of code is convenient when you cannot predict the number of arguments that\nwill be passed to a function when you write your script; you can build up a collection\nof arguments at runtime instead and call the function generically this way. Again, don’t\nconfuse the */** syntax in the function header and the function call—in the header it\ncollects any number of arguments, while in the call it unpacks any number of\narguments.\nAs we saw in Chapter 14, the *pargs form in a call is an iteration context, so technically it accepts any iterable object, not just tuples or other\nsequences as shown in the examples here. For instance, a file object\nworks after the *, and unpacks its lines into individual arguments (e.g.,\nfunc(*open('fname')).\nThis generality is supported in both Python 3.0 and 2.6, but it holds true\nonly for calls—a *pargs in a call allows any iterable, but the same form\nin a def header always bundles extra arguments into a tuple. This header",
    "sequences as shown in the examples here. For instance, a file object\nworks after the *, and unpacks its lines into individual arguments (e.g.,\nfunc(*open('fname')).\nThis generality is supported in both Python 3.0 and 2.6, but it holds true\nonly for calls—a *pargs in a call allows any iterable, but the same form\nin a def header always bundles extra arguments into a tuple. This header\nbehavior is similar in spirit and syntax to the * in Python 3.0 extended\nsequence unpacking assignment forms we met in Chapter 11 (e.g., x,\n*y = z), though that feature always creates lists, not tuples.",
    "Applying functions generically\nThe prior section’s examples may seem obtuse, but they are used more often than you\nmight expect. Some programs need to call arbitrary functions in a generic fashion,\nwithout knowing their names or arguments ahead of time. In fact, the real power of\nthe special “varargs” call syntax is that you don’t need to know how many arguments\na function call requires before you write a script. For example, you can use if logic to\nselect from a set of functions and argument lists, and call any of them generically:\nif <test>:\naction, args = func1, (1,)\nelse:\naction, args = func2, (1, 2, 3)\n...\naction(*args)\n\n# Call func1 with 1 arg in this case\n# Call func2 with 3 args here\n# Dispatch generically",
    "# Call func1 with 1 arg in this case\n# Call func2 with 3 args here\n# Dispatch generically\n\nMore generally, this varargs call syntax is useful any time you cannot predict the arguments list. If your user selects an arbitrary function via a user interface, for instance,\nyou may be unable to hardcode a function call when writing your script. To work\naround this, simply build up the arguments list with sequence operations, and call it\nwith starred names to unpack the arguments:\n\n448 | Chapter 18: Arguments\n\n\f>>> args = (2,3)\n>>> args += (4,)\n>>> args\n(2, 3, 4)\n>>> func(*args)\n\nBecause the arguments list is passed in as a tuple here, the program can build it at\nruntime. This technique also comes in handy for functions that test or time other functions. For instance, in the following code we support any function with any arguments\nby passing along whatever arguments were sent in:\ndef tracer(func, *pargs, **kargs):\nprint('calling:', func.__name__)\nreturn func(*pargs, **kargs)",
    "# Accept arbitrary arguments\n# Pass along arbitrary arguments\n\ndef func(a, b, c, d):\nreturn a + b + c + d\nprint(tracer(func, 1, 2, c=3, d=4))\n\nWhen this code is run, arguments are collected by the tracer and then propagated with\nvarargs call syntax:\ncalling: func\n10\n\nWe’ll see larger examples of such roles later in this book; see especially the sequence\ntiming example in Chapter 20 and the various decorator tools we will code in Chapter 38.\n\nThe defunct apply built-in (Python 2.6)\nPrior to Python 3.0, the effect of the *args and **args varargs call syntax could be\nachieved with a built-in function named apply. This original technique has been removed in 3.0 because it is now redundant (3.0 cleans up many such dusty tools that\nhave been subsumed over the years). It’s still available in Python 2.6, though, and you\nmay come across it in older 2.X code.\nIn short, the following are equivalent prior to Python 3.0:\nfunc(*pargs, **kargs)\n\n# Newer call syntax: func(*sequence, **dict)",
    "# Newer call syntax: func(*sequence, **dict)\n\napply(func, pargs, kargs)\n\n# Defunct built-in: apply(func, sequence, dict)\n\nFor example, consider the following function, which accepts any number of positional\nor keyword arguments:\n>>> def echo(*args, **kwargs): print(args, kwargs)\n...\n>>> echo(1, 2, a=3, b=4)\n(1, 2) {'a': 3, 'b': 4}\n\nSpecial Argument-Matching Modes | 449\n\n\fIn Python 2.6, we can call it generically with apply, or with the call syntax that is now\nrequired in 3.0:\n>>> pargs = (1, 2)\n>>> kargs = {'a':3, 'b':4}\n>>> apply(echo, pargs, kargs)\n(1, 2) {'a': 3, 'b': 4}\n>>> echo(*pargs, **kargs)\n(1, 2) {'a': 3, 'b': 4}",
    "Special Argument-Matching Modes | 449\n\n\fIn Python 2.6, we can call it generically with apply, or with the call syntax that is now\nrequired in 3.0:\n>>> pargs = (1, 2)\n>>> kargs = {'a':3, 'b':4}\n>>> apply(echo, pargs, kargs)\n(1, 2) {'a': 3, 'b': 4}\n>>> echo(*pargs, **kargs)\n(1, 2) {'a': 3, 'b': 4}\n\nThe unpacking call syntax form is newer than the apply function, is preferred in general,\nand is required in 3.0. Apart from its symmetry with the *pargs and **kargs collector\nforms in def headers, and the fact that it requires fewer keystrokes overall, the newer\ncall syntax also allows us to pass along additional arguments without having to manually extend argument sequences or dictionaries:\n>>> echo(0, c=5, *pargs, **kargs)\n(0, 1, 2) {'a': 3, 'c': 5, 'b': 4}\n\n# Normal, keyword, *sequence, **dictionary",
    "# Normal, keyword, *sequence, **dictionary\n\nThat is, the call syntax form is more general. Since it’s required in 3.0, you should now\ndisavow all knowledge of apply (unless, of course, it appears in 2.X code you must use\nor maintain...).",
    "Python 3.0 Keyword-Only Arguments\nPython 3.0 generalizes the ordering rules in function headers to allow us to specify\nkeyword-only arguments—arguments that must be passed by keyword only and will\nnever be filled in by a positional argument. This is useful if we want a function to both\nprocess any number of arguments and accept possibly optional configuration options.\nSyntactically, keyword-only arguments are coded as named arguments that appear after\n*args in the arguments list. All such arguments must be passed using keyword syntax\nin the call. For example, in the following, a may be passed by name or position, b collects\nany extra positional arguments, and c must be passed by keyword only:\n>>> def kwonly(a, *b, c):\n...\nprint(a, b, c)\n...\n>>> kwonly(1, 2, c=3)\n1 (2,) 3\n>>> kwonly(a=1, c=3)\n1 () 3\n>>> kwonly(1, 2, 3)\nTypeError: kwonly() needs keyword-only argument c",
    "We can also use a * character by itself in the arguments list to indicate that a function\ndoes not accept a variable-length argument list but still expects all arguments following\nthe * to be passed as keywords. In the next function, a may be passed by position or\nname again, but b and c must be keywords, and no extra positionals are allowed:\n\n450 | Chapter 18: Arguments\n\n\f>>> def kwonly(a, *, b, c):\n...\nprint(a, b, c)\n...\n>>> kwonly(1, c=3, b=2)\n1 2 3\n>>> kwonly(c=3, b=2, a=1)\n1 2 3\n>>> kwonly(1, 2, 3)\nTypeError: kwonly() takes exactly 1 positional argument (3 given)\n>>> kwonly(1)\nTypeError: kwonly() needs keyword-only argument b",
    "450 | Chapter 18: Arguments\n\n\f>>> def kwonly(a, *, b, c):\n...\nprint(a, b, c)\n...\n>>> kwonly(1, c=3, b=2)\n1 2 3\n>>> kwonly(c=3, b=2, a=1)\n1 2 3\n>>> kwonly(1, 2, 3)\nTypeError: kwonly() takes exactly 1 positional argument (3 given)\n>>> kwonly(1)\nTypeError: kwonly() needs keyword-only argument b\n\nYou can still use defaults for keyword-only arguments, even though they appear after\nthe * in the function header. In the following code, a may be passed by name or position,\nand b and c are optional but must be passed by keyword if used:\n>>> def kwonly(a, *, b='spam', c='ham'):\n...\nprint(a, b, c)\n...\n>>> kwonly(1)\n1 spam ham\n>>> kwonly(1, c=3)\n1 spam 3\n>>> kwonly(a=1)\n1 spam ham\n>>> kwonly(c=3, b=2, a=1)\n1 2 3\n>>> kwonly(1, 2)\nTypeError: kwonly() takes exactly 1 positional argument (2 given)",
    "In fact, keyword-only arguments with defaults are optional, but those without defaults\neffectively become required keywords for the function:\n>>> def kwonly(a, *, b, c='spam'):\n...\nprint(a, b, c)\n...\n>>> kwonly(1, b='eggs')\n1 eggs spam\n>>> kwonly(1, c='eggs')\nTypeError: kwonly() needs keyword-only argument b\n>>> kwonly(1, 2)\nTypeError: kwonly() takes exactly 1 positional argument (2 given)\n>>> def kwonly(a, *, b=1, c, d=2):\n...\nprint(a, b, c, d)\n...\n>>> kwonly(3, c=4)\n3 1 4 2\n>>> kwonly(3, c=4, b=5)\n3 5 4 2\n>>> kwonly(3)\nTypeError: kwonly() needs keyword-only argument c\n>>> kwonly(1, 2, 3)\nTypeError: kwonly() takes exactly 1 positional argument (3 given)\n\nSpecial Argument-Matching Modes | 451",
    "Special Argument-Matching Modes | 451\n\n\fOrdering rules\nFinally, note that keyword-only arguments must be specified after a single star, not\ntwo—named arguments cannot appear after the **args arbitrary keywords form, and\na ** can’t appear by itself in the arguments list. Both attempts generate a syntax error:\n>>> def kwonly(a, **pargs, b, c):\nSyntaxError: invalid syntax\n>>> def kwonly(a, **, b, c):\nSyntaxError: invalid syntax\n\nThis means that in a function header, keyword-only arguments must be coded before\nthe **args arbitrary keywords form and after the *args arbitrary positional form, when\nboth are present. Whenever an argument name appears before *args, it is a possibly\ndefault positional argument, not keyword-only:\n>>> def f(a, *b, **d, c=6): print(a, b, c, d)\nSyntaxError: invalid syntax\n\n# Keyword-only before **!\n\n>>> def f(a, *b, c=6, **d): print(a, b, c, d)\n...\n>>> f(1, 2, 3, x=4, y=5)\n1 (2, 3) 6 {'y': 5, 'x': 4}\n\n# Collect args in header",
    "# Keyword-only before **!\n\n>>> def f(a, *b, c=6, **d): print(a, b, c, d)\n...\n>>> f(1, 2, 3, x=4, y=5)\n1 (2, 3) 6 {'y': 5, 'x': 4}\n\n# Collect args in header\n\n>>> f(1, 2, 3, x=4, y=5, c=7)\n1 (2, 3) 7 {'y': 5, 'x': 4}\n\n# Override default\n\n>>> f(1, 2, 3, c=7, x=4, y=5)\n1 (2, 3) 7 {'y': 5, 'x': 4}\n\n# Anywhere in keywords\n\n>>> def f(a, c=6, *b, **d): print(a, b, c, d)\n...\n>>> f(1, 2, 3, x=4)\n1 (3,) 2 {'x': 4}\n\n# c is not keyword-only!\n\n# Default used\n\nIn fact, similar ordering rules hold true in function calls: when keyword-only arguments\nare passed, they must appear before a **args form. The keyword-only argument can\nbe coded either before or after the *args, though, and may be included in **args:\n>>> def f(a, *b, c=6, **d): print(a, b, c, d)\n...\n>>> f(1, *(2, 3), **dict(x=4, y=5))\n1 (2, 3) 6 {'y': 5, 'x': 4}\n\n# KW-only between * and **\n\n>>> f(1, *(2, 3), **dict(x=4, y=5), c=7)\nSyntaxError: invalid syntax\n\n# Keywords before **args!",
    "# KW-only between * and **\n\n>>> f(1, *(2, 3), **dict(x=4, y=5), c=7)\nSyntaxError: invalid syntax\n\n# Keywords before **args!\n\n>>> f(1, *(2, 3), c=7, **dict(x=4, y=5))\n1 (2, 3) 7 {'y': 5, 'x': 4}\n\n# Override default\n\n>>> f(1, c=7, *(2, 3), **dict(x=4, y=5))\n1 (2, 3) 7 {'y': 5, 'x': 4}\n\n# After or before *\n\n>>> f(1, *(2, 3), **dict(x=4, y=5, c=7))\n1 (2, 3) 7 {'y': 5, 'x': 4}\n\n# Keyword-only in **\n\n452 | Chapter 18: Arguments\n\n# Unpack args at call\n\n\fTrace through these cases on your own, in conjunction with the general argumentordering rules described formally earlier. They may appear to be worst cases in the\nartificial examples here, but they can come up in real practice, especially for people\nwho write libraries and tools for other Python programmers to use.",
    "# Keyword-only in **\n\n452 | Chapter 18: Arguments\n\n# Unpack args at call\n\n\fTrace through these cases on your own, in conjunction with the general argumentordering rules described formally earlier. They may appear to be worst cases in the\nartificial examples here, but they can come up in real practice, especially for people\nwho write libraries and tools for other Python programmers to use.\n\nWhy keyword-only arguments?\nSo why care about keyword-only arguments? In short, they make it easier to allow a\nfunction to accept both any number of positional arguments to be processed, and configuration options passed as keywords. While their use is optional, without keywordonly arguments extra work may be required to provide defaults for such options and\nto verify that no superfluous keywords were passed.\nImagine a function that processes a set of passed-in objects and allows a tracing flag to\nbe passed:\nprocess(X, Y, Z)\nprocess(X, Y, notify=True)\n\n# use flag's default\n# override flag default",
    "# use flag's default\n# override flag default\n\nWithout keyword-only arguments we have to use both *args and **args and manually\ninspect the keywords, but with keyword-only arguments less code is required. The\nfollowing guarantees that no positional argument will be incorrectly matched against\nnotify and requires that it be a keyword if passed:\ndef process(*args, notify=False): ...\n\nSince we’re going to see a more realistic example of this later in this chapter, in “Emulating the Python 3.0 print Function” on page 457, I’ll postpone the rest of this story\nuntil then. For an additional example of keyword-only arguments in action, see the\niteration options timing case study in Chapter 20. And for additional function definition\nenhancements in Python 3.0, stay tuned for the discussion of function annotation syntax in Chapter 19.",
    "The min Wakeup Call!\nTime for something more realistic. To make this chapter’s concepts more concrete,\nlet’s work through an exercise that demonstrates a practical application of argumentmatching tools.\nSuppose you want to code a function that is able to compute the minimum value from\nan arbitrary set of arguments and an arbitrary set of object data types. That is, the\nfunction should accept zero or more arguments, as many as you wish to pass. Moreover,\nthe function should work for all kinds of Python object types: numbers, strings, lists,\nlists of dictionaries, files, and even None.\nThe first requirement provides a natural example of how the * feature can be put to\ngood use—we can collect arguments into a tuple and step over each of them in turn\nwith a simple for loop. The second part of the problem definition is easy: because every\n\nThe min Wakeup Call! | 453",
    "The min Wakeup Call! | 453\n\n\fobject type supports comparisons, we don’t have to specialize the function per type (an\napplication of polymorphism); we can simply compare objects blindly and let Python\nworry about what sort of comparison to perform.",
    "Full Credit\nThe following file shows three ways to code this operation, at least one of which was\nsuggested by a student in one of my courses:\n• The first function fetches the first argument (args is a tuple) and traverses the rest\nby slicing off the first (there’s no point in comparing an object to itself, especially\nif it might be a large structure).\n• The second version lets Python pick off the first and rest of the arguments automatically, and so avoids an index and slice.\n• The third converts from a tuple to a list with the built-in list call and employs the\nlist sort method.\nThe sort method is coded in C, so it can be quicker than the other approaches at times,\nbut the linear scans of the first two techniques will make them faster most of the\ntime.* The file mins.py contains the code for all three solutions:\ndef min1(*args):\nres = args[0]\nfor arg in args[1:]:\nif arg < res:\nres = arg\nreturn res\ndef min2(first, *rest):\nfor arg in rest:\nif arg < first:\nfirst = arg\nreturn first",
    "but the linear scans of the first two techniques will make them faster most of the\ntime.* The file mins.py contains the code for all three solutions:\ndef min1(*args):\nres = args[0]\nfor arg in args[1:]:\nif arg < res:\nres = arg\nreturn res\ndef min2(first, *rest):\nfor arg in rest:\nif arg < first:\nfirst = arg\nreturn first\ndef min3(*args):\ntmp = list(args)\ntmp.sort()\nreturn tmp[0]",
    "# Or, in Python 2.4+: return sorted(args)[0]\n\nprint(min1(3,4,1,2))\n\n* Actually, this is fairly complicated. The Python sort routine is coded in C and uses a highly optimized\nalgorithm that attempts to take advantage of partial ordering in the items to be sorted. It’s named “timsort”\nafter Tim Peters, its creator, and in its documentation it claims to have “supernatural performance” at times\n(pretty good, for a sort!). Still, sorting is an inherently exponential operation (it must chop up the sequence\nand put it back together many times), and the other versions simply perform one linear left-to-right scan.\nThe net effect is that sorting is quicker if the arguments are partially ordered, but is likely to be slower\notherwise. Even so, Python performance can change over time, and the fact that sorting is implemented in\nthe C language can help greatly; for an exact analysis, you should time the alternatives with the time or\ntimeit modules we’ll meet in Chapter 20.",
    "454 | Chapter 18: Arguments\n\n\fprint(min2(\"bb\", \"aa\"))\nprint(min3([2,2], [1,1], [3,3]))\n\nAll three solutions produce the same result when the file is run. Try typing a few calls\ninteractively to experiment with these on your own:\n% python mins.py\n1\naa\n[1, 1]",
    "Notice that none of these three variants tests for the case where no arguments are passed\nin. They could, but there’s no point in doing so here—in all three solutions, Python\nwill automatically raise an exception if no arguments are passed in. The first variant\nraises an exception when we try to fetch item 0, the second when Python detects an\nargument list mismatch, and the third when we try to return item 0 at the end.\nThis is exactly what we want to happen—because these functions support any data\ntype, there is no valid sentinel value that we could pass back to designate an error. There\nare exceptions to this rule (e.g., if you have to run expensive actions before you reach\nthe error), but in general it’s better to assume that arguments will work in your functions’ code and let Python raise errors for you when they do not.",
    "Bonus Points\nYou can get can get bonus points here for changing these functions to compute the\nmaximum, rather than minimum, values. This one’s easy: the first two versions only\nrequire changing < to >, and the third simply requires that we return tmp[−1] instead of\ntmp[0]. For an extra point, be sure to set the function name to “max” as well (though\nthis part is strictly optional).\nIt’s also possible to generalize a single function to compute either a minimum or a\nmaximum value, by evaluating comparison expression strings with a tool like the\neval built-in function (see the library manual) or passing in an arbitrary comparison\nfunction. The file minmax.py shows how to implement the latter scheme:\ndef minmax(test, *args):\nres = args[0]\nfor arg in args[1:]:\nif test(arg, res):\nres = arg\nreturn res\ndef lessthan(x, y): return x < y\ndef grtrthan(x, y): return x > y\n\n# See also: lambda\n\nprint(minmax(lessthan, 4, 2, 1, 5, 6, 3))\nprint(minmax(grtrthan, 4, 2, 1, 5, 6, 3))\n\n# Self-test code",
    "# See also: lambda\n\nprint(minmax(lessthan, 4, 2, 1, 5, 6, 3))\nprint(minmax(grtrthan, 4, 2, 1, 5, 6, 3))\n\n# Self-test code\n\n% python minmax.py\n\nThe min Wakeup Call! | 455\n\n\f1\n6\n\nFunctions are another kind of object that can be passed into a function like this one.\nTo make this a max (or other) function, for example, we could simply pass in the right\nsort of test function. This may seem like extra work, but the main point of generalizing\nfunctions this way (instead of cutting and pasting to change just a single character) is\nthat we’ll only have one version to change in the future, not two.",
    "The Punch Line...\nOf course, all this was just a coding exercise. There’s really no reason to code min or\nmax functions, because both are built-ins in Python! We met them briefly in Chapter 5 in conjunction with numeric tools, and again in Chapter 14 when exploring iteration contexts. The built-in versions work almost exactly like ours, but they’re coded\nin C for optimal speed and accept either a single iterable or multiple arguments. Still,\nthough it’s superfluous in this context, the general coding pattern we used here might\nbe useful in other scenarios.",
    "Generalized Set Functions\nLet’s look at a more useful example of special argument-matching modes at work. At\nthe end of Chapter 16, we wrote a function that returned the intersection of two sequences (it picked out items that appeared in both). Here is a version that intersects an\narbitrary number of sequences (one or more) by using the varargs matching form\n*args to collect all the passed-in arguments. Because the arguments come in as a tuple,\nwe can process them in a simple for loop. Just for fun, we’ll code a union function that\nalso accepts an arbitrary number of arguments to collect items that appear in any of\nthe operands:\ndef intersect(*args):\nres = []\nfor x in args[0]:\nfor other in args[1:]:\nif x not in other: break\nelse:\nres.append(x)\nreturn res\ndef union(*args):\nres = []\nfor seq in args:\nfor x in seq:\nif not x in res:\nres.append(x)\nreturn res\n\n456 | Chapter 18: Arguments",
    "456 | Chapter 18: Arguments\n\n# Scan first sequence\n# For all other args\n# Item in each one?\n# No: break out of loop\n# Yes: add items to end\n\n# For all args\n# For all nodes\n# Add new items to result\n\n\fBecause these are tools worth reusing (and they’re too big to retype interactively), we’ll\nstore the functions in a module file called inter2.py (if you’ve forgotten how modules\nand imports work, see the introduction in Chapter 3, or stay tuned for in-depth coverage\nin Part V). In both functions, the arguments passed in at the call come in as the args\ntuple. As in the original intersect, both work on any kind of sequence. Here, they are\nprocessing strings, mixed types, and more than two sequences:\n% python\n>>> from inter2 import intersect, union\n>>> s1, s2, s3 = \"SPAM\", \"SCAM\", \"SLAM\"\n>>> intersect(s1, s2), union(s1, s2)\n(['S', 'A', 'M'], ['S', 'P', 'A', 'M', 'C'])\n\n# Two operands\n\n>>> intersect([1,2,3], (1,4))\n[1]\n\n# Mixed types\n\n>>> intersect(s1, s2, s3)\n['S', 'A', 'M']",
    "# Two operands\n\n>>> intersect([1,2,3], (1,4))\n[1]\n\n# Mixed types\n\n>>> intersect(s1, s2, s3)\n['S', 'A', 'M']\n\n# Three operands\n\n>>> union(s1, s2, s3)\n['S', 'P', 'A', 'M', 'C', 'L']\n\nI should note that because Python now has a set object type (described\nin Chapter 5), none of the set-processing examples in this book are\nstrictly required anymore; they are included only as demonstrations of\ncoding techniques. Because it’s constantly improving, Python has an\nuncanny way of conspiring to make my book examples obsolete over\ntime!",
    "I should note that because Python now has a set object type (described\nin Chapter 5), none of the set-processing examples in this book are\nstrictly required anymore; they are included only as demonstrations of\ncoding techniques. Because it’s constantly improving, Python has an\nuncanny way of conspiring to make my book examples obsolete over\ntime!\n\nEmulating the Python 3.0 print Function\nTo round out the chapter, let’s look at one last example of argument matching at work.\nThe code you’ll see here is intended for use in Python 2.6 or earlier (it works in 3.0,\ntoo, but is pointless there): it uses both the *args arbitrary positional tuple and the\n**args arbitrary keyword-arguments dictionary to simulate most of what the Python\n3.0 print function does.\nAs we learned in Chapter 11, this isn’t actually required, because 2.6 programmers can\nalways enable the 3.0 print function with an import of this form:\nfrom __future__ import print_function",
    "To demonstrate argument matching in general, though, the following file, print30.py,\ndoes the same job in a small amount of reusable code:\n\nEmulating the Python 3.0 print Function | 457\n\n\f\"\"\"\nEmulate most of the 3.0 print function for use in 2.X\ncall signature: print30(*args, sep=' ', end='\\n', file=None)\n\"\"\"\nimport sys\ndef print30(*args, **kargs):\nsep = kargs.get('sep', ' ')\n# Keyword arg defaults\nend = kargs.get('end', '\\n')\nfile = kargs.get('file', sys.stdout)\noutput = ''\nfirst = True\nfor arg in args:\noutput += ('' if first else sep) + str(arg)\nfirst = False\nfile.write(output + end)",
    "To test it, import this into another file or the interactive prompt, and use it like the 3.0\nprint function. Here is a test script, testprint30.py (notice that the function must be\ncalled “print30”, because “print” is a reserved word in 2.6):\nfrom print30 import print30\nprint30(1, 2, 3)\nprint30(1, 2, 3, sep='')\nprint30(1, 2, 3, sep='...')\nprint30(1, [2], (3,), sep='...')\nprint30(4, 5, 6, sep='', end='')\nprint30(7, 8, 9)\nprint30()\n\n# Suppress separator\n# Various object types\n# Suppress newline\n# Add newline (or blank line)\n\nimport sys\nprint30(1, 2, 3, sep='??', end='.\\n', file=sys.stderr)\n\n# Redirect to file\n\nWhen run under 2.6, we get the same results as 3.0’s print function:\nC:\\misc> c:\\python26\\python testprint30.py\n1 2 3\n123\n1...2...3\n1...[2]...(3,)\n4567 8 9\n1??2??3.",
    "# Suppress separator\n# Various object types\n# Suppress newline\n# Add newline (or blank line)\n\nimport sys\nprint30(1, 2, 3, sep='??', end='.\\n', file=sys.stderr)\n\n# Redirect to file\n\nWhen run under 2.6, we get the same results as 3.0’s print function:\nC:\\misc> c:\\python26\\python testprint30.py\n1 2 3\n123\n1...2...3\n1...[2]...(3,)\n4567 8 9\n1??2??3.\n\nAlthough pointless in 3.0, the results are the same when run there. As usual, the generality of Python’s design allows us to prototype or develop concepts in the Python\nlanguage itself. In this case, argument-matching tools are as flexible in Python code as\nthey are in Python’s internal implementation.\n\n458 | Chapter 18: Arguments",
    "Although pointless in 3.0, the results are the same when run there. As usual, the generality of Python’s design allows us to prototype or develop concepts in the Python\nlanguage itself. In this case, argument-matching tools are as flexible in Python code as\nthey are in Python’s internal implementation.\n\n458 | Chapter 18: Arguments\n\n\fUsing Keyword-Only Arguments\nIt’s interesting to notice that this example could be coded with Python 3.0\nkeyword-only arguments, described earlier in this chapter, to automatically validate\nconfiguration arguments:\n# Use keyword-only args\ndef print30(*args, sep=' ', end='\\n', file=sys.stdout):\noutput = ''\nfirst = True\nfor arg in args:\noutput += ('' if first else sep) + str(arg)\nfirst = False\nfile.write(output + end)",
    "This version works the same as the original, and it’s a prime example of how keywordonly arguments come in handy. The original version assumes that all positional\narguments are to be printed, and all keywords are for options only. That’s almost sufficient, but any extra keyword arguments are silently ignored. A call like the following,\nfor instance, will generate an exception with the keyword-only form:\n>>> print30(99, name='bob')\nTypeError: print30() got an unexpected keyword argument 'name'",
    "but will silently ignore the name argument in the original version. To detect superfluous\nkeywords manually, we could use dict.pop() to delete fetched entries, and check if the\ndictionary is not empty. Here is an equivalent to the keyword-only version:\n# Use keyword args deletion with defaults\ndef print30(*args, **kargs):\nsep = kargs.pop('sep', ' ')\nend = kargs.pop('end', '\\n')\nfile = kargs.pop('file', sys.stdout)\nif kargs: raise TypeError('extra keywords: %s' % kargs)\noutput = ''\nfirst = True\nfor arg in args:\noutput += ('' if first else sep) + str(arg)\nfirst = False\nfile.write(output + end)\n\nThis works as before, but it now catches extraneous keyword arguments, too:\n>>> print30(99, name='bob')\nTypeError: extra keywords: {'name': 'bob'}\n\nEmulating the Python 3.0 print Function | 459",
    "This works as before, but it now catches extraneous keyword arguments, too:\n>>> print30(99, name='bob')\nTypeError: extra keywords: {'name': 'bob'}\n\nEmulating the Python 3.0 print Function | 459\n\n\fThis version of the function runs under Python 2.6, but it requires four more lines of\ncode than the keyword-only version. Unfortunately, the extra code is required in this\ncase—the keyword-only version only works on 3.0, which negates most of the reason\nthat I wrote this example in the first place (a 3.0 emulator that only works on 3.0 isn’t\nincredibly useful!). In programs written to run on 3.0, though, keyword-only arguments\ncan simplify a specific category of functions that accept both arguments and options.\nFor another example of 3.0 keyword-only arguments, be sure to see the upcoming\niteration timing case study in Chapter 20.",
    "Why You Will Care: Keyword Arguments\nAs you can probably tell, advanced argument-matching modes can be complex. They\nare also entirely optional; you can get by with just simple positional matching, and it’s\nprobably a good idea to do so when you’re starting out. However, because some Python\ntools make use of them, some general knowledge of these modes is important.\nFor example, keyword arguments play an important role in tkinter, the de facto standard GUI API for Python (this module’s name is Tkinter in Python 2.6). We touch on\ntkinter only briefly at various points in this book, but in terms of its call patterns,\nkeyword arguments set configuration options when GUI components are built. For\ninstance, a call of the form:\nfrom tkinter import *\nwidget = Button(text=\"Press me\", command=someFunction)",
    "creates a new button and specifies its text and callback function, using the text and\ncommand keyword arguments. Since the number of configuration options for a widget\ncan be large, keyword arguments let you pick and choose which to apply. Without\nthem, you might have to either list all the possible options by position or hope for a\njudicious positional argument defaults protocol that would handle every possible option arrangement.\nMany built-in functions in Python expect us to use keywords for usage-mode options\nas well, which may or may not have defaults. As we learned in Chapter 8, for instance,\nthe sorted built-in:\nsorted(iterable, key=None, reverse=False)\n\nexpects us to pass an iterable object to be sorted, but also allows us to pass in optional\nkeyword arguments to specify a dictionary sort key and a reversal flag, which default\nto None and False, respectively. Since we normally don’t use these options, they may\nbe omitted to use defaults.",
    "expects us to pass an iterable object to be sorted, but also allows us to pass in optional\nkeyword arguments to specify a dictionary sort key and a reversal flag, which default\nto None and False, respectively. Since we normally don’t use these options, they may\nbe omitted to use defaults.\n\nChapter Summary\nIn this chapter, we studied the second of two key concepts related to functions: arguments (how objects are passed into a function). As we learned, arguments are passed\ninto a function by assignment, which means by object reference, which really means\n460 | Chapter 18: Arguments",
    "by pointer. We also studied some more advanced extensions, including default and\nkeyword arguments, tools for using arbitrarily many arguments, and keyword-only\narguments in 3.0. Finally, we saw how mutable arguments can exhibit the same behavior as other shared references to objects—unless the object is explicitly copied when\nit’s sent in, changing a passed-in mutable in a function can impact the caller.\nThe next chapter continues our look at functions by exploring some more advanced\nfunction-related ideas: function annotations, lambdas, and functional tools such as\nmap and filter. Many of these concepts stem from the fact that functions are normal\nobjects in Python, and so support some advanced and very flexible processing modes.\nBefore diving into those topics, however, take this chapter’s quiz to review the argument\nideas we’ve studied here.",
    "Test Your Knowledge: Quiz\n1. What is the output of the following code, and why?\n>>> def func(a, b=4, c=5):\nprint(a, b, c)\n...\n...\n>>> func(1, 2)\n\n2. What is the output of this code, and why?\n>>> def func(a, b, c=5):\n...\nprint(a, b, c)\n...\n>>> func(1, c=3, b=2)\n\n3. How about this code: what is its output, and why?\n>>> def func(a, *pargs):\n...\nprint(a, pargs)\n...\n>>> func(1, 2, 3)\n\n4. What does this code print, and why?\n>>> def func(a, **kargs):\n...\nprint(a, kargs)\n...\n>>> func(a=1, c=3, b=2)\n\n5. One last time: what is the output of this code, and why?\n>>> def func(a, b, c=3, d=4): print(a, b, c, d)\n...\n>>> func(1, *(5,6))\n\n6. Name three or more ways that functions can communicate results to a caller.\n\nTest Your Knowledge: Quiz | 461",
    "Test Your Knowledge: Answers\n1. The output here is '1 2 5', because 1 and 2 are passed to a and b by position, and\nc is omitted in the call and defaults to 5.\n2. The output this time is '1 2 3': 1 is passed to a by position, and b and c are passed\n2 and 3 by name (the left-to-right order doesn’t matter when keyword arguments\nare used like this).\n3. This code prints '1 (2, 3)', because 1 is passed to a and the *pargs collects the\nremaining positional arguments into a new tuple object. We can step through the\nextra positional arguments tuple with any iteration tool (e.g., for arg in\npargs: ...).\n4. This time the code prints '1, {'c': 3, 'b': 2}', because 1 is passed to a by name\nand the **kargs collects the remaining keyword arguments into a dictionary. We\ncould step through the extra keyword arguments dictionary by key with any iteration tool (e.g., for key in kargs: ...).\n5. The output here is '1 5 6 4': 1 matches a by position, 5 and 6 match b and c by",
    "pargs: ...).\n4. This time the code prints '1, {'c': 3, 'b': 2}', because 1 is passed to a by name\nand the **kargs collects the remaining keyword arguments into a dictionary. We\ncould step through the extra keyword arguments dictionary by key with any iteration tool (e.g., for key in kargs: ...).\n5. The output here is '1 5 6 4': 1 matches a by position, 5 and 6 match b and c by\n*name positionals (6 overrides c’s default), and d defaults to 4 because it was not\npassed a value.\n6. Functions can send back results with return statements, by changing passed-in\nmutable arguments, and by setting global variables. Globals are generally frowned\nupon (except for very special cases, like multithreaded programs) because they can\nmake code more difficult to understand and use. return statements are usually\nbest, but changing mutables is fine, if expected. Functions may also communicate\nwith system devices such as files and sockets, but these are beyond our scope here.",
    "462 | Chapter 18: Arguments\n\n\fCHAPTER 19\n\nAdvanced Function Topics\n\nThis chapter introduces a collection of more advanced function-related topics: recursive functions, function attributes and annotations, the lambda expression, and functional programming tools such as map and filter. These are all somewhat advanced\ntools that, depending on your job description, you may not encounter on a regular\nbasis. Because of their roles in some domains, though, a basic understanding can be\nuseful; lambdas, for instance, are regular customers in GUIs.\nPart of the art of using functions lies in the interfaces between them, so we will also\nexplore some general function design principles here. The next chapter continues this\nadvanced theme with an exploration of generator functions and expressions and a revival of list comprehensions in the context of the functional tools we will study here.",
    "Function Design Concepts\nNow that we’ve had a chance to study function basics in Python, let’s begin this chapter\nwith a few words of context. When you start using functions in earnest, you’re faced\nwith choices about how to glue components together—for instance, how to decompose\na task into purposeful functions (known as cohesion), how your functions should communicate (called coupling), and so on. You also need to take into account concepts such\nas the size of your functions, because they directly impact code usability. Some of this\nfalls into the category of structured analysis and design, but it applies to Python code\nas to any other.\nWe introduced some ideas related to function and module coupling in the Chapter 17 when studying scopes, but here is a review of a few general guidelines for function\nbeginners:\n• Coupling: use arguments for inputs and return for outputs. Generally, you\nshould strive to make a function independent of things outside of it. Arguments",
    "as to any other.\nWe introduced some ideas related to function and module coupling in the Chapter 17 when studying scopes, but here is a review of a few general guidelines for function\nbeginners:\n• Coupling: use arguments for inputs and return for outputs. Generally, you\nshould strive to make a function independent of things outside of it. Arguments\nand return statements are often the best ways to isolate external dependencies to\na small number of well-known places in your code.",
    "463",
    "• Coupling: use global variables only when truly necessary. Global variables\n(i.e., names in the enclosing module) are usually a poor way for functions to communicate. They can create dependencies and timing issues that make programs\ndifficult to debug and change.\n• Coupling: don’t change mutable arguments unless the caller expects it.\nFunctions can change parts of passed-in mutable objects, but (as with global\nvariables) this creates lots of coupling between the caller and callee, which can\nmake a function too specific and brittle.\n• Cohesion: each function should have a single, unified purpose. When designed well, each of your functions should do one thing—something you can summarize in a simple declarative sentence. If that sentence is very broad (e.g., “this\nfunction implements my whole program”), or contains lots of conjunctions (e.g.,\n“this function gives employee raises and submits a pizza order”), you might want",
    "• Cohesion: each function should have a single, unified purpose. When designed well, each of your functions should do one thing—something you can summarize in a simple declarative sentence. If that sentence is very broad (e.g., “this\nfunction implements my whole program”), or contains lots of conjunctions (e.g.,\n“this function gives employee raises and submits a pizza order”), you might want\nto think about splitting it into separate and simpler functions. Otherwise, there is\nno way to reuse the code behind the steps mixed together in the function.\n• Size: each function should be relatively small. This naturally follows from the\npreceding goal, but if your functions start spanning multiple pages on your display,\nit’s probably time to split them. Especially given that Python code is so concise to\nbegin with, a long or deeply nested function is often a symptom of design problems.\nKeep it simple, and keep it short.",
    "• Size: each function should be relatively small. This naturally follows from the\npreceding goal, but if your functions start spanning multiple pages on your display,\nit’s probably time to split them. Especially given that Python code is so concise to\nbegin with, a long or deeply nested function is often a symptom of design problems.\nKeep it simple, and keep it short.\n• Coupling: avoid changing variables in another module file directly. We introduced this concept in Chapter 17, and we’ll revisit it in the next part of the book\nwhen we focus on modules. For reference, though, remember that changing variables across file boundaries sets up a coupling between modules similar to how\nglobal variables couple functions—the modules become difficult to understand\nand reuse. Use accessor functions whenever possible, instead of direct assignment\nstatements.\nFigure 19-1 summarizes the ways functions can talk to the outside world; inputs may",
    "global variables couple functions—the modules become difficult to understand\nand reuse. Use accessor functions whenever possible, instead of direct assignment\nstatements.\nFigure 19-1 summarizes the ways functions can talk to the outside world; inputs may\ncome from items on the left side, and results may be sent out in any of the forms on the\nright. Good function designers prefer to use only arguments for inputs and return\nstatements for outputs, whenever possible.\nOf course, there are plenty of exceptions to the preceding design rules, including some\nrelated to Python’s OOP support. As you’ll see in Part VI, Python classes depend on\nchanging a passed-in mutable object—class functions set attributes of an automatically\npassed-in argument called self to change per-object state information (e.g.,\nself.name='bob'). Moreover, if classes are not used, global variables are often the most\nstraightforward way for functions in modules to retain state between calls. Side effects",
    "changing a passed-in mutable object—class functions set attributes of an automatically\npassed-in argument called self to change per-object state information (e.g.,\nself.name='bob'). Moreover, if classes are not used, global variables are often the most\nstraightforward way for functions in modules to retain state between calls. Side effects\nare dangerous only if they’re unexpected.\nIn general though, you should strive to minimize external dependencies in functions\nand other program components. The more self-contained a function is, the easier it will\nbe to understand, reuse, and modify.\n464 | Chapter 19: Advanced Function Topics",
    "Figure 19-1. Function execution environment. Functions may obtain input and produce output in a\nvariety of ways, though functions are usually easier to understand and maintain if you use arguments\nfor input and return statements and anticipated mutable argument changes for output. In Python 3,\noutputs may also take the form of declared nonlocal names that exist in an enclosing function scope.\n\nRecursive Functions\nWhile discussing scope rules near the start of Chapter 17, we briefly noted that Python\nsupports recursive functions—functions that call themselves either directly or indirectly\nin order to loop. Recursion is a somewhat advanced topic, and it’s relatively rare to see\nin Python. Still, it’s a useful technique to know about, as it allows programs to traverse\nstructures that have arbitrary and unpredictable shapes. Recursion is even an alternative\nfor simple loops and iterations, though not necessarily the simplest or most efficient\none.",
    "Summation with Recursion\nLet’s look at some examples. To sum a list (or other sequence) of numbers, we can\neither use the built-in sum function or write a more custom version of our own. Here’s\nwhat a custom summing function might look like when coded with recursion:\n>>> def mysum(L):\n...\nif not L:\n...\nreturn 0\n...\nelse:\n...\nreturn L[0] + mysum(L[1:])\n\n# Call myself\n\n>>> mysum([1, 2, 3, 4, 5])\n15\n\nAt each level, this function calls itself recursively to compute the sum of the rest of the\nlist, which is later added to the item at the front. The recursive loop ends and zero is\nreturned when the list becomes empty. When using recursion like this, each open level\n\nRecursive Functions | 465",
    "# Call myself\n\n>>> mysum([1, 2, 3, 4, 5])\n15\n\nAt each level, this function calls itself recursively to compute the sum of the rest of the\nlist, which is later added to the item at the front. The recursive loop ends and zero is\nreturned when the list becomes empty. When using recursion like this, each open level\n\nRecursive Functions | 465\n\n\fof call to the function has its own copy of the function’s local scope on the runtime call\nstack—here, that means L is different in each level.\nIf this is difficult to understand (and it often is for new programmers), try adding a\nprint of L to the function and run it again, to trace the current list at each call level:\n>>> def mysum(L):\n...\nprint(L)\n...\nif not L:\n...\nreturn 0\n...\nelse:\n...\nreturn L[0] + mysum(L[1:])\n...\n>>> mysum([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n[2, 3, 4, 5]\n[3, 4, 5]\n[4, 5]\n[5]\n[]\n15\n\n# Trace recursive levels\n# L shorter at each level",
    "# Trace recursive levels\n# L shorter at each level\n\nAs you can see, the list to be summed grows smaller at each recursive level, until it\nbecomes empty—the termination of the recursive loop. The sum is computed as the\nrecursive calls unwind.\n\nCoding Alternatives\nInterestingly, we can also use Python’s if/else ternary expression (described in Chapter 12) to save some code real-estate here. We can also generalize for any summable\ntype (which is easier if we assume at least one item in the input, as we did in Chapter 18’s minimum value example) and use Python 3.0’s extended sequence assignment\nto make the first/rest unpacking simpler (as covered in Chapter 11):\ndef mysum(L):\nreturn 0 if not L else L[0] + mysum(L[1:])\n\n# Use ternary expression\n\ndef mysum(L):\nreturn L[0] if len(L) == 1 else L[0] + mysum(L[1:]) # Any type, assume one\ndef mysum(L):\nfirst, *rest = L\nreturn first if not rest else first + mysum(rest)\n\n# Use 3.0 ext seq assign",
    "# Use ternary expression\n\ndef mysum(L):\nreturn L[0] if len(L) == 1 else L[0] + mysum(L[1:]) # Any type, assume one\ndef mysum(L):\nfirst, *rest = L\nreturn first if not rest else first + mysum(rest)\n\n# Use 3.0 ext seq assign\n\nThe latter two of these fail for empty lists but allow for sequences of any object type\nthat supports +, not just numbers:\n>>> mysum([1])\n1\n>>> mysum([1, 2, 3, 4, 5])\n15\n>>> mysum(('s', 'p', 'a', 'm'))\n'spam'\n\n466 | Chapter 19: Advanced Function Topics\n\n# mysum([]) fails in last 2\n\n# But various types now work\n\n\f>>> mysum(['spam', 'ham', 'eggs'])\n'spamhameggs'",
    "# But various types now work\n\n\f>>> mysum(['spam', 'ham', 'eggs'])\n'spamhameggs'\n\nIf you study these three variants, you’ll find that the latter two also work on a single\nstring argument (e.g., mysum ('spam')), because strings are sequences of one-character\nstrings; the third variant works on arbitary iterables, including open input files, but the\nothers do not because they index; and the function header def mysum(first, * rest),\nalthough similar to the third variant, wouldn’t work at all, because it expects individual\narguments, not a single iterable.\nKeep in mind that recursion can be direct, as in the examples so far, or indirect, as in\nthe following (a function that calls another function, which calls back to its caller). The\nnet effect is the same, though there are two function calls at each level instead of one:\n>>> def mysum(L):\n...\nif not L: return 0\n...\nreturn nonempty(L)\n...\n>>> def nonempty(L):\n...\nreturn L[0] + mysum(L[1:])\n...\n>>> mysum([1.1, 2.2, 3.3, 4.4])\n11.0",
    "# Call a function that calls me\n# Indirectly recursive\n\nLoop Statements Versus Recursion\nThough recursion works for summing in the prior sections’ examples, it’s probably\noverkill in this context. In fact, recursion is not used nearly as often in Python as in\nmore esoteric languages like Prolog or Lisp, because Python emphasizes simpler procedural statements like loops, which are usually more natural. The while, for example,\noften makes things a bit more concrete, and it doesn’t require that a function be defined\nto allow recursive calls:\n>>> L = [1, 2, 3, 4, 5]\n>>> sum = 0\n>>> while L:\n...\nsum += L[0]\n...\nL = L[1:]\n...\n>>> sum\n15\n\nBetter yet, for loops iterate for us automatically, making recursion largely extraneous\nin most cases (and, in all likelihood, less efficient in terms of memory space and execution time):\n>>> L = [1, 2, 3, 4, 5]\n>>> sum = 0\n>>> for x in L: sum += x\n...\n>>> sum\n15\n\nRecursive Functions | 467",
    "Better yet, for loops iterate for us automatically, making recursion largely extraneous\nin most cases (and, in all likelihood, less efficient in terms of memory space and execution time):\n>>> L = [1, 2, 3, 4, 5]\n>>> sum = 0\n>>> for x in L: sum += x\n...\n>>> sum\n15\n\nRecursive Functions | 467\n\n\fWith looping statements, we don’t require a fresh copy of a local scope on the call stack\nfor each iteration, and we avoid the speed costs associated with function calls in general.\n(Stay tuned for Chapter 20’s timer case study for ways to compare the execution times\nof alternatives like these.)\n\nHandling Arbitrary Structures\nOn the other hand, recursion (or equivalent explicit stack-based algorithms, which\nwe’ll finesse here) can be required to traverse arbitrarily shaped structures. As a simple\nexample of recursion’s role in this context, consider the task of computing the sum of\nall the numbers in a nested sublists structure like this:\n[1, [2, [3, 4], 5], 6, [7, 8]]",
    "Handling Arbitrary Structures\nOn the other hand, recursion (or equivalent explicit stack-based algorithms, which\nwe’ll finesse here) can be required to traverse arbitrarily shaped structures. As a simple\nexample of recursion’s role in this context, consider the task of computing the sum of\nall the numbers in a nested sublists structure like this:\n[1, [2, [3, 4], 5], 6, [7, 8]]\n\n# Arbitrarily nested sublists\n\nSimple looping statements won’t work here because this not a linear iteration. Nested\nlooping statements do not suffice either, because the sublists may be nested to arbitrary\ndepth and in an arbitrary shape. Instead, the following code accommodates such general nesting by using recursion to visit sublists along the way:\ndef sumtree(L):\ntot = 0\nfor x in L:\nif not isinstance(x, list):\ntot += x\nelse:\ntot += sumtree(x)\nreturn tot\nL = [1, [2, [3, 4], 5], 6, [7, 8]]\nprint(sumtree(L))",
    "# For each item at this level\n# Add numbers directly\n# Recur for sublists\n# Arbitrary nesting\n# Prints 36\n\n# Pathological cases\nprint(sumtree([1, [2, [3, [4, [5]]]]]))\n\n# Prints 15 (right-heavy)\n\nprint(sumtree([[[[[1], 2], 3], 4], 5]))\n\n# Prints 15 (left-heavy)\n\nTrace through the test cases at the bottom of this script to see how recursion traverses\ntheir nested lists. Although this example is artificial, it is representative of a larger class\nof programs; inheritance trees and module import chains, for example, can exhibit\nsimilarly general structures. In fact, we will use recursion again in such roles in more\nrealistic examples later in this book:\n• In Chapter 24’s reloadall.py, to traverse import chains\n• In Chapter 28’s classtree.py, to traverse class inheritance trees\n• In Chapter 30’s lister.py, to traverse class inheritance trees again\n\n468 | Chapter 19: Advanced Function Topics",
    "468 | Chapter 19: Advanced Function Topics\n\n\fAlthough you should generally prefer looping statements to recursion for linear iterations on the grounds of simplicity and efficiency, we’ll find that recursion is essential\nin scenarios like those in these later examples.\nMoreover, you sometimes need to be aware of the potential of unintended recursion in\nyour programs. As you’ll also see later in the book, some operator overloading methods\nin classes such as __setattr__ and __getattribute__ have the potential to recursively\nloop if used incorrectly. Recursion is a powerful tool, but it tends to be best when\nexpected!",
    "Function Objects: Attributes and Annotations\nPython functions are more flexible than you might think. As we’ve seen in this part of\nthe book, functions in Python are much more than code-generation specifications for\na compiler—Python functions are full-blown objects, stored in pieces of memory all\ntheir own. As such, they can be freely passed around a program and called indirectly.\nThey also support operations that have little to do with calls at all—attribute storage\nand annotation.",
    "Indirect Function Calls\nBecause Python functions are objects, you can write programs that process them generically. Function objects may be assigned to other names, passed to other functions,\nembedded in data structures, returned from one function to another, and more, as if\nthey were simple numbers or strings. Function objects also happen to support a special\noperation: they can be called by listing arguments in parentheses after a function expression. Still, functions belong to the same general category as other objects.\nWe’ve seen some of these generic use cases for functions in earlier examples, but a quick\nreview helps to underscore the object model. For example, there’s really nothing special\nabout the name used in a def statement: it’s just a variable assigned in the current scope,\nas if it had appeared on the left of an = sign. After a def runs, the function name is simply\na reference to an object—you can reassign that object to other names freely and call it",
    "review helps to underscore the object model. For example, there’s really nothing special\nabout the name used in a def statement: it’s just a variable assigned in the current scope,\nas if it had appeared on the left of an = sign. After a def runs, the function name is simply\na reference to an object—you can reassign that object to other names freely and call it\nthrough any reference:\n>>> def echo(message):\n...\nprint(message)\n...\n>>> echo('Direct call')\nDirect call",
    "# Name echo assigned to function object\n\n>>> x = echo\n>>> x('Indirect call!')\nIndirect call!\n\n# Now x references the function too\n# Call object through name by adding ()\n\n# Call object through original name\n\nFunction Objects: Attributes and Annotations | 469\n\n\fBecause arguments are passed by assigning objects, it’s just as easy to pass functions to\nother functions as arguments. The callee may then call the passed-in function just by\nadding arguments in parentheses:\n>>> def indirect(func, arg):\n...\nfunc(arg)\n...\n>>> indirect(echo, 'Argument call!')\nArgument call!\n\n# Call the passed-in object by adding ()\n# Pass the function to another function",
    "Because arguments are passed by assigning objects, it’s just as easy to pass functions to\nother functions as arguments. The callee may then call the passed-in function just by\nadding arguments in parentheses:\n>>> def indirect(func, arg):\n...\nfunc(arg)\n...\n>>> indirect(echo, 'Argument call!')\nArgument call!\n\n# Call the passed-in object by adding ()\n# Pass the function to another function\n\nYou can even stuff function objects into data structures, as though they were integers\nor strings. The following, for example, embeds the function twice in a list of tuples, as\na sort of actions table. Because Python compound types like these can contain any sort\nof object, there’s no special case here, either:\n>>> schedule = [ (echo, 'Spam!'), (echo, 'Ham!') ]\n>>> for (func, arg) in schedule:\n...\nfunc(arg)\n# Call functions embedded in containers\n...\nSpam!\nHam!",
    "This code simply steps through the schedule list, calling the echo function with one\nargument each time through (notice the tuple-unpacking assignment in the for loop\nheader, introduced in Chapter 13). As we saw in Chapter 17’s examples, functions can\nalso be created and returned for use elsewhere:\n>>> def make(label):\n# Make a function but don't call it\n...\ndef echo(message):\n...\nprint(label + ':' + message)\n...\nreturn echo\n...\n>>> F = make('Spam')\n# Label in enclosing scope is retained\n>>> F('Ham!')\n# Call the function that make returned\nSpam:Ham!\n>>> F('Eggs!')\nSpam:Eggs!\n\nPython’s universal object model and lack of type declarations make for an incredibly\nflexible programming language.",
    "Python’s universal object model and lack of type declarations make for an incredibly\nflexible programming language.\n\nFunction Introspection\nBecause they are objects, we can also process functions with normal object tools. In\nfact, functions are more flexible than you might expect. For instance, once we make a\nfunction, we can call it as usual:\n>>> def func(a):\n...\nb = 'spam'\n...\nreturn b * a\n...\n>>> func(8)\n'spamspamspamspamspamspamspamspam'\n\n470 | Chapter 19: Advanced Function Topics\n\n\fBut the call expression is just one operation defined to work on function objects. We\ncan also inspect their attributes generically (the following is run in Python 3.0, but 2.6\nresults are similar):\n>>> func.__name__\n'func'\n>>> dir(func)\n['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n...more omitted...\n'__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']",
    "Introspection tools allow us to explore implementation details too—functions have\nattached code objects, for example, which provide details on aspects such as the functions’ local variables and arguments:\n>>> func.__code__\n<code object func at 0x0257C9B0, file \"<stdin>\", line 1>\n>>> dir(func.__code__)\n['__class__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__',\n...more omitted...\n'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename',\n'co_firstlineno', 'co_flags', 'co_freevars', 'co_kwonlyargcount', 'co_lnotab',\n'co_name', 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames']\n>>> func.__code__.co_varnames\n('a', 'b')\n>>> func.__code__.co_argcount\n1\n\nTool writers can make use of such information to manage functions (in fact, we will\ntoo in Chapter 38, to implement validation of function arguments in decorators).",
    "Tool writers can make use of such information to manage functions (in fact, we will\ntoo in Chapter 38, to implement validation of function arguments in decorators).\n\nFunction Attributes\nFunction objects are not limited to the system-defined attributes listed in the prior\nsection, though. As we learned in Chapter 17, it’s possible to attach arbitrary userdefined attributes to them as well:\n>>> func\n<function func at 0x0257C738>\n>>> func.count = 0\n>>> func.count += 1\n>>> func.count\n1\n>>> func.handles = 'Button-Press'\n>>> func.handles\n'Button-Press'\n>>> dir(func)\n['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n...more omitted...\n__str__', '__subclasshook__', 'count', 'handles']\n\nFunction Objects: Attributes and Annotations | 471",
    "Function Objects: Attributes and Annotations | 471\n\n\fAs we saw in that chapter, such attributes can be used to attach state information to\nfunction objects directly, instead of using other techniques such as globals, nonlocals,\nand classes. Unlike nonlocals, such attributes are accessible anywhere the function itself\nis. In a sense, this is also a way to emulate “static locals” in other languages—variables\nwhose names are local to a function, but whose values are retained after a function\nexits. Attributes are related to objects instead of scopes, but the net effect is similar.",
    "Function Annotations in 3.0\nIn Python 3.0 (but not 2.6), it’s also possible to attach annotation information—\narbitrary user-defined data about a function’s arguments and result—to a function\nobject. Python provides special syntax for specifying annotations, but it doesn’t do\nanything with them itself; annotations are completely optional, and when present are\nsimply attached to the function object’s __annotations__ attribute for use by other\ntools.\nWe met Python 3.0’s keyword-only arguments in the prior chapter; annotations generalize function header syntax further. Consider the following nonannotated function,\nwhich is coded with three arguments and returns a result:\n>>> def func(a, b, c):\n...\nreturn a + b + c\n...\n>>> func(1, 2, 3)\n6",
    "Syntactically, function annotations are coded in def header lines, as arbitrary expressions associated with arguments and return values. For arguments, they appear after a\ncolon immediately following the argument’s name; for return values, they are written\nafter a -> following the arguments list. This code, for example, annotates all three of\nthe prior function’s arguments, as well as its return value:\n>>> def func(a: 'spam', b: (1, 10), c: float) -> int:\n...\nreturn a + b + c\n...\n>>> func(1, 2, 3)\n6\n\nCalls to an annotated function work as usual, but when annotations are present Python\ncollects them in a dictionary and attaches it to the function object itself. Argument\nnames become keys, the return value annotation is stored under key “return” if coded,\nand the values of annotation keys are assigned to the results of the annotation\nexpressions:\n>>> func.__annotations__\n{'a': 'spam', 'c': <class 'float'>, 'b': (1, 10), 'return': <class 'int'>}",
    "Because they are just Python objects attached to a Python object, annotations are\nstraightforward to process. The following annotates just two of three arguments and\nsteps through the attached annotations generically:\n472 | Chapter 19: Advanced Function Topics\n\n\f>>> def func(a: 'spam', b, c: 99):\n...\nreturn a + b + c\n...\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'a': 'spam', 'c': 99}\n>>> for arg in func.__annotations__:\n...\nprint(arg, '=>', func.__annotations__[arg])\n...\na => spam\nc => 99",
    ">>> def func(a: 'spam', b, c: 99):\n...\nreturn a + b + c\n...\n>>> func(1, 2, 3)\n6\n>>> func.__annotations__\n{'a': 'spam', 'c': 99}\n>>> for arg in func.__annotations__:\n...\nprint(arg, '=>', func.__annotations__[arg])\n...\na => spam\nc => 99\n\nThere are two fine points to note here. First, you can still use defaults for arguments if\nyou code annotations—the annotation (and its : character) appear before the default\n(and its = character). In the following, for example, a: 'spam' = 4 means that argument\na defaults to 4 and is annotated with the string 'spam':\n>>> def func(a: 'spam' = 4, b: (1, 10) = 5, c: float = 6) -> int:\n...\nreturn a + b + c\n...\n>>> func(1, 2, 3)\n6\n>>> func()\n# 4 + 5 + 6 (all defaults)\n15\n>>> func(1, c=10)\n# 1 + 5 + 10 (keywords work normally)\n16\n>>> func.__annotations__\n{'a': 'spam', 'c': <class 'float'>, 'b': (1, 10), 'return': <class 'int'>}",
    "Second, note that the blank spaces in the prior example are all optional—you can use\nspaces between components in function headers or not, but omitting them might degrade your code’s readability to some observers:\n>>> def func(a:'spam'=4, b:(1,10)=5, c:float=6)->int:\n...\nreturn a + b + c\n...\n>>> func(1, 2)\n#1+2+6\n9\n>>> func.__annotations__\n{'a': 'spam', 'c': <class 'float'>, 'b': (1, 10), 'return': <class 'int'>}",
    "Annotations are a new feature in 3.0, and some of their potential uses remain to be\nuncovered. It’s easy to imagine annotations being used to specify constraints for argument types or values, though, and larger APIs might use this feature as a way to register\nfunction interface information. In fact, we’ll see a potential application in Chapter 38, where we’ll look at annotations as an alternative to function decorator arguments (a more general concept in which information is coded outside the function\nheader and so is not limited to a single role). Like Python itself, annotation is a tool\nwhose roles are shaped by your imagination.\n\nFunction Objects: Attributes and Annotations | 473\n\n\fFinally, note that annotations work only in def statements, not lambda expressions,\nbecause lambda’s syntax already limits the utility of the functions it defines. Coincidentally, this brings us to our next topic.",
    "Function Objects: Attributes and Annotations | 473\n\n\fFinally, note that annotations work only in def statements, not lambda expressions,\nbecause lambda’s syntax already limits the utility of the functions it defines. Coincidentally, this brings us to our next topic.\n\nAnonymous Functions: lambda\nBesides the def statement, Python also provides an expression form that generates\nfunction objects. Because of its similarity to a tool in the Lisp language, it’s called\nlambda.* Like def, this expression creates a function to be called later, but it returns the\nfunction instead of assigning it to a name. This is why lambdas are sometimes known\nas anonymous (i.e., unnamed) functions. In practice, they are often used as a way to\ninline a function definition, or to defer execution of a piece of code.",
    "lambda Basics\nThe lambda’s general form is the keyword lambda, followed by one or more arguments\n(exactly like the arguments list you enclose in parentheses in a def header), followed\nby an expression after a colon:\nlambda argument1, argument2,... argumentN :expression using arguments",
    "Function objects returned by running lambda expressions work exactly the same as\nthose created and assigned by defs, but there are a few differences that make lambdas\nuseful in specialized roles:\n• lambda is an expression, not a statement. Because of this, a lambda can appear in\nplaces a def is not allowed by Python’s syntax—inside a list literal or a function\ncall’s arguments, for example. As an expression, lambda returns a value (a new\nfunction) that can optionally be assigned a name. In contrast, the def statement\nalways assigns the new function to the name in the header, instead of returning it\nas a result.\n• lambda’s body is a single expression, not a block of statements. The lambda’s\nbody is similar to what you’d put in a def body’s return statement; you simply type\nthe result as a naked expression, instead of explicitly returning it. Because it is\nlimited to an expression, a lambda is less general than a def—you can only squeeze",
    "as a result.\n• lambda’s body is a single expression, not a block of statements. The lambda’s\nbody is similar to what you’d put in a def body’s return statement; you simply type\nthe result as a naked expression, instead of explicitly returning it. Because it is\nlimited to an expression, a lambda is less general than a def—you can only squeeze\nso much logic into a lambda body without using statements such as if. This is by\ndesign, to limit program nesting: lambda is designed for coding simple functions,\nand def handles larger tasks.",
    "* The lambda tends to intimidate people more than it should. This reaction seems to stem from the name\n“lambda” itself—a name that comes from the Lisp language, which got it from lambda calculus, which is a\nform of symbolic logic. In Python, though, it’s really just a keyword that introduces the expression\nsyntactically. Obscure mathematical heritage aside, lambda is simpler to use than you may think.\n\n474 | Chapter 19: Advanced Function Topics\n\n\fApart from those distinctions, defs and lambdas do the same sort of work. For instance,\nwe’ve seen how to make a function with a def statement:\n>>> def func(x, y, z): return x + y + z\n...\n>>> func(2, 3, 4)\n9\n\nBut you can achieve the same effect with a lambda expression by explicitly assigning its\nresult to a name through which you can later call the function:\n>>> f = lambda x, y, z: x + y + z\n>>> f(2, 3, 4)\n9",
    "But you can achieve the same effect with a lambda expression by explicitly assigning its\nresult to a name through which you can later call the function:\n>>> f = lambda x, y, z: x + y + z\n>>> f(2, 3, 4)\n9\n\nHere, f is assigned the function object the lambda expression creates; this is how def\nworks, too, but its assignment is automatic.\nDefaults work on lambda arguments, just like in a def:\n>>> x = (lambda a=\"fee\", b=\"fie\", c=\"foe\": a + b + c)\n>>> x(\"wee\")\n'weefiefoe'\n\nThe code in a lambda body also follows the same scope lookup rules as code inside a\ndef. lambda expressions introduce a local scope much like a nested def, which automatically sees names in enclosing functions, the module, and the built-in scope (via the\nLEGB rule):\n>>> def knights():\n...\ntitle = 'Sir'\n...\naction = (lambda x: title + ' ' + x)\n...\nreturn action\n...\n>>> act = knights()\n>>> act('robin')\n'Sir robin'\n\n# Title in enclosing def\n# Return a function",
    "# Title in enclosing def\n# Return a function\n\nIn this example, prior to Release 2.2, the value for the name title would typically have\nbeen passed in as a default argument value instead; flip back to the scopes coverage in\nChapter 17 if you’ve forgotten why.\n\nWhy Use lambda?\nGenerally speaking, lambdas come in handy as a sort of function shorthand that allows\nyou to embed a function’s definition within the code that uses it. They are entirely\noptional (you can always use defs instead), but they tend to be simpler coding constructs in scenarios where you just need to embed small bits of executable code.\nFor instance, we’ll see later that callback handlers are frequently coded as inline\nlambda expressions embedded directly in a registration call’s arguments list, instead of\nbeing defined with a def elsewhere in a file and referenced by name (see the sidebar\n“Why You Will Care: Callbacks” on page 479 for an example).\nAnonymous Functions: lambda | 475",
    "lambdas are also commonly used to code jump tables, which are lists or dictionaries of\nactions to be performed on demand. For example:\n# Inline function definition\n\nL = [lambda x: x ** 2,\nlambda x: x ** 3,\nlambda x: x ** 4]\n\n# A list of 3 callable functions\n\nfor f in L:\nprint(f(2))\n\n# Prints 4, 8, 16\n\nprint(L[0](3))\n\n# Prints 9\n\nThe lambda expression is most useful as a shorthand for def, when you need to stuff\nsmall pieces of executable code into places where statements are illegal syntactically.\nThis code snippet, for example, builds up a list of three functions by embedding\nlambda expressions inside a list literal; a def won’t work inside a list literal like this\nbecause it is a statement, not an expression. The equivalent def coding would require\ntemporary function names and function definitions outside the context of intended use:\ndef f1(x): return x ** 2\ndef f2(x): return x ** 3\ndef f3(x): return x ** 4\n\n# Define named functions\n\nL = [f1, f2, f3]\n\n# Reference by name",
    "# Define named functions\n\nL = [f1, f2, f3]\n\n# Reference by name\n\nfor f in L:\nprint(f(2))\n\n# Prints 4, 8, 16\n\nprint(L[0](3))\n\n# Prints 9\n\nIn fact, you can do the same sort of thing with dictionaries and other data structures\nin Python to build up more general sorts of action tables. Here’s another example to\nillustrate, at the interactive prompt:\n>>> key = 'got'\n>>> {'already': (lambda: 2 + 2),\n... 'got':\n(lambda: 2 * 4),\n... 'one':\n(lambda: 2 ** 6)}[key]()\n8",
    "In fact, you can do the same sort of thing with dictionaries and other data structures\nin Python to build up more general sorts of action tables. Here’s another example to\nillustrate, at the interactive prompt:\n>>> key = 'got'\n>>> {'already': (lambda: 2 + 2),\n... 'got':\n(lambda: 2 * 4),\n... 'one':\n(lambda: 2 ** 6)}[key]()\n8\n\nHere, when Python makes the temporary dictionary, each of the nested lambdas generates and leaves behind a function to be called later. Indexing by key fetches one of\nthose functions, and parentheses force the fetched function to be called. When coded\nthis way, a dictionary becomes a more general multiway branching tool than what I\ncould show you in Chapter 12’s coverage of if statements.\nTo make this work without lambda, you’d need to instead code three def statements\nsomewhere else in your file, outside the dictionary in which the functions are to be\nused, and reference the functions by name:\n>>> def f1(): return 2 + 2\n...\n>>> def f2(): return 2 * 4\n...",
    "476 | Chapter 19: Advanced Function Topics\n\n\f>>> def f3(): return 2 ** 6\n...\n>>> key = 'one'\n>>> {'already': f1, 'got': f2, 'one': f3}[key]()\n64\n\nThis works, too, but your defs may be arbitrarily far away in your file, even if they are\njust little bits of code. The code proximity that lambdas provide is especially useful for\nfunctions that will only be used in a single context—if the three functions here are not\nuseful anywhere else, it makes sense to embed their definitions within the dictionary\nas lambdas. Moreover, the def form requires you to make up names for these little\nfunctions that may clash with other names in this file (perhaps unlikely, but always\npossible).\nlambdas also come in handy in function-call argument lists as a way to inline temporary\n\nfunction definitions not used anywhere else in your program; we’ll see some examples\nof such other uses later in this chapter, when we study map.",
    "function definitions not used anywhere else in your program; we’ll see some examples\nof such other uses later in this chapter, when we study map.\n\nHow (Not) to Obfuscate Your Python Code\nThe fact that the body of a lambda has to be a single expression (not a series of statements) would seem to place severe limits on how much logic you can pack into a\nlambda. If you know what you’re doing, though, you can code most statements in Python as expression-based equivalents.\nFor example, if you want to print from the body of a lambda function, simply say\nsys.stdout.write(str(x)+'\\n'), instead of print(x) (recall from Chapter 11 that this\nis what print really does). Similarly, to nest logic in a lambda, you can use the if/else\nternary expression introduced in Chapter 12, or the equivalent but trickier and/or combination also described there. As you learned earlier, the following statement:\nif a:\nb\nelse:\nc",
    "can be emulated by either of these roughly equivalent expressions:\nb if a else c\n((a and b) or c)\n\nBecause expressions like these can be placed inside a lambda, they may be used to implement selection logic within a lambda function:\n>>> lower = (lambda x, y: x if x < y else y)\n>>> lower('bb', 'aa')\n'aa'\n>>> lower('aa', 'bb')\n'aa'\n\nAnonymous Functions: lambda | 477\n\n\fFurthermore, if you need to perform loops within a lambda, you can also embed things\nlike map calls and list comprehension expressions (tools we met in earlier chapters and\nwill revisit in this and the next chapter):\n>>> import sys\n>>> showall = lambda x: list(map(sys.stdout.write, x))\n\n# Use list in 3.0\n\n>>> t = showall(['spam\\n', 'toast\\n', 'eggs\\n'])\nspam\ntoast\neggs\n>>> showall = lambda x: [sys.stdout.write(line) for line in x]\n>>> t = showall(('bright\\n', 'side\\n', 'of\\n', 'life\\n'))\nbright\nside\nof\nlife",
    "# Use list in 3.0\n\n>>> t = showall(['spam\\n', 'toast\\n', 'eggs\\n'])\nspam\ntoast\neggs\n>>> showall = lambda x: [sys.stdout.write(line) for line in x]\n>>> t = showall(('bright\\n', 'side\\n', 'of\\n', 'life\\n'))\nbright\nside\nof\nlife\n\nNow that I’ve shown you these tricks, I am required by law to ask you to please only\nuse them as a last resort. Without due care, they can lead to unreadable (a.k.a. obfuscated) Python code. In general, simple is better than complex, explicit is better than\nimplicit, and full statements are better than arcane expressions. That’s why lambda is\nlimited to expressions. If you have larger logic to code, use def; lambda is for small pieces\nof inline code. On the other hand, you may find these techniques useful in moderation.",
    "Nested lambdas and Scopes\nlambdas are the main beneficiaries of nested function scope lookup (the E in the LEGB\nscope rule we studied in Chapter 17). In the following, for example, the lambda appears\ninside a def—the typical case—and so can access the value that the name x had in the\n\nenclosing function’s scope at the time that the enclosing function was called:\n>>> def action(x):\n...\nreturn (lambda y: x + y)\n...\n>>> act = action(99)\n>>> act\n<function <lambda> at 0x00A16A88>\n>>> act(2)\n101\n\n# Make and return function, remember x\n\n# Call what action returned\n\nWhat wasn’t illustrated in the prior discussion of nested function scopes is that a\nlambda also has access to the names in any enclosing lambda. This case is somewhat\nobscure, but imagine if we recoded the prior def with a lambda:\n>>> action = (lambda x: (lambda y: x + y))\n>>> act = action(99)\n>>> act(3)\n102\n\n478 | Chapter 19: Advanced Function Topics\n\n\f>>> ((lambda x: (lambda y: x + y))(99))(4)\n103",
    "478 | Chapter 19: Advanced Function Topics\n\n\f>>> ((lambda x: (lambda y: x + y))(99))(4)\n103\n\nHere, the nested lambda structure makes a function that makes a function when called.\nIn both cases, the nested lambda’s code has access to the variable x in the enclosing\nlambda. This works, but it’s fairly convoluted code; in the interest of readability, nested\nlambdas are generally best avoided.\n\nWhy You Will Care: Callbacks\nAnother very common application of lambda is to define inline callback functions for\nPython’s tkinter GUI API (this module is named Tkinter in Python 2.6). For example,\nthe following creates a button that prints a message on the console when pressed, assuming tkinter is available on your computer (it is by default on Windows and other\nOSs):\nimport sys\nfrom tkinter import Button, mainloop\n# Tkinter in 2.6\nx = Button(\ntext ='Press me',\ncommand=(lambda:sys.stdout.write('Spam\\n')))\nx.pack()\nmainloop()",
    "Here, the callback handler is registered by passing a function generated with a lambda\nto the command keyword argument. The advantage of lambda over def here is that the\ncode that handles a button press is right here, embedded in the button-creation call.\nIn effect, the lambda defers execution of the handler until the event occurs: the write\ncall happens on button presses, not when the button is created.\nBecause the nested function scope rules apply to lambdas as well, they are also easier to\nuse as callback handlers, as of Python 2.2—they automatically see names in the functions in which they are coded and no longer require passed-in defaults in most cases.\nThis is especially handy for accessing the special self instance argument that is a local\nvariable in enclosing class method functions (more on classes in Part VI):\nclass MyGui:\ndef makewidgets(self):\nButton(command=(lambda: self.onPress(\"spam\")))\ndef onPress(self, message):\n...use message...",
    "In prior releases, even self had to be passed in to a lambda with defaults.\n\nMapping Functions over Sequences: map\nOne of the more common things programs do with lists and other sequences is apply\nan operation to each item and collect the results. For instance, updating all the counters\nin a list can be done easily with a for loop:\nMapping Functions over Sequences: map | 479\n\n\f>>> counters = [1, 2, 3, 4]\n>>>\n>>> updated = []\n>>> for x in counters:\n...\nupdated.append(x + 10)\n...\n>>> updated\n[11, 12, 13, 14]\n\n# Add 10 to each item\n\nBut because this is such a common operation, Python actually provides a built-in that\ndoes most of the work for you. The map function applies a passed-in function to each\nitem in an iterable object and returns a list containing all the function call results. For\nexample:\n>>> def inc(x): return x + 10\n...\n>>> list(map(inc, counters))\n[11, 12, 13, 14]\n\n# Function to be run\n# Collect results",
    "# Function to be run\n# Collect results\n\nWe met map briefly in Chapters 13 and 14, as a way to apply a built-in function to items\nin an iterable. Here, we make better use of it by passing in a user-defined function to\nbe applied to each item in the list—map calls inc on each list item and collects all the\nreturn values into a new list. Remember that map is an iterable in Python 3.0, so a\nlist call is used to force it to produce all its results for display here; this isn’t necessary\nin 2.6.\nBecause map expects a function to be passed in, it also happens to be one of the places\nwhere lambda commonly appears:\n>>> list(map((lambda x: x + 3), counters))\n[4, 5, 6, 7]\n\n# Function expression",
    "# Function expression\n\nHere, the function adds 3 to each item in the counters list; as this little function isn’t\nneeded elsewhere, it was written inline as a lambda. Because such uses of map are equivalent to for loops, with a little extra code you can always code a general mapping utility\nyourself:\n>>> def mymap(func, seq):\n...\nres = []\n...\nfor x in seq: res.append(func(x))\n...\nreturn res\n\nAssuming the function inc is still as it was when it was shown previously, we can map\nit across a sequence with the built-in or our equivalent:\n>>> list(map(inc, [1, 2, 3]))\n[11, 12, 13]\n>>> mymap(inc, [1, 2, 3])\n[11, 12, 13]\n\n# Built-in is an iterator\n# Ours builds a list (see generators)\n\nHowever, as map is a built-in, it’s always available, always works the same way, and has\nsome performance benefits (as we’ll prove in the next chapter, it’s usually faster than\na manually coded for loop). Moreover, map can be used in more advanced ways than\n\n480 | Chapter 19: Advanced Function Topics",
    "# Built-in is an iterator\n# Ours builds a list (see generators)\n\nHowever, as map is a built-in, it’s always available, always works the same way, and has\nsome performance benefits (as we’ll prove in the next chapter, it’s usually faster than\na manually coded for loop). Moreover, map can be used in more advanced ways than\n\n480 | Chapter 19: Advanced Function Topics\n\n\fshown here. For instance, given multiple sequence arguments, it sends items taken from\nsequences in parallel as distinct arguments to the function:\n>>> pow(3, 4)\n81\n>>> list(map(pow, [1, 2, 3], [2, 3, 4]))\n[1, 8, 81]\n\n# 3**4\n# 1**2, 2**3, 3**4",
    "# 3**4\n# 1**2, 2**3, 3**4\n\nWith multiple sequences, map expects an N-argument function for N sequences. Here,\nthe pow function takes two arguments on each call—one from each sequence passed to\nmap. It’s not much extra work to simulate this multiple-sequence generality in code,\ntoo, but we’ll postpone doing so until later in the next chapter, after we’ve met some\nadditional iteration tools.\nThe map call is similar to the list comprehension expressions we studied in Chapter 14 and will meet again in the next chapter, but map applies a function call to each\nitem instead of an arbitrary expression. Because of this limitation, it is a somewhat less\ngeneral tool. However, in some cases map may be faster to run than a list comprehension\n(e.g., when mapping a built-in function), and it may also require less coding.",
    "Functional Programming Tools: filter and reduce\nThe map function is the simplest representative of a class of Python built-ins used for\nfunctional programming—tools that apply functions to sequences and other iterables.\nIts relatives filter out items based on a test function (filter) and apply functions to\npairs of items and running results (reduce). Because they return iterables, range and\nfilter both require list calls to display all their results in 3.0. For example, the following filter call picks out items in a sequence that are greater than zero:\n>>> list(range(−5, 5))\n[−5, −4, −3, −2, −1, 0, 1, 2, 3, 4]\n\n# An iterator in 3.0\n\n>>> list(filter((lambda x: x > 0), range(−5, 5)))\n[1, 2, 3, 4]\n\n# An iterator in 3.0",
    "# An iterator in 3.0\n\n>>> list(filter((lambda x: x > 0), range(−5, 5)))\n[1, 2, 3, 4]\n\n# An iterator in 3.0\n\nItems in the sequence or iterable for which the function returns a true result are added\nto the result list. Like map, this function is roughly equivalent to a for loop, but it is\nbuilt-in and fast:\n>>> res = []\n>>> for x in range(−5, 5):\n...\nif x > 0:\n...\nres.append(x)\n...\n>>> res\n[1, 2, 3, 4]\n\nreduce, which is a simple built-in function in 2.6 but lives in the functools module in\n\n3.0, is more complex. It accepts an iterator to process, but it’s not an iterator itself—it\n\nFunctional Programming Tools: filter and reduce | 481\n\n\freturns a single result. Here are two reduce calls that compute the sum and product of\nthe items in a list:\n>>> from functools import reduce\n\n# Import in 3.0, not in 2.6\n\n>>> reduce((lambda x, y: x + y), [1, 2, 3, 4])\n10\n>>> reduce((lambda x, y: x * y), [1, 2, 3, 4])\n24",
    "Functional Programming Tools: filter and reduce | 481\n\n\freturns a single result. Here are two reduce calls that compute the sum and product of\nthe items in a list:\n>>> from functools import reduce\n\n# Import in 3.0, not in 2.6\n\n>>> reduce((lambda x, y: x + y), [1, 2, 3, 4])\n10\n>>> reduce((lambda x, y: x * y), [1, 2, 3, 4])\n24\n\nAt each step, reduce passes the current sum or product, along with the next item from\nthe list, to the passed-in lambda function. By default, the first item in the sequence\ninitializes the starting value. To illustrate, here’s the for loop equivalent to the first of\nthese calls, with the addition hardcoded inside the loop:\n>>> L = [1,2,3,4]\n>>> res = L[0]\n>>> for x in L[1:]:\n...\nres = res + x\n...\n>>> res\n10",
    "Coding your own version of reduce is actually fairly straightforward. The following\nfunction emulates most of the built-in’s behavior and helps demystify its operation in\ngeneral:\n>>> def myreduce(function, sequence):\n...\ntally = sequence[0]\n...\nfor next in sequence[1:]:\n...\ntally = function(tally, next)\n...\nreturn tally\n...\n>>> myreduce((lambda x, y: x + y), [1, 2, 3, 4, 5])\n15\n>>> myreduce((lambda x, y: x * y), [1, 2, 3, 4, 5])\n120",
    "The built-in reduce also allows an optional third argument placed before the items in\nthe sequence to serve as a default result when the sequence is empty, but we’ll leave\nthis extension as a suggested exercise.\nIf this coding technique has sparked your interest, you might also be interested in the\nstandard library operator module, which provides functions that correspond to builtin expressions and so comes in handy for some uses of functional tools (see Python’s\nlibrary manual for more details on this module):\n>>> import operator, functools\n>>> functools.reduce(operator.add, [2, 4, 6])\n# Function-based +\n12\n>>> functools.reduce((lambda x, y: x + y), [2, 4, 6])\n12\n\n482 | Chapter 19: Advanced Function Topics",
    "482 | Chapter 19: Advanced Function Topics\n\n\fTogether with map, filter and reduce support powerful functional programming techniques. Some observers might also extend the functional programming toolset in Python to include lambda, discussed earlier, as well as list comprehensions—a topic we\nwill return to in the next chapter.\n\nChapter Summary\nThis chapter took us on a tour of advanced function-related concepts: recursive functions; function annotations; lambda expression functions; functional tools such as map,\nfilter, and reduce; and general function design ideas. The next chapter continues the\nadvanced topics motif with a look at generators and a reprisal of iterators and list comprehensions—tools that are just as related to functional programming as to looping\nstatements. Before you move on, though, make sure you’ve mastered the concepts\ncovered here by working through this chapter’s quiz.",
    "Test Your Knowledge: Quiz\n1. How are lambda expressions and def statements related?\n2. What’s the point of using lamba?\n3. Compare and contrast map, filter, and reduce.\n4. What are function annotations, and how are they used?\n5. What are recursive functions, and how are they used?\n6. What are some general design guidelines for coding functions?",
    "Test Your Knowledge: Answers\n1. Both lambda and def create function objects to be called later. Because lambda is an\nexpression, though, it returns a function object instead of assigning it to a name,\nand it can be used to nest a function definition in places where a def will not work\nsyntactically. A lambda only allows for a single implicit return value expression,\nthough; because it does not support a block of statements, it is not ideal for larger\nfunctions.\n2. lambdas allow us to “inline” small units of executable code, defer its execution, and\nprovide it with state in the form of default arguments and enclosing scope variables.\nUsing a lambda is never required; you can always code a def instead and reference\nthe function by name. lambdas come in handy, though, to embed small pieces of\ndeferred code that are unlikely to be used elsewhere in a program. They commonly\nappear in callback-based program such as GUIs, and they have a natural affinity",
    "Using a lambda is never required; you can always code a def instead and reference\nthe function by name. lambdas come in handy, though, to embed small pieces of\ndeferred code that are unlikely to be used elsewhere in a program. They commonly\nappear in callback-based program such as GUIs, and they have a natural affinity\nwith function tools like map and filter that expect a processing function.\nTest Your Knowledge: Answers | 483",
    "3. These three built-in functions all apply another function to items in a sequence\n(iterable) object and collect results. map passes each item to the function and collects\nall results, filter collects items for which the function returns a True value, and\nreduce computes a single value by applying the function to an accumulator and\nsuccessive items. Unlike the other two, reduce is available in the functools module\nin 3.0, not the built-in scope.\n4. Function annotations, available in 3.0 and later, are syntactic embellishments of a\nfunction’s arguments and result, which are collected into a dictionary assigned to\nthe function’s __annotations__ attribute. Python places no semantic meaning on\nthese annotations, but simply packages them for potential use by other tools.\n5. Recursive functions call themselves either directly or indirectly in order to loop.\nThey may be used to traverse arbitrarily shaped structures, but they can also be",
    "the function’s __annotations__ attribute. Python places no semantic meaning on\nthese annotations, but simply packages them for potential use by other tools.\n5. Recursive functions call themselves either directly or indirectly in order to loop.\nThey may be used to traverse arbitrarily shaped structures, but they can also be\nused for iteration in general (though the latter role is often more simply and efficiently coded with looping statements).\n6. Functions should generally be small, as self-contained as possible, have a single\nunified purpose, and communicate with other components through input arguments and return values. They may use mutable arguments to communicate results\ntoo if changes are expected, and some types of programs imply other communication mechanisms.",
    "484 | Chapter 19: Advanced Function Topics\n\n\fCHAPTER 20\n\nIterations and Comprehensions, Part 2",
    "This chapter continues the advanced function topics theme, with a reprisal of the comprehension and iteration concepts introduced in Chapter 14. Because list comprehensions are as much related to the prior chapter’s functional tools (e.g., map and filter)\nas they are to for loops, we’ll revisit them in this context here. We’ll also take a second\nlook at iterators in order to study generator functions and their generator expression\nrelatives—user-defined ways to produce results on demand.\nIteration in Python also encompasses user-defined classes, but we’ll defer that final part\nof this story until Part VI, when we study operator overloading. As this is the last pass\nwe’ll make over built-in iteration tools, though, we will summarize the various tools\nwe’ve met thus far, and time the relative performance of some of them. Finally, because\nthis is the last chapter in the part of the book, we’ll close with the usual sets of “gotchas”",
    "of this story until Part VI, when we study operator overloading. As this is the last pass\nwe’ll make over built-in iteration tools, though, we will summarize the various tools\nwe’ve met thus far, and time the relative performance of some of them. Finally, because\nthis is the last chapter in the part of the book, we’ll close with the usual sets of “gotchas”\nand exercises to help you start coding the ideas you’ve read about.",
    "List Comprehensions Revisited: Functional Tools\nIn the prior chapter, we studied functional programming tools like map and filter,\nwhich map operations over sequences and collect results. Because this is such a common task in Python coding, Python eventually sprouted a new expression—the list\ncomprehension—that is even more flexible than the tools we just studied. In short, list\ncomprehensions apply an arbitrary expression to items in an iterable, rather than applying a function. As such, they can be more general tools.\nWe met list comprehensions in Chapter 14, in conjunction with looping statements.\nBecause they’re also related to functional programming tools like the map and filter\ncalls, though, we’ll resurrect the topic here for one last look. Technically, this feature\nis not tied to functions—as we’ll see, list comprehensions can be a more general tool\nthan map and filter—but it is sometimes best understood by analogy to function-based\nalternatives.\n\n485",
    "485\n\n\fList Comprehensions Versus map\nLet’s work through an example that demonstrates the basics. As we saw in Chapter 7, Python’s built-in ord function returns the ASCII integer code of a single character\n(the chr built-in is the converse—it returns the character for an ASCII integer code):\n>>> ord('s')\n115\n\nNow, suppose we wish to collect the ASCII codes of all characters in an entire string.\nPerhaps the most straightforward approach is to use a simple for loop and append the\nresults to a list:\n>>> res = []\n>>> for x in 'spam':\n...\nres.append(ord(x))\n...\n>>> res\n[115, 112, 97, 109]\n\nNow that we know about map, though, we can achieve similar results with a single\nfunction call without having to manage list construction in the code:\n>>> res = list(map(ord, 'spam'))\n>>> res\n[115, 112, 97, 109]\n\n# Apply function to sequence",
    "Now that we know about map, though, we can achieve similar results with a single\nfunction call without having to manage list construction in the code:\n>>> res = list(map(ord, 'spam'))\n>>> res\n[115, 112, 97, 109]\n\n# Apply function to sequence\n\nHowever, we can get the same results from a list comprehension expression—while\nmap maps a function over a sequence, list comprehensions map an expression over a\nsequence:\n>>> res = [ord(x) for x in 'spam']\n>>> res\n[115, 112, 97, 109]\n\n# Apply expression to sequence",
    "# Apply expression to sequence\n\nList comprehensions collect the results of applying an arbitrary expression to a sequence of values and return them in a new list. Syntactically, list comprehensions are\nenclosed in square brackets (to remind you that they construct lists). In their simple\nform, within the brackets you code an expression that names a variable followed by\nwhat looks like a for loop header that names the same variable. Python then collects\nthe expression’s results for each iteration of the implied loop.\nThe effect of the preceding example is similar to that of the manual for loop and the\nmap call. List comprehensions become more convenient, though, when we wish to apply\nan arbitrary expression to a sequence:\n>>> [x ** 2 for x in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]",
    "Here, we’ve collected the squares of the numbers 0 through 9 (we’re just letting the\ninteractive prompt print the resulting list; assign it to a variable if you need to retain\nit). To do similar work with a map call, we would probably need to invent a little function\nto implement the square operation. Because we won’t need this function elsewhere,\n\n486 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fwe’d typically (but not necessarily) code it inline, with a lambda, instead of using a\ndef statement elsewhere:\n>>> list(map((lambda x: x ** 2), range(10)))\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nThis does the same job, and it’s only a few keystrokes longer than the equivalent list\ncomprehension. It’s also only marginally more complex (at least, once you understand\nthe lambda). For more advanced kinds of expressions, though, list comprehensions will\noften require considerably less typing. The next section shows why.",
    "Adding Tests and Nested Loops: filter\nList comprehensions are even more general than shown so far. For instance, as we\nlearned in Chapter 14, you can code an if clause after the for to add selection logic.\nList comprehensions with if clauses can be thought of as analogous to the filter builtin discussed in the prior chapter—they skip sequence items for which the if clause is\nnot true.\nTo demonstrate, here are both schemes picking up even numbers from 0 to 4; like the\nmap list comprehension alternative of the prior section, the filter version here must\ninvent a little lambda function for the test expression. For comparison, the equivalent\nfor loop is shown here as well:\n>>> [x for x in range(5) if x % 2 == 0]\n[0, 2, 4]\n>>> list(filter((lambda x: x % 2 == 0), range(5)))\n[0, 2, 4]\n>>> res = []\n>>> for x in range(5):\n...\nif x % 2 == 0:\n...\nres.append(x)\n...\n>>> res\n[0, 2, 4]",
    "All of these use the modulus (remainder of division) operator, %, to detect even numbers:\nif there is no remainder after dividing a number by 2, it must be even. The filter call\nhere is not much longer than the list comprehension either. However, we can combine\nan if clause and an arbitrary expression in our list comprehension, to give it the effect\nof a filter and a map, in a single expression:\n>>> [x ** 2 for x in range(10) if x % 2 == 0]\n[0, 4, 16, 36, 64]\n\nThis time, we collect the squares of the even numbers from 0 through 9: the for loop\nskips numbers for which the attached if clause on the right is false, and the expression\non the left computes the squares. The equivalent map call would require a lot more work\n\nList Comprehensions Revisited: Functional Tools | 487",
    "This time, we collect the squares of the even numbers from 0 through 9: the for loop\nskips numbers for which the attached if clause on the right is false, and the expression\non the left computes the squares. The equivalent map call would require a lot more work\n\nList Comprehensions Revisited: Functional Tools | 487\n\n\fon our part—we would have to combine filter selections with map iteration, making\nfor a noticeably more complex expression:\n>>> list( map((lambda x: x**2), filter((lambda x: x % 2 == 0), range(10))) )\n[0, 4, 16, 36, 64]\n\nIn fact, list comprehensions are more general still. You can code any number of nested\nfor loops in a list comprehension, and each may have an optional associated if test.\n\nThe general structure of list comprehensions looks like this:\n[ expression for target1 in iterable1 [if condition1]\nfor target2 in iterable2 [if condition2] ...\nfor targetN in iterableN [if conditionN] ]",
    "In fact, list comprehensions are more general still. You can code any number of nested\nfor loops in a list comprehension, and each may have an optional associated if test.\n\nThe general structure of list comprehensions looks like this:\n[ expression for target1 in iterable1 [if condition1]\nfor target2 in iterable2 [if condition2] ...\nfor targetN in iterableN [if conditionN] ]\n\nWhen for clauses are nested within a list comprehension, they work like equivalent\nnested for loop statements. For example, the following:\n>>> res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]\n>>> res\n[100, 200, 300, 101, 201, 301, 102, 202, 302]\n\nhas the same effect as this substantially more verbose equivalent:\n>>> res = []\n>>> for x in [0, 1, 2]:\n...\nfor y in [100, 200, 300]:\n...\nres.append(x + y)\n...\n>>> res\n[100, 200, 300, 101, 201, 301, 102, 202, 302]",
    "has the same effect as this substantially more verbose equivalent:\n>>> res = []\n>>> for x in [0, 1, 2]:\n...\nfor y in [100, 200, 300]:\n...\nres.append(x + y)\n...\n>>> res\n[100, 200, 300, 101, 201, 301, 102, 202, 302]\n\nAlthough list comprehensions construct lists, remember that they can iterate over any\nsequence or other iterable type. Here’s a similar bit of code that traverses strings instead\nof lists of numbers, and so collects concatenation results:\n>>> [x + y for x in 'spam' for y in 'SPAM']\n['sS', 'sP', 'sA', 'sM', 'pS', 'pP', 'pA', 'pM',\n'aS', 'aP', 'aA', 'aM', 'mS', 'mP', 'mA', 'mM']\n\nFinally, here is a much more complex list comprehension that illustrates the effect of\nattached if selections on nested for clauses:\n>>> [(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]\n[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]",
    "Finally, here is a much more complex list comprehension that illustrates the effect of\nattached if selections on nested for clauses:\n>>> [(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]\n[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n\nThis expression permutes even numbers from 0 through 4 with odd numbers from 0\nthrough 4. The if clauses filter out items in each sequence iteration. Here is the equivalent statement-based code:\n>>> res = []\n>>> for x in range(5):\n...\nif x % 2 == 0:\n...\nfor y in range(5):\n...\nif y % 2 == 1:\n...\nres.append((x, y))\n...\n\n488 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f>>> res\n[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]",
    "488 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f>>> res\n[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]\n\nRecall that if you’re confused about what a complex list comprehension does, you can\nalways nest the list comprehension’s for and if clauses inside each other (indenting\nsuccessively further to the right) to derive the equivalent statements. The result is longer, but perhaps clearer.\nThe map and filter equivalent would be wildly complex and deeply nested, so I won’t\neven try showing it here. I’ll leave its coding as an exercise for Zen masters, ex-Lisp\nprogrammers, and the criminally insane....",
    "List Comprehensions and Matrixes\nNot all list comprehensions are so artificial, of course. Let’s look at one more application to stretch a few synapses. One basic way to code matrixes (a.k.a. multidimensional\narrays) in Python is with nested list structures. The following, for example, defines two\n3 × 3 matrixes as lists of nested lists:\n>>> M = [[1, 2, 3],\n...\n[4, 5, 6],\n...\n[7, 8, 9]]\n>>> N = [[2, 2, 2],\n...\n[3, 3, 3],\n...\n[4, 4, 4]]\n\nGiven this structure, we can always index rows, and columns within rows, using normal\nindex operations:\n>>> M[1]\n[4, 5, 6]\n>>> M[1][2]\n6",
    "Given this structure, we can always index rows, and columns within rows, using normal\nindex operations:\n>>> M[1]\n[4, 5, 6]\n>>> M[1][2]\n6\n\nList comprehensions are powerful tools for processing such structures, though, because\nthey automatically scan rows and columns for us. For instance, although this structure\nstores the matrix by rows, to collect the second column we can simply iterate across\nthe rows and pull out the desired column, or iterate through positions in the rows and\nindex as we go:\n>>> [row[1] for row in M]\n[2, 5, 8]\n>>> [M[row][1] for row in (0, 1, 2)]\n[2, 5, 8]\n\nGiven positions, we can also easily perform tasks such as pulling out a diagonal. The\nfollowing expression uses range to generate the list of offsets and then indexes with the\nrow and column the same, picking out M[0][0], then M[1][1], and so on (we assume\nthe matrix has the same number of rows and columns):\nList Comprehensions Revisited: Functional Tools | 489\n\n\f>>> [M[i][i] for i in range(len(M))]\n[1, 5, 9]",
    ">>> [M[i][i] for i in range(len(M))]\n[1, 5, 9]\n\nFinally, with a bit of creativity, we can also use list comprehensions to combine multiple\nmatrixes. The following first builds a flat list that contains the result of multiplying the\nmatrixes pairwise, and then builds a nested list structure having the same values by\nnesting list comprehensions:\n>>> [M[row][col] * N[row][col] for row in range(3) for col in range(3)]\n[2, 4, 6, 12, 15, 18, 28, 32, 36]\n>>> [[M[row][col] * N[row][col] for col in range(3)] for row in range(3)]\n[[2, 4, 6], [12, 15, 18], [28, 32, 36]]\n\nThis last expression works because the row iteration is an outer loop: for each row, it\nruns the nested column iteration to build up one row of the result matrix. It’s equivalent\nto this statement-based code:\n>>> res = []\n>>> for row in range(3):\n...\ntmp = []\n...\nfor col in range(3):\n...\ntmp.append(M[row][col] * N[row][col])\n...\nres.append(tmp)\n...\n>>> res\n[[2, 4, 6], [12, 15, 18], [28, 32, 36]]",
    "This last expression works because the row iteration is an outer loop: for each row, it\nruns the nested column iteration to build up one row of the result matrix. It’s equivalent\nto this statement-based code:\n>>> res = []\n>>> for row in range(3):\n...\ntmp = []\n...\nfor col in range(3):\n...\ntmp.append(M[row][col] * N[row][col])\n...\nres.append(tmp)\n...\n>>> res\n[[2, 4, 6], [12, 15, 18], [28, 32, 36]]\n\nCompared to these statements, the list comprehension version requires only one line\nof code, will probably run substantially faster for large matrixes, and just might make\nyour head explode! Which brings us to the next section.",
    "Comprehending List Comprehensions\nWith such generality, list comprehensions can quickly become, well, incomprehensible, especially when nested. Consequently, my advice is typically to use simple for\nloops when getting started with Python, and map or comprehensions in isolated cases\nwhere they are easy to apply. The “keep it simple” rule applies here, as always: code\nconciseness is a much less important goal than code readability.\nHowever, in this case, there is currently a substantial performance advantage to\nthe extra complexity: based on tests run under Python today, map calls are roughly twice\nas fast as equivalent for loops, and list comprehensions are usually slightly faster than\nmap calls.* This speed difference is generally due to the fact that map and list\n* These performance generalizations can depend on call patterns, as well as changes and optimizations in\nPython itself. Recent Python releases have sped up the simple for loop statement, for example. Usually,",
    "as fast as equivalent for loops, and list comprehensions are usually slightly faster than\nmap calls.* This speed difference is generally due to the fact that map and list\n* These performance generalizations can depend on call patterns, as well as changes and optimizations in\nPython itself. Recent Python releases have sped up the simple for loop statement, for example. Usually,\nthough, list comprehensions are still substantially faster than for loops and even faster than map (though\nmap can still win for built-in functions). To time these alternatives yourself, see the standard library’s time\nmodule’s time.clock and time.time calls, the newer timeit module added in Release 2.4, or this chapter’s\nupcoming section “Timing Iteration Alternatives” on page 509.",
    "490 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fcomprehensions run at C language speed inside the interpreter, which is much faster\nthan stepping through Python for loop code within the PVM.\nBecause for loops make logic more explicit, I recommend them in general on the\ngrounds of simplicity. However, map and list comprehensions are worth knowing and\nusing for simpler kinds of iterations, and if your application’s speed is an important\nconsideration. In addition, because map and list comprehensions are both expressions,\nthey can show up syntactically in places that for loop statements cannot, such as in the\nbodies of lambda functions, within list and dictionary literals, and more. Still, you should\ntry to keep your map calls and list comprehensions simple; for more complex tasks, use\nfull statements instead.",
    "Why You Will Care: List Comprehensions and map\nHere’s a more realistic example of list comprehensions and map in action (we solved\nthis problem with list comprehensions in Chapter 14, but we’ll revive it here to add\nmap-based alternatives). Recall that the file readlines method returns lines with \\n endof-line characters at the ends:\n>>> open('myfile').readlines()\n['aaa\\n', 'bbb\\n', 'ccc\\n']\n\nIf you don’t want the end-of-line characters, you can slice them off all the lines in a\nsingle step with a list comprehension or a map call (map results are iterables in Python\n3.0, so we must run them through list to see all their results at once):\n>>> [line.rstrip() for line in open('myfile').readlines()]\n['aaa', 'bbb', 'ccc']\n>>> [line.rstrip() for line in open('myfile')]\n['aaa', 'bbb', 'ccc']\n>>> list(map((lambda line: line.rstrip()), open('myfile')))\n['aaa', 'bbb', 'ccc']",
    "The last two of these make use of file iterators (which essentially means that you don’t\nneed a method call to grab all the lines in iteration contexts such as these). The map call\nis slightly longer than the list comprehension, but neither has to manage result list\nconstruction explicitly.\nA list comprehension can also be used as a sort of column projection operation. Python’s standard SQL database API returns query results as a list of tuples much like the\nfollowing—the list is the table, tuples are rows, and items in tuples are column values:\nlistoftuple = [('bob', 35, 'mgr'), ('mel', 40, 'dev')]\n\nA for loop could pick up all the values from a selected column manually, but map and\nlist comprehensions can do it in a single step, and faster:\n>>> [age for (name, age, job) in listoftuple]\n[35, 40]\n>>> list(map((lambda row: row[1]), listoftuple))\n[35, 40]\n\nList Comprehensions Revisited: Functional Tools | 491",
    "A for loop could pick up all the values from a selected column manually, but map and\nlist comprehensions can do it in a single step, and faster:\n>>> [age for (name, age, job) in listoftuple]\n[35, 40]\n>>> list(map((lambda row: row[1]), listoftuple))\n[35, 40]\n\nList Comprehensions Revisited: Functional Tools | 491\n\n\fThe first of these makes use of tuple assignment to unpack row tuples in the list, and\nthe second uses indexing. In Python 2.6 (but not in 3.0—see the note on 2.6 argument\nunpacking in Chapter 18), map can use tuple unpacking on its argument, too:\n# 2.6 only\n>>> list(map((lambda (name, age, job): age), listoftuple))\n[35, 40]",
    "List Comprehensions Revisited: Functional Tools | 491\n\n\fThe first of these makes use of tuple assignment to unpack row tuples in the list, and\nthe second uses indexing. In Python 2.6 (but not in 3.0—see the note on 2.6 argument\nunpacking in Chapter 18), map can use tuple unpacking on its argument, too:\n# 2.6 only\n>>> list(map((lambda (name, age, job): age), listoftuple))\n[35, 40]\n\nSee other books and resources for more on Python’s database API.\nBeside the distinction between running functions versus expressions, the biggest difference between map and list comprehensions in Python 3.0 is that map is an iterator,\ngenerating results on demand; to achieve the same memory economy, list comprehensions must be coded as generator expressions (one of the topics of this chapter).",
    "Iterators Revisited: Generators\nPython today supports procrastination much more than it did in the past—it provides\ntools that produce results only when needed, instead of all at once. In particular, two\nlanguage constructs delay result creation whenever possible:\n• Generator functions are coded as normal def statements but use yield statements\nto return results one at a time, suspending and resuming their state between each.\n• Generator expressions are similar to the list comprehensions of the prior section,\nbut they return an object that produces results on demand instead of building a\nresult list.\nBecause neither constructs a result list all at once, they save memory space and allow\ncomputation time to be split across result requests. As we’ll see, both of these ultimately\nperform their delayed-results magic by implementing the iteration protocol we studied\nin Chapter 14.",
    "Generator Functions: yield Versus return\nIn this part of the book, we’ve learned about coding normal functions that receive input\nparameters and send back a single result immediately. It is also possible, however, to\nwrite functions that may send back a value and later be resumed, picking up where they\nleft off. Such functions are known as generator functions because they generate a sequence of values over time.\nGenerator functions are like normal functions in most respects, and in fact are coded\nwith normal def statements. However, when created, they are automatically made to\nimplement the iteration protocol so that they can appear in iteration contexts. We\nstudied iterators in Chapter 14; here, we’ll revisit them to see how they relate to\ngenerators.\n\n492 | Chapter 20: Iterations and Comprehensions, Part 2",
    "State suspension\nUnlike normal functions that return a value and exit, generator functions automatically\nsuspend and resume their execution and state around the point of value generation.\nBecause of that, they are often a useful alternative to both computing an entire series\nof values up front and manually saving and restoring state in classes. Because the state\nthat generator functions retain when they are suspended includes their entire local\nscope, their local variables retain information and make it available when the functions\nare resumed.\nThe chief code difference between generator and normal functions is that a generator\nyields a value, rather than returning one—the yield statement suspends the function\nand sends a value back to the caller, but retains enough state to enable the function to\nresume from where it left off. When resumed, the function continues execution immediately after the last yield run. From the function’s perspective, this allows its code",
    "yields a value, rather than returning one—the yield statement suspends the function\nand sends a value back to the caller, but retains enough state to enable the function to\nresume from where it left off. When resumed, the function continues execution immediately after the last yield run. From the function’s perspective, this allows its code\nto produce a series of values over time, rather than computing them all at once and\nsending them back in something like a list.",
    "Iteration protocol integration\nTo truly understand generator functions, you need to know that they are closely bound\nup with the notion of the iteration protocol in Python. As we’ve seen, iterable objects\ndefine a __next__ method, which either returns the next item in the iteration, or raises\nthe special StopIteration exception to end the iteration. An object’s iterator is fetched\nwith the iter built-in function.\nPython for loops, and all other iteration contexts, use this iteration protocol to step\nthrough a sequence or value generator, if the protocol is supported; if not, iteration\nfalls back on repeatedly indexing sequences instead.\nTo support this protocol, functions containing a yield statement are compiled specially\nas generators. When called, they return a generator object that supports the iteration\ninterface with an automatically created method named __next__ to resume execution.\nGenerator functions may also have a return statement that, along with falling off the",
    "falls back on repeatedly indexing sequences instead.\nTo support this protocol, functions containing a yield statement are compiled specially\nas generators. When called, they return a generator object that supports the iteration\ninterface with an automatically created method named __next__ to resume execution.\nGenerator functions may also have a return statement that, along with falling off the\nend of the def block, simply terminates the generation of values—technically, by raising\na StopIteration exception after any normal function exit actions. From the caller’s\nperspective, the generator’s __next__ method resumes the function and runs until either\nthe next yield result is returned or a StopIteration is raised.\nThe net effect is that generator functions, coded as def statements containing yield\nstatements, are automatically made to support the iteration protocol and thus may be\nused in any iteration context to produce results over time and on demand.",
    "Iterators Revisited: Generators | 493\n\n\fAs noted in Chapter 14, in Python 2.6 and earlier, iterable objects define\na method named next instead of __next__. This includes the generator\nobjects we are using here. In 3.0 this method is renamed to __next__.\nThe next built-in function is provided as a convenience and portability\ntool: next(I) is the same as I.__next__() in 3.0 and I.next() in 2.6.\nPrior to 2.6, programs simply call I.next() instead to iterate manually.\n\nGenerator functions in action\nTo illustrate generator basics, let’s turn to some code. The following code defines a\ngenerator function that can be used to generate the squares of a series of numbers over\ntime:\n>>> def gensquares(N):\n...\nfor i in range(N):\n...\nyield i ** 2\n...\n\n# Resume here later",
    "Generator functions in action\nTo illustrate generator basics, let’s turn to some code. The following code defines a\ngenerator function that can be used to generate the squares of a series of numbers over\ntime:\n>>> def gensquares(N):\n...\nfor i in range(N):\n...\nyield i ** 2\n...\n\n# Resume here later\n\nThis function yields a value, and so returns to its caller, each time through the loop;\nwhen it is resumed, its prior state is restored and control picks up again immediately\nafter the yield statement. For example, when it’s used in the body of a for loop, control\nreturns to the function after its yield statement each time through the loop:\n# Resume the function\n# Print last yielded value\n\n>>> for i in gensquares(5):\n...\nprint(i, end=' : ')\n...\n0 : 1 : 4 : 9 : 16 :\n>>>",
    ">>> for i in gensquares(5):\n...\nprint(i, end=' : ')\n...\n0 : 1 : 4 : 9 : 16 :\n>>>\n\nTo end the generation of values, functions either use a return statement with no value\nor simply allow control to fall off the end of the function body.\nIf you want to see what is going on inside the for, call the generator function directly:\n>>> x = gensquares(4)\n>>> x\n<generator object at 0x0086C378>\n\nYou get back a generator object that supports the iteration protocol we met in Chapter 14—the generator object has a __next__ method that starts the function, or resumes\nit from where it last yielded a value, and raises a StopIteration exception when the end\nof the series of values is reached. For convenience, the next(X) built-in calls an object’s\nX.__next__() method for us:\n>>> next(x)\n0\n>>> next(x)\n1\n>>> next(x)\n4\n>>> next(x)\n9\n>>> next(x)\n\n# Same as x.__next__() in 3.0\n# Use x.next() or next() in 2.6\n\n494 | Chapter 20: Iterations and Comprehensions, Part 2",
    "# Same as x.__next__() in 3.0\n# Use x.next() or next() in 2.6\n\n494 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fTraceback (most recent call last):\n...more text omitted...\nStopIteration\n\nAs we learned in Chapter 14, for loops (and other iteration contexts) work with generators in the same way—by calling the __next__ method repeatedly, until an exception\nis caught. If the object to be iterated over does not support this protocol, for loops\ninstead use the indexing protocol to iterate.\nNote that in this example, we could also simply build the list of yielded values all at\nonce:\n>>> def buildsquares(n):\n...\nres = []\n...\nfor i in range(n): res.append(i ** 2)\n...\nreturn res\n...\n>>> for x in buildsquares(5): print(x, end=' : ')\n...\n0 : 1 : 4 : 9 : 16 :",
    "For that matter, we could use any of the for loop, map, or list comprehension techniques:\n>>> for x in [n ** 2 for n in range(5)]:\n...\nprint(x, end=' : ')\n...\n0 : 1 : 4 : 9 : 16 :\n>>> for x in map((lambda n: n ** 2), range(5)):\n...\nprint(x, end=' : ')\n...\n0 : 1 : 4 : 9 : 16 :",
    "However, generators can be better in terms of both memory use and performance. They\nallow functions to avoid doing all the work up front, which is especially useful when\nthe result lists are large or when it takes a lot of computation to produce each value.\nGenerators distribute the time required to produce the series of values among loop\niterations.\nMoreover, for more advanced uses, generators can provide a simpler alternative to\nmanually saving the state between iterations in class objects—with generators,\nvariables accessible in the function’s scopes are saved and restored automatically.†\nWe’ll discuss class-based iterators in more detail in Part VI.\n† Interestingly, generator functions are also something of a “poor man’s” multithreading device—they\ninterleave a function’s work with that of its caller, by dividing its operation into steps run between yields.\nGenerators are not threads, though: the program is explicitly directed to and from the function within a single",
    "We’ll discuss class-based iterators in more detail in Part VI.\n† Interestingly, generator functions are also something of a “poor man’s” multithreading device—they\ninterleave a function’s work with that of its caller, by dividing its operation into steps run between yields.\nGenerators are not threads, though: the program is explicitly directed to and from the function within a single\nthread of control. In one sense, threading is more general (producers can run truly independently and post\nresults to a queue), but generators may be simpler to code. See the second footnote in Chapter 17 for a brief\nintroduction to Python multithreading tools. Note that because control is routed explicitly at yield and\nnext calls, generators are also not backtracking, but are more strongly related to coroutines—formal concepts\nthat are both beyond this chapter’s scope.",
    "Iterators Revisited: Generators | 495",
    "Extended generator function protocol: send versus next\nIn Python 2.5, a send method was added to the generator function protocol. The send\nmethod advances to the next item in the series of results, just like __next__, but also\nprovides a way for the caller to communicate with the generator, to affect its operation.\nTechnically, yield is now an expression form that returns the item passed to send, not\na statement (though it can be called either way—as yield X, or A = (yield X)). The\nexpression must be enclosed in parentheses unless it’s the only item on the right side\nof the assignment statement. For example, X = yield Y is OK, as is X = (yield Y) + 42.\nWhen this extra protocol is used, values are sent into a generator G by calling\nG.send(value). The generator’s code is then resumed, and the yield expression in the\ngenerator returns the value passed to send. If the regular G.__next__() method (or its",
    "of the assignment statement. For example, X = yield Y is OK, as is X = (yield Y) + 42.\nWhen this extra protocol is used, values are sent into a generator G by calling\nG.send(value). The generator’s code is then resumed, and the yield expression in the\ngenerator returns the value passed to send. If the regular G.__next__() method (or its\nnext(G) equivalent) is called to advance, the yield simply returns None. For example:\n>>> def gen():\n...\nfor i in range(10):\n...\nX = yield i\n...\nprint(X)\n...\n>>> G = gen()\n>>> next(G)\n# Must call next() first, to start generator\n0\n>>> G.send(77)\n# Advance, and send value to yield expression\n77\n1\n>>> G.send(88)\n88\n2\n>>> next(G)\n# next() and X.__next__() send None\nNone\n3",
    "The send method can be used, for example, to code a generator that its caller can terminate by sending a termination code, or redirect by passing a new position. In addition, generators in 2.5 also support a throw(type) method to raise an exception inside\nthe generator at the latest yield, and a close method that raises a special Generator\nExit exception inside the generator to terminate the iteration. These are advanced features that we won’t delve into in more detail here; see reference texts and Python’s\nstandard manuals for more information.\nNote that while Python 3.0 provides a next(X) convenience built-in that calls the\nX.__next__() method of an object, other generator methods, like send, must be called\nas methods of generator objects directly (e.g., G.send(X)). This makes sense if you realize that these extra methods are implemented on built-in generator objects only,\nwhereas the __next__ method applies to all iterable objects (both built-in types and\nuser-defined classes).",
    "496 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fGenerator Expressions: Iterators Meet Comprehensions\nIn all recent versions of Python, the notions of iterators and list comprehensions are\ncombined in a new feature of the language, generator expressions. Syntactically, generator expressions are just like normal list comprehensions, but they are enclosed in\nparentheses instead of square brackets:\n>>> [x ** 2 for x in range(4)]\n[0, 1, 4, 9]\n\n# List comprehension: build a list\n\n>>> (x ** 2 for x in range(4))\n<generator object at 0x011DC648>\n\n# Generator expression: make an iterable\n\nIn fact, at least on a function basis, coding a list comprehension is essentially the same\nas wrapping a generator expression in a list built-in call to force it to produce all its\nresults in a list at once:\n>>> list(x ** 2 for x in range(4))\n[0, 1, 4, 9]\n\n# List comprehension equivalence",
    ">>> (x ** 2 for x in range(4))\n<generator object at 0x011DC648>\n\n# Generator expression: make an iterable\n\nIn fact, at least on a function basis, coding a list comprehension is essentially the same\nas wrapping a generator expression in a list built-in call to force it to produce all its\nresults in a list at once:\n>>> list(x ** 2 for x in range(4))\n[0, 1, 4, 9]\n\n# List comprehension equivalence\n\nOperationally, however, generator expressions are very different—instead of building\nthe result list in memory, they return a generator object, which in turn supports the\niteration protocol to yield one piece of the result list at a time in any iteration context:\n>>> G = (x ** 2 for x in range(4))\n>>> next(G)\n0\n>>> next(G)\n1\n>>> next(G)\n4\n>>> next(G)\n9\n>>> next(G)\nTraceback (most recent call last):\n...more text omitted...\nStopIteration",
    "We don’t typically see the next iterator machinery under the hood of a generator expression like this because for loops trigger it for us automatically:\n>>> for num in (x ** 2 for x in range(4)):\n...\nprint('%s, %s' % (num, num / 2.0))\n...\n0, 0.0\n1, 0.5\n4, 2.0\n9, 4.5\n\nAs we’ve already learned, every iteration context does this, including the sum, map, and\nsorted built-in functions; list comprehensions; and other iteration contexts we learned\nabout in Chapter 14, such as the any, all, and list built-in functions.\n\nIterators Revisited: Generators | 497",
    "As we’ve already learned, every iteration context does this, including the sum, map, and\nsorted built-in functions; list comprehensions; and other iteration contexts we learned\nabout in Chapter 14, such as the any, all, and list built-in functions.\n\nIterators Revisited: Generators | 497\n\n\fNotice that the parentheses are not required around a generator expression if they are\nthe sole item enclosed in other parentheses, like those of a function call. Extra parentheses are required, however, in the second call to sorted:\n>>> sum(x ** 2 for x in range(4))\n14\n>>> sorted(x ** 2 for x in range(4))\n[0, 1, 4, 9]\n>>> sorted((x ** 2 for x in range(4)), reverse=True)\n[9, 4, 1, 0]\n>>> import math\n>>> list( map(math.sqrt, (x ** 2 for x in range(4))) )\n[0.0, 1.0, 2.0, 3.0]",
    "Generator expressions are primarily a memory-space optimization—they do not require the entire result list to be constructed all at once, as the square-bracketed list\ncomprehension does. They may also run slightly slower in practice, so they are probably\nbest used only for very large result sets. A more authoritative statement about performance, though, will have to await the timing script we’ll code later in this chapter.\n\nGenerator Functions Versus Generator Expressions\nInterestingly, the same iteration can often be coded with either a generator function or\na generator expression. The following generator expression, for example, repeats each\ncharacter in a string four times:\n>>> G = (c * 4 for c in 'SPAM')\n>>> list(G)\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n# Generator expression\n# Force generator to produce all results",
    "# Generator expression\n# Force generator to produce all results\n\nThe equivalent generator function requires slightly more code, but as a multistatement\nfunction it will be able to code more logic and use more state information if needed:\n>>> def timesfour(S):\n...\nfor c in S:\n...\nyield c * 4\n...\n>>> G = timesfour('spam')\n>>> list(G)\n['ssss', 'pppp', 'aaaa', 'mmmm']\n\n# Generator function\n\n# Iterate automatically\n\nBoth expressions and functions support both automatic and manual iteration—the\nprior list call iterates automatically, and the following iterate manually:\n>>> G = (c * 4 for c in 'SPAM')\n>>> I = iter(G)\n>>> next(I)\n'SSSS'\n>>> next(I)\n'PPPP'\n\n498 | Chapter 20: Iterations and Comprehensions, Part 2\n\n# Iterate manually\n\n\f>>> G = timesfour('spam')\n>>> I = iter(G)\n>>> next(I)\n'ssss'\n>>> next(I)\n'pppp'\n\nNotice that we make new generators here to iterate again—as explained in the next\nsection, generators are one-shot iterators.",
    "498 | Chapter 20: Iterations and Comprehensions, Part 2\n\n# Iterate manually\n\n\f>>> G = timesfour('spam')\n>>> I = iter(G)\n>>> next(I)\n'ssss'\n>>> next(I)\n'pppp'\n\nNotice that we make new generators here to iterate again—as explained in the next\nsection, generators are one-shot iterators.\n\nGenerators Are Single-Iterator Objects\nBoth generator functions and generator expressions are their own iterators and thus\nsupport just one active iteration—unlike some built-in types, you can’t have multiple\niterators of either positioned at different locations in the set of results. For example,\nusing the prior section’s generator expression, a generator’s iterator is the generator\nitself (in fact, calling iter on a generator is a no-op):\n>>> G = (c * 4 for c in 'SPAM')\n>>> iter(G) is G\nTrue\n\n# My iterator is myself: G has __next__",
    "# My iterator is myself: G has __next__\n\nIf you iterate over the results stream manually with multiple iterators, they will all point\nto the same position:\n>>> G = (c * 4 for c in 'SPAM')\n>>> I1 = iter(G)\n>>> next(I1)\n'SSSS'\n>>> next(I1)\n'PPPP'\n>>> I2 = iter(G)\n>>> next(I2)\n'AAAA'\n\n# Make a new generator\n# Iterate manually\n\n# Second iterator at same position!\n\nMoreover, once any iteration runs to completion, all are exhausted—we have to make\na new generator to start again:\n>>> list(I1)\n['MMMM']\n>>> next(I2)\nStopIteration\n\n# Collect the rest of I1's items\n\n>>> I3 = iter(G)\n>>> next(I3)\nStopIteration\n\n# Ditto for new iterators\n\n>>> I3 = iter(c * 4 for c in 'SPAM')\n>>> next(I3)\n'SSSS'\n\n# New generator to start over\n\n# Other iterators exhausted too\n\nIterators Revisited: Generators | 499",
    "# Collect the rest of I1's items\n\n>>> I3 = iter(G)\n>>> next(I3)\nStopIteration\n\n# Ditto for new iterators\n\n>>> I3 = iter(c * 4 for c in 'SPAM')\n>>> next(I3)\n'SSSS'\n\n# New generator to start over\n\n# Other iterators exhausted too\n\nIterators Revisited: Generators | 499\n\n\fThe same holds true for generator functions—the following def statement-based equivalent supports just one active iterator and is exhausted after one pass:\n>>> def timesfour(S):\n...\nfor c in S:\n...\nyield c * 4\n...\n>>> G = timesfour('spam')\n>>> iter(G) is G\nTrue\n>>> I1, I2 = iter(G), iter(G)\n>>> next(I1)\n'ssss'\n>>> next(I1)\n'pppp'\n>>> next(I2)\n'aaaa'\n\n# Generator functions work the same way\n\n# I2 at same position as I1\n\nThis is different from the behavior of some built-in types, which support multiple iterators and passes and reflect their in-place changes in active iterators:\n>>> L = [1, 2, 3, 4]\n>>> I1, I2 = iter(L), iter(L)\n>>> next(I1)\n1\n>>> next(I1)\n2\n>>> next(I2)\n1\n>>> del L[2:]\n>>> next(I1)\nStopIteration",
    "# Generator functions work the same way\n\n# I2 at same position as I1\n\nThis is different from the behavior of some built-in types, which support multiple iterators and passes and reflect their in-place changes in active iterators:\n>>> L = [1, 2, 3, 4]\n>>> I1, I2 = iter(L), iter(L)\n>>> next(I1)\n1\n>>> next(I1)\n2\n>>> next(I2)\n1\n>>> del L[2:]\n>>> next(I1)\nStopIteration\n\n# Lists support multiple iterators\n# Changes reflected in iterators\n\nWhen we begin coding class-based iterators in Part VI, we’ll see that it’s up to us to\ndecide how any iterations we wish to support for our objects, if any.",
    "# Lists support multiple iterators\n# Changes reflected in iterators\n\nWhen we begin coding class-based iterators in Part VI, we’ll see that it’s up to us to\ndecide how any iterations we wish to support for our objects, if any.\n\nEmulating zip and map with Iteration Tools\nTo demonstrate the power of iteration tools in action, let’s turn to some more advanced\nuse case examples. Once you know about list comprehensions, generators, and other\niteration tools, it turns out that emulating many of Python’s functional built-ins is both\nstraightforward and instructive.\nFor example, we’ve already seen how the built-in zip and map functions combine iterables and project functions across them, respectively. With multiple sequence arguments, map projects the function across items taken from each sequence in much the\nsame way that zip pairs them up:\n>>> S1 = 'abc'\n>>> S2 = 'xyz123'\n>>> list(zip(S1, S2))\n[('a', 'x'), ('b', 'y'), ('c', 'z')]\n\n500 | Chapter 20: Iterations and Comprehensions, Part 2",
    "500 | Chapter 20: Iterations and Comprehensions, Part 2\n\n# zip pairs items from iterables\n\n\f# zip pairs items, truncates at shortest\n>>> list(zip([−2, −1, 0, 1, 2]))\n[(−2,), (−1,), (0,), (1,), (2,)]\n\n# Single sequence: 1-ary tuples\n\n>>> list(zip([1, 2, 3], [2, 3, 4, 5]))\n[(1, 2), (2, 3), (3, 4)]\n\n# N sequences: N-ary tuples\n\n# map passes paired itenms to a function, truncates\n>>> list(map(abs, [−2, −1, 0, 1, 2]))\n[2, 1, 0, 1, 2]\n\n# Single sequence: 1-ary function\n\n>>> list(map(pow, [1, 2, 3], [2, 3, 4, 5]))\n[1, 8, 81]\n\n# N sequences: N-ary function\n\nThough they’re being used for different purposes, if you study these examples long\nenough, you might notice a relationship between zip results and mapped function\narguments that our next example can exploit.",
    "# Single sequence: 1-ary function\n\n>>> list(map(pow, [1, 2, 3], [2, 3, 4, 5]))\n[1, 8, 81]\n\n# N sequences: N-ary function\n\nThough they’re being used for different purposes, if you study these examples long\nenough, you might notice a relationship between zip results and mapped function\narguments that our next example can exploit.\n\nCoding your own map(func, ...)\nAlthough the map and zip built-ins are fast and convenient, it’s always possible to emulate them in code of our own. In the preceding chapter, for example, we saw a function\nthat emulated the map built-in for a single sequence argument. It doesn’t take much\nmore work to allow for multiple sequences, as the built-in does:\n# map(func, seqs...) workalike with zip\ndef mymap(func, *seqs):\nres = []\nfor args in zip(*seqs):\nres.append(func(*args))\nreturn res\nprint(mymap(abs, [−2, −1, 0, 1, 2]))\nprint(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))",
    "This version relies heavily upon the special *args argument-passing syntax—it collects\nmultiple sequence (really, iterable) arguments, unpacks them as zip arguments to combine, and then unpacks the paired zip results as arguments to the passed-in function.\nThat is, we’re using the fact that the zipping is essentially a nested operation in mapping.\nThe test code at the bottom applies this to both one and two sequences to produce this\noutput (the same we would get with the built-in map):\n[2, 1, 0, 1, 2]\n[1, 8, 81]\n\nReally, though, the prior version exhibits the classic list comprehension pattern, building\na list of operation results within a for loop. We can code our map more concisely as\nan equivalent one-line list comprehension:\n\nIterators Revisited: Generators | 501\n\n\f# Using a list comprehension\ndef mymap(func, *seqs):\nreturn [func(*args) for args in zip(*seqs)]\nprint(mymap(abs, [−2, −1, 0, 1, 2]))\nprint(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))",
    "Iterators Revisited: Generators | 501\n\n\f# Using a list comprehension\ndef mymap(func, *seqs):\nreturn [func(*args) for args in zip(*seqs)]\nprint(mymap(abs, [−2, −1, 0, 1, 2]))\nprint(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))\n\nWhen this is run the result is the same as before, but the code is more concise and might\nrun faster (more on performance in the section “Timing Iteration Alternatives” on page 509). Both of the preceding mymap versions build result lists all at once,\nthough, and this can waste memory for larger lists. Now that we know about generator\nfunctions and expressions, it’s simple to recode both these alternatives to produce results\non demand instead:\n# Using generators: yield and (...)\ndef mymap(func, *seqs):\nres = []\nfor args in zip(*seqs):\nyield func(*args)\ndef mymap(func, *seqs):\nreturn (func(*args) for args in zip(*seqs))",
    "These versions produce the same results but return generators designed to support the\niteration protocol—the first yields one result at a time, and the second returns a generator expression’s result to do the same. They produce the same results if we wrap\nthem in list calls to force them to produce their values all at once:\nprint(list(mymap(abs, [−2, −1, 0, 1, 2])))\nprint(list(mymap(pow, [1, 2, 3], [2, 3, 4, 5])))\n\nNo work is really done here until the list calls force the generators to run, by activating\nthe iteration protocol. The generators returned by these functions themselves, as well\nas that returned by the Python 3.0 flavor of the zip built-in they use, produce results\nonly on demand.",
    "No work is really done here until the list calls force the generators to run, by activating\nthe iteration protocol. The generators returned by these functions themselves, as well\nas that returned by the Python 3.0 flavor of the zip built-in they use, produce results\nonly on demand.\n\nCoding your own zip(...) and map(None, ...)\nOf course, much of the magic in the examples shown so far lies in their use of the zip\nbuilt-in to pair arguments from multiple sequences. You’ll also note that our map\nworkalikes are really emulating the behavior of the Python 3.0 map—they truncate at\nthe length of the shortest sequence, and they do not support the notion of padding\nresults when lengths differ, as map does in Python 2.X with a None argument:\nC:\\misc> c:\\python26\\python\n>>> map(None, [1, 2, 3], [2, 3, 4, 5])\n[(1, 2), (2, 3), (3, 4), (None, 5)]\n>>> map(None, 'abc', 'xyz123')\n[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]",
    "502 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fUsing iteration tools, we can code workalikes that emulate both truncating zip and\n2.6’s padding map—these turn out to be nearly the same in code:\n# zip(seqs...) and 2.6 map(None, seqs...) workalikes\ndef myzip(*seqs):\nseqs = [list(S) for S in seqs]\nres = []\nwhile all(seqs):\nres.append(tuple(S.pop(0) for S in seqs))\nreturn res\ndef mymapPad(*seqs, pad=None):\nseqs = [list(S) for S in seqs]\nres = []\nwhile any(seqs):\nres.append(tuple((S.pop(0) if S else pad) for S in seqs))\nreturn res\nS1, S2 = 'abc', 'xyz123'\nprint(myzip(S1, S2))\nprint(mymapPad(S1, S2))\nprint(mymapPad(S1, S2, pad=99))",
    "Both of the functions coded here work on any type of iterable object, because they run\ntheir arguments through the list built-in to force result generation (e.g., files would\nwork as arguments, in addition to sequences like strings). Notice the use of the all and\nany built-ins here—these return True if all and any items in an iterable are True (or\nequivalently, nonempty), respectively. These built-ins are used to stop looping when\nany or all of the listified arguments become empty after deletions.\nAlso note the use of the Python 3.0 keyword-only argument, pad; unlike the 2.6 map,\nour version will allow any pad object to be specified (if you’re using 2.6, use a\n**kargs form to support this option instead; see Chapter 18 for details). When these\nfunctions are run, the following results are printed—a zip, and two padding maps:\n[('a', 'x'), ('b', 'y'), ('c', 'z')]\n[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]",
    "our version will allow any pad object to be specified (if you’re using 2.6, use a\n**kargs form to support this option instead; see Chapter 18 for details). When these\nfunctions are run, the following results are printed—a zip, and two padding maps:\n[('a', 'x'), ('b', 'y'), ('c', 'z')]\n[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]\n[('a', 'x'), ('b', 'y'), ('c', 'z'), (99, '1'), (99, '2'), (99, '3')]",
    "These functions aren’t amenable to list comprehension translation because their loops\nare too specific. As before, though, while our zip and map workalikes currently build\nand return result lists, it’s just as easy to turn them into generators with yield so that\nthey each return one piece of their result set at a time. The results are the same as before,\nbut we need to use list again to force the generators to yield their values for display:\n# Using generators: yield\ndef myzip(*seqs):\nseqs = [list(S) for S in seqs]\nwhile all(seqs):\nyield tuple(S.pop(0) for S in seqs)\n\nIterators Revisited: Generators | 503\n\n\fdef mymapPad(*seqs, pad=None):\nseqs = [list(S) for S in seqs]\nwhile any(seqs):\nyield tuple((S.pop(0) if S else pad) for S in seqs)\nS1, S2 = 'abc', 'xyz123'\nprint(list(myzip(S1, S2)))\nprint(list(mymapPad(S1, S2)))\nprint(list(mymapPad(S1, S2, pad=99)))",
    "Finally, here’s an alternative implementation of our zip and map emulators—rather than\ndeleting arguments from lists with the pop method, the following versions do their job\nby calculating the minimum and maximum argument lengths. Armed with these\nlengths, it’s easy to code nested list comprehensions to step through argument index\nranges:\n# Alternate implementation with lengths\ndef myzip(*seqs):\nminlen = min(len(S) for S in seqs)\nreturn [tuple(S[i] for S in seqs) for i in range(minlen)]\ndef mymapPad(*seqs, pad=None):\nmaxlen = max(len(S) for S in seqs)\nindex = range(maxlen)\nreturn [tuple((S[i] if len(S) > i else pad) for S in seqs) for i in index]\nS1, S2 = 'abc', 'xyz123'\nprint(myzip(S1, S2))\nprint(mymapPad(S1, S2))\nprint(mymapPad(S1, S2, pad=99))",
    "Because these use len and indexing, they assume that arguments are sequences or similar, not arbitrary iterables. The outer comprehensions here step through argument\nindex ranges, and the inner comprehensions (passed to tuple) step through the passedin sequences to pull out arguments in parallel. When they’re run, the results are as\nbefore.\nMost strikingly, generators and iterators seem to run rampant in this example. The\narguments passed to min and max are generator expressions, which run to completion\nbefore the nested comprehensions begin iterating. Moreover, the nested list comprehensions employ two levels of delayed evaluation—the Python 3.0 range built-in is an\niterable, as is the generator expression argument to tuple.\nIn fact, no results are produced here until the square brackets of the list comprehensions\nrequest values to place in the result list—they force the comprehensions and generators",
    "iterable, as is the generator expression argument to tuple.\nIn fact, no results are produced here until the square brackets of the list comprehensions\nrequest values to place in the result list—they force the comprehensions and generators\nto run. To turn these functions themselves into generators instead of list builders, use\nparentheses instead of square brackets again. Here’s the case for our zip:\n# Using generators: (...)\ndef myzip(*seqs):\nminlen = min(len(S) for S in seqs)",
    "504 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\freturn (tuple(S[i] for S in seqs) for i in range(minlen))\nprint(list(myzip(S1, S2)))\n\nIn this case, it takes a list call to activate the generators and iterators to produce their\nresults. Experiment with these on your own for more details. Developing further coding\nalternatives is left as a suggested exercise (see also the sidebar “Why You Will Care:\nOne-Shot Iterations” for investigation of one such option).",
    "In this case, it takes a list call to activate the generators and iterators to produce their\nresults. Experiment with these on your own for more details. Developing further coding\nalternatives is left as a suggested exercise (see also the sidebar “Why You Will Care:\nOne-Shot Iterations” for investigation of one such option).\n\nWhy You Will Care: One-Shot Iterations\nIn Chapter 14, we saw how some built-ins (like map) support only a single traversal and\nare empty after it occurs, and I promised to show you an example of how that can\nbecome subtle but important in practice. Now that we’ve studied a few more iteration\ntopics, I can make good on this promise. Consider the following clever alternative coding for this chapter’s zip emulation examples, adapted from one in Python’s manuals:\ndef myzip(*args):\niters = map(iter, args)\nwhile iters:\nres = [next(i) for i in iters]\nyield tuple(res)",
    "Because this code uses iter and next, it works on any type of iterable. Note that there\nis no reason to catch the StopIteration raised by the next(it) inside the comprehension\nhere when any one of the arguments’ iterators is exhausted—allowing it to pass ends\nthis generator function and has the same effect that a return statement would. The\nwhile iters: suffices to loop if at least one argument is passed, and avoids an infinite\nloop otherwise (the list comprehension would always return an empty list).\nThis code works fine in Python 2.6 as is:\n>>> list(myzip('abc', 'lmnop'))\n[('a', 'l'), ('b', 'm'), ('c', 'n')]",
    "But it falls into an infinite loop and fails in Python 3.0, because the 3.0 map returns a\none-shot iterable object instead of a list as in 2.6. In 3.0, as soon as we’ve run the list\ncomprehension inside the loop once, iters will be empty (and res will be []) forever.\nTo make this work in 3.0, we need to use the list built-in function to create an object\nthat can support multiple iterations:\ndef myzip(*args):\niters = list(map(iter, args))\n...rest as is...\n\nRun this on your own to trace its operation. The lesson here: wrapping map calls in\nlist calls in 3.0 is not just for display!\n\nIterators Revisited: Generators | 505",
    "Run this on your own to trace its operation. The lesson here: wrapping map calls in\nlist calls in 3.0 is not just for display!\n\nIterators Revisited: Generators | 505\n\n\fValue Generation in Built-in Types and Classes\nFinally, although we’ve focused on coding value generators ourselves in this section,\ndon’t forget that many built-in types behave in similar ways—as we saw in Chapter 14, for example, dictionaries have iterators that produce keys on each iteration:\n>>> D = {'a':1, 'b':2, 'c':3}\n>>> x = iter(D)\n>>> next(x)\n'a'\n>>> next(x)\n'c'\n\nLike the values produced by handcoded generators, dictionary keys may be iterated\nover both manually and with automatic iteration tools including for loops, map calls,\nlist comprehensions, and the many other contexts we met in Chapter 14:\n>>> for key in D:\n...\nprint(key, D[key])\n...\na 1\nc 3\nb 2",
    "Like the values produced by handcoded generators, dictionary keys may be iterated\nover both manually and with automatic iteration tools including for loops, map calls,\nlist comprehensions, and the many other contexts we met in Chapter 14:\n>>> for key in D:\n...\nprint(key, D[key])\n...\na 1\nc 3\nb 2\n\nAs we’ve also seen, for file iterators, Python simply loads lines from the file on demand:\n>>> for line in open('temp.txt'):\n...\nprint(line, end='')\n...\nTis but\na flesh wound.",
    "While built-in type iterators are bound to a specific type of value generation, the concept\nis similar to generators we code with expressions and functions. Iteration contexts like\nfor loops accept any iterable, whether user-defined or built-in.\nAlthough beyond the scope of this chapter, it is also possible to implement arbitrary\nuser-defined generator objects with classes that conform to the iteration protocol. Such\nclasses define a special __iter__ method run by the iter built-in function that returns\nan object having a __next__ method run by the next built-in function (a __getitem__\nindexing method is also available as a fallback option for iteration).\nThe instance objects created from such a class are considered iterable and may be used\nin for loops and all other iteration contexts. With classes, though, we have access to\nricher logic and data structuring options than other generator constructs can offer.",
    "indexing method is also available as a fallback option for iteration).\nThe instance objects created from such a class are considered iterable and may be used\nin for loops and all other iteration contexts. With classes, though, we have access to\nricher logic and data structuring options than other generator constructs can offer.\nThe iterator story won’t really be complete until we’ve seen how it maps to classes, too.\nFor now, we’ll have to settle for postponing its conclusion until we study class-based\niterators in Chapter 29.",
    "506 | Chapter 20: Iterations and Comprehensions, Part 2",
    "3.0 Comprehension Syntax Summary\nWe’ve been focusing on list comprehensions and generators in this chapter, but keep\nin mind that there are two other comprehension expression forms: set and dictionary\ncomprehensions are also available as of Python 3.0. We met these briefly in Chapters\n5 and 8, but with our new knowledge of comprehensions and generators, you should\nnow be able to grasp these 3.0 extensions in full:\n• For sets, the new literal form {1, 3, 2} is equivalent to set([1, 3, 2]), and the\nnew set comprehension syntax {f(x) for x in S if P(x)} is like the generator\nexpression set(f(x) for x in S if P(x)), where f(x) is an arbitrary expression.\n• For dictionaries, the new dictionary comprehension syntax {key: val for (key,\nval) in zip(keys, vals)} works like the form dict(zip(keys, vals)), and {x:\nf(x) for x in items} is like the generator expression dict((x, f(x)) for x in\nitems).\nHere’s a summary of all the comprehension alternatives in 3.0. The last two are new",
    "• For dictionaries, the new dictionary comprehension syntax {key: val for (key,\nval) in zip(keys, vals)} works like the form dict(zip(keys, vals)), and {x:\nf(x) for x in items} is like the generator expression dict((x, f(x)) for x in\nitems).\nHere’s a summary of all the comprehension alternatives in 3.0. The last two are new\nand are not available in 2.6:\n>>> [x * x for x in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]",
    "# List comprehension: builds list\n# like list(generator expr)\n\n>>> (x * x for x in range(10))\n<generator object at 0x009E7328>\n\n# Generator expression: produces items\n# Parens are often optional\n\n>>> {x * x for x in range(10)}\n{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}\n\n# Set comprehension, new in 3.0\n# {x, y} is a set in 3.0 too\n\n>>> {x: x * x for x in range(10)}\n# Dictionary comprehension, new in 3.0\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n\nComprehending Set and Dictionary Comprehensions\nIn a sense, set and dictionary comprehensions are just syntactic sugar for passing generator expressions to the type names. Because both accept any iterable, a generator\nworks well here:\n>>> {x * x for x in range(10)}\n{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}\n>>> set(x * x for x in range(10))\n{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}\n\n# Comprehension\n# Generator and type name",
    "# Comprehension\n# Generator and type name\n\n>>> {x: x * x for x in range(10)}\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n>>> dict((x, x * x) for x in range(10))\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n\nAs for list comprehensions, though, we can always build the result objects with manual\ncode, too. Here are statement-based equivalents of the last two comprehensions:\n\n3.0 Comprehension Syntax Summary | 507\n\n\f>>> res = set()\n>>> for x in range(10):\n...\nres.add(x * x)\n...\n>>> res\n{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}\n\n# Set comprehension equivalent\n\n>>> res = {}\n>>> for x in range(10):\n# Dict comprehension equivalent\n...\nres[x] = x * x\n...\n>>> res\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}",
    "3.0 Comprehension Syntax Summary | 507\n\n\f>>> res = set()\n>>> for x in range(10):\n...\nres.add(x * x)\n...\n>>> res\n{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}\n\n# Set comprehension equivalent\n\n>>> res = {}\n>>> for x in range(10):\n# Dict comprehension equivalent\n...\nres[x] = x * x\n...\n>>> res\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n\nNotice that although both forms accept iterators, they have no notion of generating\nresults on demand—both forms build objects all at once. If you mean to produce keys\nand values upon request, a generator expression is more appropriate:\n>>> G = ((x, x * x) for x in range(10))\n>>> next(G)\n(0, 0)\n>>> next(G)\n(1, 1)",
    "Notice that although both forms accept iterators, they have no notion of generating\nresults on demand—both forms build objects all at once. If you mean to produce keys\nand values upon request, a generator expression is more appropriate:\n>>> G = ((x, x * x) for x in range(10))\n>>> next(G)\n(0, 0)\n>>> next(G)\n(1, 1)\n\nExtended Comprehension Syntax for Sets and Dictionaries\nLike list comprehensions and generator expressions, both set and dictionary comprehensions support nested associated if clauses to filter items out of the result—the\nfollowing collect squares of even items (i.e., items having no remainder for division by\n2) in a range:\n>>> [x * x for x in range(10) if x % 2 == 0]\n[0, 4, 16, 36, 64]\n>>> {x * x for x in range(10) if x % 2 == 0}\n{0, 16, 4, 64, 36}\n>>> {x: x * x for x in range(10) if x % 2 == 0}\n{0: 0, 8: 64, 2: 4, 4: 16, 6: 36}\n\n# Lists are ordered\n# But sets are not\n# Neither are dict keys",
    "# Lists are ordered\n# But sets are not\n# Neither are dict keys\n\nNested for loops work as well, though the unordered and no-duplicates nature of both\ntypes of objects can make the results a bit less straightforward to decipher:\n>>> [x + y for x in [1, 2, 3] for y in [4, 5, 6]]\n[5, 6, 7, 6, 7, 8, 7, 8, 9]\n>>> {x + y for x in [1, 2, 3] for y in [4, 5, 6]}\n{8, 9, 5, 6, 7}\n>>> {x: y for x in [1, 2, 3] for y in [4, 5, 6]}\n{1: 6, 2: 6, 3: 6}\n\n# Lists keep duplicates\n# But sets do not\n# Neither do dict keys\n\nLike list comprehensions, the set and dictionary varieties can also iterate over any type\nof iterator—lists, strings, files, ranges, and anything else that supports the iteration\nprotocol:\n>>> {x + y for x in 'ab' for y in 'cd'}\n{'bd', 'ac', 'ad', 'bc'}\n\n508 | Chapter 20: Iterations and Comprehensions, Part 2",
    "# Lists keep duplicates\n# But sets do not\n# Neither do dict keys\n\nLike list comprehensions, the set and dictionary varieties can also iterate over any type\nof iterator—lists, strings, files, ranges, and anything else that supports the iteration\nprotocol:\n>>> {x + y for x in 'ab' for y in 'cd'}\n{'bd', 'ac', 'ad', 'bc'}\n\n508 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f>>> {x + y: (ord(x), ord(y)) for x in 'ab' for y in 'cd'}\n{'bd': (98, 100), 'ac': (97, 99), 'ad': (97, 100), 'bc': (98, 99)}\n>>> {k * 2 for k in ['spam', 'ham', 'sausage'] if k[0] == 's'}\n{'sausagesausage', 'spamspam'}\n>>> {k.upper(): k * 2 for k in ['spam', 'ham', 'sausage'] if k[0] == 's'}\n{'SAUSAGE': 'sausagesausage', 'SPAM': 'spamspam'}\n\nFor more details, experiment with these tools on your own. They may or may not have\na performance advantage over the generator or for loop alternatives, but we would\nhave to time their performance explicitly to be sure—which seems a natural segue to\nthe next section.",
    "Timing Iteration Alternatives\nWe’ve met quite a few iteration alternatives in this book. To summarize, let’s work\nthrough a larger case study that pulls together some of the things we’ve learned about\niteration and functions.\nI’ve mentioned a few times that list comprehensions have a speed performance advantage over for loop statements, and that map performance can be better or worse\ndepending on call patterns. The generator expressions of the prior sections tend to be\nslightly slower than list comprehensions, though they minimize memory space\nrequirements.\nAll that’s true today, but relative performance can vary over time because Python’s\ninternals are constantly being changed and optimized. If you want to verify their performance for yourself, you need to time these alternatives on your own computer and\nyour own version of Python.",
    "Timing Module\nLuckily, Python makes it easy to time code. To see how the iteration options stack up,\nlet’s start with a simple but general timer utility function coded in a module file, so it\ncan be used in a variety of programs:\n# File mytimer.py\nimport time\nreps = 1000\nrepslist = range(reps)\ndef timer(func, *pargs, **kargs):\nstart = time.clock()\nfor i in repslist:\nret = func(*pargs, **kargs)\nelapsed = time.clock() - start\nreturn (elapsed, ret)\n\nTiming Iteration Alternatives | 509",
    "Operationally, this module times calls to any function with any positional and keyword\narguments by fetching the start time, calling the function a fixed number of times, and\nsubtracting the start time from the stop time. Points to notice:\n• Python’s time module gives access to the current time, with precision that varies\nper platform. On Windows, this call is claimed to give microsecond granularity\nand so is very accurate.\n• The range call is hoisted out of the timing loop, so its construction cost is not\ncharged to the timed function in Python 2.6. In 3.0 range is an iterator, so this step\nisn’t required (but doesn’t hurt).\n• The reps count is a global that importers can change if needed: mytimer.reps = N.\nWhen complete, the total elapsed time for all calls is returned in a tuple, along with the\ntimed function’s final return value so callers can verify its operation.\nFrom a larger perspective, because this function is coded in a module file, it becomes",
    "isn’t required (but doesn’t hurt).\n• The reps count is a global that importers can change if needed: mytimer.reps = N.\nWhen complete, the total elapsed time for all calls is returned in a tuple, along with the\ntimed function’s final return value so callers can verify its operation.\nFrom a larger perspective, because this function is coded in a module file, it becomes\na generally useful tool anywhere we wish to import it. You’ll learn more about modules\nand imports in the next part of this book, but you’ve already seen enough of the basics\nto make sense of this code—simply import the module and call the function to use this\nfile’s timer (and see Chapter 3’s coverage of module attributes if you need a refresher).",
    "Timing Script\nNow, to time iteration tool speed, run the following script—it uses the timer module\nwe just wrote to time the relative speeds of the various list construction techniques\nwe’ve studied:\n# File timeseqs.py\nimport sys, mytimer\nreps = 10000\nrepslist = range(reps)\n\n# Import timer function\n# Hoist range out in 2.6\n\ndef forLoop():\nres = []\nfor x in repslist:\nres.append(abs(x))\nreturn res\ndef listComp():\nreturn [abs(x) for x in repslist]\ndef mapCall():\nreturn list(map(abs, repslist))\n\n# Use list in 3.0 only\n\ndef genExpr():\nreturn list(abs(x) for x in repslist)\n\n# list forces results\n\ndef genFunc():\ndef gen():\n\n510 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\ffor x in repslist:\nyield abs(x)\nreturn list(gen())\nprint(sys.version)\nfor test in (forLoop, listComp, mapCall, genExpr, genFunc):\nelapsed, result = mytimer.timer(test)\nprint ('-' * 33)\nprint ('%-9s: %.5f => [%s...%s]' %\n(test.__name__, elapsed, result[0], result[-1]))",
    "This script tests five alternative ways to build lists of results and, as shown, executes\non the order of 10 million steps for each—that is, each of the five tests builds a list of\n10,000 items 1,000 times.\nNotice how we have to run the generator expression and function results through the\nbuilt-in list call to force them to yield all of their values; if we did not, we would just\nproduce generators that never do any real work. In Python 3.0 (only) we must do\nthe same for the map result, since it is now an iterable object as well. Also notice how\nthe code at the bottom steps through a tuple of four function objects and prints the\n__name__ of each: as we’ve seen, this is a built-in attribute that gives a function’s name.",
    "Timing Results\nWhen the script of the prior section is run under Python 3.0, I get the following results\non my Windows Vista laptop—map is slightly faster than list comprehensions, both are\nsubstantially quicker than for loops, and generator expressions and functions place in\nthe middle:\nC:\\misc> c:\\python30\\python timeseqs.py\n3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]\n--------------------------------forLoop : 2.64441 => [0...9999]\n--------------------------------listComp : 1.60110 => [0...9999]\n--------------------------------mapCall : 1.41977 => [0...9999]\n--------------------------------genExpr : 2.21758 => [0...9999]\n--------------------------------genFunc : 2.18696 => [0...9999]",
    "If you study this code and its output long enough, you’ll notice that generator expressions run slower than list comprehensions. Although wrapping a generator expression\nin a list call makes it functionally equivalent to a square-bracketed list comprehension,\nthe internal implementations of the two expressions appear to differ (though we’re also\neffectively timing the list call for the generator test):\nreturn [abs(x) for x in range(size)]\nreturn list(abs(x) for x in range(size))\n\n# 1.6 seconds\n# 2.2 seconds: differs internally\n\nTiming Iteration Alternatives | 511",
    "# 1.6 seconds\n# 2.2 seconds: differs internally\n\nTiming Iteration Alternatives | 511\n\n\fInterestingly, when I ran this on Windows XP with Python 2.5 for the prior edition of\nthis book, the results were relatively similar—list comprehensions were nearly twice as\nfast as equivalent for loop statements, and map was slightly quicker than list comprehensions when mapping a built-in function such as abs (absolute value). I didn’t test\ngenerator functions then, and the output format wasn’t quite as grandiose:\n2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)]\nforStatement\n=> 6.10899996758\nlistComprehension\n=> 3.51499986649\nmapFunction\n=> 2.73399996758\ngeneratorExpression => 4.11600017548",
    "The fact that the actual 2.5 test times listed here are over two times as slow as the output\nI showed earlier is likely due to my using a quicker laptop for the more recent test, not\ndue to improvements in Python 3.0. In fact, all the 2.6 results for this script are slightly\nquicker than 3.0 on this same machine if the list call is removed from the map test to\navoid creating the results list twice (try this on your own to verify).\nWatch what happens, though, if we change this script to perform a real operation on\neach iteration, such as addition, instead of calling a trivial built-in function like abs (the\nomitted parts of the following are the same as before):\n# File timeseqs.py\n...\n...\ndef forLoop():\nres = []\nfor x in repslist:\nres.append(x + 10)\nreturn res\ndef listComp():\nreturn [x + 10 for x in repslist]\ndef mapCall():\nreturn list(map((lambda x: x + 10), repslist))\n\n# list in 3.0 only\n\ndef genExpr():\nreturn list(x + 10 for x in repslist)\n\n# list in 2.6 + 3.0",
    "# list in 3.0 only\n\ndef genExpr():\nreturn list(x + 10 for x in repslist)\n\n# list in 2.6 + 3.0\n\ndef genFunc():\ndef gen():\nfor x in repslist:\nyield x + 10\nreturn list(gen())\n...\n...\n\nNow the need to call a user-defined function for the map call makes it slower than the\nfor loop statements, despite the fact that the looping statements version is larger in\nterms of code. On Python 3.0:\nC:\\misc> c:\\python30\\python timeseqs.py\n3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]\n\n512 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f--------------------------------forLoop : 2.60754 => [10...10009]\n--------------------------------listComp : 1.57585 => [10...10009]\n--------------------------------mapCall : 3.10276 => [10...10009]\n--------------------------------genExpr : 1.96482 => [10...10009]\n--------------------------------genFunc : 1.95340 => [10...10009]",
    "512 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f--------------------------------forLoop : 2.60754 => [10...10009]\n--------------------------------listComp : 1.57585 => [10...10009]\n--------------------------------mapCall : 3.10276 => [10...10009]\n--------------------------------genExpr : 1.96482 => [10...10009]\n--------------------------------genFunc : 1.95340 => [10...10009]\n\nThe Python 2.5 results on a slower machine were again relatively similar in the prior\nedition, but twice as slow due to test machine differences:\n2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)]\nforStatement\n=> 5.25699996948\nlistComprehension\n=> 2.68400001526\nmapFunction\n=> 5.96900010109\ngeneratorExpression => 3.37400007248",
    "Because the interpreter optimizes so much internally, performance analysis of Python\ncode like this is a very tricky affair. It’s virtually impossible to guess which method will\nperform the best—the best you can do is time your own code, on your computer, with\nyour version of Python. In this case, all we should say for certain is that on this Python,\nusing a user-defined function in map calls can slow performance by at least a factor of\n2, and that list comprehensions run quickest for this test.\nAs I’ve mentioned before, however, performance should not be your primary concern\nwhen writing Python code—the first thing you should do to optimize Python code is\nto not optimize Python code! Write for readability and simplicity first, then optimize\nlater, if and only if needed. It could very well be that any of the five alternatives is quick\nenough for the data sets your program needs to process; if so, program clarity should\nbe the chief goal.",
    "Timing Module Alternatives\nThe timing module of the prior section works, but it’s a bit primitive on multiple fronts:\n• It always uses the time.clock call to time code. While that option is best on Windows, the time.time call may provide better resolution on some Unix platforms.\n• Adjusting the number of repetitions requires changing module-level globals—a\nless than ideal arrangement if the timer function is being used and shared by multiple importers.\n• As is, the timer works by running the test function a large number of times. To\naccount for random system load fluctuations, it might be better to select the best\ntime among all the tests, instead of the total time.\nThe following alternative implements a more sophisticated timer module that addresses\nall three points by selecting a timer call based on platform, allowing the repeat count\n\nTiming Iteration Alternatives | 513",
    "Timing Iteration Alternatives | 513\n\n\fto be passed in as a keyword argument named _reps, and providing a best-of-N alternative timing function:\n# File mytimer.py (2.6 and 3.0)\n\"\"\"\ntimer(spam, 1, 2, a=3, b=4, _reps=1000) calls and times spam(1, 2, a=3)\n_reps times, and returns total time for all runs, with final result;\nbest(spam, 1, 2, a=3, b=4, _reps=50) runs best-of-N timer to filter out\nany system load variation, and returns best time among _reps tests\n\"\"\"\nimport time, sys\nif sys.platform[:3] == 'win':\ntimefunc = time.clock\nelse:\ntimefunc = time.time\n\n# Use time.clock on Windows\n\ndef trace(*args): pass\n\n# Or: print args\n\ndef timer(func, *pargs, **kargs):\n_reps = kargs.pop('_reps', 1000)\ntrace(func, pargs, kargs, _reps)\nrepslist = range(_reps)\nstart = timefunc()\nfor i in repslist:\nret = func(*pargs, **kargs)\nelapsed = timefunc() - start\nreturn (elapsed, ret)\n\n# Better resolution on some Unix platforms\n\n# Passed-in or default reps\n# Hoist range out for 2.6 lists",
    "def trace(*args): pass\n\n# Or: print args\n\ndef timer(func, *pargs, **kargs):\n_reps = kargs.pop('_reps', 1000)\ntrace(func, pargs, kargs, _reps)\nrepslist = range(_reps)\nstart = timefunc()\nfor i in repslist:\nret = func(*pargs, **kargs)\nelapsed = timefunc() - start\nreturn (elapsed, ret)\n\n# Better resolution on some Unix platforms\n\n# Passed-in or default reps\n# Hoist range out for 2.6 lists\n\ndef best(func, *pargs, **kargs):\n_reps = kargs.pop('_reps', 50)\nbest = 2 ** 32\nfor i in range(_reps):\n(time, ret) = timer(func, *pargs, _reps=1, **kargs)\nif time < best: best = time\nreturn (best, ret)",
    "# Better resolution on some Unix platforms\n\n# Passed-in or default reps\n# Hoist range out for 2.6 lists\n\ndef best(func, *pargs, **kargs):\n_reps = kargs.pop('_reps', 50)\nbest = 2 ** 32\nfor i in range(_reps):\n(time, ret) = timer(func, *pargs, _reps=1, **kargs)\nif time < best: best = time\nreturn (best, ret)\n\nThis module’s docstring at the top of the file describes its intended usage. It uses dictionary pop operations to remove the _reps argument from arguments intended for the\ntest function and provide it with a default, and it traces arguments during development\nif you change its trace function to print. To test with this new timer module on either\nPython 3.0 or 2.6, change the timing script as follows (the omitted code in the test\nfunctions of this version use the x + 1 operation for each test, as coded in the prior\nsection):\n# File timeseqs.py\nimport sys, mytimer\nreps = 10000\nrepslist = range(reps)\ndef forLoop(): ...\n\n514 | Chapter 20: Iterations and Comprehensions, Part 2",
    "514 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fdef listComp(): ...\ndef mapCall(): ...\ndef genExpr(): ...\ndef genFunc(): ...\nprint(sys.version)\nfor tester in (mytimer.timer, mytimer.best):\nprint('<%s>' % tester.__name__)\nfor test in (forLoop, listComp, mapCall, genExpr, genFunc):\nelapsed, result = tester(test)\nprint ('-' * 35)\nprint ('%-9s: %.5f => [%s...%s]' %\n(test.__name__, elapsed, result[0], result[-1]))",
    "When run under Python 3.0, the timing results are essentially the same as before, and\nrelatively the same for both to the total-of-N and best-of-N timing techniques—running\ntests many times seems to do as good a job filtering out system load fluctuations as\ntaking the best case, but the best-of-N scheme may be better when testing a longrunning function. The results on my machine are as follows:\nC:\\misc> c:\\python30\\python timeseqs.py\n3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]\n<timer>\n----------------------------------forLoop : 2.35371 => [10...10009]\n----------------------------------listComp : 1.29640 => [10...10009]\n----------------------------------mapCall : 3.16556 => [10...10009]\n----------------------------------genExpr : 1.97440 => [10...10009]\n----------------------------------genFunc : 1.95072 => [10...10009]\n<best>\n----------------------------------forLoop : 0.00193 => [10...10009]",
    "----------------------------------listComp : 1.29640 => [10...10009]\n----------------------------------mapCall : 3.16556 => [10...10009]\n----------------------------------genExpr : 1.97440 => [10...10009]\n----------------------------------genFunc : 1.95072 => [10...10009]\n<best>\n----------------------------------forLoop : 0.00193 => [10...10009]\n----------------------------------listComp : 0.00124 => [10...10009]\n----------------------------------mapCall : 0.00268 => [10...10009]\n----------------------------------genExpr : 0.00164 => [10...10009]\n----------------------------------genFunc : 0.00165 => [10...10009]",
    "The times reported by the best-of-N timer here are small, of course, but they might\nbecome significant if your program iterates many times over large data sets. At least in\nterms of relative performance, list comprehensions appear best in most cases; map is\nonly slightly better when built-ins are applied.\n\nTiming Iteration Alternatives | 515",
    "Using keyword-only arguments in 3.0\nWe can also make use of Python 3.0 keyword-only arguments here to simplify the timer\nmodule’s code. As we learned in Chapter 19, keyword-only arguments are ideal for\nconfiguration options such as our functions’ _reps argument. They must be coded after\na * and before a ** in the function header, and in a function call they must be passed\nby keyword and appear before the ** if used. Here’s a keyword-only-based alternative\nto the prior module. Though simpler, it compiles and runs under Python 3.X only, not\n2.6:\n# File mytimer.py (3.X only)\n\"\"\"\nUse 3.0 keyword-only default arguments, instead of ** and dict pops.\nNo need to hoist range() out of test in 3.0: a generator, not a list\n\"\"\"\nimport time, sys\ntrace = lambda *args: None # or print\ntimefunc = time.clock if sys.platform == 'win32' else time.time\ndef timer(func, *pargs, _reps=1000, **kargs):\ntrace(func, pargs, kargs, _reps)\nstart = timefunc()\nfor i in range(_reps):\nret = func(*pargs, **kargs)",
    "No need to hoist range() out of test in 3.0: a generator, not a list\n\"\"\"\nimport time, sys\ntrace = lambda *args: None # or print\ntimefunc = time.clock if sys.platform == 'win32' else time.time\ndef timer(func, *pargs, _reps=1000, **kargs):\ntrace(func, pargs, kargs, _reps)\nstart = timefunc()\nfor i in range(_reps):\nret = func(*pargs, **kargs)\nelapsed = timefunc() - start\nreturn (elapsed, ret)\ndef best(func, *pargs, _reps=50, **kargs):\nbest = 2 ** 32\nfor i in range(_reps):\n(time, ret) = timer(func, *pargs, _reps=1, **kargs)\nif time < best: best = time\nreturn (best, ret)",
    "This version is used the same way as and produces results identical to the prior version,\nnot counting negligible test time differences from run to run:\nC:\\misc> c:\\python30\\python timeseqs.py\n...same results as before...\n\nIn fact, for variety we can also test this version of the module from the interactive\nprompt, completely independent of the sequence timer script—it’s a general-purpose\ntool:\nC:\\misc> c:\\python30\\python\n>>> from mytimer import timer, best\n>>>\n>>> def power(X, Y): return X ** Y\n...\n>>> timer(power, 2, 32)\n(0.002625403507987747, 4294967296)\n>>> timer(power, 2, 32, _reps=1000000)\n\n516 | Chapter 20: Iterations and Comprehensions, Part 2\n\n# Test function\n# Total time, last result\n# Override defult reps\n\n\f(1.1822605247314932, 4294967296)\n>>> timer(power, 2, 100000)[0]\n2.2496919999608878\n>>> best(power, 2, 32)\n(5.58730229727189e-06, 4294967296)\n>>> best(power, 2, 100000)[0]\n0.0019937589833460834\n>>> best(power, 2, 100000, _reps=500)[0]\n0.0019845399345541637",
    "516 | Chapter 20: Iterations and Comprehensions, Part 2\n\n# Test function\n# Total time, last result\n# Override defult reps\n\n\f(1.1822605247314932, 4294967296)\n>>> timer(power, 2, 100000)[0]\n2.2496919999608878\n>>> best(power, 2, 32)\n(5.58730229727189e-06, 4294967296)\n>>> best(power, 2, 100000)[0]\n0.0019937589833460834\n>>> best(power, 2, 100000, _reps=500)[0]\n0.0019845399345541637\n\n# 2 ** 100,000 tot time @1,000 reps\n# Best time, last result\n# 2 ** 100,000 best time\n# Override default reps",
    "# 2 ** 100,000 tot time @1,000 reps\n# Best time, last result\n# 2 ** 100,000 best time\n# Override default reps\n\nFor trivial functions like the one tested in this interactive session, the costs of the timer’s\ncode are probably as significant as those of the timed function, so you should not take\ntimer results too absolutely (we are timing more than just X ** Y here). The timer’s\nresults can help you judge relative speeds of coding alternatives, though, and may be\nmore meaningful for longer-running operations like the following—calculating 2 to the\npower one million takes an order of magnitude (power of 10) longer than the preceding\n2**100,000:\n>>> timer(power, 2, 1000000, _reps=1)[0]\n0.088112804839710179\n>>> timer(power, 2, 1000000, _reps=10)[0]\n0.40922470593329763\n\n# 2 ** 1,000,000: total time\n\n>>> best(power, 2, 1000000, _reps=1)[0]\n0.086550036387279761\n>>> best(power, 2, 1000000, _reps=10)[0]\n0.029616752967200455\n>>> best(power, 2, 1000000, _reps=50)[0]\n0.029486918030102061",
    "# 2 ** 1,000,000: total time\n\n>>> best(power, 2, 1000000, _reps=1)[0]\n0.086550036387279761\n>>> best(power, 2, 1000000, _reps=10)[0]\n0.029616752967200455\n>>> best(power, 2, 1000000, _reps=50)[0]\n0.029486918030102061\n\n# 2 ** 1,000,000: best time\n# 10 is sometimes as good as 50\n# Best resolution\n\nAgain, although the times measured here are small, the differences can be significant\nin programs that compute powers often.\nSee Chapter 19 for more on keyword-only arguments in 3.0; they can simplify code for\nconfigurable tools like this one but are not backward compatible with 2.X Pythons. If\nyou want to compare 2.X and 3.X speed, for example, or support programmers using\neither Python line, the prior version is likely a better choice. If you’re using Python 2.6,\nthe above session runs the same with the prior version of the timer module.",
    "Other Suggestions\nFor more insight, try modifying the repetition counts used by these modules, or explore\nthe alternative timeit module in Python’s standard library, which automates timing of\ncode, supports command-line usage modes, and finesses some platform-specific issues.\nPython’s manuals document its use.\nYou might also want to look at the profile standard library module for a complete\nsource code profiler tool—we’ll learn more about it in Chapter 35 in the context of\ndevelopment tools for large projects. In general, you should profile code to isolate bottlenecks before recoding and timing alternatives as we’ve done here.\nTiming Iteration Alternatives | 517",
    "It might be useful as well to experiment with using the new str.format method in\nPython 2.6 and 3.0 instead of the % formatting expression (which could potentially be\ndeprecated in the future!), by changing the timing script’s formatted print lines as\nfollows:\nprint('<%s>' % tester.__name__)\nprint('<{0}>'.format(tester.__name__))\n\n# From expression\n# To method call\n\nprint ('%-9s: %.5f => [%s...%s]' %\n(test.__name__, elapsed, result[0], result[-1]))\nprint('{0:<9}: {1:.5f} => [{2}...{3}]'.format(\ntest.__name__, elapsed, result[0], result[-1]))",
    "print ('%-9s: %.5f => [%s...%s]' %\n(test.__name__, elapsed, result[0], result[-1]))\nprint('{0:<9}: {1:.5f} => [{2}...{3}]'.format(\ntest.__name__, elapsed, result[0], result[-1]))\n\nYou can judge the difference between these techniques yourself.\nIf you feel ambitious, you might also try modifying or emulating the timing script to\nmeasure the speed of the 3.0 set and dictionary comprehensions illustrated in this chapter, and their for loop equivalents. Since using them is much less common in Python\nprograms than building lists of results, we’ll leave this task in the suggested exercise\ncolumn (and please, no wagering...).\nFinally, keep the timing module we wrote here filed away for future reference—we’ll\nrepurpose it to measure performance of alternative numeric square root operations in\nan exercise at the end of this chapter. If you’re interested in pursuing this topic further,\nwe’ll also experiment with techniques for timing dictionary comprehensions versus\nfor loops interactively.",
    "Function Gotchas\nNow that we’ve reached the end of the function story, let’s review some common pitfalls. Functions have some jagged edges that you might not expect. They’re all obscure,\nand a few have started to fall away from the language completely in recent releases, but\nmost have been known to trip up new users.\n\nLocal Names Are Detected Statically\nAs you know, Python classifies names assigned in a function as locals by default; they\nlive in the function’s scope and exist only while the function is running. What you may\nnot realize is that Python detects locals statically, when it compiles the def’s code, rather\nthan by noticing assignments as they happen at runtime. This leads to one of the most\ncommon oddities posted on the Python newsgroup by beginners.\nNormally, a name that isn’t assigned in a function is looked up in the enclosing module:\n\n518 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f>>> X = 99\n>>> def selector():\n...\nprint(X)\n...\n>>> selector()\n99",
    "518 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\f>>> X = 99\n>>> def selector():\n...\nprint(X)\n...\n>>> selector()\n99\n\n# X used but not assigned\n# X found in global scope\n\nHere, the X in the function resolves to the X in the module. But watch what happens if\nyou add an assignment to X after the reference:\n>>> def selector():\n...\nprint(X)\n# Does not yet exist!\n...\nX = 88\n# X classified as a local name (everywhere)\n...\n# Can also happen for \"import X\", \"def X\"...\n>>> selector()\n...error text omitted...\nUnboundLocalError: local variable 'X' referenced before assignment",
    "You get the name usage error shown here, but the reason is subtle. Python reads and\ncompiles this code when it’s typed interactively or imported from a module. While\ncompiling, Python sees the assignment to X and decides that X will be a local name\neverywhere in the function. But when the function is actually run, because the assignment hasn’t yet happened when the print executes, Python says you’re using an undefined name. According to its name rules, it should say this; the local X is used before\nbeing assigned. In fact, any assignment in a function body makes a name local. Imports,\n=, nested defs, nested classes, and so on are all susceptible to this behavior.\nThe problem occurs because assigned names are treated as locals everywhere in a function, not just after the statements where they are assigned. Really, the previous example\nis ambiguous at best: was the intention to print the global X and then create a local X,",
    "=, nested defs, nested classes, and so on are all susceptible to this behavior.\nThe problem occurs because assigned names are treated as locals everywhere in a function, not just after the statements where they are assigned. Really, the previous example\nis ambiguous at best: was the intention to print the global X and then create a local X,\nor is this a genuine programming error? Because Python treats X as a local everywhere,\nit is viewed as an error; if you really mean to print the global X, you need to declare it\nin a global statement:\n>>> def selector():\n...\nglobal X\n...\nprint(X)\n...\nX = 88\n...\n>>> selector()\n99",
    "# Force X to be global (everywhere)\n\nRemember, though, that this means the assignment also changes the global X, not a\nlocal X. Within a function, you can’t use both local and global versions of the same\nsimple name. If you really meant to print the global and then set a local of the same\nname, you’d need to import the enclosing module and use module attribute notation\nto get to the global version:\n>>> X = 99\n>>> def selector():\n...\nimport __main__\n...\nprint(__main__.X)\n...\nX = 88\n\n# Import enclosing module\n# Qualify to get to global version of name\n# Unqualified X classified as local\n\nFunction Gotchas | 519\n\n\f...\nprint(X)\n...\n>>> selector()\n99\n88\n\n# Prints local version of name",
    "# Import enclosing module\n# Qualify to get to global version of name\n# Unqualified X classified as local\n\nFunction Gotchas | 519\n\n\f...\nprint(X)\n...\n>>> selector()\n99\n88\n\n# Prints local version of name\n\nQualification (the .X part) fetches a value from a namespace object. The interactive\nnamespace is a module called __main__, so __main__.X reaches the global version of X.\nIf that isn’t clear, check out Chapter 17.\nIn recent versions Python has improved on this story somewhat by issuing for this case\nthe more specific “unbound local” error message shown in the example listing (it used\nto simply raise a generic name error); this gotcha is still present in general, though.",
    "Defaults and Mutable Objects\nDefault argument values are evaluated and saved when a def statement is run, not when\nthe resulting function is called. Internally, Python saves one object per default argument\nattached to the function itself.\nThat’s usually what you want—because defaults are evaluated at def time, it lets you\nsave values from the enclosing scope, if needed. But because a default retains an object\nbetween calls, you have to be careful about changing mutable defaults. For instance,\nthe following function uses an empty list as a default value, and then changes it in-place\neach time the function is called:\n>>> def saver(x=[]):\n...\nx.append(1)\n...\nprint(x)\n...\n>>> saver([2])\n[2, 1]\n>>> saver()\n[1]\n>>> saver()\n[1, 1]\n>>> saver()\n[1, 1, 1]\n\n# Saves away a list object\n# Changes same object each time!\n# Default not used\n# Default used\n# Grows on each call!",
    "# Saves away a list object\n# Changes same object each time!\n# Default not used\n# Default used\n# Grows on each call!\n\nSome see this behavior as a feature—because mutable default arguments retain their\nstate between function calls, they can serve some of the same roles as static local function variables in the C language. In a sense, they work sort of like global variables, but\ntheir names are local to the functions and so will not clash with names elsewhere in a\nprogram.\nTo most observers, though, this seems like a gotcha, especially the first time they run\ninto it. There are better ways to retain state between calls in Python (e.g., using classes,\nwhich will be discussed in Part VI).\nMoreover, mutable defaults are tricky to remember (and to understand at all). They\ndepend upon the timing of default object construction. In the prior example, there is\n\n520 | Chapter 20: Iterations and Comprehensions, Part 2",
    "520 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fjust one list object for the default value—the one created when the def is executed. You\ndon’t get a new list every time the function is called, so the list grows with each new\nappend; it is not reset to empty on each call.\nIf that’s not the behavior you want, simply make a copy of the default at the start of\nthe function body, or move the default value expression into the function body. As long\nas the value resides in code that’s actually executed each time the function runs, you’ll\nget a new object each time through:\n>>> def saver(x=None):\n...\nif x is None:\n...\nx = []\n...\nx.append(1)\n...\nprint(x)\n...\n>>> saver([2])\n[2, 1]\n>>> saver()\n[1]\n>>> saver()\n[1]\n\n# No argument passed?\n# Run code to make a new list\n# Changes new list object\n\n# Doesn't grow here",
    "By the way, the if statement in this example could almost be replaced by the assignment\nx = x or [], which takes advantage of the fact that Python’s or returns one of its\noperand objects: if no argument was passed, x would default to None, so the or would\nreturn the new empty list on the right.\nHowever, this isn’t exactly the same. If an empty list were passed in, the or expression\nwould cause the function to extend and return a newly created list, rather than extending and returning the passed-in list like the if version. (The expression becomes\n[] or [], which evaluates to the new empty list on the right; see the section “Truth\nTests” on page 320 if you don’t recall why). Real program requirements may call for\neither behavior.\nToday, another way to achieve the effect of mutable defaults in a possibly less confusing\nway is to use the function attributes we discussed in Chapter 19:\n>>> def saver():\n...\nsaver.x.append(1)\n...\nprint(saver.x)\n...\n>>> saver.x = []\n>>> saver()\n[1]",
    "Tests” on page 320 if you don’t recall why). Real program requirements may call for\neither behavior.\nToday, another way to achieve the effect of mutable defaults in a possibly less confusing\nway is to use the function attributes we discussed in Chapter 19:\n>>> def saver():\n...\nsaver.x.append(1)\n...\nprint(saver.x)\n...\n>>> saver.x = []\n>>> saver()\n[1]\n>>> saver()\n[1, 1]\n>>> saver()\n[1, 1, 1]",
    "The function name is global to the function itself, but it need not be declared because\nit isn’t changed directly within the function. This isn’t used in exactly the same way,\n\nFunction Gotchas | 521\n\n\fbut when coded like this, the attachment of an object to the function is much more\nexplicit (and arguably less magical).\n\nFunctions Without returns\nIn Python functions, return (and yield) statements are optional. When a function\ndoesn’t return a value explicitly, the function exits when control falls off the end of the\nfunction body. Technically, all functions return a value; if you don’t provide a return\nstatement, your function returns the None object automatically:\n>>> def proc(x):\n...\nprint(x)\n...\n>>> x = proc('testing 123...')\ntesting 123...\n>>> print(x)\nNone\n\n# No return is a None return",
    "# No return is a None return\n\nFunctions such as this without a return are Python’s equivalent of what are called\n“procedures” in some languages. They’re usually invoked as statements, and the None\nresults are ignored, as they do their business without computing a useful result.\nThis is worth knowing, because Python won’t tell you if you try to use the result of a\nfunction that doesn’t return one. For instance, assigning the result of a list append\nmethod won’t raise an error, but you’ll get back None, not the modified list:\n>>> list = [1, 2, 3]\n>>> list = list.append(4)\n>>> print(list)\nNone\n\n# append is a \"procedure\"\n# append changes list in-place\n\nAs mentioned in “Common Coding Gotchas” on page 387 in Chapter 15, such functions do their business as a side effect and are usually designed to be run as statements,\nnot expressions.",
    "# append is a \"procedure\"\n# append changes list in-place\n\nAs mentioned in “Common Coding Gotchas” on page 387 in Chapter 15, such functions do their business as a side effect and are usually designed to be run as statements,\nnot expressions.\n\nEnclosing Scope Loop Variables\nWe described this gotcha in Chapter 17’s discussion of enclosing function scopes, but\nas a reminder, be careful about relying on enclosing function scope lookup for variables\nthat are changed by enclosing loops—all such references will remember the value of\nthe last loop iteration. Use defaults to save loop variable values instead (see Chapter 17 for more details on this topic).\n\nChapter Summary\nThis chapter wrapped up our coverage of built-in comprehension and iteration tools.\nIt explored list comprehensions in the context of functional tools and presented generator functions and expressions as additional iteration protocol tools. As a finale, we\n\n522 | Chapter 20: Iterations and Comprehensions, Part 2",
    "522 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\falso measured the performance of iteration alternatives, and we closed with a review\nof common function-related mistakes to help you avoid pitfalls.\nThis concludes the functions part of this book. In the next part, we will study modules—\nthe topmost organizational structure in Python, and the structure in which our functions always live. After that, we will explore classes, tools that are largely packages of\nfunctions with special first arguments. As we’ll see, user-defined classes can implement\nobjects that tap into the iteration protocol, just like the generators and iterables we met\nhere. Everything we have learned in this part of the book will apply when functions\npop up later in the context of class methods.\nBefore moving on to modules, though, be sure to work through this chapter’s quiz and\nthe exercises for this part of the book, to practice what we’ve learned about functions\nhere.",
    "Test Your Knowledge: Quiz\n1. What is the difference between enclosing a list comprehension in square brackets\nand parentheses?\n2. How are generators and iterators related?\n3. How can you tell if a function is a generator function?\n4. What does a yield statement do?\n5. How are map calls and list comprehensions related? Compare and contrast the two.",
    "Test Your Knowledge: Answers\n1. List comprehensions in square brackets produce the result list all at once in memory. When they are enclosed in parentheses instead, they are actually generator\nexpressions—they have a similar meaning but do not produce the result list all at\nonce. Instead, generator expressions return a generator object, which yields one\nitem in the result at a time when used in an iteration context.\n2. Generators are objects that support the iteration protocol—they have a __next__\nmethod that repeatedly advances to the next item in a series of results and raises\nan exception at the end of the series. In Python, we can code generator functions\nwith def, generator expressions with parenthesized list comprehensions, and generator objects with classes that define a special method named __iter__ (discussed\nlater in the book).\n3. A generator function has a yield statement somewhere in its code. Generator",
    "an exception at the end of the series. In Python, we can code generator functions\nwith def, generator expressions with parenthesized list comprehensions, and generator objects with classes that define a special method named __iter__ (discussed\nlater in the book).\n3. A generator function has a yield statement somewhere in its code. Generator\nfunctions are otherwise identical to normal functions syntactically, but they are\ncompiled specially by Python so as to return an iterable object when called.",
    "Test Your Knowledge: Answers | 523",
    "4. When present, this statement makes Python compile the function specially as a\ngenerator; when called, the function returns a generator object that supports the\niteration protocol. When the yield statement is run, it sends a result back to the\ncaller and suspends the function’s state; the function can then be resumed after the\nlast yield statement, in response to a next built-in or __next__ method call issued\nby the caller. Generator functions may also have a return statement, which terminates the generator.\n5. The map call is similar to a list comprehension—both build a new list by collecting\nthe results of applying an operation to each item in a sequence or other iterable,\none item at a time. The main difference is that map applies a function call to each\nitem, and list comprehensions apply arbitrary expressions. Because of this, list\ncomprehensions are more general; they can apply a function call expression like",
    "the results of applying an operation to each item in a sequence or other iterable,\none item at a time. The main difference is that map applies a function call to each\nitem, and list comprehensions apply arbitrary expressions. Because of this, list\ncomprehensions are more general; they can apply a function call expression like\nmap, but map requires a function to apply other kinds of expressions. List comprehensions also support extended syntax such as nested for loops and if clauses that\nsubsume the filter built-in.",
    "Test Your Knowledge: Part IV Exercises\nIn these exercises, you’re going to start coding more sophisticated programs. Be sure\nto check the solutions in “Part IV, Functions” on page 1111 in Appendix B, and be\nsure to start writing your code in module files. You won’t want to retype these exercises\nfrom scratch if you make a mistake.\n1. The basics. At the Python interactive prompt, write a function that prints its single\nargument to the screen and call it interactively, passing a variety of object types:\nstring, integer, list, dictionary. Then, try calling it without passing any argument.\nWhat happens? What happens when you pass two arguments?\n2. Arguments. Write a function called adder in a Python module file. The function\nshould accept two arguments and return the sum (or concatenation) of the two.\nThen, add code at the bottom of the file to call the adder function with a variety of\nobject types (two strings, two lists, two floating points), and run this file as a script",
    "What happens? What happens when you pass two arguments?\n2. Arguments. Write a function called adder in a Python module file. The function\nshould accept two arguments and return the sum (or concatenation) of the two.\nThen, add code at the bottom of the file to call the adder function with a variety of\nobject types (two strings, two lists, two floating points), and run this file as a script\nfrom the system command line. Do you have to print the call statement results to\nsee results on your screen?\n3. varargs. Generalize the adder function you wrote in the last exercise to compute\nthe sum of an arbitrary number of arguments, and change the calls to pass more\nor fewer than two arguments. What type is the return value sum? (Hints: a slice\nsuch as S[:0] returns an empty sequence of the same type as S, and the type builtin function can test types; but see the manually coded min examples in Chapter 18 for a simpler approach.) What happens if you pass in arguments of different",
    "the sum of an arbitrary number of arguments, and change the calls to pass more\nor fewer than two arguments. What type is the return value sum? (Hints: a slice\nsuch as S[:0] returns an empty sequence of the same type as S, and the type builtin function can test types; but see the manually coded min examples in Chapter 18 for a simpler approach.) What happens if you pass in arguments of different\ntypes? What about passing in dictionaries?",
    "524 | Chapter 20: Iterations and Comprehensions, Part 2",
    "4. Keywords. Change the adder function from exercise 2 to accept and sum/concatenate three arguments: def adder(good, bad, ugly). Now, provide default values\nfor each argument, and experiment with calling the function interactively. Try\npassing one, two, three, and four arguments. Then, try passing keyword arguments. Does the call adder(ugly=1, good=2) work? Why? Finally, generalize the\nnew adder to accept and sum/concatenate an arbitrary number of keyword arguments. This is similar to what you did in exercise 3, but you’ll need to iterate over\na dictionary, not a tuple. (Hint: the dict.keys method returns a list you can step\nthrough with a for or while, but be sure to wrap it in a list call to index it in 3.0!)\n5. Write a function called copyDict(dict) that copies its dictionary argument. It\nshould return a new dictionary containing all the items in its argument. Use the\ndictionary keys method to iterate (or, in Python 2.2, step over a dictionary’s keys",
    "through with a for or while, but be sure to wrap it in a list call to index it in 3.0!)\n5. Write a function called copyDict(dict) that copies its dictionary argument. It\nshould return a new dictionary containing all the items in its argument. Use the\ndictionary keys method to iterate (or, in Python 2.2, step over a dictionary’s keys\nwithout calling keys). Copying sequences is easy (X[:] makes a top-level copy);\ndoes this work for dictionaries, too?\n6. Write a function called addDict(dict1, dict2) that computes the union of two\ndictionaries. It should return a new dictionary containing all the items in both its\narguments (which are assumed to be dictionaries). If the same key appears in both\narguments, feel free to pick a value from either. Test your function by writing it in\na file and running the file as a script. What happens if you pass lists instead of\ndictionaries? How could you generalize your function to handle this case, too?",
    "arguments (which are assumed to be dictionaries). If the same key appears in both\narguments, feel free to pick a value from either. Test your function by writing it in\na file and running the file as a script. What happens if you pass lists instead of\ndictionaries? How could you generalize your function to handle this case, too?\n(Hint: see the type built-in function used earlier.) Does the order of the arguments\npassed in matter?\n7. More argument-matching examples. First, define the following six functions (either\ninteractively or in a module file that can be imported):\ndef f1(a, b): print(a, b)\ndef f2(a, *b): print(a, b)",
    "# Normal args\n# Positional varargs\n\ndef f3(a, **b): print(a, b)\n\n# Keyword varargs\n\ndef f4(a, *b, **c): print(a, b, c)\n\n# Mixed modes\n\ndef f5(a, b=2, c=3): print(a, b, c)\n\n# Defaults\n\ndef f6(a, b=2, *c): print(a, b, c)\n\n# Defaults and positional varargs\n\nNow, test the following calls interactively, and try to explain each result; in some\ncases, you’ll probably need to fall back on the matching algorithm shown in Chapter 18. Do you think mixing matching modes is a good idea in general? Can you\nthink of cases where it would be useful?\n>>> f1(1, 2)\n>>> f1(b=2, a=1)\n>>> f2(1, 2, 3)\n>>> f3(1, x=2, y=3)\n>>> f4(1, 2, 3, x=2, y=3)\n\nTest Your Knowledge: Part IV Exercises | 525\n\n\f>>> f5(1)\n>>> f5(1, 4)\n>>> f6(1)\n>>> f6(1, 3, 4)\n\n8. Primes revisited. Recall the following code snippet from Chapter 13, which simplistically determines whether a positive integer is prime:\nx = y // 2\nwhile x > 1:\nif y % x == 0:\nprint(y, 'has factor', x)\nbreak\nx -= 1\nelse:\nprint(y, 'is prime')",
    "Test Your Knowledge: Part IV Exercises | 525\n\n\f>>> f5(1)\n>>> f5(1, 4)\n>>> f6(1)\n>>> f6(1, 3, 4)\n\n8. Primes revisited. Recall the following code snippet from Chapter 13, which simplistically determines whether a positive integer is prime:\nx = y // 2\nwhile x > 1:\nif y % x == 0:\nprint(y, 'has factor', x)\nbreak\nx -= 1\nelse:\nprint(y, 'is prime')\n\n# For some y > 1\n# Remainder\n# Skip else\n# Normal exit\n\nPackage this code as a reusable function in a module file (y should be a passed-in\nargument), and add some calls to the function at the bottom of your file. While\nyou’re at it, experiment with replacing the first line’s // operator with / to see how\ntrue division changes the / operator in Python 3.0 and breaks this code (refer back\nto Chapter 5 if you need a refresher). What can you do about negatives, and the\nvalues 0 and 1? How about speeding this up? Your outputs should look something\nlike this:\n13 is prime\n13.0 is prime\n15 has factor 5\n15.0 has factor 5.0",
    "9. List comprehensions. Write code to build a new list containing the square roots of\nall the numbers in this list: [2, 4, 9, 16, 25]. Code this as a for loop first, then\nas a map call, and finally as a list comprehension. Use the sqrt function in the builtin math module to do the calculation (i.e., import math and say math.sqrt(x)). Of\nthe three, which approach do you like best?\n10. Timing tools. In Chapter 5, we saw three ways to compute square roots:\nmath.sqrt(X), X ** .5, and pow(X, .5). If your programs run a lot these, their\nrelative performance might become important. To see which is quickest, repurpose\nthe timerseqs.py script we wrote in this chapter to time each of these three tools.\nUse the mytimer.py timer module with the best function (you can use either the\n3.0-ony keyword-only variant, or the 2.6/3.0 version). You might also want to\nrepackage the testing code in this script for better reusability—by passing a test",
    "the timerseqs.py script we wrote in this chapter to time each of these three tools.\nUse the mytimer.py timer module with the best function (you can use either the\n3.0-ony keyword-only variant, or the 2.6/3.0 version). You might also want to\nrepackage the testing code in this script for better reusability—by passing a test\nfunctions tuple to a general tester function, for example (for this exercise a\ncopy-and-modify approach is fine). Which of the three square root tools seems to\nrun fastest on your machine and Python in general? Finally, how might you go\nabout interactively timing the speed of dictionary comprehensions versus for\nloops?",
    "526 | Chapter 20: Iterations and Comprehensions, Part 2\n\n\fPART V\n\nModules\n\n\f\fCHAPTER 21\n\nModules: The Big Picture\n\nThis chapter begins our in-depth look at the Python module, the highest-level program\norganization unit, which packages program code and data for reuse. In concrete terms,\nmodules usually correspond to Python program files (or extensions coded in external\nlanguages such as C, Java, or C#). Each file is a module, and modules import other\nmodules to use the names they define. Modules are processed with two statements and\none important function:\nimport\n\nLets a client (importer) fetch a module as a whole\nfrom\n\nAllows clients to fetch particular names from a module\nimp.reload",
    "Lets a client (importer) fetch a module as a whole\nfrom\n\nAllows clients to fetch particular names from a module\nimp.reload\n\nProvides a way to reload a module’s code without stopping Python\nChapter 3 introduced module fundamentals, and we’ve been using them ever since.\nThis part of the book begins by expanding on core module concepts, then moves on\nto explore more advanced module usage. This first chapter offers a general look at the\nrole of modules in overall program structure. In the following chapters, we’ll dig into\nthe coding details behind the theory.\nAlong the way, we’ll flesh out module details omitted so far: you’ll learn about reloads,\nthe __name__ and __all__ attributes, package imports, relative import syntax, and so\non. Because modules and classes are really just glorified namespaces, we’ll formalize\nnamespace concepts here as well.",
    "Why Use Modules?\nIn short, modules provide an easy way to organize components into a system by serving\nas self-contained packages of variables known as namespaces. All the names defined at\nthe top level of a module file become attributes of the imported module object. As we\nsaw in the last part of this book, imports give access to names in a module’s global\n\n529",
    "scope. That is, the module file’s global scope morphs into the module object’s attribute\nnamespace when it is imported. Ultimately, Python’s modules allow us to link individual files into a larger program system.\nMore specifically, from an abstract perspective, modules have at least three roles:\nCode reuse\nAs discussed in Chapter 3, modules let you save code in files permanently. Unlike\ncode you type at the Python interactive prompt, which goes away when you exit\nPython, code in module files is persistent—it can be reloaded and rerun as many\ntimes as needed. More to the point, modules are a place to define names, known\nas attributes, which may be referenced by multiple external clients.\nSystem namespace partitioning\nModules are also the highest-level program organization unit in Python. Fundamentally, they are just packages of names. Modules seal up names into\nself-contained packages, which helps avoid name clashes—you can never see a",
    "as attributes, which may be referenced by multiple external clients.\nSystem namespace partitioning\nModules are also the highest-level program organization unit in Python. Fundamentally, they are just packages of names. Modules seal up names into\nself-contained packages, which helps avoid name clashes—you can never see a\nname in another file, unless you explicitly import that file. In fact, everything “lives”\nin a module—code you execute and objects you create are always implicitly enclosed in modules. Because of that, modules are natural tools for grouping system\ncomponents.\nImplementing shared services or data\nFrom an operational perspective, modules also come in handy for implementing\ncomponents that are shared across a system and hence require only a single copy.\nFor instance, if you need to provide a global object that’s used by more than one\nfunction or file, you can code it in a module that can then be imported by many\nclients.",
    "components.\nImplementing shared services or data\nFrom an operational perspective, modules also come in handy for implementing\ncomponents that are shared across a system and hence require only a single copy.\nFor instance, if you need to provide a global object that’s used by more than one\nfunction or file, you can code it in a module that can then be imported by many\nclients.\nFor you to truly understand the role of modules in a Python system, though, we need\nto digress for a moment and explore the general structure of a Python program.",
    "Python Program Architecture\nSo far in this book, I’ve sugarcoated some of the complexity in my descriptions of\nPython programs. In practice, programs usually involve more than just one file; for all\nbut the simplest scripts, your programs will take the form of multifile systems. And\neven if you can get by with coding a single file yourself, you will almost certainly wind\nup using external files that someone else has already written.\nThis section introduces the general architecture of Python programs—the way you\ndivide a program into a collection of source files (a.k.a. modules) and link the parts\ninto a whole. Along the way, we’ll also explore the central concepts of Python modules,\nimports, and object attributes.\n\n530 | Chapter 21: Modules: The Big Picture",
    "How to Structure a Program\nGenerally, a Python program consists of multiple text files containing Python statements. The program is structured as one main, top-level file, along with zero or more\nsupplemental files known as modules in Python.\nIn Python, the top-level (a.k.a. script) file contains the main flow of control of your\nprogram—this is the file you run to launch your application. The module files are\nlibraries of tools used to collect components used by the top-level file (and possibly\nelsewhere). Top-level files use tools defined in module files, and modules use tools\ndefined in other modules.\nModule files generally don’t do anything when run directly; rather, they define tools\nintended for use in other files. In Python, a file imports a module to gain access to the\ntools it defines, which are known as its attributes (i.e., variable names attached to objects such as functions). Ultimately, we import modules and access their attributes to\nuse their tools.",
    "Imports and Attributes\nLet’s make this a bit more concrete. Figure 21-1 sketches the structure of a Python\nprogram composed of three files: a.py, b.py, and c.py. The file a.py is chosen to be the\ntop-level file; it will be a simple text file of statements, which is executed from top to\nbottom when launched. The files b.py and c.py are modules; they are simple text files\nof statements as well, but they are not usually launched directly. Instead, as explained\npreviously, modules are normally imported by other files that wish to use the tools they\ndefine.\n\nFigure 21-1. Program architecture in Python. A program is a system of modules. It has one top-level\nscript file (launched to run the program), and multiple module files (imported libraries of tools). Scripts\nand modules are both text files containing Python statements, though the statements in modules\nusually just create objects to be used later. Python’s standard library provides a collection of precoded\nmodules.",
    "Python Program Architecture | 531\n\n\fFor instance, suppose the file b.py in Figure 21-1 defines a function called spam, for\nexternal use. As we learned when studying functions in Part IV, b.py will contain a\nPython def statement to generate the function, which can later be run by passing zero\nor more values in parentheses after the function’s name:\ndef spam(text):\nprint(text, 'spam')\n\nNow, suppose a.py wants to use spam. To this end, it might contain Python statements\nsuch as the following:\nimport b\nb.spam('gumby')",
    "The first of these, a Python import statement, gives the file a.py access to everything\ndefined by top-level code in the file b.py. It roughly means “load the file b.py (unless\nit’s already loaded), and give me access to all its attributes through the name b.”\nimport (and, as you’ll see later, from) statements execute and load other files at runtime.\nIn Python, cross-file module linking is not resolved until such import statements are\nexecuted at runtime; their net effect is to assign module names—simple variables—to\nloaded module objects. In fact, the module name used in an import statement serves\ntwo purposes: it identifies the external file to be loaded, but it also becomes a variable\nassigned to the loaded module. Objects defined by a module are also created at runtime,\nas the import is executing: import literally runs statements in the target file one at a time\nto create its contents.\nThe second of the statements in a.py calls the function spam defined in the module b,",
    "two purposes: it identifies the external file to be loaded, but it also becomes a variable\nassigned to the loaded module. Objects defined by a module are also created at runtime,\nas the import is executing: import literally runs statements in the target file one at a time\nto create its contents.\nThe second of the statements in a.py calls the function spam defined in the module b,\nusing object attribute notation. The code b.spam means “fetch the value of the name\nspam that lives within the object b.” This happens to be a callable function in our example, so we pass a string in parentheses ('gumby'). If you actually type these files, save\nthem, and run a.py, the words “gumby spam” will be printed.\nYou’ll see the object.attribute notation used throughout Python scripts—most objects have useful attributes that are fetched with the “.” operator. Some are callable\nthings like functions, and others are simple data values that give object properties (e.g.,\na person’s name).",
    "them, and run a.py, the words “gumby spam” will be printed.\nYou’ll see the object.attribute notation used throughout Python scripts—most objects have useful attributes that are fetched with the “.” operator. Some are callable\nthings like functions, and others are simple data values that give object properties (e.g.,\na person’s name).\nThe notion of importing is also completely general throughout Python. Any file can\nimport tools from any other file. For instance, the file a.py may import b.py to call its\nfunction, but b.py might also import c.py to leverage different tools defined there. Import chains can go as deep as you like: in this example, the module a can import b,\nwhich can import c, which can import b again, and so on.\nBesides serving as the highest organizational structure, modules (and module packages,\ndescribed in Chapter 23) are also the highest level of code reuse in Python. Coding\ncomponents in module files makes them useful in your original program, and in any",
    "which can import c, which can import b again, and so on.\nBesides serving as the highest organizational structure, modules (and module packages,\ndescribed in Chapter 23) are also the highest level of code reuse in Python. Coding\ncomponents in module files makes them useful in your original program, and in any\nother programs you may write. For instance, if after coding the program in Figure 21-1 we discover that the function b.spam is a general-purpose tool, we can reuse",
    "532 | Chapter 21: Modules: The Big Picture\n\n\fit in a completely different program; all we have to do is import the file b.py again from\nthe other program’s files.",
    "Standard Library Modules\nNotice the rightmost portion of Figure 21-1. Some of the modules that your programs\nwill import are provided by Python itself and are not files you will code.\nPython automatically comes with a large collection of utility modules known as the\nstandard library. This collection, roughly 200 modules large at last count, contains\nplatform-independent support for common programming tasks: operating system interfaces, object persistence, text pattern matching, network and Internet scripting, GUI\nconstruction, and much more. None of these tools are part of the Python language\nitself, but you can use them by importing the appropriate modules on any standard\nPython installation. Because they are standard library modules, you can also be reasonably sure that they will be available and will work portably on most platforms on\nwhich you will run Python.\nYou will see a few of the standard library modules in action in this book’s examples,",
    "itself, but you can use them by importing the appropriate modules on any standard\nPython installation. Because they are standard library modules, you can also be reasonably sure that they will be available and will work portably on most platforms on\nwhich you will run Python.\nYou will see a few of the standard library modules in action in this book’s examples,\nbut for a complete look you should browse the standard Python library reference manual, available either with your Python installation (via IDLE or the Python Start button\nmenu on Windows) or online at http://www.python.org.\nBecause there are so many modules, this is really the only way to get a feel for what\ntools are available. You can also find tutorials on Python library tools in commercial\nbooks that cover application-level programming, such as O’Reilly’s Programming Py\nthon, but the manuals are free, viewable in any web browser (they ship in HTML format), and updated each time Python is rereleased.",
    "How Imports Work\nThe prior section talked about importing modules without really explaining what happens when you do so. Because imports are at the heart of program structure in Python,\nthis section goes into more detail on the import operation to make this process less\nabstract.\nSome C programmers like to compare the Python module import operation to a C\n#include, but they really shouldn’t—in Python, imports are not just textual insertions\nof one file into another. They are really runtime operations that perform three distinct\nsteps the first time a program imports a given file:\n1. Find the module’s file.\n2. Compile it to byte code (if needed).\n3. Run the module’s code to build the objects it defines.\n\nHow Imports Work | 533",
    "How Imports Work | 533\n\n\fTo better understand module imports, we’ll explore these steps in turn. Bear in mind\nthat all three of these steps are carried out only the first time a module is imported\nduring a program’s execution; later imports of the same module bypass all of these\nsteps and simply fetch the already loaded module object in memory. Technically, Python does this by storing loaded modules in a table named sys.modules and checking\nthere at the start of an import operation. If the module is not present, a three-step\nprocess begins.",
    "1. Find It\nFirst, Python must locate the module file referenced by an import statement. Notice\nthat the import statement in the prior section’s example names the file without a .py\nsuffix and without its directory path: it just says import b, instead of something like\nimport c:\\dir1\\b.py. In fact, you can only list a simple name; path and suffix details\nare omitted on purpose and Python uses a standard module search path to locate the\nmodule file corresponding to an import statement.* Because this is the main part of the\nimport operation that programmers must know about, we’ll return to this topic in a\nmoment.",
    "2. Compile It (Maybe)\nAfter finding a source code file that matches an import statement by traversing the\nmodule search path, Python next compiles it to byte code, if necessary. (We discussed\nbyte code in Chapter 2.)\nPython checks the file timestamps and, if the byte code file is older than the source file\n(i.e., if you’ve changed the source), automatically regenerates the byte code when the\nprogram is run. If, on the other hand, it finds a .pyc byte code file that is not older than\nthe corresponding .py source file, it skips the source-to–byte code compile step. In\naddition, if Python finds only a byte code file on the search path and no source, it simply\nloads the byte code directly (this means you can ship a program as just byte code files\nand avoid sending source). In other words, the compile step is bypassed if possible to\nspeed program startup.\nNotice that compilation happens when a file is being imported. Because of this, you",
    "addition, if Python finds only a byte code file on the search path and no source, it simply\nloads the byte code directly (this means you can ship a program as just byte code files\nand avoid sending source). In other words, the compile step is bypassed if possible to\nspeed program startup.\nNotice that compilation happens when a file is being imported. Because of this, you\nwill not usually see a .pyc byte code file for the top-level file of your program, unless it\nis also imported elsewhere—only imported files leave behind .pyc files on your",
    "* It’s actually syntactically illegal to include path and suffix details in a standard import. Package imports, which\nwe’ll discuss in Chapter 23, allow import statements to include part of the directory path leading to a file as\na set of period-separated names; however, package imports still rely on the normal module search path to\nlocate the leftmost directory in a package path (i.e., they are relative to a directory in the search path). They\nalso cannot make use of any platform-specific directory syntax in the import statements; such syntax only\nworks on the search path. Also, note that module file search path issues are not as relevant when you run\nfrozen executables (discussed in Chapter 2); they typically embed byte code in the binary image.\n\n534 | Chapter 21: Modules: The Big Picture",
    "534 | Chapter 21: Modules: The Big Picture\n\n\fmachine. The byte code of top-level files is used internally and discarded; byte code of\nimported files is saved in files to speed future imports.\nTop-level files are often designed to be executed directly and not imported at all. Later,\nwe’ll see that it is possible to design a file that serves both as the top-level code of a\nprogram and as a module of tools to be imported. Such a file may be both executed\nand imported, and thus does generate a .pyc. To learn how this works, watch for the\ndiscussion of the special __name__ attribute and __main__ in Chapter 24.",
    "3. Run It\nThe final step of an import operation executes the byte code of the module. All statements in the file are executed in turn, from top to bottom, and any assignments made\nto names during this step generate attributes of the resulting module object. This execution step therefore generates all the tools that the module’s code defines. For instance,\ndef statements in a file are run at import time to create functions and assign attributes\nwithin the module to those functions. The functions can then be called later in the\nprogram by the file’s importers.\nBecause this last import step actually runs the file’s code, if any top-level code in a\nmodule file does real work, you’ll see its results at import time. For example, top-level\nprint statements in a module show output when the file is imported. Function def\nstatements simply define objects for later use.\nAs you can see, import operations involve quite a bit of work—they search for files,",
    "Because this last import step actually runs the file’s code, if any top-level code in a\nmodule file does real work, you’ll see its results at import time. For example, top-level\nprint statements in a module show output when the file is imported. Function def\nstatements simply define objects for later use.\nAs you can see, import operations involve quite a bit of work—they search for files,\npossibly run a compiler, and run Python code. Because of this, any given module is\nimported only once per process by default. Future imports skip all three import steps\nand reuse the already loaded module in memory. If you need to import a file again after\nit has already been loaded (for example, to support end-user customization), you have\nto force the issue with an imp.reload call—a tool we’ll meet in the next chapter.†",
    "The Module Search Path\nAs mentioned earlier, the part of the import procedure that is most important to programmers is usually the first—locating the file to be imported (the “find it” part). Because you may need to tell Python where to look to find files to import, you need to\nknow how to tap into its search path in order to extend it.\n\n† As described earlier, Python keeps already imported modules in the built-in sys.modules dictionary so it can\nkeep track of what’s been loaded. In fact, if you want to see which modules are loaded, you can import sys\nand print list(sys.modules.keys()). More on other uses for this internal table in Chapter 24.\n\nThe Module Search Path | 535",
    "In many cases, you can rely on the automatic nature of the module import search path\nand won’t need to configure this path at all. If you want to be able to import files across\ndirectory boundaries, though, you will need to know how the search path works in\norder to customize it. Roughly, Python’s module search path is composed of the\nconcatenation of these major components, some of which are preset for you and some\nof which you can tailor to tell Python where to look:\n1. The home directory of the program\n2. PYTHONPATH directories (if set)\n3. Standard library directories\n4. The contents of any .pth files (if present)\nUltimately, the concatenation of these four components becomes sys.path, a list of\ndirectory name strings that I’ll expand upon later in this section. The first and third\nelements of the search path are defined automatically. Because Python searches the\nconcatenation of these components from first to last, though, the second and fourth",
    "4. The contents of any .pth files (if present)\nUltimately, the concatenation of these four components becomes sys.path, a list of\ndirectory name strings that I’ll expand upon later in this section. The first and third\nelements of the search path are defined automatically. Because Python searches the\nconcatenation of these components from first to last, though, the second and fourth\nelements can be used to extend the path to include your own source code directories.\nHere is how Python uses each of these path components:\nHome directory\nPython first looks for the imported file in the home directory. The meaning of this\nentry depends on how you are running the code. When you’re running a program,\nthis entry is the directory containing your program’s top-level script file. When\nyou’re working interactively, this entry is the directory in which you are working\n(i.e., the current working directory).\nBecause this directory is always searched first, if a program is located entirely in a",
    "entry depends on how you are running the code. When you’re running a program,\nthis entry is the directory containing your program’s top-level script file. When\nyou’re working interactively, this entry is the directory in which you are working\n(i.e., the current working directory).\nBecause this directory is always searched first, if a program is located entirely in a\nsingle directory, all of its imports will work automatically with no path configuration required. On the other hand, because this directory is searched first, its files\nwill also override modules of the same name in directories elsewhere on the path;\nbe careful not to accidentally hide library modules this way if you need them in\nyour program.\nPYTHONPATH directories\nNext, Python searches all directories listed in your PYTHONPATH environment\nvariable setting, from left to right (assuming you have set this at all). In brief,\nPYTHONPATH is simply set to a list of user-defined and platform-specific names of",
    "be careful not to accidentally hide library modules this way if you need them in\nyour program.\nPYTHONPATH directories\nNext, Python searches all directories listed in your PYTHONPATH environment\nvariable setting, from left to right (assuming you have set this at all). In brief,\nPYTHONPATH is simply set to a list of user-defined and platform-specific names of\ndirectories that contain Python code files. You can add all the directories from\nwhich you wish to be able to import, and Python will extend the module search\npath to include all the directories your PYTHONPATH lists.\nBecause Python searches the home directory first, this setting is only important\nwhen importing files across directory boundaries—that is, if you need to import a\nfile that is stored in a different directory from the file that imports it. You’ll probably\nwant to set your PYTHONPATH variable once you start writing substantial programs,\nbut when you’re first starting out, as long as you save all your module files in the",
    "536 | Chapter 21: Modules: The Big Picture",
    "directory in which you’re working (i.e., the home directory, described earlier) your\nimports will work without you needing to worry about this setting at all.\nStandard library directories\nNext, Python automatically searches the directories where the standard library\nmodules are installed on your machine. Because these are always searched, they\nnormally do not need to be added to your PYTHONPATH or included in path files\n(discussed next).\n.pth path file directories\nFinally, a lesser-used feature of Python allows users to add directories to the module\nsearch path by simply listing them, one per line, in a text file whose name ends\nwith a .pth suffix (for “path”). These path configuration files are a somewhat advanced installation-related feature; we won’t them cover fully here, but they provide an alternative to PYTHONPATH settings.\nIn short, text files of directory names dropped in an appropriate directory can serve",
    "search path by simply listing them, one per line, in a text file whose name ends\nwith a .pth suffix (for “path”). These path configuration files are a somewhat advanced installation-related feature; we won’t them cover fully here, but they provide an alternative to PYTHONPATH settings.\nIn short, text files of directory names dropped in an appropriate directory can serve\nroughly the same role as the PYTHONPATH environment variable setting. For instance,\nif you’re running Windows and Python 3.0, a file named myconfig.pth may be\nplaced at the top level of the Python install directory (C:\\Python30) or in the sitepackages subdirectory of the standard library there (C:\\Python30\\Lib\\sitepackages) to extend the module search path. On Unix-like systems, this file might\nbe located in usr/local/lib/python3.0/site-packages or /usr/local/lib/site-python\ninstead.\nWhen present, Python will add the directories listed on each line of the file, from",
    "be located in usr/local/lib/python3.0/site-packages or /usr/local/lib/site-python\ninstead.\nWhen present, Python will add the directories listed on each line of the file, from\nfirst to last, near the end of the module search path list. In fact, Python will collect\nthe directory names in all the path files it finds and will filter out any duplicates\nand nonexistent directories. Because they are files rather than shell settings, path\nfiles can apply to all users of an installation, instead of just one user or shell. Moreover, for some users text files may be simpler to code than environment settings.\nThis feature is more sophisticated than I’ve described here. For more details consult\nthe Python library manual, and especially its documentation for the standard library module site—this module allows the locations of Python libraries and path\nfiles to be configured, and its documentation describes the expected locations of",
    "This feature is more sophisticated than I’ve described here. For more details consult\nthe Python library manual, and especially its documentation for the standard library module site—this module allows the locations of Python libraries and path\nfiles to be configured, and its documentation describes the expected locations of\npath files in general. I recommend that beginners use PYTHONPATH or perhaps a single .pth file, and then only if you must import across directories. Path files are used\nmore often by third-party libraries, which commonly install a path file in Python’s\nsite-packages directory so that user settings are not required (Python’s distutils\ninstall system, described in an upcoming sidebar, automates many install steps).",
    "Configuring the Search Path\nThe net effect of all of this is that both the PYTHONPATH and path file components of the\nsearch path allow you to tailor the places where imports look for files. The way you set\nenvironment variables and where you store path files varies per platform. For instance,\n\nThe Module Search Path | 537\n\n\fon Windows, you might use your Control Panel’s System icon to set PYTHONPATH to a\nlist of directories separated by semicolons, like this:\nc:\\pycode\\utilities;d:\\pycode\\package1\n\nOr you might instead create a text file called C:\\Python30\\pydirs.pth, which looks like\nthis:\nc:\\pycode\\utilities\nd:\\pycode\\package1\n\nThese settings are analogous on other platforms, but the details can vary too widely for\nus to cover in this chapter. See Appendix A for pointers on extending your module\nsearch path with PYTHONPATH or .pth files on various platforms.",
    "Search Path Variations\nThis description of the module search path is accurate, but generic; the exact configuration of the search path is prone to changing across platforms and Python releases.\nDepending on your platform, additional directories may automatically be added to the\nmodule search path as well.\nFor instance, Python may add an entry for the current working directory—the directory\nfrom which you launched your program—in the search path after the PYTHONPATH directories, and before the standard library entries. When you’re launching from a command line, the current working directory may not be the same as the home directory\nof your top-level file (i.e., the directory where your program file resides). Because the\ncurrent working directory can vary each time your program runs, you normally\nshouldn’t depend on its value for import purposes. See Chapter 3 for more on launching\nprograms from command lines.‡",
    "of your top-level file (i.e., the directory where your program file resides). Because the\ncurrent working directory can vary each time your program runs, you normally\nshouldn’t depend on its value for import purposes. See Chapter 3 for more on launching\nprograms from command lines.‡\nTo see how your Python configures the module search path on your platform, you can\nalways inspect sys.path—the topic of the next section.",
    "The sys.path List\nIf you want to see how the module search path is truly configured on your machine,\nyou can always inspect the path as Python knows it by printing the built-in sys.path\nlist (that is, the path attribute of the standard library module sys). This list of directory\nname strings is the actual search path within Python; on imports, Python searches each\ndirectory in this list from left to right.\n\n‡ See also Chapter 23’s discussion of the new relative import syntax in Python 3.0; this modifies the search\npath for from statements in files inside packages when “.” characters are used (e.g., from . import string).\nBy default, a package’s own directory is not automatically searched by imports in Python 3.0, unless relative\nimports are used by files in the package itself.\n\n538 | Chapter 21: Modules: The Big Picture",
    "Really, sys.path is the module search path. Python configures it at program startup,\nautomatically merging the home directory of the top-level file (or an empty string to\ndesignate the current working directory), any PYTHONPATH directories, the contents of\nany .pth file paths you’ve created, and the standard library directories. The result is a\nlist of directory name strings that Python searches on each import of a new file.\nPython exposes this list for two good reasons. First, it provides a way to verify the search\npath settings you’ve made—if you don’t see your settings somewhere in this list, you\nneed to recheck your work. For example, here is what my module search path looks\nlike on Windows under Python 3.0, with my PYTHONPATH set to C:\\users and a\nC:\\Python30\\mypath.py path file that lists C:\\users\\mark. The empty string at the front\nmeans current directory and my two settings are merged in (the rest are standard library\ndirectories and files):\n>>> import sys\n>>> sys.path",
    "need to recheck your work. For example, here is what my module search path looks\nlike on Windows under Python 3.0, with my PYTHONPATH set to C:\\users and a\nC:\\Python30\\mypath.py path file that lists C:\\users\\mark. The empty string at the front\nmeans current directory and my two settings are merged in (the rest are standard library\ndirectories and files):\n>>> import sys\n>>> sys.path\n['', 'C:\\\\users', 'C:\\\\Windows\\\\system32\\\\python30.zip', 'c:\\\\Python30\\\\DLLs',\n'c:\\\\Python30\\\\lib', 'c:\\\\Python30\\\\lib\\\\plat-win', 'c:\\\\Python30',\n'C:\\\\Users\\\\Mark', 'c:\\\\Python30\\\\lib\\\\site-packages']",
    "Second, if you know what you’re doing, this list provides a way for scripts to tailor their\nsearch paths manually. As you’ll see later in this part of the book, by modifying the\nsys.path list, you can modify the search path for all future imports. Such changes only\nlast for the duration of the script, however; PYTHONPATH and .pth files offer more permanent ways to modify the path.§",
    "Module File Selection\nKeep in mind that filename suffixes (e.g., .py) are intentionally omitted from import\nstatements. Python chooses the first file it can find on the search path that matches the\nimported name. For example, an import statement of the form import b might load:\n• A source code file named b.py\n• A byte code file named b.pyc\n• A directory named b, for package imports (described in Chapter 23)\n• A compiled extension module, usually coded in C or C++ and dynamically linked\nwhen imported (e.g., b.so on Linux, or b.dll or b.pyd on Cygwin and Windows)\n• A compiled built-in module coded in C and statically linked into Python\n• A ZIP file component that is automatically extracted when imported\n• An in-memory image, for frozen executables",
    "§ Some programs really need to change sys.path, though. Scripts that run on web servers, for example, often\nrun as the user “nobody” to limit machine access. Because such scripts cannot usually depend on “nobody”\nto have set PYTHONPATH in any particular way, they often set sys.path manually to include required source\ndirectories, prior to running any import statements. A sys.path.append(dirname) will often suffice.\n\nThe Module Search Path | 539",
    "• A Java class, in the Jython version of Python\n• A .NET component, in the IronPython version of Python\nC extensions, Jython, and package imports all extend imports beyond simple files. To\nimporters, though, differences in the loaded file type are completely transparent, both\nwhen importing and when fetching module attributes. Saying import b gets whatever\nmodule b is, according to your module search path, and b.attr fetches an item in the\nmodule, be it a Python variable or a linked-in C function. Some standard modules we\nwill use in this book are actually coded in C, not Python; because of this transparency,\ntheir clients don’t have to care.\nIf you have both a b.py and a b.so in different directories, Python will always load the\none found in the first (leftmost) directory of your module search path during the leftto-right search of sys.path. But what happens if it finds both a b.py and a b.so in the",
    "will use in this book are actually coded in C, not Python; because of this transparency,\ntheir clients don’t have to care.\nIf you have both a b.py and a b.so in different directories, Python will always load the\none found in the first (leftmost) directory of your module search path during the leftto-right search of sys.path. But what happens if it finds both a b.py and a b.so in the\nsame directory? In this case, Python follows a standard picking order, though this order\nis not guaranteed to stay the same over time. In general, you should not depend on\nwhich type of file Python will choose within a given directory—make your module\nnames distinct, or configure your module search path to make your module selection\npreferences more obvious.",
    "Advanced Module Selection Concepts\nNormally, imports work as described in this section—they find and load files on your\nmachine. However, it is possible to redefine much of what an import operation does\nin Python, using what are known as import hooks. These hooks can be used to make\nimports do various useful things, such as loading files from archives, performing decryption, and so on.\nIn fact, Python itself makes use of these hooks to enable files to be directly imported\nfrom ZIP archives: archived files are automatically extracted at import time when\na .zip file is selected from the module import search path. One of the standard library\ndirectories in the earlier sys.path display, for example, is a .zip file today. For more\ndetails, see the Python standard library manual’s description of the built-in\n__import__ function, the customizable tool that import statements actually run.\nPython also supports the notion of .pyo optimized byte code files, created and run with",
    "directories in the earlier sys.path display, for example, is a .zip file today. For more\ndetails, see the Python standard library manual’s description of the built-in\n__import__ function, the customizable tool that import statements actually run.\nPython also supports the notion of .pyo optimized byte code files, created and run with\nthe -O Python command-line flag; because these run only slightly faster than normal .pyc files (typically 5 percent faster), however, they are infrequently used. The Psyco\nsystem (see Chapter 2) provides more substantial speedups.",
    "Third-Party Software: distutils\nThis chapter’s description of module search path settings is targeted mainly at userdefined source code that you write on your own. Third-party extensions for Python\ntypically use the distutils tools in the standard library to automatically install themselves, so no path configuration is required to use their code.\n540 | Chapter 21: Modules: The Big Picture",
    "Systems that use distutils generally come with a setup.py script, which is run to install\nthem; this script imports and uses distutils modules to place such systems in a directory that is automatically part of the module search path (usually in the Lib\\sitepackages subdirectory of the Python install tree, wherever that resides on the target\nmachine).\nFor more details on distributing and installing with distutils, see the Python standard\nmanual set; its use is beyond the scope of this book (for instance, it also provides ways\nto automatically compile C-coded extensions on the target machine). Also check out\nthe emerging third-party open source eggs system, which adds dependency checking\nfor installed Python software.",
    "Chapter Summary\nIn this chapter, we covered the basics of modules, attributes, and imports and explored\nthe operation of import statements. We learned that imports find the designated file on\nthe module search path, compile it to byte code, and execute all of its statements to\ngenerate its contents. We also learned how to configure the search path to be able to\nimport from directories other than the home directory and the standard library directories, primarily with PYTHONPATH settings.\nAs this chapter demonstrated, the import operation and modules are at the heart of\nprogram architecture in Python. Larger programs are divided into multiple files, which\nare linked together at runtime by imports. Imports in turn use the module search path\nto locate files, and modules define attributes for external use.\nOf course, the whole point of imports and modules is to provide a structure to your\nprogram, which divides its logic into self-contained software components. Code in one",
    "are linked together at runtime by imports. Imports in turn use the module search path\nto locate files, and modules define attributes for external use.\nOf course, the whole point of imports and modules is to provide a structure to your\nprogram, which divides its logic into self-contained software components. Code in one\nmodule is isolated from code in another; in fact, no file can ever see the names defined\nin another, unless explicit import statements are run. Because of this, modules minimize\nname collisions between different parts of your program.\nYou’ll see what this all means in terms of actual statements and code in the next chapter.\nBefore we move on, though, let’s run through the chapter quiz.",
    "Test Your Knowledge: Quiz\n1. How does a module source code file become a module object?\n2. Why might you have to set your PYTHONPATH environment variable?\n3. Name the four major components of the module import search path.\n4. Name four file types that Python might load in response to an import operation.\n5. What is a namespace, and what does a module’s namespace contain?\n\nTest Your Knowledge: Quiz | 541",
    "Test Your Knowledge: Answers\n1. A module’s source code file automatically becomes a module object when that\nmodule is imported. Technically, the module’s source code is run during the\nimport, one statement at a time, and all the names assigned in the process become\nattributes of the module object.\n2. You only need to set PYTHONPATH to import from directories other than the one in\nwhich you are working (i.e., the current directory when working interactively, or\nthe directory containing your top-level file).\n3. The four major components of the module import search path are the top-level\nscript’s home directory (the directory containing it), all directories listed in the\nPYTHONPATH environment variable, the standard library directories, and all directories listed in .pth path files located in standard places. Of these, programmers can\ncustomize PYTHONPATH and .pth files.\n4. Python might load a source code (.py) file, a byte code (.pyc) file, a C extension",
    "script’s home directory (the directory containing it), all directories listed in the\nPYTHONPATH environment variable, the standard library directories, and all directories listed in .pth path files located in standard places. Of these, programmers can\ncustomize PYTHONPATH and .pth files.\n4. Python might load a source code (.py) file, a byte code (.pyc) file, a C extension\nmodule (e.g., a .so file on Linux or a .dll or .pyd file on Windows), or a directory\nof the same name for package imports. Imports may also load more exotic things\nsuch as ZIP file components, Java classes under the Jython version of Python, .NET\ncomponents under IronPython, and statically linked C extensions that have no files\npresent at all. With import hooks, imports can load anything.\n5. A namespace is a self-contained package of variables, which are known as the\nattributes of the namespace object. A module’s namespace contains all the names",
    "such as ZIP file components, Java classes under the Jython version of Python, .NET\ncomponents under IronPython, and statically linked C extensions that have no files\npresent at all. With import hooks, imports can load anything.\n5. A namespace is a self-contained package of variables, which are known as the\nattributes of the namespace object. A module’s namespace contains all the names\nassigned by code at the top level of the module file (i.e., not nested in def or\nclass statements). Technically, a module’s global scope morphs into the module\nobject’s attributes namespace. A module’s namespace may also be altered by assignments from other files that import it, though this is frowned upon (see Chapter 17 for more on this issue).",
    "542 | Chapter 21: Modules: The Big Picture\n\n\fCHAPTER 22\n\nModule Coding Basics\n\nNow that we’ve looked at the larger ideas behind modules, let’s turn to a simple example of modules in action. Python modules are easy to create; they’re just files of\nPython program code created with a text editor. You don’t need to write special syntax\nto tell Python you’re making a module; almost any text file will do. Because Python\nhandles all the details of finding and loading modules, modules are also easy to use;\nclients simply import a module, or specific names a module defines, and use the objects\nthey reference.",
    "Module Creation\nTo define a module, simply use your text editor to type some Python code into a text\nfile, and save it with a “.py” extension; any such file is automatically considered a\nPython module. All the names assigned at the top level of the module become its\nattributes (names associated with the module object) and are exported for clients to use.\nFor instance, if you type the following def into a file called module1.py and import it,\nyou create a module object with one attribute—the name printer, which happens to\nbe a reference to a function object:\ndef printer(x):\nprint(x)\n\n# Module attribute",
    "# Module attribute\n\nBefore we go on, I should say a few more words about module filenames. You can call\nmodules just about anything you like, but module filenames should end in a .py suffix\nif you plan to import them. The .py is technically optional for top-level files that will\nbe run but not imported, but adding it in all cases makes your files’ types more obvious\nand allows you to import any of your files in the future.\nBecause module names become variable names inside a Python program (without\nthe .py), they should also follow the normal variable name rules outlined in Chapter 11. For instance, you can create a module file named if.py, but you cannot import\nit because if is a reserved word—when you try to run import if, you’ll get a syntax\nerror. In fact, both the names of module files and the names of directories used in\n543",
    "package imports (discussed in the next chapter) must conform to the rules for variable\nnames presented in Chapter 11; they may, for instance, contain only letters, digits, and\nunderscores. Package directories also cannot contain platform-specific syntax such as\nspaces in their names.\nWhen a module is imported, Python maps the internal module name to an external\nfilename by adding a directory path from the module search path to the front, and\na .py or other extension at the end. For instance, a module named M ultimately maps\nto some external file <directory>\\M.<extension> that contains the module’s code.\nAs mentioned in the preceding chapter, it is also possible to create a Python module by\nwriting code in an external language such as C or C++ (or Java, in the Jython implementation of the language). Such modules are called extension modules, and they are\ngenerally used to wrap up external libraries for use in Python scripts. When imported",
    "As mentioned in the preceding chapter, it is also possible to create a Python module by\nwriting code in an external language such as C or C++ (or Java, in the Jython implementation of the language). Such modules are called extension modules, and they are\ngenerally used to wrap up external libraries for use in Python scripts. When imported\nby Python code, extension modules look and feel the same as modules coded as Python\nsource code files—they are accessed with import statements, and they provide functions\nand objects as module attributes. Extension modules are beyond the scope of this book;\nsee Python’s standard manuals or advanced texts such as Programming Python for more\ndetails.",
    "Module Usage\nClients can use the simple module file we just wrote by running an import or from\nstatement. Both statements find, compile, and run a module file’s code, if it hasn’t yet\nbeen loaded. The chief difference is that import fetches the module as a whole, so you\nmust qualify to fetch its names; in contrast, from fetches (or copies) specific names out\nof the module.\nLet’s see what this means in terms of code. All of the following examples wind up calling\nthe printer function defined in the prior section’s module1.py module file, but in different ways.\n\nThe import Statement\nIn the first example, the name module1 serves two different purposes—it identifies an\nexternal file to be loaded, and it becomes a variable in the script, which references the\nmodule object after the file is loaded:\n>>> import module1\n>>> module1.printer('Hello world!')\nHello world!\n\n# Get module as a whole\n# Qualify to get names",
    "The import Statement\nIn the first example, the name module1 serves two different purposes—it identifies an\nexternal file to be loaded, and it becomes a variable in the script, which references the\nmodule object after the file is loaded:\n>>> import module1\n>>> module1.printer('Hello world!')\nHello world!\n\n# Get module as a whole\n# Qualify to get names\n\nBecause import gives a name that refers to the whole module object, we must go through\nthe module name to fetch its attributes (e.g., module1.printer).\n\n544 | Chapter 22: Module Coding Basics\n\n\fThe from Statement\nBy contrast, because from also copies names from one file over to another scope, it\nallows us to use the copied names directly in the script without going through the\nmodule (e.g., printer):\n>>> from module1 import printer\n>>> printer('Hello world!')\nHello world!\n\n# Copy out one variable\n# No need to qualify name",
    "544 | Chapter 22: Module Coding Basics\n\n\fThe from Statement\nBy contrast, because from also copies names from one file over to another scope, it\nallows us to use the copied names directly in the script without going through the\nmodule (e.g., printer):\n>>> from module1 import printer\n>>> printer('Hello world!')\nHello world!\n\n# Copy out one variable\n# No need to qualify name\n\nThis has the same effect as the prior example, but because the imported name is copied\ninto the scope where the from statement appears, using that name in the script requires\nless typing: we can use it directly instead of naming the enclosing module.\nAs you’ll see in more detail later, the from statement is really just a minor extension to\nthe import statement—it imports the module file as usual, but adds an extra step that\ncopies one or more names out of the file.",
    "The from * Statement\nFinally, the next example uses a special form of from: when we use a *, we get copies\nof all the names assigned at the top level of the referenced module. Here again, we can\nthen use the copied name printer in our script without going through the module name:\n>>> from module1 import *\n>>> printer('Hello world!')\nHello world!\n\n# Copy out all variables",
    "# Copy out all variables\n\nTechnically, both import and from statements invoke the same import operation; the\nfrom * form simply adds an extra step that copies all the names in the module into the\nimporting scope. It essentially collapses one module’s namespace into another; again,\nthe net effect is less typing for us.\nAnd that’s it—modules really are simple to use. To give you a better understanding of\nwhat really happens when you define and use modules, though, let’s move on to look\nat some of their properties in more detail.\nIn Python 3.0, the from ...* statement form described here can be used\nonly at the top level of a module file, not within a function. Python 2.6\nallows it to be used within a function, but issues a warning. It’s extremely rare to see this statement used inside a function in practice;\nwhen present, it makes it impossible for Python to detect variables statically, before the function runs.\n\nModule Usage | 545",
    "Module Usage | 545\n\n\fImports Happen Only Once\nOne of the most common questions people seem to ask when they start using modules\nis, “Why won’t my imports keep working?” They often report that the first import\nworks fine, but later imports during an interactive session (or program run) seem to\nhave no effect. In fact, they’re not supposed to. This section explains why.\nModules are loaded and run on the first import or from, and only the first. This is on\npurpose—because importing is an expensive operation, by default Python does it just\nonce per file, per process. Later import operations simply fetch the already loaded\nmodule object.\nAs one consequence, because top-level code in a module file is usually executed only\nonce, you can use it to initialize variables. Consider the file simple.py, for example:\nprint('hello')\nspam = 1\n\n# Initialize variable",
    "# Initialize variable\n\nIn this example, the print and = statements run the first time the module is imported,\nand the variable spam is initialized at import time:\n% python\n>>> import simple\nhello\n>>> simple.spam\n1\n\n# First import: loads and runs file's code\n# Assignment makes an attribute\n\nSecond and later imports don’t rerun the module’s code; they just fetch the already\ncreated module object from Python’s internal modules table. Thus, the variable spam\nis not reinitialized:\n>>> simple.spam = 2\n>>> import simple\n>>> simple.spam\n2\n\n# Change attribute in module\n# Just fetches already loaded module\n# Code wasn't rerun: attribute unchanged\n\nOf course, sometimes you really want a module’s code to be rerun on a subsequent\nimport. We’ll see how to do this with Python’s reload function later in this chapter.",
    "# Change attribute in module\n# Just fetches already loaded module\n# Code wasn't rerun: attribute unchanged\n\nOf course, sometimes you really want a module’s code to be rerun on a subsequent\nimport. We’ll see how to do this with Python’s reload function later in this chapter.\n\nimport and from Are Assignments\nJust like def, import and from are executable statements, not compile-time declarations.\nThey may be nested in if tests, appear in function defs, and so on, and they are not\nresolved or run until Python reaches them while executing your program. In other\nwords, imported modules and names are not available until their associated import or\nfrom statements run. Also, like def, import and from are implicit assignments:\n• import assigns an entire module object to a single name.\n• from assigns one or more names to objects of the same names in another module.\n\n546 | Chapter 22: Module Coding Basics",
    "546 | Chapter 22: Module Coding Basics\n\n\fAll the things we’ve already discussed about assignment apply to module access, too.\nFor instance, names copied with a from become references to shared objects; as with\nfunction arguments, reassigning a fetched name has no effect on the module from which\nit was copied, but changing a fetched mutable object can change it in the module from\nwhich it was imported. To illustrate, consider the following file, small.py:\nx = 1\ny = [1, 2]\n% python\n>>> from small import x, y\n>>> x = 42\n>>> y[0] = 42\n\n# Copy two names out\n# Changes local x only\n# Changes shared mutable in-place\n\nHere, x is not a shared mutable object, but y is. The name y in the importer and the\nimportee reference the same list object, so changing it from one place changes it in the\nother:\n>>> import small\n>>> small.x\n1\n>>> small.y\n[42, 2]\n\n# Get module name (from doesn't)\n# Small's x is not my x\n# But we share a changed mutable",
    "Here, x is not a shared mutable object, but y is. The name y in the importer and the\nimportee reference the same list object, so changing it from one place changes it in the\nother:\n>>> import small\n>>> small.x\n1\n>>> small.y\n[42, 2]\n\n# Get module name (from doesn't)\n# Small's x is not my x\n# But we share a changed mutable\n\nFor a graphical picture of what from assignments do with references, flip back to Figure 18-1 (function argument passing), and mentally replace “caller” and “function”\nwith “imported” and “importer.” The effect is the same, except that here we’re dealing\nwith names in modules, not functions. Assignment works the same everywhere in\nPython.",
    "For a graphical picture of what from assignments do with references, flip back to Figure 18-1 (function argument passing), and mentally replace “caller” and “function”\nwith “imported” and “importer.” The effect is the same, except that here we’re dealing\nwith names in modules, not functions. Assignment works the same everywhere in\nPython.\n\nCross-File Name Changes\nRecall from the preceding example that the assignment to x in the interactive session\nchanged the name x in that scope only, not the x in the file—there is no link from a\nname copied with from back to the file it came from. To really change a global name in\nanother file, you must use import:\n% python\n>>> from small import x, y\n>>> x = 42\n\n# Copy two names out\n# Changes my x only\n\n>>> import small\n>>> small.x = 42\n\n# Get module name\n# Changes x in other module",
    "# Copy two names out\n# Changes my x only\n\n>>> import small\n>>> small.x = 42\n\n# Get module name\n# Changes x in other module\n\nThis phenomenon was introduced in Chapter 17. Because changing variables in other\nmodules like this is a common source of confusion (and often a bad design choice),\nwe’ll revisit this technique again later in this part of the book. Note that the change to\ny[0] in the prior session is different; it changes an object, not a name.\n\nModule Usage | 547\n\n\fimport and from Equivalence\nNotice in the prior example that we have to execute an import statement after the\nfrom to access the small module name at all. from only copies names from one module\nto another; it does not assign the module name itself. At least conceptually, a from\nstatement like this one:\nfrom module import name1, name2\n\n# Copy these two names out (only)\n\nis equivalent to this statement sequence:\nimport module\nname1 = module.name1\nname2 = module.name2\ndel module",
    "# Copy these two names out (only)\n\nis equivalent to this statement sequence:\nimport module\nname1 = module.name1\nname2 = module.name2\ndel module\n\n# Fetch the module object\n# Copy names out by assignment\n# Get rid of the module name",
    "# Fetch the module object\n# Copy names out by assignment\n# Get rid of the module name\n\nLike all assignments, the from statement creates new variables in the importer, which\ninitially refer to objects of the same names in the imported file. Only the names are\ncopied out, though, not the module itself. When we use the from * form of this statement (from module import *), the equivalence is the same, but all the top-level names\nin the module are copied over to the importing scope this way.\nNotice that the first step of the from runs a normal import operation. Because of this,\nthe from always imports the entire module into memory if it has not yet been imported,\nregardless of how many names it copies out of the file. There is no way to load just part\nof a module file (e.g., just one function), but because modules are byte code in Python\ninstead of machine code, the performance implications are generally negligible.",
    "Potential Pitfalls of the from Statement\nBecause the from statement makes the location of a variable more implicit and obscure\n(name is less meaningful to the reader than module.name), some Python users recommend\nusing import instead of from most of the time. I’m not sure this advice is warranted,\nthough; from is commonly and widely used, without too many dire consequences. In\npractice, in realistic programs, it’s often convenient not to have to type a module’s name\nevery time you wish to use one of its tools. This is especially true for large modules that\nprovide many attributes—the standard library’s tkinter GUI module, for example.\nIt is true that the from statement has the potential to corrupt namespaces, at least in\nprinciple—if you use it to import variables that happen to have the same names as\nexisting variables in your scope, your variables will be silently overwritten. This problem doesn’t occur with the simple import statement because you must always go",
    "It is true that the from statement has the potential to corrupt namespaces, at least in\nprinciple—if you use it to import variables that happen to have the same names as\nexisting variables in your scope, your variables will be silently overwritten. This problem doesn’t occur with the simple import statement because you must always go\nthrough a module’s name to get to its contents (module.attr will not clash with a\nvariable named attr in your scope). As long as you understand and expect that this can\nhappen when using from, though, this isn’t a major concern in practice, especially if\nyou list the imported names explicitly (e.g., from module import x, y, z).\nOn the other hand, the from statement has more serious issues when used in conjunction with the reload call, as imported names might reference prior versions of objects.\n548 | Chapter 22: Module Coding Basics",
    "Moreover, the from module import * form really can corrupt namespaces and make\nnames difficult to understand, especially when applied to more than one file—in this\ncase, there is no way to tell which module a name came from, short of searching the\nexternal source files. In effect, the from * form collapses one namespace into another,\nand so defeats the namespace partitioning feature of modules. We will explore these\nissues in more detail in the section “Module Gotchas” on page 599 at the end of this\npart of the book (see Chapter 24).\nProbably the best real-world advice here is to generally prefer import to from for simple\nmodules, to explicitly list the variables you want in most from statements, and to limit\nthe from * form to just one import per file. That way, any undefined names can be\nassumed to live in the module referenced with the from *. Some care is required when\nusing the from statement, but armed with a little knowledge, most programmers find",
    "modules, to explicitly list the variables you want in most from statements, and to limit\nthe from * form to just one import per file. That way, any undefined names can be\nassumed to live in the module referenced with the from *. Some care is required when\nusing the from statement, but armed with a little knowledge, most programmers find\nit to be a convenient way to access modules.",
    "When import is required\nThe only time you really must use import instead of from is when you must use the same\nname defined in two different modules. For example, if two files define the same name\ndifferently:\n# M.py\ndef func():\n...do something...\n# N.py\ndef func():\n...do something else...\n\nand you must use both versions of the name in your program, the from statement will\nfail—you can only have one assignment to the name in your scope:\n# O.py\nfrom M import func\nfrom N import func\nfunc()\n\n# This overwites the one we got from M\n# Calls N.func only\n\nAn import will work here, though, because including the name of the enclosing module\nmakes the two names unique:\n# O.py\nimport M, N\nM.func()\nN.func()\n\n# Get the whole modules, not their names\n# We can call both names now\n# The module names make them unique\n\nThis case is unusual enough that you’re unlikely to encounter it very often in practice.\nIf you do, though, import allows you to avoid the name collision.\n\nModule Usage | 549",
    "# Get the whole modules, not their names\n# We can call both names now\n# The module names make them unique\n\nThis case is unusual enough that you’re unlikely to encounter it very often in practice.\nIf you do, though, import allows you to avoid the name collision.\n\nModule Usage | 549\n\n\fModule Namespaces\nModules are probably best understood as simply packages of names—i.e., places to\ndefine names you want to make visible to the rest of a system. Technically, modules\nusually correspond to files, and Python creates a module object to contain all the names\nassigned in a module file. But in simple terms, modules are just namespaces (places\nwhere names are created), and the names that live in a module are called its attributes. We’ll explore how all this works in this section.",
    "Files Generate Namespaces\nSo, how do files morph into namespaces? The short story is that every name that is\nassigned a value at the top level of a module file (i.e., not nested in a function or class\nbody) becomes an attribute of that module.\nFor instance, given an assignment statement such as X = 1 at the top level of a module\nfile M.py, the name X becomes an attribute of M, which we can refer to from outside the\nmodule as M.X. The name X also becomes a global variable to other code inside M.py,\nbut we need to explain the notion of module loading and scopes a bit more formally\nto understand why:\n• Module statements run on the first import. The first time a module is imported\nanywhere in a system, Python creates an empty module object and executes the\nstatements in the module file one after another, from the top of the file to the\nbottom.\n• Top-level assignments create module attributes. During an import, statements",
    "to understand why:\n• Module statements run on the first import. The first time a module is imported\nanywhere in a system, Python creates an empty module object and executes the\nstatements in the module file one after another, from the top of the file to the\nbottom.\n• Top-level assignments create module attributes. During an import, statements\nat the top level of the file not nested in a def or class that assign names (e.g., =,\ndef) create attributes of the module object; assigned names are stored in the module’s namespace.\n• Module namespaces can be accessed via the attribute__dict__ or dir(M).\nModule namespaces created by imports are dictionaries; they may be accessed\nthrough the built-in __dict__ attribute associated with module objects and may be\ninspected with the dir function. The dir function is roughly equivalent to the sorted\nkeys list of an object’s __dict__ attribute, but it includes inherited names for classes,",
    "Module namespaces created by imports are dictionaries; they may be accessed\nthrough the built-in __dict__ attribute associated with module objects and may be\ninspected with the dir function. The dir function is roughly equivalent to the sorted\nkeys list of an object’s __dict__ attribute, but it includes inherited names for classes,\nmay not be complete, and is prone to changing from release to release.\n• Modules are a single scope (local is global). As we saw in Chapter 17, names\nat the top level of a module follow the same reference/assignment rules as names\nin a function, but the local and global scopes are the same (more formally, they\nfollow the LEGB scope rule we met in Chapter 17, but without the L and E lookup\nlayers). But, in modules, the module scope becomes an attribute dictionary of a\nmodule object after the module has been loaded. Unlike with functions (where the\nlocal namespace exists only while the function runs), a module file’s scope becomes",
    "follow the LEGB scope rule we met in Chapter 17, but without the L and E lookup\nlayers). But, in modules, the module scope becomes an attribute dictionary of a\nmodule object after the module has been loaded. Unlike with functions (where the\nlocal namespace exists only while the function runs), a module file’s scope becomes\na module object’s attribute namespace and lives on after the import.",
    "550 | Chapter 22: Module Coding Basics\n\n\fHere’s a demonstration of these ideas. Suppose we create the following module file in\na text editor and call it module2.py:\nprint('starting to load...')\nimport sys\nname = 42\ndef func(): pass\nclass klass: pass\nprint('done loading.')\n\nThe first time this module is imported (or run as a program), Python executes its statements from top to bottom. Some statements create names in the module’s namespace\nas a side effect, but others do actual work while the import is going on. For instance,\nthe two print statements in this file execute at import time:\n>>> import module2\nstarting to load...\ndone loading.",
    "The first time this module is imported (or run as a program), Python executes its statements from top to bottom. Some statements create names in the module’s namespace\nas a side effect, but others do actual work while the import is going on. For instance,\nthe two print statements in this file execute at import time:\n>>> import module2\nstarting to load...\ndone loading.\n\nOnce the module is loaded, its scope becomes an attribute namespace in the module\nobject we get back from import. We can then access attributes in this namespace by\nqualifying them with the name of the enclosing module:\n>>> module2.sys\n<module 'sys' (built-in)>\n>>> module2.name\n42\n>>> module2.func\n<function func at 0x026D3BB8>\n>>> module2.klass\n<class 'module2.klass'>",
    "Here, sys, name, func, and klass were all assigned while the module’s statements were\nbeing run, so they are attributes after the import. We’ll talk about classes in Part VI,\nbut notice the sys attribute—import statements really assign module objects to names,\nand any type of assignment to a name at the top level of a file generates a module\nattribute.\nInternally, module namespaces are stored as dictionary objects. These are just normal\ndictionary objects with the usual methods. We can access a module’s namespace dictionary through the module’s __dict__ attribute (remember to wrap this in a list call\nin Python 3.0—it’s a view object):\n>>> list(module2.__dict__.keys())\n['name', '__builtins__', '__file__', '__package__', 'sys', 'klass', 'func',\n'__name__', '__doc__']\n\nModule Namespaces | 551",
    "Module Namespaces | 551\n\n\fThe names we assigned in the module file become dictionary keys internally, so most\nof the names here reflect top-level assignments in our file. However, Python also adds\nsome names in the module’s namespace for us; for instance, __file__ gives the name\nof the file the module was loaded from, and __name__ gives its name as known to importers (without the .py extension and directory path).",
    "Attribute Name Qualification\nNow that you’re becoming more familiar with modules, we should look at the notion\nof name qualification (fetching attributes) in more depth. In Python, you can access the\nattributes of any object that has attributes using the qualification syntax\nobject.attribute.\nQualification is really an expression that returns the value assigned to an attribute name\nassociated with an object. For example, the expression module2.sys in the previous\nexample fetches the value assigned to sys in module2. Similarly, if we have a built-in list\nobject L, L.append returns the append method object associated with that list.\nSo, what does attribute qualification do to the scope rules we studied in Chapter 17?\nNothing, really: it’s an independent concept. When you use qualification to access\nnames, you give Python an explicit object from which to fetch the specified names. The\nLEGB rule applies only to bare, unqualified names. Here are the rules:\nSimple variables",
    "So, what does attribute qualification do to the scope rules we studied in Chapter 17?\nNothing, really: it’s an independent concept. When you use qualification to access\nnames, you give Python an explicit object from which to fetch the specified names. The\nLEGB rule applies only to bare, unqualified names. Here are the rules:\nSimple variables\nX means search for the name X in the current scopes (following the LEGB rule).\nQualification\nX.Y means find X in the current scopes, then search for the attribute Y in the object\nX (not in scopes).\nQualification paths\nX.Y.Z means look up the name Y in the object X, then look up Z in the object X.Y.\nGenerality\nQualification works on all objects with attributes: modules, classes, C extension\ntypes, etc.\nIn Part VI, we’ll see that qualification means a bit more for classes (it’s also the place\nwhere something called inheritance happens), but in general, the rules outlined here\napply to all names in Python.",
    "Imports Versus Scopes\nAs we’ve learned, it is never possible to access names defined in another module file\nwithout first importing that file. That is, you never automatically get to see names in\nanother file, regardless of the structure of imports or function calls in your program. A\nvariable’s meaning is always determined by the locations of assignments in your source\ncode, and attributes are always requested of an object explicitly.\n552 | Chapter 22: Module Coding Basics\n\n\fFor example, consider the following two simple modules. The first, moda.py, defines\na variable X global to code in its file only, along with a function that changes the global\nX in this file:\nX = 88\ndef f():\nglobal X\nX = 99\n\n# My X: global to this file only\n# Change this file's X\n# Cannot see names in other modules\n\nThe second module, modb.py, defines its own global variable X and imports and calls\nthe function in the first module:\nX = 11\n\n# My X: global to this file only\n\nimport moda\nmoda.f()\nprint(X, moda.X)",
    "# My X: global to this file only\n# Change this file's X\n# Cannot see names in other modules\n\nThe second module, modb.py, defines its own global variable X and imports and calls\nthe function in the first module:\nX = 11\n\n# My X: global to this file only\n\nimport moda\nmoda.f()\nprint(X, moda.X)\n\n# Gain access to names in moda\n# Sets moda.X, not this file's X\n\nWhen run, moda.f changes the X in moda, not the X in modb. The global scope for\nmoda.f is always the file enclosing it, regardless of which module it is ultimately called\nfrom:\n% python modb.py\n11 99",
    "# My X: global to this file only\n\nimport moda\nmoda.f()\nprint(X, moda.X)\n\n# Gain access to names in moda\n# Sets moda.X, not this file's X\n\nWhen run, moda.f changes the X in moda, not the X in modb. The global scope for\nmoda.f is always the file enclosing it, regardless of which module it is ultimately called\nfrom:\n% python modb.py\n11 99\n\nIn other words, import operations never give upward visibility to code in imported\nfiles—an imported file cannot see names in the importing file. More formally:\n• Functions can never see names in other functions, unless they are physically\nenclosing.\n• Module code can never see names in other modules, unless they are explicitly\nimported.\nSuch behavior is part of the lexical scoping notion—in Python, the scopes surrounding\na piece of code are completely determined by the code’s physical position in your file.\nScopes are never influenced by function calls or module imports.*",
    "Namespace Nesting\nIn some sense, although imports do not nest namespaces upward, they do nest downward. Using attribute qualification paths, it’s possible to descend into arbitrarily nested\nmodules and access their attributes. For example, consider the next three files.\nmod3.py defines a single global name and attribute by assignment:\nX = 3\n\nmod2.py in turn defines its own X, then imports mod3 and uses qualification to access\nthe imported module’s attribute:\n\n* Some languages act differently and provide for dynamic scoping, where scopes really may depend on runtime\ncalls. This tends to make code trickier, though, because the meaning of a variable can differ over time.\n\nModule Namespaces | 553\n\n\fX = 2\nimport mod3\nprint(X, end=' ')\nprint(mod3.X)\n\n# My global X\n# mod3's X\n\nmod1.py also defines its own X, then imports mod2, and fetches attributes in both the\nfirst and second files:\nX = 1\nimport mod2\nprint(X, end=' ')\nprint(mod2.X, end=' ')\nprint(mod2.mod3.X)",
    "Module Namespaces | 553\n\n\fX = 2\nimport mod3\nprint(X, end=' ')\nprint(mod3.X)\n\n# My global X\n# mod3's X\n\nmod1.py also defines its own X, then imports mod2, and fetches attributes in both the\nfirst and second files:\nX = 1\nimport mod2\nprint(X, end=' ')\nprint(mod2.X, end=' ')\nprint(mod2.mod3.X)\n\n# My global X\n# mod2's X\n# Nested mod3's X\n\nReally, when mod1 imports mod2 here, it sets up a two-level namespace nesting. By using\nthe path of names mod2.mod3.X, it can descend into mod3, which is nested in the imported\nmod2. The net effect is that mod1 can see the Xs in all three files, and hence has access to\nall three global scopes:\n% python mod1.py\n2 3\n1 2 3",
    "The reverse, however, is not true: mod3 cannot see names in mod2, and mod2 cannot see\nnames in mod1. This example may be easier to grasp if you don’t think in terms of\nnamespaces and scopes, but instead focus on the objects involved. Within mod1, mod2\nis just a name that refers to an object with attributes, some of which may refer to other\nobjects with attributes (import is an assignment). For paths like mod2.mod3.X, Python\nsimply evaluates from left to right, fetching attributes from objects along the way.\nNote that mod1 can say import mod2, and then mod2.mod3.X, but it cannot say import\nmod2.mod3—this syntax invokes something called package (directory) imports,\ndescribed in the next chapter. Package imports also create module namespace nesting,\nbut their import statements are taken to reflect directory trees, not simple import chains.",
    "Reloading Modules\nAs we’ve seen, a module’s code is run only once per process by default. To force a\nmodule’s code to be reloaded and rerun, you need to ask Python to do so explicitly by\ncalling the reload built-in function. In this section, we’ll explore how to use reloads to\nmake your systems more dynamic. In a nutshell:\n• Imports (via both import and from statements) load and run a module’s code only\nthe first time the module is imported in a process.\n• Later imports use the already loaded module object without reloading or rerunning\nthe file’s code.\n\n554 | Chapter 22: Module Coding Basics",
    "• The reload function forces an already loaded module’s code to be reloaded and\nrerun. Assignments in the file’s new code change the existing module object\nin-place.\nWhy all the fuss about reloading modules? The reload function allows parts of a program to be changed without stopping the whole program. With reload, therefore, the\neffects of changes in components can be observed immediately. Reloading doesn’t help\nin every situation, but where it does, it makes for a much shorter development cycle.\nFor instance, imagine a database program that must connect to a server on startup;\nbecause program changes or customizations can be tested immediately after reloads,\nyou need to connect only once while debugging. Long-running servers can update\nthemselves this way, too.\nBecause Python is interpreted (more or less), it already gets rid of the compile/link steps\nyou need to go through to get a C program to run: modules are loaded dynamically",
    "because program changes or customizations can be tested immediately after reloads,\nyou need to connect only once while debugging. Long-running servers can update\nthemselves this way, too.\nBecause Python is interpreted (more or less), it already gets rid of the compile/link steps\nyou need to go through to get a C program to run: modules are loaded dynamically\nwhen imported by a running program. Reloading offers a further performance advantage by allowing you to also change parts of running programs without stopping.\nNote that reload currently only works on modules written in Python; compiled extension modules coded in a language such as C can be dynamically loaded at runtime, too,\nbut they can’t be reloaded.\nVersion skew note: In Python 2.6, reload is available as a built-in function. In Python 3.0, it has been moved to the imp standard library\nmodule—it’s known as imp.reload in 3.0. This simply means that an\nextra import or from statement is required to load this tool (in 3.0 only).",
    "but they can’t be reloaded.\nVersion skew note: In Python 2.6, reload is available as a built-in function. In Python 3.0, it has been moved to the imp standard library\nmodule—it’s known as imp.reload in 3.0. This simply means that an\nextra import or from statement is required to load this tool (in 3.0 only).\nReaders using 2.6 can ignore these imports in this book’s examples, or\nuse them anyhow—2.6 also has a reload in its imp module to ease migration to 3.0. Reloading works the same regardless of its packaging.",
    "reload Basics\nUnlike import and from:\n• reload is a function in Python, not a statement.\n• reload is passed an existing module object, not a name.\n• reload lives in a module in Python 3.0 and must be imported itself.\nBecause reload expects an object, a module must have been previously imported successfully before you can reload it (if the import was unsuccessful, due to a syntax or\nother error, you may need to repeat it before you can reload the module). Furthermore,\nthe syntax of import statements and reload calls differs: reloads require parentheses,\nbut imports do not. Reloading looks like this:\nimport module\n...use module.attributes...\n...\n...\n\n# Initial import\n# Now, go change the module file\n\nReloading Modules | 555\n\n\ffrom imp import reload\nreload(module)\n...use module.attributes...\n\n# Get reload itself (in 3.0)\n# Get updated exports",
    "The typical usage pattern is that you import a module, then change its source code in\na text editor, and then reload it. When you call reload, Python rereads the module file’s\nsource code and reruns its top-level statements. Perhaps the most important thing to\nknow about reload is that it changes a module object in-place; it does not delete and\nre-create the module object. Because of that, every reference to a module object anywhere in your program is automatically affected by a reload. Here are the details:\n• reload runs a module file’s new code in the module’s current namespace.\nRerunning a module file’s code overwrites its existing namespace, rather than deleting and re-creating it.\n• Top-level assignments in the file replace names with new values. For instance,\nrerunning a def statement replaces the prior version of the function in the module’s\nnamespace by reassigning the function name.\n• Reloads impact all clients that use import to fetch modules. Because clients",
    "Rerunning a module file’s code overwrites its existing namespace, rather than deleting and re-creating it.\n• Top-level assignments in the file replace names with new values. For instance,\nrerunning a def statement replaces the prior version of the function in the module’s\nnamespace by reassigning the function name.\n• Reloads impact all clients that use import to fetch modules. Because clients\nthat use import qualify to fetch attributes, they’ll find new values in the module\nobject after a reload.\n• Reloads impact future from clients only. Clients that used from to fetch attributes\nin the past won’t be affected by a reload; they’ll still have references to the old\nobjects fetched before the reload.",
    "reload Example\nTo demonstrate, here’s a more concrete example of reload in action. In the following,\nwe’ll change and reload a module file without stopping the interactive Python session.\nReloads are used in many other scenarios, too (see the sidebar “Why You Will Care:\nModule Reloads” on page 557), but we’ll keep things simple for illustration here.\nFirst, in the text editor of your choice, write a module file named changer.py with the\nfollowing contents:\nmessage = \"First version\"\ndef printer():\nprint(message)\n\nThis module creates and exports two names—one bound to a string, and another to a\nfunction. Now, start the Python interpreter, import the module, and call the function\nit exports. The function will print the value of the global message variable:\n% python\n>>> import changer\n>>> changer.printer()\nFirst version\n\n556 | Chapter 22: Module Coding Basics",
    "This module creates and exports two names—one bound to a string, and another to a\nfunction. Now, start the Python interpreter, import the module, and call the function\nit exports. The function will print the value of the global message variable:\n% python\n>>> import changer\n>>> changer.printer()\nFirst version\n\n556 | Chapter 22: Module Coding Basics\n\n\fKeeping the interpreter active, now edit the module file in another window:\n...modify changer.py without stopping Python...\n% vi changer.py\n\nChange the global message variable, as well as the printer function body:\nmessage = \"After editing\"\ndef printer():\nprint('reloaded:', message)",
    "556 | Chapter 22: Module Coding Basics\n\n\fKeeping the interpreter active, now edit the module file in another window:\n...modify changer.py without stopping Python...\n% vi changer.py\n\nChange the global message variable, as well as the printer function body:\nmessage = \"After editing\"\ndef printer():\nprint('reloaded:', message)\n\nThen, return to the Python window and reload the module to fetch the new code. Notice\nin the following interaction that importing the module again has no effect; we get the\noriginal message, even though the file’s been changed. We have to call reload in order\nto get the new version:\n...back to the Python interpreter/program...\n>>> import changer\n>>> changer.printer()\nFirst version\n>>> from imp import reload\n>>> reload(changer)\n<module 'changer' from 'changer.py'>\n>>> changer.printer()\nreloaded: After editing\n\n# No effect: uses loaded module\n# Forces new code to load/run\n# Runs the new version now",
    "# No effect: uses loaded module\n# Forces new code to load/run\n# Runs the new version now\n\nNotice that reload actually returns the module object for us—its result is usually ignored, but because expression results are printed at the interactive prompt, Python\nshows a default <module 'name'...> representation.",
    "Why You Will Care: Module Reloads\nBesides allowing you to reload (and hence rerun) modules at the interactive prompt,\nmodule reloads are also useful in larger systems, especially when the cost of restarting\nthe entire application is prohibitive. For instance, systems that must connect to servers\nover a network on startup are prime candidates for dynamic reloads.\nThey’re also useful in GUI work (a widget’s callback action can be changed while the\nGUI remains active), and when Python is used as an embedded language in a C or\nC++ program (the enclosing program can request a reload of the Python code it runs,\nwithout having to stop). See Programming Python for more on reloading GUI callbacks\nand embedded Python code.\nMore generally, reloads allow programs to provide highly dynamic interfaces. For instance, Python is often used as a customization language for larger systems—users can\ncustomize products by coding bits of Python code onsite, without having to recompile",
    "without having to stop). See Programming Python for more on reloading GUI callbacks\nand embedded Python code.\nMore generally, reloads allow programs to provide highly dynamic interfaces. For instance, Python is often used as a customization language for larger systems—users can\ncustomize products by coding bits of Python code onsite, without having to recompile\nthe entire product (or even having its source code at all). In such worlds, the Python\ncode already adds a dynamic flavor by itself.",
    "Reloading Modules | 557\n\n\fTo be even more dynamic, though, such systems can automatically reload the Python\ncustomization code periodically at runtime. That way, users’ changes are picked up\nwhile the system is running; there is no need to stop and restart each time the Python\ncode is modified. Not all systems require such a dynamic approach, but for those that\ndo, module reloads provide an easy-to-use dynamic customization tool.",
    "Chapter Summary\nThis chapter delved into the basics of module coding tools—the import and from statements, and the reload call. We learned how the from statement simply adds an extra\nstep that copies names out of a file after it has been imported, and how reload forces\na file to be imported again without stopping and restarting Python. We also surveyed\nnamespace concepts, saw what happens when imports are nested, explored the way\nfiles become module namespaces, and learned about some potential pitfalls of the\nfrom statement.\nAlthough we’ve already seen enough to handle module files in our programs, the next\nchapter extends our coverage of the import model by presenting package imports—a\nway for our import statements to specify part of the directory path leading to the desired\nmodule. As we’ll see, package imports give us a hierarchy that is useful in larger systems\nand allow us to break conflicts between same-named modules. Before we move on,",
    "chapter extends our coverage of the import model by presenting package imports—a\nway for our import statements to specify part of the directory path leading to the desired\nmodule. As we’ll see, package imports give us a hierarchy that is useful in larger systems\nand allow us to break conflicts between same-named modules. Before we move on,\nthough, here’s a quick quiz on the concepts presented here.",
    "Test Your Knowledge: Quiz\n1. How do you make a module?\n2. How is the from statement related to the import statement?\n3. How is the reload function related to imports?\n4. When must you use import instead of from?\n5. Name three potential pitfalls of the from statement.\n6. What...is the airspeed velocity of an unladen swallow?\n\nTest Your Knowledge: Answers\n1. To create a module, you just write a text file containing Python statements; every\nsource code file is automatically a module, and there is no syntax for declaring one.\nImport operations load module files into module objects in memory. You can also\nmake a module by writing code in an external language like C or Java, but such\nextension modules are beyond the scope of this book.\n\n558 | Chapter 22: Module Coding Basics",
    "2. The from statement imports an entire module, like the import statement, but as an\nextra step it also copies one or more variables from the imported module into the\nscope where the from appears. This enables you to use the imported names directly\n(name) instead of having to go through the module (module.name).\n3. By default, a module is imported only once per process. The reload function forces\na module to be imported again. It is mostly used to pick up new versions of a\nmodule’s source code during development, and in dynamic customization\nscenarios.\n4. You must use import instead of from only when you need to access the same name\nin two different modules; because you’ll have to specify the names of the enclosing\nmodules, the two names will be unique.\n5. The from statement can obscure the meaning of a variable (which module it is\ndefined in), can have problems with the reload call (names may reference prior",
    "scenarios.\n4. You must use import instead of from only when you need to access the same name\nin two different modules; because you’ll have to specify the names of the enclosing\nmodules, the two names will be unique.\n5. The from statement can obscure the meaning of a variable (which module it is\ndefined in), can have problems with the reload call (names may reference prior\nversions of objects), and can corrupt namespaces (it might silently overwrite names\nyou are using in your scope). The from * form is worse in most regards—it can\nseriously corrupt namespaces and obscure the meaning of variables, so it is probably best used sparingly.\n6. What do you mean? An African or European swallow?",
    "Test Your Knowledge: Answers | 559\n\n\f\fCHAPTER 23\n\nModule Packages",
    "So far, when we’ve imported modules, we’ve been loading files. This represents typical\nmodule usage, and it’s probably the technique you’ll use for most imports you’ll code\nearly on in your Python career. However, the module import story is a bit richer than\nI have thus far implied.\nIn addition to a module name, an import can name a directory path. A directory of\nPython code is said to be a package, so such imports are known as package imports. In\neffect, a package import turns a directory on your computer into another Python namespace, with attributes corresponding to the subdirectories and module files that the\ndirectory contains.\nThis is a somewhat advanced feature, but the hierarchy it provides turns out to be handy\nfor organizing the files in a large system and tends to simplify module search path\nsettings. As we’ll see, package imports are also sometimes required to resolve import\nambiguities when multiple program files of the same name are installed on a single\nmachine.",
    "directory contains.\nThis is a somewhat advanced feature, but the hierarchy it provides turns out to be handy\nfor organizing the files in a large system and tends to simplify module search path\nsettings. As we’ll see, package imports are also sometimes required to resolve import\nambiguities when multiple program files of the same name are installed on a single\nmachine.\nBecause it is relevant to code in packages only, we’ll also introduce Python’s recent\nrelative imports model and syntax here. As we’ll see, this model modifies search paths\nand extends the from statement for imports within packages.",
    "Package Import Basics\nSo, how do package imports work? In the place where you have been naming a simple\nfile in your import statements, you can instead list a path of names separated by periods:\nimport dir1.dir2.mod\n\nThe same goes for from statements:\nfrom dir1.dir2.mod import x\n\n561\n\n\fThe “dotted” path in these statements is assumed to correspond to a path through the\ndirectory hierarchy on your machine, leading to the file mod.py (or similar; the extension may vary). That is, the preceding statements indicate that on your machine there\nis a directory dir1, which has a subdirectory dir2, which contains a module file\nmod.py (or similar).\nFurthermore, these imports imply that dir1 resides within some container directory\ndir0, which is a component of the Python module search path. In other words, the two\nimport statements imply a directory structure that looks something like this (shown\nwith DOS backslash separators):\ndir0\\dir1\\dir2\\mod.py\n\n# Or mod.pyc, mod.so, etc.",
    "# Or mod.pyc, mod.so, etc.\n\nThe container directory dir0 needs to be added to your module search path (unless it’s\nthe home directory of the top-level file), exactly as if dir1 were a simple module file.\nMore generally, the leftmost component in a package import path is still relative to a\ndirectory included in the sys.path module search path list we met in Chapter 21. From\nthere down, though, the import statements in your script give the directory paths leading to the modules explicitly.",
    "Packages and Search Path Settings\nIf you use this feature, keep in mind that the directory paths in your import statements\ncan only be variables separated by periods. You cannot use any platform-specific path\nsyntax in your import statements, such as C:\\dir1, My Documents.dir2 or ../dir1—these\ndo not work syntactically. Instead, use platform-specific syntax in your module search\npath settings to name the container directories.\nFor instance, in the prior example, dir0—the directory name you add to your module\nsearch path—can be an arbitrarily long and platform-specific directory path leading up\nto dir1. Instead of using an invalid statement like this:\nimport C:\\mycode\\dir1\\dir2\\mod\n\n# Error: illegal syntax\n\nadd C:\\mycode to your PYTHONPATH variable or a .pth file (assuming it is not the program’s\nhome directory, in which case this step is not necessary), and say this in your script:\nimport dir1.dir2.mod",
    "# Error: illegal syntax\n\nadd C:\\mycode to your PYTHONPATH variable or a .pth file (assuming it is not the program’s\nhome directory, in which case this step is not necessary), and say this in your script:\nimport dir1.dir2.mod\n\nIn effect, entries on the module search path provide platform-specific directory path\nprefixes, which lead to the leftmost names in import statements. import statements\nprovide directory path tails in a platform-neutral fashion.*\n\n* The dot path syntax was chosen partly for platform neutrality, but also because paths in import statements\nbecome real nested object paths. This syntax also means that you get odd error messages if you forget to omit\nthe .py in your import statements. For example, import mod.py is assumed to be a directory path import—it\nloads mod.py, then tries to load a mod\\py.py, and ultimately issues a potentially confusing “No module named\npy” error message.\n\n562 | Chapter 23: Module Packages",
    "562 | Chapter 23: Module Packages\n\n\fPackage __init__.py Files\nIf you choose to use package imports, there is one more constraint you must follow:\neach directory named within the path of a package import statement must contain a\nfile named __init__.py, or your package imports will fail. That is, in the example we’ve\nbeen using, both dir1 and dir2 must contain a file called __init__.py; the container\ndirectory dir0 does not require such a file because it’s not listed in the import statement\nitself. More formally, for a directory structure such as this:\ndir0\\dir1\\dir2\\mod.py\n\nand an import statement of the form:\nimport dir1.dir2.mod",
    "and an import statement of the form:\nimport dir1.dir2.mod\n\nthe following rules apply:\n• dir1 and dir2 both must contain an __init__.py file.\n• dir0, the container, does not require an __init__.py file; this file will simply be\nignored if present.\n• dir0, not dir0\\dir1, must be listed on the module search path (i.e., it must be the\nhome directory, or be listed in your PYTHONPATH, etc.).\nThe net effect is that this example’s directory structure should be as follows, with indentation designating directory nesting:\ndir0\\\ndir1\\\n__init__.py\ndir2\\\n__init__.py\nmod.py\n\n# Container on module search path",
    "The __init__.py files can contain Python code, just like normal module files. They are\npartly present as a declaration to Python, however, and can be completely empty. As\ndeclarations, these files serve to prevent directories with common names from unintentionally hiding true modules that appear later on the module search path. Without\nthis safeguard, Python might pick a directory that has nothing to do with your code,\njust because it appears in an earlier directory on the search path.\nMore generally, the __init__.py file serves as a hook for package-initialization-time actions, generates a module namespace for a directory, and implements the behavior of\nfrom * (i.e., from .. import *) statements when used with directory imports:\nPackage initialization\nThe first time Python imports through a directory, it automatically runs all the code\nin the directory’s __init__.py file. Because of that, these files are a natural place to",
    "from * (i.e., from .. import *) statements when used with directory imports:\nPackage initialization\nThe first time Python imports through a directory, it automatically runs all the code\nin the directory’s __init__.py file. Because of that, these files are a natural place to\nput code to initialize the state required by files in a package. For instance, a package\nmight use its initialization file to create required data files, open connections to",
    "Package Import Basics | 563",
    "databases, and so on. Typically, __init__.py files are not meant to be useful if executed directly; they are run automatically when a package is first accessed.\nModule namespace initialization\nIn the package import model, the directory paths in your script become real nested\nobject paths after an import. For instance, in the preceding example, after the import the expression dir1.dir2 works and returns a module object whose namespace\ncontains all the names assigned by dir2’s __init__.py file. Such files provide a\nnamespace for module objects created for directories, which have no real associated module files.\nfrom * statement behavior\nAs an advanced feature, you can use __all__ lists in __init__.py files to define what\nis exported when a directory is imported with the from * statement form. In an\n__init__.py file, the __all__ list is taken to be the list of submodule names that\nshould be imported when from * is used on the package (directory) name. If",
    "from * statement behavior\nAs an advanced feature, you can use __all__ lists in __init__.py files to define what\nis exported when a directory is imported with the from * statement form. In an\n__init__.py file, the __all__ list is taken to be the list of submodule names that\nshould be imported when from * is used on the package (directory) name. If\n__all__ is not set, the from * statement does not automatically load submodules\nnested in the directory; instead, it loads just names defined by assignments in the\ndirectory’s __init__.py file, including any submodules explicitly imported by code\nin this file. For instance, the statement from submodule import X in a directory’s\n__init__.py makes the name X available in that directory’s namespace. (We’ll see\nadditional roles for __all__ in Chapter 24.)\nYou can also simply leave these files empty, if their roles are beyond your needs (and\nfrankly, they are often empty in practice). They must exist, though, for your directory",
    "in this file. For instance, the statement from submodule import X in a directory’s\n__init__.py makes the name X available in that directory’s namespace. (We’ll see\nadditional roles for __all__ in Chapter 24.)\nYou can also simply leave these files empty, if their roles are beyond your needs (and\nfrankly, they are often empty in practice). They must exist, though, for your directory\nimports to work at all.\nDon’t confuse package __init__.py files with the class __init__ constructor methods we’ll meet in the next part of the book. The former\nare files of code run when imports first step through a package directory,\nwhile the latter are called when an instance is created. Both have initialization roles, but they are otherwise very different.",
    "Package Import Example\nLet’s actually code the example we’ve been talking about to show how initialization\nfiles and paths come into play. The following three files are coded in a directory dir1\nand its subdirectory dir2—comments give the path names of these files:\n# dir1\\__init__.py\nprint('dir1 init')\nx = 1\n# dir1\\dir2\\__init__.py\nprint('dir2 init')\ny = 2\n\n564 | Chapter 23: Module Packages\n\n\f# dir1\\dir2\\mod.py\nprint('in mod.py')\nz = 3\n\nHere, dir1 will be either a subdirectory of the one we’re working in (i.e., the home\ndirectory), or a subdirectory of a directory that is listed on the module search path\n(technically, on sys.path). Either way, dir1’s container does not need an __init__.py file.\nimport statements run each directory’s initialization file the first time that directory is\ntraversed, as Python descends the path; print statements are included here to trace",
    "their execution. As with module files, an already imported directory may be passed to\nreload to force reexecution of that single item. As shown here, reload accepts a dotted\npathname to reload nested directories and files:\n% python\n>>> import dir1.dir2.mod\n# First imports run init files\ndir1 init\ndir2 init\nin mod.py\n>>>\n>>> import dir1.dir2.mod\n# Later imports do not\n>>>\n>>> from imp import reload\n# Needed in 3.0\n>>> reload(dir1)\ndir1 init\n<module 'dir1' from 'dir1\\__init__.pyc'>\n>>>\n>>> reload(dir1.dir2)\ndir2 init\n<module 'dir1.dir2' from 'dir1\\dir2\\__init__.pyc'>\n\nOnce imported, the path in your import statement becomes a nested object path in your\nscript. Here, mod is an object nested in the object dir2, which in turn is nested in the\nobject dir1:\n>>> dir1\n<module 'dir1' from 'dir1\\__init__.pyc'>\n>>> dir1.dir2\n<module 'dir1.dir2' from 'dir1\\dir2\\__init__.pyc'>\n>>> dir1.dir2.mod\n<module 'dir1.dir2.mod' from 'dir1\\dir2\\mod.pyc'>",
    "Once imported, the path in your import statement becomes a nested object path in your\nscript. Here, mod is an object nested in the object dir2, which in turn is nested in the\nobject dir1:\n>>> dir1\n<module 'dir1' from 'dir1\\__init__.pyc'>\n>>> dir1.dir2\n<module 'dir1.dir2' from 'dir1\\dir2\\__init__.pyc'>\n>>> dir1.dir2.mod\n<module 'dir1.dir2.mod' from 'dir1\\dir2\\mod.pyc'>\n\nIn fact, each directory name in the path becomes a variable assigned to a module object\nwhose namespace is initialized by all the assignments in that directory’s __init__.py\nfile. dir1.x refers to the variable x assigned in dir1\\__init__.py, much as mod.z refers to\nthe variable z assigned in mod.py:\n>>> dir1.x\n1\n>>> dir1.dir2.y\n2\n>>> dir1.dir2.mod.z\n3\n\nPackage Import Example | 565\n\n\ffrom Versus import with Packages\nimport statements can be somewhat inconvenient to use with packages, because you",
    "Package Import Example | 565\n\n\ffrom Versus import with Packages\nimport statements can be somewhat inconvenient to use with packages, because you\n\nmay have to retype the paths frequently in your program. In the prior section’s example,\nfor instance, you must retype and rerun the full path from dir1 each time you want to\nreach z. If you try to access dir2 or mod directly, you’ll get an error:\n>>> dir2.mod\nNameError: name 'dir2' is not defined\n>>> mod.z\nNameError: name 'mod' is not defined",
    "may have to retype the paths frequently in your program. In the prior section’s example,\nfor instance, you must retype and rerun the full path from dir1 each time you want to\nreach z. If you try to access dir2 or mod directly, you’ll get an error:\n>>> dir2.mod\nNameError: name 'dir2' is not defined\n>>> mod.z\nNameError: name 'mod' is not defined\n\nIt’s often more convenient, therefore, to use the from statement with packages to avoid\nretyping the paths at each access. Perhaps more importantly, if you ever restructure\nyour directory tree, the from statement requires just one path update in your code,\nwhereas imports may require many. The import as extension, discussed formally in the\nnext chapter, can also help here by providing a shorter synonym for the full path:\n% python\n>>> from dir1.dir2 import mod\ndir1 init\ndir2 init\nin mod.py\n>>> mod.z\n3\n>>> from dir1.dir2.mod import z\n>>> z\n3\n>>> import dir1.dir2.mod as mod\n>>> mod.z\n3\n\n# Code path here only\n\n# Don't repeat path",
    "# Code path here only\n\n# Don't repeat path\n\n# Use shorter name (see Chapter 24)",
    "# Don't repeat path\n\n# Use shorter name (see Chapter 24)\n\nWhy Use Package Imports?\nIf you’re new to Python, make sure that you’ve mastered simple modules before stepping up to packages, as they are a somewhat advanced feature. They do serve useful\nroles, though, especially in larger programs: they make imports more informative, serve\nas an organizational tool, simplify your module search path, and can resolve\nambiguities.\nFirst of all, because package imports give some directory information in program files,\nthey both make it easier to locate your files and serve as an organizational tool. Without\npackage paths, you must often resort to consulting the module search path to find files.\nMoreover, if you organize your files into subdirectories for functional areas, package\nimports make it more obvious what role a module plays, and so make your code more\nreadable. For example, a normal import of a file in a directory somewhere on the module\nsearch path, like this:\nimport utilities",
    "566 | Chapter 23: Module Packages\n\n\foffers much less information than an import that includes the path:\nimport database.client.utilities\n\nPackage imports can also greatly simplify your PYTHONPATH and .pth file search path\nsettings. In fact, if you use explicit package imports for all your cross-directory imports,\nand you make those package imports relative to a common root directory where all\nyour Python code is stored, you really only need a single entry on your search path: the\ncommon root. Finally, package imports serve to resolve ambiguities by making explicit\nexactly which files you want to import. The next section explores this role in more\ndetail.",
    "A Tale of Three Systems\nThe only time package imports are actually required is to resolve ambiguities that may\narise when multiple programs with same-named files are installed on a single machine.\nThis is something of an install issue, but it can also become a concern in general practice.\nLet’s turn to a hypothetical scenario to illustrate.\nSuppose that a programmer develops a Python program that contains a file called\nutilities.py for common utility code and a top-level file named main.py that users launch\nto start the program. All over this program, its files say import utilities to load and\nuse the common code. When the program is shipped, it arrives as a single .tar or .zip\nfile containing all the program’s files, and when it is installed, it unpacks all its files into\na single directory named system1 on the target machine:\nsystem1\\\nutilities.py\nmain.py\nother.py\n\n# Common utility functions, classes\n# Launch this to start the program\n# Import utilities to load my tools",
    "# Common utility functions, classes\n# Launch this to start the program\n# Import utilities to load my tools\n\nNow, suppose that a second programmer develops a different program with files also\ncalled utilities.py and main.py, and again uses import utilities throughout the program to load the common code file. When this second system is fetched and installed\non the same computer as the first system, its files will unpack into a new directory called\nsystem2 somewhere on the receiving machine (ensuring that they do not overwrite\nsame-named files from the first system):\nsystem2\\\nutilities.py\nmain.py\nother.py\n\n# Common utilities\n# Launch this to run\n# Imports utilities",
    "# Common utilities\n# Launch this to run\n# Imports utilities\n\nSo far, there’s no problem: both systems can coexist and run on the same machine. In\nfact, you won’t even need to configure the module search path to use these programs\non your computer—because Python always searches the home directory first (that is,\nthe directory containing the top-level file), imports in either system’s files will automatically see all the files in that system’s directory. For instance, if you click on\nsystem1\\main.py, all imports will search system1 first. Similarly, if you launch\n\nWhy Use Package Imports? | 567",
    "Why Use Package Imports? | 567\n\n\fsystem2\\main.py, system2 will be searched first instead. Remember, module search path\nsettings are only needed to import across directory boundaries.\nHowever, suppose that after you’ve installed these two programs on your machine, you\ndecide that you’d like to use some of the code in each of the utilities.py files in a system\nof your own. It’s common utility code, after all, and Python code by nature wants to\nbe reused. In this case, you want to be able to say the following from code that you’re\nwriting in a third directory to load one of the two files:\nimport utilities\nutilities.func('spam')",
    "Now the problem starts to materialize. To make this work at all, you’ll have to set the\nmodule search path to include the directories containing the utilities.py files. But which\ndirectory do you put first in the path—system1 or system2?\nThe problem is the linear nature of the search path. It is always scanned from left to\nright, so no matter how long you ponder this dilemma, you will always get utilities.py\nfrom the directory listed first (leftmost) on the search path. As is, you’ll never be able\nto import it from the other directory at all. You could try changing sys.path within\nyour script before each import operation, but that’s both extra work and highly error\nprone. By default, you’re stuck.\nThis is the issue that packages actually fix. Rather than installing programs as flat lists\nof files in standalone directories, you can package and install them as subdirectories\nunder a common root. For instance, you might organize all the code in this example as",
    "your script before each import operation, but that’s both extra work and highly error\nprone. By default, you’re stuck.\nThis is the issue that packages actually fix. Rather than installing programs as flat lists\nof files in standalone directories, you can package and install them as subdirectories\nunder a common root. For instance, you might organize all the code in this example as\nan install hierarchy that looks like this:\nroot\\\nsystem1\\\n__init__.py\nutilities.py\nmain.py\nother.py\nsystem2\\\n__init__.py\nutilities.py\nmain.py\nother.py\nsystem3\\\n__init__.py\nmyfile.py",
    "# Here or elsewhere\n# Your new code here\n\nNow, add just the common root directory to your search path. If your code’s imports\nare all relative to this common root, you can import either system’s utility file with a\npackage import—the enclosing directory name makes the path (and hence, the module\nreference) unique. In fact, you can import both utility files in the same module, as long\nas you use an import statement and repeat the full path each time you reference the\nutility modules:\n\n568 | Chapter 23: Module Packages\n\n\fimport system1.utilities\nimport system2.utilities\nsystem1.utilities.function('spam')\nsystem2.utilities.function('eggs')",
    "The names of the enclosing directories here make the module references unique.\nNote that you have to use import instead of from with packages only if you need to\naccess the same attribute in two or more paths. If the name of the called function here\nwas different in each path, from statements could be used to avoid repeating the full\npackage path whenever you call one of the functions, as described earlier.\nAlso, notice in the install hierarchy shown earlier that __init__.py files were added to\nthe system1 and system2 directories to make this work, but not to the root directory.\nOnly directories listed within import statements in your code require these files; as you’ll\nrecall, they are run automatically the first time the Python process imports through a\npackage directory.\nTechnically, in this case the system3 directory doesn’t have to be under root—just the\npackages of code from which you will import. However, because you never know when",
    "Only directories listed within import statements in your code require these files; as you’ll\nrecall, they are run automatically the first time the Python process imports through a\npackage directory.\nTechnically, in this case the system3 directory doesn’t have to be under root—just the\npackages of code from which you will import. However, because you never know when\nyour own modules might be useful in other programs, you might as well place them\nunder the common root directory as well to avoid similar name-collision problems in\nthe future.\nFinally, notice that both of the two original systems’ imports will keep working unchanged. Because their home directories are searched first, the addition of the common\nroot on the search path is irrelevant to code in system1 and system2; they can keep\nsaying just import utilities and expect to find their own files. Moreover, if you’re",
    "the future.\nFinally, notice that both of the two original systems’ imports will keep working unchanged. Because their home directories are searched first, the addition of the common\nroot on the search path is irrelevant to code in system1 and system2; they can keep\nsaying just import utilities and expect to find their own files. Moreover, if you’re\ncareful to unpack all your Python systems under a common root like this, path configuration becomes simple: you’ll only need to add the common root directory, once.",
    "Package Relative Imports\nThe coverage of package imports so far has focused mostly on importing package files\nfrom outside the package. Within the package itself, imports of package files can use\nthe same path syntax as outside imports, but they can also make use of special intrapackage search rules to simplify import statements. That is, rather than listing package\nimport paths, imports within the package can be relative to the package.\nThe way this works is version-dependent today: Python 2.6 implicitly searches package\ndirectories first on imports, while 3.0 requires explicit relative import syntax. This 3.0\nchange can enhance code readability, by making same-package imports more obvious.\nIf you’re starting out in Python with version 3.0, your focus in this section will likely\nbe on its new import syntax. If you’ve used other Python packages in the past, though,\nyou’ll probably also be interested in how the 3.0 model differs.\n\nPackage Relative Imports | 569",
    "Changes in Python 3.0\nThe way import operations in packages work has changed slightly in Python 3.0. This\nchange applies only to imports within files located in the package directories we’ve\nbeen studying in this chapter; imports in other files work as before. For imports in\npackages, though, Python 3.0 introduces two changes:\n• It modifies the module import search path semantics to skip the package’s own\ndirectory by default. Imports check only other components of the search path.\nThese are known as “absolute” imports.\n• It extends the syntax of from statements to allow them to explicitly request that\nimports search the package’s directory only. This is known as “relative” import\nsyntax.\nThese changes are fully present in Python 3.0. The new from statement relative syntax\nis also available in Python 2.6, but the default search path change must be enabled as\nan option. It’s currently scheduled to be added in the 2.7 release†—this change is being",
    "imports search the package’s directory only. This is known as “relative” import\nsyntax.\nThese changes are fully present in Python 3.0. The new from statement relative syntax\nis also available in Python 2.6, but the default search path change must be enabled as\nan option. It’s currently scheduled to be added in the 2.7 release†—this change is being\nphased in this way because the search path portion is not backward compatible with\nearlier Pythons.\nThe impact of this change is that in 3.0 (and optionally in 2.6), you must generally use\nspecial from syntax to import modules located in the same package as the importer,\nunless you spell out a complete path from a package root. Without this syntax, your\npackage is not automatically searched.",
    "Relative Import Basics\nIn Python 3.0 and 2.6, from statements can now use leading dots (“.”) to specify that\nthey require modules located within the same package (known as package relative imports), instead of modules located elsewhere on the module import search path (called\nabsolute imports). That is:\n• In both Python 3.0 and 2.6, you can use leading dots in from statements to indicate\nthat imports should be relative to the containing package—such imports will\nsearch for modules inside the package only and will not look for same-named\nmodules located elsewhere on the import search path (sys.path). The net effect is\nthat package modules override outside modules.\n• In Python 2.6, normal imports in a package’s code (without leading dots) currently\ndefault to a relative-then-absolute search path order—that is, they search the package’s own directory first. However, in Python 3.0, imports within a package are\nabsolute by default—in the absence of any special dot syntax, imports skip the",
    "that package modules override outside modules.\n• In Python 2.6, normal imports in a package’s code (without leading dots) currently\ndefault to a relative-then-absolute search path order—that is, they search the package’s own directory first. However, in Python 3.0, imports within a package are\nabsolute by default—in the absence of any special dot syntax, imports skip the\ncontaining package itself and look elsewhere on the sys.path search path.\n† Yes, there will be a 2.7 release, and possibly 2.8 and later releases, in parallel with new releases in the 3.X\nline. As described in the Preface, both the Python 2 and Python 3 lines are expected to be fully supported for\nyears to come, to accommodate the large existing Python 2 user and code bases.",
    "570 | Chapter 23: Module Packages\n\n\fFor example, in both Python 3.0 and 2.6, a statement of the form:\n# Relative to this package\n\nfrom . import spam\n\ninstructs Python to import a module named spam located in the same package directory\nas the file in which this statement appears. Similarly, this statement:\nfrom .spam import name\n\nmeans “from a module named spam located in the same package as the file that contains\nthis statement, import the variable name.”\nThe behavior of a statement without the leading dot depends on which version of\nPython you use. In 2.6, such an import will still default to the current\nrelative-then-absolute search path order (i.e., searching the package’s directory first),\nunless a statement of the following form is included in the importing file:\nfrom __future__ import\n\nabsolute_import\n\n# Required until 2.7?",
    "absolute_import\n\n# Required until 2.7?\n\nIf present, this statement enables the Python 3.0 absolute-by-default default search path\nchange, described in the next paragraph.\nIn 3.0, an import without a leading dot always causes Python to skip the relative components of the module import search path and look instead in the absolute directories\nthat sys.path contains. For instance, in 3.0’s model, a statement of the following form\nwill always find a string module somewhere on sys.path, instead of a module of the\nsame name in the package:\nimport string\n\n# Skip this package's version\n\nWithout the from __future__ statement in 2.6, if there’s a string module in the package,\nit will be imported instead. To get the same behavior in 3.0 and in 2.6 when the absolute\nimport change is enabled, run a statement of the following form to force a relative\nimport:\nfrom . import string\n\n# Searches this package only",
    "This works in both Python 2.6 and 3.0 today. The only difference in the 3.0 model is\nthat it is required in order to load a module that is located in the same package directory\nas the file in which this appears, when the module is given with a simple name.\nNote that leading dots can be used to force relative imports only with the from statement, not with the import statement. In Python 3.0, the import modname statement is\nalways absolute, skipping the containing package’s directory. In 2.6, this statement\nform still performs relative imports today (i.e., the package’s directory is searched first),\nbut these will become absolute in Python 2.7, too. from statements without leading dots\nbehave the same as import statements—absolute in 3.0 (skipping the package directory), and relative-then-absolute in 2.6 (searching the package directory first).",
    "form still performs relative imports today (i.e., the package’s directory is searched first),\nbut these will become absolute in Python 2.7, too. from statements without leading dots\nbehave the same as import statements—absolute in 3.0 (skipping the package directory), and relative-then-absolute in 2.6 (searching the package directory first).\nOther dot-based relative reference patterns are possible, too. Within a module file located in a package directory named mypkg, the following alternative import forms work\nas described:",
    "Package Relative Imports | 571\n\n\ffrom .string import name1, name2\nfrom . import string\nfrom .. import string\n\n# Imports names from mypkg.string\n# Imports mypkg.string\n# Imports string sibling of mypkg\n\nTo understand these latter forms better, we need to understand the rationale behind\nthis change.\n\nWhy Relative Imports?\nThis feature is designed to allow scripts to resolve ambiguities that can arise when a\nsame-named file appears in multiple places on the module search path. Consider the\nfollowing package directory:\nmypkg\\\n__init__.py\nmain.py\nstring.py",
    "This defines a package named mypkg containing modules named mypkg.main and\nmypkg.string. Now, suppose that the main module tries to import a module named\nstring. In Python 2.6 and earlier, Python will first look in the mypkg directory to perform a relative import. It will find and import the string.py file located there, assigning\nit to the name string in the mypkg.main module’s namespace.\nIt could be, though, that the intent of this import was to load the Python standard\nlibrary’s string module instead. Unfortunately, in these versions of Python, there’s no\nstraightforward way to ignore mypkg.string and look for the standard library’s string\nmodule located on the module search path. Moreover, we cannot resolve this with\npackage import paths, because we cannot depend on any extra package directory\nstructure above the standard library being present on every machine.\nIn other words, imports in packages can be ambiguous—within a package, it’s not clear",
    "straightforward way to ignore mypkg.string and look for the standard library’s string\nmodule located on the module search path. Moreover, we cannot resolve this with\npackage import paths, because we cannot depend on any extra package directory\nstructure above the standard library being present on every machine.\nIn other words, imports in packages can be ambiguous—within a package, it’s not clear\nwhether an import spam statement refers to a module within or outside the package.\nMore accurately, a local module or package can hide another hanging directly off of\nsys.path, whether intentionally or not.\nIn practice, Python users can avoid reusing the names of standard library modules they\nneed for modules of their own (if you need the standard string, don’t name a new\nmodule string!). But this doesn’t help if a package accidentally hides a standard module; moreover, Python might add a new standard library module in the future that has",
    "sys.path, whether intentionally or not.\nIn practice, Python users can avoid reusing the names of standard library modules they\nneed for modules of their own (if you need the standard string, don’t name a new\nmodule string!). But this doesn’t help if a package accidentally hides a standard module; moreover, Python might add a new standard library module in the future that has\nthe same name as a module of your own. Code that relies on relative imports is also\nless easy to understand, because the reader may be confused about which module is\nintended to be used. It’s better if the resolution can be made explicit in code.",
    "The relative imports solution in 3.0\nTo address this dilemma, imports run within packages have changed in Python 3.0\n(and as an option in 2.6) to be absolute. Under this model, an import statement of the\n\n572 | Chapter 23: Module Packages\n\n\ffollowing form in our example file mypkg/main.py will always find a string outside the\npackage, via an absolute import search of sys.path:\nimport string\n\n# Imports string outside package\n\nA from import without leading-dot syntax is considered absolute as well:\nfrom string import name\n\n# Imports name from string outside package\n\nIf you really want to import a module from your package without giving its full path\nfrom the package root, though, relative imports are still possible by using the dot syntax\nin the from statement:\nfrom . import string\n\n# Imports mypkg.string (relative)",
    "A from import without leading-dot syntax is considered absolute as well:\nfrom string import name\n\n# Imports name from string outside package\n\nIf you really want to import a module from your package without giving its full path\nfrom the package root, though, relative imports are still possible by using the dot syntax\nin the from statement:\nfrom . import string\n\n# Imports mypkg.string (relative)\n\nThis form imports the string module relative to the current package only and is the\nrelative equivalent to the prior import example’s absolute form; when this special relative syntax is used, the package’s directory is the only directory searched.\nWe can also copy specific names from a module with relative syntax:\nfrom .string import name1, name2\n\n# Imports names from mypkg.string",
    "This form imports the string module relative to the current package only and is the\nrelative equivalent to the prior import example’s absolute form; when this special relative syntax is used, the package’s directory is the only directory searched.\nWe can also copy specific names from a module with relative syntax:\nfrom .string import name1, name2\n\n# Imports names from mypkg.string\n\nThis statement again refers to the string module relative to the current package. If this\ncode appears in our mypkg.main module, for example, it will import name1 and name2\nfrom mypkg.string.\nIn effect, the “.” in a relative import is taken to stand for the package directory containing the file in which the import appears. An additional leading dot performs the\nrelative import starting from the parent of the current package. For example, this\nstatement:\nfrom .. import spam\n\n# Imports a sibling of mypkg",
    "# Imports a sibling of mypkg\n\nwill load a sibling of mypkg—i.e., the spam module located in the package’s own container directory, next to mypkg. More generally, code located in some module A.B.C can\ndo any of these:\nfrom . import D\nfrom .. import E\n\n# Imports A.B.D (. means A.B)\n# Imports A.E\n(.. means A)\n\nfrom .D import X\nfrom ..E import X\n\n# Imports A.B.D.X (. means A.B)\n# Imports A.E.X (.. means A)\n\nRelative imports versus absolute package paths\nAlternatively, a file can sometimes name its own package explicitly in an absolute import statement. For example, in the following, mypkg will be found in an absolute directory on sys.path:\nfrom mypkg import string\n\n# Imports mypkg.string (absolute)\n\nHowever, this relies on both the configuration and the order of the module search path\nsettings, while relative import dot syntax does not. In fact, this form requires that the\ndirectory immediately containing mypkg be included in the module search path. In\nPackage Relative Imports | 573",
    "# Imports mypkg.string (absolute)\n\nHowever, this relies on both the configuration and the order of the module search path\nsettings, while relative import dot syntax does not. In fact, this form requires that the\ndirectory immediately containing mypkg be included in the module search path. In\nPackage Relative Imports | 573\n\n\fgeneral, absolute import statements must list all the directories below the package’s\nroot entry in sys.path when naming packages explicitly like this:\nfrom system.section.mypkg import string\n\n# system container on sys.path only\n\nIn large or deep packages, that could be much more work than a dot:\nfrom . import string\n\n# Relative import syntax\n\nWith this latter form, the containing package is searched automatically, regardless of\nthe search path settings.",
    "The Scope of Relative Imports\nRelative imports can seem a bit perplexing on first encounter, but it helps if you remember a few key points about them:\n• Relative imports apply to imports within packages only. Keep in mind that\nthis feature’s module search path change applies only to import statements within\nmodule files located in a package. Normal imports coded outside package files still\nwork exactly as described earlier, automatically searching the directory containing\nthe top-level script first.\n• Relative imports apply to the from statement only. Also remember that this\nfeature’s new syntax applies only to from statements, not import statements. It’s\ndetected by the fact that the module name in a from begins with one or more dots\n(periods). Module names that contain dots but don’t have a leading dot are package\nimports, not relative imports.\n• The terminology is ambiguous. Frankly, the terminology used to describe this",
    "feature’s new syntax applies only to from statements, not import statements. It’s\ndetected by the fact that the module name in a from begins with one or more dots\n(periods). Module names that contain dots but don’t have a leading dot are package\nimports, not relative imports.\n• The terminology is ambiguous. Frankly, the terminology used to describe this\nfeature is probably more confusing than it needs to be. Really, all imports are relative to something. Outside a package, imports are still relative to directories listed\non the sys.path module search path. As we learned in Chapter 21, this path includes the program’s container directory, PYTHONPATH settings, path file settings,\nand standard libraries. When working interactively, the program container directory is simply the current working directory.\nFor imports made inside packages, 2.6 augments this behavior by searching the",
    "on the sys.path module search path. As we learned in Chapter 21, this path includes the program’s container directory, PYTHONPATH settings, path file settings,\nand standard libraries. When working interactively, the program container directory is simply the current working directory.\nFor imports made inside packages, 2.6 augments this behavior by searching the\npackage itself first. In the 3.0 model, all that really changes is that normal “absolute” import syntax skips the package directory, but special “relative” import syntax causes it to be searched first and only. When we talk about 3.0 imports as being\n“absolute,” what we really mean is that they are relative to the directories on\nsys.path, but not the package itself. Conversely, when we speak of “relative” imports, we mean they are relative to the package directory only. Some sys.path\nentries could, of course, be absolute or relative paths too. (And I could probably\nmake up something more confusing, but it would be a stretch!)",
    "574 | Chapter 23: Module Packages\n\n\fIn other words, “package relative imports” in 3.0 really just boil down to a removal of\n2.6’s special search path behavior for packages, along with the addition of special\nfrom syntax to explicitly request relative behavior. If you wrote your package imports\nin the past to not depend on 2.6’s special implicit relative lookup (e.g., by always spelling out full paths from a package root), this change is largely a moot point. If you didn’t,\nyou’ll need to update your package files to use the new from syntax for local package\nfiles.",
    "Module Lookup Rules Summary\nWith packages and relative imports, the module search story in Python 3.0 in its entirety\ncan be summarized as follows:\n• Simple module names (e.g., A) are looked up by searching each directory on the\nsys.path list, from left to right. This list is constructed from both system defaults\nand user-configurable settings.\n• Packages are simply directories of Python modules with a special __init__.py file,\nwhich enables A.B.C directory path syntax in imports. In an import of A.B.C, for\nexample, the directory named A is located relative to the normal module import\nsearch of sys.path, B is another package subdirectory within A, and C is a module\nor other importable item within B.\n• Within a package’s files, normal import statements use the same sys.path search\nrule as imports elsewhere. Imports in packages using from statements and leading\ndots, however, are relative to the package; that is, only the package directory is",
    "search of sys.path, B is another package subdirectory within A, and C is a module\nor other importable item within B.\n• Within a package’s files, normal import statements use the same sys.path search\nrule as imports elsewhere. Imports in packages using from statements and leading\ndots, however, are relative to the package; that is, only the package directory is\nchecked, and the normal sys.path lookup is not used. In from . import A, for\nexample, the module search is restricted to the directory containing the file in which\nthis statement appears.",
    "Relative Imports in Action\nBut enough theory: let’s run some quick tests to demonstrate the concepts behind\nrelative imports.\n\nImports outside packages\nFirst of all, as mentioned previously, this feature does not impact imports outside a\npackage. Thus, the following finds the standard library string module as expected:\nC:\\test> c:\\Python30\\python\n>>> import string\n>>> string\n<module 'string' from 'c:\\Python30\\lib\\string.py'>\n\nPackage Relative Imports | 575\n\n\fBut if we add a module of the same name in the directory we’re working in, it is selected\ninstead, because the first entry on the module search path is the current working\ndirectory (CWD):\n# test\\string.py\nprint('string' * 8)\nC:\\test> c:\\Python30\\python\n>>> import string\nstringstringstringstringstringstringstringstring\n>>> string\n<module 'string' from 'string.py'>",
    "But if we add a module of the same name in the directory we’re working in, it is selected\ninstead, because the first entry on the module search path is the current working\ndirectory (CWD):\n# test\\string.py\nprint('string' * 8)\nC:\\test> c:\\Python30\\python\n>>> import string\nstringstringstringstringstringstringstringstring\n>>> string\n<module 'string' from 'string.py'>\n\nIn other words, normal imports are still relative to the “home” directory (the top-level\nscript’s container, or the directory you’re working in). In fact, relative import syntax is\nnot even allowed in code that is not in a file being used as part of a package:\n>>> from . import string\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: Attempted relative import in non-package",
    "In this and all examples in this section, code entered at the interactive prompt behaves\nthe same as it would if run in a top-level script, because the first entry on sys.path is\neither the interactive working directory or the directory containing the top-level file.\nThe only difference is that the start of sys.path is an absolute directory, not an empty\nstring:\n# test\\main.py\nimport string\nprint(string)\nC:\\test> C:\\python30\\python main.py\nstringstringstringstringstringstringstringstring\n<module 'string' from 'C:\\test\\string.py'>\n\n# Same results in 2.6\n\nImports within packages\nNow, let’s get rid of the local string module we coded in the CWD and build a package\ndirectory there with two modules, including the required but empty test\\pkg\n\\__init__.py file (which I’ll omit here):\nC:\\test> del string*\nC:\\test> mkdir pkg\n# test\\pkg\\spam.py\nimport eggs\nprint(eggs.X)\n# test\\pkg\\eggs.py\nX = 99999\nimport string\nprint(string)\n\n576 | Chapter 23: Module Packages\n\n# <== Works in 2.6 but not 3.0!",
    "576 | Chapter 23: Module Packages\n\n# <== Works in 2.6 but not 3.0!\n\n\fThe first file in this package tries to import the second with a normal import statement.\nBecause this is taken to be relative in 2.6 but absolute in 3.0, it fails in the latter. That\nis, 2.6 searches the containing package first, but 3.0 does not. This is the noncompatible\nbehavior you have to be aware of in 3.0:\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python26\\lib\\string.pyc'>\n99999\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"pkg\\spam.py\", line 1, in <module>\nimport eggs\nImportError: No module named eggs\n\nTo make this work in both 2.6 and 3.0, change the first file to use the special relative\nimport syntax, so that its import searches the package directory in 3.0, too:\n# test\\pkg\\spam.py\nfrom . import eggs\nprint(eggs.X)\n\n# <== Use package relative import in 2.6 or 3.0",
    "To make this work in both 2.6 and 3.0, change the first file to use the special relative\nimport syntax, so that its import searches the package directory in 3.0, too:\n# test\\pkg\\spam.py\nfrom . import eggs\nprint(eggs.X)\n\n# <== Use package relative import in 2.6 or 3.0\n\n# test\\pkg\\eggs.py\nX = 99999\nimport string\nprint(string)\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python26\\lib\\string.pyc'>\n99999\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python30\\lib\\string.py'>\n99999",
    "# <== Use package relative import in 2.6 or 3.0\n\n# test\\pkg\\eggs.py\nX = 99999\nimport string\nprint(string)\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python26\\lib\\string.pyc'>\n99999\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python30\\lib\\string.py'>\n99999\n\nImports are still relative to the CWD\nNotice in the preceding example that the package modules still have access to standard\nlibrary modules like string. Really, their imports are still relative to the entries on the\nmodule search path, even if those entries are relative themselves. If you add a string\nmodule to the CWD again, imports in a package will find it there instead of in the\nstandard library. Although you can skip the package directory with an absolute import\nin 3.0, you still can’t skip the home directory of the program that imports the package:\n# test\\string.py\nprint('string' * 8)\n# test\\pkg\\spam.py\nfrom . import eggs\n\nPackage Relative Imports | 577",
    "Package Relative Imports | 577\n\n\fprint(eggs.X)\n# test\\pkg\\eggs.py\nX = 99999\nimport string\nprint(string)\n\n# <== Gets string in CWD, not Python lib!\n\nC:\\test> c:\\Python30\\python\n# Same result in 2.6\n>>> import pkg.spam\nstringstringstringstringstringstringstringstring\n<module 'string' from 'string.py'>\n99999\n\nSelecting modules with relative and absolute imports\nTo show how this applies to imports of standard library modules, reset the package\none more time. Get rid of the local string module, and define a new one inside the\npackage itself:\nC:\\test> del string*\n# test\\pkg\\spam.py\nimport string\nprint(string)\n\n# <== Relative in 2.6, absolute in 3.0\n\n# test\\pkg\\string.py\nprint('Ni' * 8)",
    "Selecting modules with relative and absolute imports\nTo show how this applies to imports of standard library modules, reset the package\none more time. Get rid of the local string module, and define a new one inside the\npackage itself:\nC:\\test> del string*\n# test\\pkg\\spam.py\nimport string\nprint(string)\n\n# <== Relative in 2.6, absolute in 3.0\n\n# test\\pkg\\string.py\nprint('Ni' * 8)\n\nNow, which version of the string module you get depends on which Python you use.\nAs before, 3.0 interprets the import in the first file as absolute and skips the package,\nbut 2.6 does not:\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python30\\lib\\string.py'>\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n<module 'pkg.string' from 'pkg\\string.py'>",
    "Now, which version of the string module you get depends on which Python you use.\nAs before, 3.0 interprets the import in the first file as absolute and skips the package,\nbut 2.6 does not:\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\n<module 'string' from 'c:\\Python30\\lib\\string.py'>\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n<module 'pkg.string' from 'pkg\\string.py'>\n\nUsing relative import syntax in 3.0 forces the package to be searched again, as it is in\n2.6—by using absolute or relative import syntax in 3.0, you can either skip or select\nthe package directory explicitly. In fact, this is the use case that the 3.0 model addresses:\n# test\\pkg\\spam.py\nfrom . import string\nprint(string)\n# test\\pkg\\string.py\nprint('Ni' * 8)\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n\n578 | Chapter 23: Module Packages\n\n# <== Relative in both 2.6 and 3.0",
    "578 | Chapter 23: Module Packages\n\n# <== Relative in both 2.6 and 3.0\n\n\f<module 'pkg.string' from 'pkg\\string.py'>\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n<module 'pkg.string' from 'pkg\\string.py'>\n\nIt’s important to note that relative import syntax is really a binding declaration, not\njust a preference. If we delete the string.py file in this example, the relative import in\nspam.py fails in both 3.0 and 2.6, instead of falling back on the standard library’s version\nof this module (or any other):\n# test\\pkg\\spam.py\nfrom . import string\n\n# <== Fails if no string.py here!\n\nC:\\test> C:\\python30\\python\n>>> import pkg.spam\n...text omitted...\nImportError: cannot import name string\n\nModules referenced by relative imports must exist in the package directory.",
    "# <== Fails if no string.py here!\n\nC:\\test> C:\\python30\\python\n>>> import pkg.spam\n...text omitted...\nImportError: cannot import name string\n\nModules referenced by relative imports must exist in the package directory.\n\nImports are still relative to the CWD (again)\nAlthough absolute imports let you skip package modules, they still rely on other components of sys.path. For one last test, let’s define two string modules of our own. In\nthe following, there is one module by that name in the CWD, one in the package, and\nanother in the standard library:\n# test\\string.py\nprint('string' * 8)\n# test\\pkg\\spam.py\nfrom . import string\nprint(string)\n\n# <== Relative in both 2.6 and 3.0\n\n# test\\pkg\\string.py\nprint('Ni' * 8)\n\nWhen we import the string module with relative import syntax, we get the version in\nthe package, as desired:\nC:\\test> c:\\Python30\\python\n# Same result in 2.6\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n<module 'pkg.string' from 'pkg\\string.py'>",
    "# <== Relative in both 2.6 and 3.0\n\n# test\\pkg\\string.py\nprint('Ni' * 8)\n\nWhen we import the string module with relative import syntax, we get the version in\nthe package, as desired:\nC:\\test> c:\\Python30\\python\n# Same result in 2.6\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n<module 'pkg.string' from 'pkg\\string.py'>\n\nWhen absolute syntax is used, though, the module we get varies per version again. 2.6\ninterprets this as relative to the package, but 3.0 makes it “absolute,” which in this case\nreally just means it skips the package and loads the version relative to the CWD (not\nthe version the standard library):\n# test\\string.py\nprint('string' * 8)\n\nPackage Relative Imports | 579\n\n\f# test\\pkg\\spam.py\nimport string\nprint(string)\n\n# <== Relative in 2.6, \"absolute\" in 3.0: CWD!",
    "Package Relative Imports | 579\n\n\f# test\\pkg\\spam.py\nimport string\nprint(string)\n\n# <== Relative in 2.6, \"absolute\" in 3.0: CWD!\n\n# test\\pkg\\string.py\nprint('Ni' * 8)\nC:\\test> c:\\Python30\\python\n>>> import pkg.spam\nstringstringstringstringstringstringstringstring\n<module 'string' from 'string.py'>\nC:\\test> c:\\Python26\\python\n>>> import pkg.spam\nNiNiNiNiNiNiNiNi\n<module 'pkg.string' from 'pkg\\string.pyc'>",
    "As you can see, although packages can explicitly request modules within their own\ndirectories, their imports are otherwise still relative to the rest of the normal module\nsearch path. In this case, a file in the program using the package hides the standard\nlibrary module the package may want. All that the change in 3.0 really accomplishes is\nallowing package code to select files either inside or outside the package (i.e., relatively\nor absolutely). Because import resolution can depend on an enclosing context that may\nnot be foreseen, absolute imports in 3.0 are not a guarantee of finding a module in the\nstandard library.\nExperiment with these examples on your own for more insight. In practice, this is not\nusually as ad-hoc as it might seem: you can generally structure your imports, search\npaths, and module names to work the way you wish during development. You should\nkeep in mind, though, that imports in larger systems may depend upon context of use,",
    "standard library.\nExperiment with these examples on your own for more insight. In practice, this is not\nusually as ad-hoc as it might seem: you can generally structure your imports, search\npaths, and module names to work the way you wish during development. You should\nkeep in mind, though, that imports in larger systems may depend upon context of use,\nand the module import protocol is part of a successful library’s design.\nNow that you’ve learned about package-relative imports, also keep in\nmind that they may not always be your best option. Absolute package\nimports, relative to a directory on sys.path, are still sometimes preferred\nover both implicit package-relative imports in Python 2, and explicit\npackage-relative import syntax in both Python 2 and 3.\nPackage-relative import syntax and Python 3.0’s new absolute import\nsearch rules at least require relative imports from a package to be made",
    "imports, relative to a directory on sys.path, are still sometimes preferred\nover both implicit package-relative imports in Python 2, and explicit\npackage-relative import syntax in both Python 2 and 3.\nPackage-relative import syntax and Python 3.0’s new absolute import\nsearch rules at least require relative imports from a package to be made\nexplicit, and thus easier to understand and maintain. Files that use imports with dots, though, are implicitly bound to a package directory and\ncannot be used elsewhere without code changes.\nNaturally, the extent to which this may impact your modules can vary\nper package; absolute imports may also require changes when directories are reorganized.",
    "580 | Chapter 23: Module Packages\n\n\fWhy You Will Care: Module Packages\nNow that packages are a standard part of Python, it’s common to see larger third-party\nextensions shipped as sets of package directories, rather than flat lists of modules. The\nwin32all Windows extensions package for Python, for instance, was one of the first to\njump on the package bandwagon. Many of its utility modules reside in packages imported with paths. For instance, to load client-side COM tools, you use a statement\nlike this:\nfrom win32com.client import constants, Dispatch",
    "This line fetches names from the client module of the win32com package (an install\nsubdirectory).\nPackage imports are also pervasive in code run under the Jython Java-based implementation of Python, because Java libraries are organized into hierarchies as well. In\nrecent Python releases, the email and XML tools are likewise organized into package\nsubdirectories in the standard library, and Python 3.0 groups even more related modules into packages (including tkinter GUI tools, HTTP networking tools, and more).\nThe following imports access various standard library tools in 3.0:\nfrom email.message import Message\nfrom tkinter.filedialog import askopenfilename\nfrom http.server import CGIHTTPRequestHandler\n\nWhether you create package directories or not, you will probably import from them\neventually.",
    "Chapter Summary\nThis chapter introduced Python’s package import model—an optional but useful way\nto explicitly list part of the directory path leading up to your modules. Package imports\nare still relative to a directory on your module import search path, but rather than\nrelying on Python to traverse the search path manually, your script gives the rest of the\npath to the module explicitly.\nAs we’ve seen, packages not only make imports more meaningful in larger systems, but\nalso simplify import search path settings (if all cross-directory imports are relative to a\ncommon root directory) and resolve ambiguities when there is more than one module\nof the same name (including the name of the enclosing directory in a package import\nhelps distinguish between them).\nBecause it’s relevant only to code in packages, we also explored the newer relative\nimport model here—a way for imports in package files to select modules in the same",
    "common root directory) and resolve ambiguities when there is more than one module\nof the same name (including the name of the enclosing directory in a package import\nhelps distinguish between them).\nBecause it’s relevant only to code in packages, we also explored the newer relative\nimport model here—a way for imports in package files to select modules in the same\npackage using leading dots in a from, instead of relying on an older implicit package\nsearch rule.",
    "Chapter Summary | 581\n\n\fIn the next chapter, we will survey a handful of more advanced module-related topics,\nsuch as relative import syntax and the __name__ usage mode variable. As usual, though,\nwe’ll close out this chapter with a short quiz to test what you’ve learned here.\n\nTest Your Knowledge: Quiz\n1. What is the purpose of an __init__.py file in a module package directory?\n2. How can you avoid repeating the full package path every time you reference a\npackage’s content?\n3. Which directories require __init__.py files?\n4. When must you use import instead of from with packages?\n5. What is the difference between from mypkg import spam and from . import spam?",
    "Test Your Knowledge: Answers\n1. The __init__.py file serves to declare and initialize a module package; Python automatically runs its code the first time you import through a directory in a process.\nIts assigned variables become the attributes of the module object created in memory\nto correspond to that directory. It is also not optional—you can’t import through\na directory with package syntax unless it contains this file.\n2. Use the from statement with a package to copy names out of the package directly,\nor use the as extension with the import statement to rename the path to a shorter\nsynonym. In both cases, the path is listed in only one place, in the from or import\nstatement.\n3. Each directory listed in an import or from statement must contain an __init__.py\nfile. Other directories, including the directory containing the leftmost component\nof a package path, do not need to include this file.\n4. You must use import instead of from with packages only if you need to access the",
    "synonym. In both cases, the path is listed in only one place, in the from or import\nstatement.\n3. Each directory listed in an import or from statement must contain an __init__.py\nfile. Other directories, including the directory containing the leftmost component\nof a package path, do not need to include this file.\n4. You must use import instead of from with packages only if you need to access the\nsame name defined in more than one path. With import, the path makes the references unique, but from allows only one version of any given name.\n5. from mypkg import spam is an absolute import—the search for mypkg skips the\npackage directory and the module is located in an absolute directory in sys.path.\nA statement from . import spam, on the other hand, is a relative import—spam is\nlooked up relative to the package in which this statement is contained before\nsys.path is searched.",
    "582 | Chapter 23: Module Packages\n\n\fCHAPTER 24\n\nAdvanced Module Topics",
    "Advanced Module Topics\n\nThis chapter concludes this part of the book with a collection of more advanced\nmodule-related topics—data hiding, the __future__ module, the __name__ variable,\nsys.path changes, listing tools, running modules by name string, transitive reloads, and\nso on—along with the standard set of gotchas and exercises related to what we’ve\ncovered in this part of the book.\nAlong the way, we’ll build some larger and more useful tools than we have so far, that\ncombine functions and modules. Like functions, modules are more effective when their\ninterfaces are well defined, so this chapter also briefly reviews module design concepts,\nsome of which we have explored in prior chapters.\nDespite the word “advanced” in this chapter’s title, this is also something of a grab bag\nof additional module topics. Because some of the topics discussed here are widely used\n(especially the __name__ trick), be sure to take a look before moving on to classes in the\nnext part of the book.",
    "Data Hiding in Modules\nAs we’ve seen, a Python module exports all the names assigned at the top level of its\nfile. There is no notion of declaring which names should and shouldn’t be visible outside the module. In fact, there’s no way to prevent a client from changing names inside\na module if it wants to.\nIn Python, data hiding in modules is a convention, not a syntactical constraint. If you\nwant to break a module by trashing its names, you can, but fortunately, I’ve yet to meet\na programmer who would. Some purists object to this liberal attitude toward data\nhiding, claiming that it means Python can’t implement encapsulation. However, encapsulation in Python is more about packaging than about restricting.\n\n583",
    "583\n\n\fMinimizing from * Damage: _X and __all__\nAs a special case, you can prefix names with a single underscore (e.g., _X) to prevent\nthem from being copied out when a client imports a module’s names with a from *\nstatement. This really is intended only to minimize namespace pollution; because from\n* copies out all names, the importer may get more than it’s bargained for (including\nnames that overwrite names in the importer). Underscores aren’t “private” declarations: you can still see and change such names with other import forms, such as the\nimport statement.\nAlternatively, you can achieve a hiding effect similar to the _X naming convention by\nassigning a list of variable name strings to the variable __all__ at the top level of the\nmodule. For example:\n__all__ = [\"Error\", \"encode\", \"decode\"]\n\n# Export these only",
    "# Export these only\n\nWhen this feature is used, the from * statement will copy out only those names listed\nin the __all__ list. In effect, this is the converse of the _X convention: __all__ identifies\nnames to be copied, while _X identifies names not to be copied. Python looks for an\n__all__ list in the module first; if one is not defined, from * copies all names without\na single leading underscore.\nLike the _X convention, the __all__ list has meaning only to the from * statement form\nand does not amount to a privacy declaration. Module writers can use either trick to\nimplement modules that are well behaved when used with from *. (See also the discussion of __all__ lists in package __init__.py files in Chapter 23; there, these lists\ndeclare submodules to be loaded for a from *.)",
    "Enabling Future Language Features\nChanges to the language that may potentially break existing code are introduced gradually. Initially, they appear as optional extensions, which are disabled by default. To\nturn on such extensions, use a special import statement of this form:\nfrom __future__ import featurename",
    "This statement should generally appear at the top of a module file (possibly after a\ndocstring), because it enables special compilation of code on a per-module basis. It’s\nalso possible to submit this statement at the interactive prompt to experiment with\nupcoming language changes; the feature will then be available for the rest of the interactive session.\nFor example, in prior editions of this book, we had to use this statement form to demonstrate generator functions, which required a keyword that was not yet enabled by\ndefault (they use a featurename of generators). We also used this statement to activate\n3.0 true division in Chapter 5, 3.0 print calls in Chapter 11, and 3.0 absolute imports\nfor packages in Chapter 23.\n\n584 | Chapter 24: Advanced Module Topics\n\n\fAll of these changes have the potential to break existing code in Python 2.6, so they are\nbeing phased in gradually as optional features enabled with this special import.",
    "584 | Chapter 24: Advanced Module Topics\n\n\fAll of these changes have the potential to break existing code in Python 2.6, so they are\nbeing phased in gradually as optional features enabled with this special import.\n\nMixed Usage Modes: __name__ and __main__\nHere’s another module-related trick that lets you both import a file as a module and\nrun it as a standalone program. Each module has a built-in attribute called __name__,\nwhich Python sets automatically as follows:\n• If the file is being run as a top-level program file, __name__ is set to the string\n\"__main__\" when it starts.\n• If the file is being imported instead, __name__ is set to the module’s name as known\nby its clients.\nThe upshot is that a module can test its own __name__ to determine whether it’s being\nrun or imported. For example, suppose we create the following module file, named\nrunme.py, to export a single function called tester:\ndef tester():\nprint(\"It's Christmas in Heaven...\")\nif __name__ == '__main__':\ntester()",
    "# Only when run\n# Not when imported\n\nThis module defines a function for clients to import and use as usual:\n% python\n>>> import runme\n>>> runme.tester()\nIt's Christmas in Heaven...\n\nBut, the module also includes code at the bottom that is set up to call the function when\nthis file is run as a program:\n% python runme.py\nIt's Christmas in Heaven...",
    "In effect, a module’s __name__ variable serves as a usage mode flag, allowing its code to\nbe leveraged as both an importable library and a top-level script. Though simple, you’ll\nsee this hook used in nearly every realistic Python program file you are likely to\nencounter.\nPerhaps the most common way you’ll see the __name__ test applied is for self-test code.\nIn short, you can package code that tests a module’s exports in the module itself by\nwrapping it in a __name__ test at the bottom of the file. This way, you can use the file\nin clients by importing it, but also test its logic by running it from the system shell or\nvia another launching scheme. In practice, self-test code at the bottom of a file under\nthe __name__ test is probably the most common and simplest unit-testing protocol in\nPython. (Chapter 35 will discuss other commonly used options for testing Python\n\nMixed Usage Modes: __name__ and __main__ | 585",
    "Mixed Usage Modes: __name__ and __main__ | 585\n\n\fcode—as you’ll see, the unittest and doctest standard library modules provide more\nadvanced testing tools.)\nThe __name__ trick is also commonly used when writing files that can be used both as\ncommand-line utilities and as tool libraries. For instance, suppose you write a file-finder\nscript in Python. You can get more mileage out of your code if you package it in functions and add a __name__ test in the file to automatically call those functions when the\nfile is run standalone. That way, the script’s code becomes reusable in other programs.",
    "Unit Tests with __name__\nIn fact, we’ve already seen a prime example in this book of an instance where the\n__name__ check could be useful. In the section on arguments in Chapter 18, we coded\na script that computed the minimum value from the set of arguments sent in:\ndef minmax(test, *args):\nres = args[0]\nfor arg in args[1:]:\nif test(arg, res):\nres = arg\nreturn res\ndef lessthan(x, y): return x < y\ndef grtrthan(x, y): return x > y\nprint(minmax(lessthan, 4, 2, 1, 5, 6, 3))\nprint(minmax(grtrthan, 4, 2, 1, 5, 6, 3))\n\n# Self-test code",
    "# Self-test code\n\nThis script includes self-test code at the bottom, so we can test it without having to\nretype everything at the interactive command line each time we run it. The problem\nwith the way it is currently coded, however, is that the output of the self-test call will\nappear every time this file is imported from another file to be used as a tool—not exactly\na user-friendly feature! To improve it, we can wrap up the self-test call in a __name__\ncheck, so that it will be launched only when the file is run as a top-level script, not when\nit is imported:\nprint('I am:', __name__)\ndef minmax(test, *args):\nres = args[0]\nfor arg in args[1:]:\nif test(arg, res):\nres = arg\nreturn res\ndef lessthan(x, y): return x < y\ndef grtrthan(x, y): return x > y\nif __name__ == '__main__':\nprint(minmax(lessthan, 4, 2, 1, 5, 6, 3))\nprint(minmax(grtrthan, 4, 2, 1, 5, 6, 3))\n\n586 | Chapter 24: Advanced Module Topics\n\n# Self-test code",
    "586 | Chapter 24: Advanced Module Topics\n\n# Self-test code\n\n\fWe’re also printing the value of __name__ at the top here to trace its value. Python creates\nand assigns this usage-mode variable as soon as it starts loading a file. When we run\nthis file as a top-level script, its name is set to __main__, so its self-test code kicks in\nautomatically:\n% python min.py\nI am: __main__\n1\n6\n\nBut, if we import the file, its name is not __main__, so we must explicitly call the function\nto make it run:\n>>> import min\nI am: min\n>>> min.minmax(min.lessthan, 's', 'p', 'a', 'm')\n'a'\n\nAgain, regardless of whether this is used for testing, the net effect is that we get to use\nour code in two different roles—as a library module of tools, or as an executable\nprogram.",
    "Using Command-Line Arguments with __name__\nHere’s a more substantial module example that demonstrates another way that the\n__name__ trick is commonly employed. The following module, formats.py, defines string\nformatting utilities for importers, but also checks its name to see if it is being run as a\ntop-level script; if so, it tests and uses arguments listed on the system command line to\nrun a canned or passed-in test. In Python, the sys.argv list contains command-line\narguments—it is a list of strings reflecting words typed on the command line, where\nthe first item is always the name of the script being run:\n\"\"\"\nVarious specialized string display formatting utilities.\nTest me with canned self-test or command-line arguments.\n\"\"\"\ndef commas(N):\n\"\"\"\nformat positive integer-like N for display with\ncommas between digit groupings: xxx,yyy,zzz\n\"\"\"\ndigits = str(N)\nassert(digits.isdigit())\nresult = ''\nwhile digits:\ndigits, last3 = digits[:-3], digits[-3:]",
    "\"\"\"\nVarious specialized string display formatting utilities.\nTest me with canned self-test or command-line arguments.\n\"\"\"\ndef commas(N):\n\"\"\"\nformat positive integer-like N for display with\ncommas between digit groupings: xxx,yyy,zzz\n\"\"\"\ndigits = str(N)\nassert(digits.isdigit())\nresult = ''\nwhile digits:\ndigits, last3 = digits[:-3], digits[-3:]\nresult = (last3 + ',' + result) if result else last3\nreturn result\ndef money(N, width=0):\n\"\"\"",
    "Mixed Usage Modes: __name__ and __main__ | 587\n\n\fformat number N for display with commas, 2 decimal digits,\nleading $ and sign, and optional padding: $ -xxx,yyy.zz\n\"\"\"\nsign\n= '-' if N < 0 else ''\nN\n= abs(N)\nwhole = commas(int(N))\nfract = ('%.2f' % N)[-2:]\nformat = '%s%s.%s' % (sign, whole, fract)\nreturn '$%*s' % (width, format)\nif __name__ == '__main__':\ndef selftest():\ntests = 0, 1\n# fails: −1, 1.23\ntests += 12, 123, 1234, 12345, 123456, 1234567\ntests += 2 ** 32, 2 ** 100\nfor test in tests:\nprint(commas(test))\nprint('')\ntests = 0, 1, −1, 1.23, 1., 1.2, 3.14159\ntests += 12.34, 12.344, 12.345, 12.346\ntests += 2 ** 32, (2 ** 32 + .2345)\ntests += 1.2345, 1.2, 0.2345\ntests += −1.2345, −1.2, −0.2345\ntests += −(2 ** 32), −(2**32 + .2345)\ntests += (2 ** 100), −(2 ** 100)\nfor test in tests:\nprint('%s [%s]' % (money(test, 17), test))\nimport sys\nif len(sys.argv) == 1:\nselftest()\nelse:\nprint(money(float(sys.argv[1]), int(sys.argv[2])))",
    "This file works the same in Python 2.6 and 3.0. When run directly, it tests itself as\nbefore, but it uses options on the command line to control the test behavior. Run this\nfile directly with no command-line arguments on your own to see what its self-test code\nprints. To test specific strings, pass them in on the command line along with a minimum\nfield width:\nC:\\misc> python formats.py 999999999 0\n$999,999,999.00\nC:\\misc> python formats.py −999999999 0\n$-999,999,999.00\nC:\\misc> python formats.py 123456789012345 0\n$123,456,789,012,345.00\nC:\\misc> python formats.py −123456789012345 25\n$ −123,456,789,012,345.00\nC:\\misc> python formats.py 123.456 0\n$123.46\n\n588 | Chapter 24: Advanced Module Topics\n\n\fC:\\misc> python formats.py −123.454 0\n$-123.45\nC:\\misc> python formats.py\n...canned tests: try this yourself...",
    "588 | Chapter 24: Advanced Module Topics\n\n\fC:\\misc> python formats.py −123.454 0\n$-123.45\nC:\\misc> python formats.py\n...canned tests: try this yourself...\n\nAs before, because this code is instrumented for dual-mode usage, we can also import\nits tools normally in other contexts as library components:\n>>> from formats import money, commas\n>>> money(123.456)\n'$123.46'\n>>> money(-9999999.99, 15)\n'$ −9,999,999.99'\n>>> X = 99999999999999999999\n>>> '%s (%s)' % (commas(X), X)\n'99,999,999,999,999,999,999 (99999999999999999999)'\n\nBecause this file uses the docstring feature introduced in Chapter 15, we can use the\nhelp function to explore its tools as well—it serves as a general-purpose tool:\n>>> import formats\n>>> help(formats)\nHelp on module formats:\nNAME\n\nformats\n\nFILE\n\nc:\\misc\\formats.py",
    "Because this file uses the docstring feature introduced in Chapter 15, we can use the\nhelp function to explore its tools as well—it serves as a general-purpose tool:\n>>> import formats\n>>> help(formats)\nHelp on module formats:\nNAME\n\nformats\n\nFILE\n\nc:\\misc\\formats.py\n\nDESCRIPTION\nVarious specialized string display formatting utilities.\nTest me with canned self-test or command-line arguments.\nFUNCTIONS\ncommas(N)\nformat positive integer-like N for display with\ncommas between digit groupings: xxx,yyy,zzz\nmoney(N, width=0)\nformat number N for display with commas, 2 decimal digits,\nleading $ and sign, and optional padding: $ -xxx,yyy.zz",
    "FILE\n\nc:\\misc\\formats.py\n\nDESCRIPTION\nVarious specialized string display formatting utilities.\nTest me with canned self-test or command-line arguments.\nFUNCTIONS\ncommas(N)\nformat positive integer-like N for display with\ncommas between digit groupings: xxx,yyy,zzz\nmoney(N, width=0)\nformat number N for display with commas, 2 decimal digits,\nleading $ and sign, and optional padding: $ -xxx,yyy.zz\n\nYou can use command-line arguments in similar ways to provide general inputs to\nscripts that may also package their code as functions and classes for reuse by importers.\nFor more advanced command-line processing, be sure to see the getopt and optparse\nmodules in Python’s standard library and manuals. In some scenarios, you might also\nuse the built-in input function introduced in Chapter 3 and used in Chapter 10 to\nprompt the shell user for test inputs instead of pulling them from the command line.\n\nMixed Usage Modes: __name__ and __main__ | 589",
    "Mixed Usage Modes: __name__ and __main__ | 589\n\n\fAlso see Chapter 7’s discussion of the new {,d} string format method\nsyntax that will be available in Python 3.1 and later; this formatting\nextension separates thousands groups with commas much like the code\nhere. The module listed here, though, adds money formatting and serves\nas a manual alternative for comma insertion for Python versions before\n3.1.",
    "Changing the Module Search Path\nIn Chapter 21, we learned that the module search path is a list of directories that can\nbe customized via the environment variable PYTHONPATH, and possibly via .pth files. What\nI haven’t shown you until now is how a Python program itself can actually change the\nsearch path by changing a built-in list called sys.path (the path attribute in the builtin sys module). sys.path is initialized on startup, but thereafter you can delete, append,\nand reset its components however you like:\n>>> import sys\n>>> sys.path\n['', 'C:\\\\users', 'C:\\\\Windows\\\\system32\\\\python30.zip', ...more deleted...]\n>>> sys.path.append('C:\\\\sourcedir')\n>>> import string\n\n# Extend module search path\n# All imports search the new dir last",
    "# Extend module search path\n# All imports search the new dir last\n\nOnce you’ve made such a change, it will impact future imports anywhere in the Python\nprogram, as all imports and all files share the single sys.path list. In fact, this list may\nbe changed arbitrarily:\n>>> sys.path = [r'd:\\temp']\n>>> sys.path.append('c:\\\\lp4e\\\\examples')\n>>> sys.path\n['d:\\\\temp', 'c:\\\\lp4e\\\\examples']\n\n# Change module search path\n# For this process only\n\n>>> import string\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nImportError: No module named string",
    "# Change module search path\n# For this process only\n\n>>> import string\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nImportError: No module named string\n\nThus, you can use this technique to dynamically configure a search path inside a Python\nprogram. Be careful, though: if you delete a critical directory from the path, you may\nlose access to critical utilities. In the prior example, for instance, we no longer have\naccess to the string module because we deleted the Python source library’s directory\nfrom the path.\nAlso, remember that such sys.path settings endure for only as long as the Python session or program (technically, process) that made them runs; they are not retained after\nPython exits. PYTHONPATH and .pth file path configurations live in the operating system\ninstead of a running Python program, and so are more global: they are picked up by\nevery program on your machine and live on after a program completes.\n\n590 | Chapter 24: Advanced Module Topics",
    "590 | Chapter 24: Advanced Module Topics\n\n\fThe as Extension for import and from\nBoth the import and from statements have been extended to allow an imported name\nto be given a different name in your script. The following import statement:\nimport modulename as name\n\nis equivalent to:\nimport modulename\nname = modulename\ndel modulename\n\n# Don't keep original name\n\nAfter such an import, you can (and in fact must) use the name listed after the as to refer\nto the module. This works in a from statement, too, to assign a name imported from a\nfile to a different name in your script:\nfrom modulename import attrname as name\n\nThis extension is commonly used to provide short synonyms for longer names, and to\navoid name clashes when you are already using a name in your script that would otherwise be overwritten by a normal import statement:\nimport reallylongmodulename as name\nname.func()\n\n# Use shorter nickname",
    "This extension is commonly used to provide short synonyms for longer names, and to\navoid name clashes when you are already using a name in your script that would otherwise be overwritten by a normal import statement:\nimport reallylongmodulename as name\nname.func()\n\n# Use shorter nickname\n\nfrom module1 import utility as util1\nfrom module2 import utility as util2\nutil1(); util2()\n\n# Can have only 1 \"utility\"\n\nIt also comes in handy for providing a short, simple name for an entire directory path\nwhen using the package import feature described in Chapter 23:\nimport dir1.dir2.mod as mod\nmod.func()\n\n# Only list full path once",
    "Modules Are Objects: Metaprograms\nBecause modules expose most of their interesting properties as built-in attributes, it’s\neasy to write programs that manage other programs. We usually call such manager\nprograms metaprograms because they work on top of other systems. This is also referred\nto as introspection, because programs can see and process object internals. Introspection is an advanced feature, but it can be useful for building programming tools.\nFor instance, to get to an attribute called name in a module called M, we can use qualification or index the module’s attribute dictionary, exposed in the built-in __dict__\nattribute we met briefly in Chapter 22. Python also exports the list of all loaded modules\nas the sys.modules dictionary (that is, the modules attribute of the sys module) and\nprovides a built-in called getattr that lets us fetch attributes from their string names\n(it’s like saying object.attr, but attr is an expression that yields a string at runtime).",
    "attribute we met briefly in Chapter 22. Python also exports the list of all loaded modules\nas the sys.modules dictionary (that is, the modules attribute of the sys module) and\nprovides a built-in called getattr that lets us fetch attributes from their string names\n(it’s like saying object.attr, but attr is an expression that yields a string at runtime).\nBecause of that, all the following expressions reach the same attribute and object:",
    "Modules Are Objects: Metaprograms | 591\n\n\fM.name\nM.__dict__['name']\nsys.modules['M'].name\ngetattr(M, 'name')\n\n# Qualify object\n# Index namespace dictionary manually\n# Index loaded-modules table manually\n# Call built-in fetch function",
    "By exposing module internals like this, Python helps you build programs about programs.* For example, here is a module named mydir.py that puts these ideas to work\nto implement a customized version of the built-in dir function. It defines and exports\na function called listing, which takes a module object as an argument and prints a\nformatted listing of the module’s namespace:\n\"\"\"\nmydir.py: a module that lists the namespaces of other modules\n\"\"\"\nseplen = 60\nsepchr = '-'\ndef listing(module, verbose=True):\nsepline = sepchr * seplen\nif verbose:\nprint(sepline)\nprint('name:', module.__name__, 'file:', module.__file__)\nprint(sepline)\ncount = 0\nfor attr in module.__dict__:\n# Scan namespace keys\nprint('%02d) %s' % (count, attr), end = ' ')\nif attr.startswith('__'):\nprint('<built-in name>')\n# Skip __file__, etc.\nelse:\nprint(getattr(module, attr))\n# Same as .__dict__[attr]\ncount += 1\nif verbose:\nprint(sepline)\nprint(module.__name__, 'has %d names' % count)\nprint(sepline)",
    "print(sepline)\ncount = 0\nfor attr in module.__dict__:\n# Scan namespace keys\nprint('%02d) %s' % (count, attr), end = ' ')\nif attr.startswith('__'):\nprint('<built-in name>')\n# Skip __file__, etc.\nelse:\nprint(getattr(module, attr))\n# Same as .__dict__[attr]\ncount += 1\nif verbose:\nprint(sepline)\nprint(module.__name__, 'has %d names' % count)\nprint(sepline)\nif __name__ == '__main__':\nimport mydir\nlisting(mydir)",
    "# Self-test code: list myself\n\nNotice the docstring at the top; as in the prior formats.py example, because we may\nwant to use this as a general tool, a docstring is coded to provide functional information\naccessible via __doc__ attributes or the help function (see Chapter 15 for details):\n\n* As we saw in Chapter 17, because a function can access its enclosing module by going through the\nsys.modules table like this, it’s possible to emulate the effect of the global statement. For instance, the effect\nof global X; X=0 can be simulated (albeit with much more typing!) by saying this inside a function:\nimport sys; glob=sys.modules[__name__]; glob.X=0. Remember, each module gets a __name__ attribute for\nfree; it’s visible as a global name inside the functions within the module. This trick provides another way to\nchange both local and global variables of the same name inside a function.\n\n592 | Chapter 24: Advanced Module Topics\n\n\f>>> import mydir\n>>> help(mydir)\nHelp on module mydir:\nNAME",
    "592 | Chapter 24: Advanced Module Topics\n\n\f>>> import mydir\n>>> help(mydir)\nHelp on module mydir:\nNAME\n\nmydir - mydir.py: a module that lists the namespaces of other modules\n\nFILE\n\nc:\\users\\veramark\\mark\\mydir.py\n\nFUNCTIONS\nlisting(module, verbose=True)\nDATA\n\nsepchr = '-'\nseplen = 60",
    "FILE\n\nc:\\users\\veramark\\mark\\mydir.py\n\nFUNCTIONS\nlisting(module, verbose=True)\nDATA\n\nsepchr = '-'\nseplen = 60\n\nI’ve also provided self-test logic at the bottom of this module, which narcissistically\nimports and lists itself. Here’s the sort of output produced in Python 3.0 (to use this in\n2.6, enable 3.0 print calls with the __future__ import described in Chapter 11—the\nend keyword is 3.0-only):\nC:\\Users\\veramark\\Mark> c:\\Python30\\python mydir.py\n-----------------------------------------------------------name: mydir file: C:\\Users\\veramark\\Mark\\mydir.py\n-----------------------------------------------------------00) seplen 60\n01) __builtins__ <built-in name>\n02) __file__ <built-in name>\n03) __package__ <built-in name>\n04) listing <function listing at 0x026D3B70>\n05) __name__ <built-in name>\n06) sepchr 07) __doc__ <built-in name>\n-----------------------------------------------------------mydir has 8 names\n------------------------------------------------------------",
    "To use this as a tool for listing other modules, simply pass the modules in as objects to\nthis file’s function. Here it is listing attributes in the tkinter GUI module in the standard\nlibrary (a.k.a. Tkinter in Python 2.6):\n>>> import mydir\n>>> import tkinter\n>>> mydir.listing(tkinter)\n-----------------------------------------------------------name: tkinter file: c:\\PYTHON30\\lib\\tkinter\\__init__.py\n-----------------------------------------------------------00) getdouble <class 'float'>\n01) MULTIPLE multiple\n02) mainloop <function mainloop at 0x02913B70>\n03) Canvas <class 'tkinter.Canvas'>\n04) AtSelLast <function AtSelLast at 0x028FA7C8>\n...many more name omitted...\n151) StringVar <class 'tkinter.StringVar'>\n\nModules Are Objects: Metaprograms | 593\n\n\f152) ARC arc\n153) At <function At at 0x028FA738>\n154) NSEW nsew\n155) SCROLL scroll\n-----------------------------------------------------------tkinter has 156 names\n------------------------------------------------------------",
    "Modules Are Objects: Metaprograms | 593\n\n\f152) ARC arc\n153) At <function At at 0x028FA738>\n154) NSEW nsew\n155) SCROLL scroll\n-----------------------------------------------------------tkinter has 156 names\n------------------------------------------------------------\n\nWe’ll meet getattr and its relatives again later. The point to notice here is that mydir\nis a program that lets you browse other programs. Because Python exposes its internals,\nyou can process objects generically.†",
    "We’ll meet getattr and its relatives again later. The point to notice here is that mydir\nis a program that lets you browse other programs. Because Python exposes its internals,\nyou can process objects generically.†\n\nImporting Modules by Name String\nThe module name in an import or from statement is a hardcoded variable name. Sometimes, though, your program will get the name of a module to be imported as a string\nat runtime (e.g., if a user selects a module name from within a GUI). Unfortunately,\nyou can’t use import statements directly to load a module given its name as a string—\nPython expects a variable name, not a string. For instance:\n>>> import \"string\"\nFile \"<stdin>\", line 1\nimport \"string\"\n^\nSyntaxError: invalid syntax\n\nIt also won’t work to simply assign the string to a variable name:\nx = \"string\"\nimport x",
    "It also won’t work to simply assign the string to a variable name:\nx = \"string\"\nimport x\n\nHere, Python will try to import a file x.py, not the string module—the name in an\nimport statement both becomes a variable assigned to the loaded module and identifies\nthe external file literally.\nTo get around this, you need to use special tools to load a module dynamically from a\nstring that is generated at runtime. The most general approach is to construct an\nimport statement as a string of Python code and pass it to the exec built-in function to\nrun (exec is a statement in Python 2.6, but it can be used exactly as shown here—the\nparentheses are simply ignored):\n>>> modname = \"string\"\n>>> exec(\"import \" + modname)\n# Run a string of code\n>>> string\n# Imported in this namespace\n<module 'string' from 'c:\\Python30\\lib\\string.py'>",
    "† Tools such as mydir.listing can be preloaded into the interactive namespace by importing them in the file\nreferenced by the PYTHONSTARTUP environment variable. Because code in the startup file runs in the interactive\nnamespace (module __main__), importing common tools in the startup file can save you some typing. See\nAppendix A for more details.\n\n594 | Chapter 24: Advanced Module Topics",
    "594 | Chapter 24: Advanced Module Topics\n\n\fThe exec function (and its cousin for expressions, eval) compiles a string of code and\npasses it to the Python interpreter to be executed. In Python, the byte code compiler is\navailable at runtime, so you can write programs that construct and run other programs\nlike this. By default, exec runs the code in the current scope, but you can get more\nspecific by passing in optional namespace dictionaries.\nThe only real drawback to exec is that it must compile the import statement each time\nit runs; if it runs many times, your code may run quicker if it uses the built-in\n__import__ function to load from a name string instead. The effect is similar, but\n__import__ returns the module object, so assign it to a name here to keep it:\n>>> modname = \"string\"\n>>> string = __import__(modname)\n>>> string\n<module 'string' from 'c:\\Python30\\lib\\string.py'>",
    "Transitive Module Reloads\nWe studied module reloads in Chapter 22, as a way to pick up changes in code without\nstopping and restarting a program. When you reload a module, though, Python only\nreloads that particular module’s file; it doesn’t automatically reload modules that the\nfile being reloaded happens to import.\nFor example, if you reload some module A, and A imports modules B and C, the reload\napplies only to A, not to B and C. The statements inside A that import B and C are rerun\nduring the reload, but they just fetch the already loaded B and C module objects (assuming they’ve been imported before). In actual code, here’s the file A.py:\nimport B\nimport C\n\n# Not reloaded when A is\n# Just an import of an already loaded module\n\n% python\n>>> . . .\n>>> from imp import reload\n>>> reload(A)",
    "By default, this means that you cannot depend on reloads picking up changes in all the\nmodules in your program transitively—instead, you must use multiple reload calls to\nupdate the subcomponents independently. This can require substantial work for large\nsystems you’re testing interactively. You can design your systems to reload their subcomponents automatically by adding reload calls in parent modules like A, but this\ncomplicates the modules’ code.\nA better approach is to write a general tool to do transitive reloads automatically by\nscanning modules’ __dict__ attributes and checking each item’s type to find nested\nmodules to reload. Such a utility function could call itself recursively to navigate arbitrarily shaped import dependency chains. Module __dict__ attributes were introduced\nearlier in, the section “Modules Are Objects: Metaprograms” on page 591, and the\ntype call was presented in Chapter 9; we just need to combine the two tools.\nTransitive Module Reloads | 595",
    "For example, the module reloadall.py listed next has a reload_all function that automatically reloads a module, every module that the module imports, and so on, all the\nway to the bottom of each import chain. It uses a dictionary to keep track of already\nreloaded modules, recursion to walk the import chains, and the standard library’s\ntypes module, which simply predefines type results for built-in types. The visited\ndictionary technique works to avoid cycles here when imports are recursive or redundant, because module objects can be dictionary keys (as we learned in Chapter 5, a set\nwould offer similar functionality if we use visited.add(module) to insert):\n\"\"\"\nreloadall.py: transitively reload nested modules\n\"\"\"\nimport types\nfrom imp import reload\n\n# from required in 3.0",
    "# from required in 3.0\n\ndef status(module):\nprint('reloading ' + module.__name__)\ndef transitive_reload(module, visited):\nif not module in visited:\nstatus(module)\nreload(module)\nvisited[module] = None\nfor attrobj in module.__dict__.values():\nif type(attrobj) == types.ModuleType:\ntransitive_reload(attrobj, visited)\n\n# Trap cycles, duplicates\n# Reload this module\n# And visit children\n# For all attrs\n# Recur if module\n\ndef reload_all(*args):\nvisited = {}\nfor arg in args:\nif type(arg) == types.ModuleType:\ntransitive_reload(arg, visited)\nif __name__ == '__main__':\nimport reloadall\nreload_all(reloadall)\n\n# Test code: reload myself\n# Should reload this, types",
    "# Trap cycles, duplicates\n# Reload this module\n# And visit children\n# For all attrs\n# Recur if module\n\ndef reload_all(*args):\nvisited = {}\nfor arg in args:\nif type(arg) == types.ModuleType:\ntransitive_reload(arg, visited)\nif __name__ == '__main__':\nimport reloadall\nreload_all(reloadall)\n\n# Test code: reload myself\n# Should reload this, types\n\nTo use this utility, import its reload_all function and pass it the name of an already\nloaded module (like you would the built-in reload function). When the file runs standalone, its self-test code will test itself—it has to import itself because its own name is\nnot defined in the file without an import (this code works in both 3.0 and 2.6 and prints\nidentical output, because we’ve used + instead of a comma in the print):\nC:\\misc> c:\\Python30\\python reloadall.py\nreloading reloadall\nreloading types",
    "Here is this module at work in 3.0 on some standard library modules. Notice how os\nis imported by tkinter, but tkinter reaches sys before os can (if you want to test this\non Python 2.6, substitute Tkinter for tkinter):\n\n596 | Chapter 24: Advanced Module Topics\n\n\f>>> from reloadall import reload_all\n>>> import os, tkinter\n>>> reload_all(os)\nreloading os\nreloading copyreg\nreloading ntpath\nreloading genericpath\nreloading stat\nreloading sys\nreloading errno\n>>> reload_all(tkinter)\nreloading tkinter\nreloading _tkinter\nreloading tkinter._fix\nreloading sys\nreloading ctypes\nreloading os\nreloading copyreg\nreloading ntpath\nreloading genericpath\nreloading stat\nreloading errno\nreloading ctypes._endian\nreloading tkinter.constants\n\nAnd here is a session that shows the effect of normal versus transitive reloads—changes\nmade to the two nested files are not picked up by reloads, unless the transitive utility\nis used:\nimport b\nX = 1\n\n# a.py\n\nimport c\nY = 2\n\n# b.py\n\nZ = 3\n\n# c.py",
    "And here is a session that shows the effect of normal versus transitive reloads—changes\nmade to the two nested files are not picked up by reloads, unless the transitive utility\nis used:\nimport b\nX = 1\n\n# a.py\n\nimport c\nY = 2\n\n# b.py\n\nZ = 3\n\n# c.py\n\nC:\\misc> C:\\Python30\\python\n>>> import a\n>>> a.X, a.b.Y, a.b.c.Z\n(1, 2, 3)\n# Change all three files' assignment values and save\n>>> from imp import reload\n>>> reload(a)\n<module 'a' from 'a.py'>\n>>> a.X, a.b.Y, a.b.c.Z\n(111, 2, 3)\n\n# Normal reload is top level only\n\n>>> from reloadall import reload_all\n>>> reload_all(a)\nreloading a\n\nTransitive Module Reloads | 597\n\n\freloading b\nreloading c\n>>> a.X, a.b.Y, a.b.c.Z\n(111, 222, 333)\n\n# Reloads all nested modules too\n\nFor more insight, study and experiment with this example on your own; it’s another\nimportable tool you might want to add to your own source code library.",
    "Module Design Concepts\nLike functions, modules present design tradeoffs: you have to think about which functions go in which modules, module communication mechanisms, and so on. All of this\nwill become clearer when you start writing bigger Python systems, but here are a few\ngeneral ideas to keep in mind:\n• You’re always in a module in Python. There’s no way to write code that doesn’t\nlive in some module. In fact, code typed at the interactive prompt really goes in a\nbuilt-in module called __main__; the only unique things about the interactive\nprompt are that code runs and is discarded immediately, and expression results\nare printed automatically.\n• Minimize module coupling: global variables. Like functions, modules work\nbest if they’re written to be closed boxes. As a rule of thumb, they should be as\nindependent of global variables used within other modules as possible, except for\nfunctions and classes imported from them.",
    "prompt are that code runs and is discarded immediately, and expression results\nare printed automatically.\n• Minimize module coupling: global variables. Like functions, modules work\nbest if they’re written to be closed boxes. As a rule of thumb, they should be as\nindependent of global variables used within other modules as possible, except for\nfunctions and classes imported from them.\n• Maximize module cohesion: unified purpose. You can minimize a module’s\ncouplings by maximizing its cohesion; if all the components of a module share a\ngeneral purpose, you’re less likely to depend on external names.\n• Modules should rarely change other modules’ variables. We illustrated this\nwith code in Chapter 17, but it’s worth repeating here: it’s perfectly OK to use\nglobals defined in another module (that’s how clients import services, after all),\nbut changing globals in another module is often a symptom of a design problem.",
    "general purpose, you’re less likely to depend on external names.\n• Modules should rarely change other modules’ variables. We illustrated this\nwith code in Chapter 17, but it’s worth repeating here: it’s perfectly OK to use\nglobals defined in another module (that’s how clients import services, after all),\nbut changing globals in another module is often a symptom of a design problem.\nThere are exceptions, of course, but you should try to communicate results through\ndevices such as function arguments and return values, not cross-module changes.\nOtherwise, your globals’ values become dependent on the order of arbitrarily remote assignments in other files, and your modules become harder to understand\nand reuse.\nAs a summary, Figure 24-1 sketches the environment in which modules operate. Modules contain variables, functions, classes, and other modules (if imported). Functions\nhave local variables of their own, as do classes—i.e., objects that live within modules,",
    "and reuse.\nAs a summary, Figure 24-1 sketches the environment in which modules operate. Modules contain variables, functions, classes, and other modules (if imported). Functions\nhave local variables of their own, as do classes—i.e., objects that live within modules,\nwhich we’ll meet next in Chapter 25.",
    "598 | Chapter 24: Advanced Module Topics\n\n\fFigure 24-1. Module execution environment. Modules are imported, but modules also import and use\nother modules, which may be coded in Python or another language such as C. Modules in turn contain\nvariables, functions, and classes to do their work, and their functions and classes may contain variables\nand other items of their own. At the top, though, programs are just sets of modules.\n\nModule Gotchas\nIn this section, we’ll take a look at the usual collection of boundary cases that make life\ninteresting for Python beginners. Some are so obscure that it was hard to come up with\nexamples, but most illustrate something important about the language.",
    "Statement Order Matters in Top-Level Code\nWhen a module is first imported (or reloaded), Python executes its statements one by\none, from the top of the file to the bottom. This has a few subtle implications regarding\nforward references that are worth underscoring here:\n• Code at the top level of a module file (not nested in a function) runs as soon as\nPython reaches it during an import; because of that, it can’t reference names assigned lower in the file.\n• Code inside a function body doesn’t run until the function is called; because names\nin a function aren’t resolved until the function actually runs, they can usually reference names anywhere in the file.\nGenerally, forward references are only a concern in top-level module code that executes\nimmediately; functions can reference names arbitrarily. Here’s an example that illustrates forward reference:\n\nModule Gotchas | 599\n\n\ffunc1()\n\n# Error: \"func1\" not yet assigned\n\ndef func1():\nprint(func2())\n\n# Okay: \"func2\" looked up later",
    "Module Gotchas | 599\n\n\ffunc1()\n\n# Error: \"func1\" not yet assigned\n\ndef func1():\nprint(func2())\n\n# Okay: \"func2\" looked up later\n\nfunc1()\n\n# Error: \"func2\" not yet assigned\n\ndef func2():\nreturn \"Hello\"\nfunc1()\n\n# Okay: \"func1\" and \"func2\" assigned",
    "def func1():\nprint(func2())\n\n# Okay: \"func2\" looked up later\n\nfunc1()\n\n# Error: \"func2\" not yet assigned\n\ndef func2():\nreturn \"Hello\"\nfunc1()\n\n# Okay: \"func1\" and \"func2\" assigned\n\nWhen this file is imported (or run as a standalone program), Python executes its statements from top to bottom. The first call to func1 fails because the func1 def hasn’t run\nyet. The call to func2 inside func1 works as long as func2’s def has been reached by the\ntime func1 is called (it hasn’t when the second top-level func1 call is run). The last call\nto func1 at the bottom of the file works because func1 and func2 have both been\nassigned.\nMixing defs with top-level code is not only hard to read, it’s dependent on statement\nordering. As a rule of thumb, if you need to mix immediate code with defs, put your\ndefs at the top of the file and your top-level code at the bottom. That way, your functions\nare guaranteed to be defined and assigned by the time code that uses them runs.",
    "from Copies Names but Doesn’t Link\nAlthough it’s commonly used, the from statement is the source of a variety of potential\ngotchas in Python. The from statement is really an assignment to names in the importer’s\nscope—a name-copy operation, not a name aliasing. The implications of this are the\nsame as for all assignments in Python, but they’re subtle, especially given that the code\nthat shares the objects lives in different files. For instance, suppose we define the following module, nested1.py:\n# nested1.py\nX = 99\ndef printer(): print(X)\n\nIf we import its two names using from in another module, nested2.py, we get copies of\nthose names, not links to them. Changing a name in the importer resets only the binding\nof the local version of that name, not the name in nested1.py:\n# nested2.py\nfrom nested1 import X, printer\nX = 88\nprinter()\n% python nested2.py\n99\n\n600 | Chapter 24: Advanced Module Topics\n\n# Copy names out\n# Changes my \"X\" only!\n# nested1's X is still 99",
    "600 | Chapter 24: Advanced Module Topics\n\n# Copy names out\n# Changes my \"X\" only!\n# nested1's X is still 99\n\n\fIf we use import to get the whole module and then assign to a qualified name, however,\nwe change the name in nested1.py. Qualification directs Python to a name in the module\nobject, rather than a name in the importer, nested3.py:\n# nested3.py\nimport nested1\nnested1.X = 88\nnested1.printer()\n\n# Get module as a whole\n# OK: change nested1's X\n\n% python nested3.py\n88",
    "# Get module as a whole\n# OK: change nested1's X\n\n% python nested3.py\n88\n\nfrom * Can Obscure the Meaning of Variables\nI mentioned this earlier but saved the details for here. Because you don’t list the variables you want when using the from module import * statement form, it can accidentally\noverwrite names you’re already using in your scope. Worse, it can make it difficult to\ndetermine where a variable comes from. This is especially true if the from * form is used\non more than one imported file.\nFor example, if you use from * on three modules, you’ll have no way of knowing what\na raw function call really means, short of searching all three external module files (all\nof which may be in other directories):\n>>> from module1 import *\n>>> from module2 import *\n>>> from module3 import *\n>>> . . .\n\n# Bad: may overwrite my names silently\n# Worse: no way to tell what we get!\n\n>>> func()\n\n# Huh???",
    "# Bad: may overwrite my names silently\n# Worse: no way to tell what we get!\n\n>>> func()\n\n# Huh???\n\nThe solution again is not to do this: try to explicitly list the attributes you want in your\nfrom statements, and restrict the from * form to at most one imported module per file.\nThat way, any undefined names must by deduction be in the module named in the\nsingle from *. You can avoid the issue altogether if you always use import instead of\nfrom, but that advice is too harsh; like much else in programming, from is a convenient\ntool if used wisely. Even this example isn’t an absolute evil—it’s OK for a program to\nuse this technique to collect names in a single space for convenience, as long as it’s well\nknown.",
    "reload May Not Impact from Imports\nHere’s another from-related gotcha: as discussed previously, because from copies (assigns) names when run, there’s no link back to the modules where the names came\nfrom. Names imported with from simply become references to objects, which happen\nto have been referenced by the same names in the importee when the from ran.\n\nModule Gotchas | 601\n\n\fBecause of this behavior, reloading the importee has no effect on clients that import its\nnames using from. That is, the client’s names will still reference the original objects\nfetched with from, even if the names in the original module are later reset:\nfrom module import X\n. . .\nfrom imp import reload\nreload(module)\nX\n\n# X may not reflect any module reloads!\n# Changes module, but not my names\n# Still references old object",
    "# X may not reflect any module reloads!\n# Changes module, but not my names\n# Still references old object\n\nTo make reloads more effective, use import and name qualification instead of from.\nBecause qualifications always go back to the module, they will find the new bindings\nof module names after reloading:\nimport module\n. . .\nfrom imp import reload\nreload(module)\nmodule.X\n\n# Get module, not names\n# Changes module in-place\n# Get current X: reflects module reloads",
    "To make reloads more effective, use import and name qualification instead of from.\nBecause qualifications always go back to the module, they will find the new bindings\nof module names after reloading:\nimport module\n. . .\nfrom imp import reload\nreload(module)\nmodule.X\n\n# Get module, not names\n# Changes module in-place\n# Get current X: reflects module reloads\n\nreload, from, and Interactive Testing\nIn fact, the prior gotcha is even more subtle than it appears. Chapter 3 warned that it’s\nusually better not to launch programs with imports and reloads because of the complexities involved. Things get even worse when from is brought into the mix. Python\nbeginners often stumble onto its issues in scenarios like the one outlined next. Say that\nafter opening a module file in a text edit window, you launch an interactive session to\nload and test your module with from:\nfrom module import function\nfunction(1, 2, 3)",
    "Finding a bug, you jump back to the edit window, make a change, and try to reload\nthe module this way:\nfrom imp import reload\nreload(module)\n\nThis doesn’t work, because the from statement assigned the name function, not\nmodule. To refer to the module in a reload, you have to first load it with an import\nstatement at least once:\nfrom imp import reload\nimport module\nreload(module)\nfunction(1, 2, 3)\n\nHowever, this doesn’t quite work either—reload updates the module object, but as\ndiscussed in the preceding section, names like function that were copied out of the\nmodule in the past still refer to the old objects (in this instance, the original version of\nthe function). To really get the new function, you must refer to it as module.function\nafter the reload, or rerun the from:\n\n602 | Chapter 24: Advanced Module Topics\n\n\ffrom imp import reload\nimport module\nreload(module)\nfrom module import function\nfunction(1, 2, 3)\n\n# Or give up and use module.function()",
    "602 | Chapter 24: Advanced Module Topics\n\n\ffrom imp import reload\nimport module\nreload(module)\nfrom module import function\nfunction(1, 2, 3)\n\n# Or give up and use module.function()\n\nNow, the new version of the function will finally run.\nAs you can see, there are problems inherent in using reload with from: not only do you\nhave to remember to reload after imports, but you also have to remember to rerun your\nfrom statements after reloads. This is complex enough to trip up even an expert once\nin a while. (In fact, the situation has gotten even worse in Python 3.0, because you must\nalso remember to import reload itself!)\nThe short story is that you should not expect reload and from to play together nicely.\nThe best policy is not to combine them at all—use reload with import, or launch your\nprograms other ways, as suggested in Chapter 3: using the Run→Run Module menu\noption in IDLE, file icon clicks, system command lines, or the exec built-in function.",
    "Recursive from Imports May Not Work\nI saved the most bizarre (and, thankfully, obscure) gotcha for last. Because imports\nexecute a file’s statements from top to bottom, you need to be careful when using\nmodules that import each other (known as recursive imports). Because the statements\nin a module may not all have been run when it imports another module, some of its\nnames may not yet exist.\nIf you use import to fetch the module as a whole, this may or may not matter; the\nmodule’s names won’t be accessed until you later use qualification to fetch their values.\nBut if you use from to fetch specific names, you must bear in mind that you will only\nhave access to names in that module that have already been assigned.\nFor instance, take the following modules, recur1 and recur2. recur1 assigns a name X,\nand then imports recur2 before assigning the name Y. At this point, recur2 can fetch\nrecur1 as a whole with an import (it already exists in Python’s internal modules table),",
    "have access to names in that module that have already been assigned.\nFor instance, take the following modules, recur1 and recur2. recur1 assigns a name X,\nand then imports recur2 before assigning the name Y. At this point, recur2 can fetch\nrecur1 as a whole with an import (it already exists in Python’s internal modules table),\nbut if it uses from, it will be able to see only the name X; the name Y, which is assigned\nbelow the import in recur1, doesn’t yet exist, so you get an error:\n# recur1.py\nX = 1\nimport recur2\nY = 2\n# recur2.py\nfrom recur1 import X\nfrom recur1 import Y",
    "# Run recur2 now if it doesn't exist\n\n# OK: \"X\" already assigned\n# Error: \"Y\" not yet assigned\n\nC:\\misc> C:\\Python30\\python\n>>> import recur1\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n\nModule Gotchas | 603\n\n\fFile \"recur1.py\", line 2, in <module>\nimport recur2\nFile \"recur2.py\", line 2, in <module>\nfrom recur1 import Y\nImportError: cannot import name Y",
    "Python avoids rerunning recur1’s statements when they are imported recursively from\nrecur2 (otherwise the imports would send the script into an infinite loop), but\nrecur1’s namespace is incomplete when it’s imported by recur2.\nThe solution? Don’t use from in recursive imports (no, really!). Python won’t get stuck\nin a cycle if you do, but your programs will once again be dependent on the order of\nthe statements in the modules.\nThere are two ways out of this gotcha:\n• You can usually eliminate import cycles like this by careful design—maximizing\ncohesion and minimizing coupling are good first steps.\n• If you can’t break the cycles completely, postpone module name accesses by using\nimport and qualification (instead of from), or by running your froms either inside\nfunctions (instead of at the top level of the module), or near the bottom of your\nfile to defer their execution.",
    "Chapter Summary\nThis chapter surveyed some more advanced module-related concepts. We studied data\nhiding techniques, enabling new language features with the __future__ module, the\n__name__ usage mode variable, transitive reloads, importing by name strings, and more.\nWe also explored and summarized module design issues and looked at common mistakes related to modules to help you avoid them in your code.\nThe next chapter begins our look at Python’s object-oriented programming tool, the\nclass. Much of what we’ve covered in the last few chapters will apply there, too—classes\nlive in modules and are namespaces as well, but they add an extra component to attribute lookup called inheritance search. As this is the last chapter in this part of the\nbook, however, before we dive into that topic, be sure to work through this part’s set\nof lab exercises. And before that, here is this chapter’s quiz to review the topics covered\nhere.",
    "Test Your Knowledge: Quiz\n1. What is significant about variables at the top level of a module whose names begin\nwith a single underscore?\n2. What does it mean when a module’s __name__ variable is the string \"__main__\"?\n\n604 | Chapter 24: Advanced Module Topics\n\n\f3. If the user interactively types the name of a module to test, how can you import it?\n4. How is changing sys.path different from setting PYTHONPATH to modify the module\nsearch path?\n5. If the module __future__ allows us to import from the future, can we also import\nfrom the past?",
    "Test Your Knowledge: Answers\n1. Variables at the top level of a module whose names begin with a single underscore\nare not copied out to the importing scope when the from * statement form is used.\nThey can still be accessed by an import or the normal from statement form, though.\n2. If a module’s __name__ variable is the string \"__main__\", it means that the file is\nbeing executed as a top-level script instead of being imported from another file in\nthe program. That is, the file is being used as a program, not a library.\n3. User input usually comes into a script as a string; to import the referenced module\ngiven its string name, you can build and run an import statement with exec, or pass\nthe string name in a call to the __import__ function.\n4. Changing sys.path only affects one running program, and is temporary—the\nchange goes away when the program ends. PYTHONPATH settings live in the operating\nsystem—they are picked up globally by all programs on a machine, and changes",
    "given its string name, you can build and run an import statement with exec, or pass\nthe string name in a call to the __import__ function.\n4. Changing sys.path only affects one running program, and is temporary—the\nchange goes away when the program ends. PYTHONPATH settings live in the operating\nsystem—they are picked up globally by all programs on a machine, and changes\nto these settings endure after programs exit.\n5. No, we can’t import from the past in Python. We can install (or stubbornly use)\nan older version of the language, but the latest Python is generally the best Python.",
    "Test Your Knowledge: Part V Exercises\nSee “Part V, Modules” on page 1119 in Appendix B for the solutions.\n1. Import basics. Write a program that counts the lines and characters in a file (similar\nin spirit to wc on Unix). With your text editor, code a Python module called\nmymod.py that exports three top-level names:\n• A countLines(name) function that reads an input file and counts the number of\nlines in it (hint: file.readlines does most of the work for you, and len does the\nrest).\n• A countChars(name) function that reads an input file and counts the number of\ncharacters in it (hint: file.read returns a single string).\n• A test(name) function that calls both counting functions with a given input\nfilename. Such a filename generally might be passed in, hardcoded, input with\nthe input built-in function, or pulled from a command line via the sys.argv list\nshown in this chapter’s formats.py example; for now, you can assume it’s a\npassed-in function argument.",
    "• A test(name) function that calls both counting functions with a given input\nfilename. Such a filename generally might be passed in, hardcoded, input with\nthe input built-in function, or pulled from a command line via the sys.argv list\nshown in this chapter’s formats.py example; for now, you can assume it’s a\npassed-in function argument.\nTest Your Knowledge: Part V Exercises | 605",
    "All three mymod functions should expect a filename string to be passed in. If you\ntype more than two or three lines per function, you’re working much too hard—\nuse the hints I just gave!\nNext, test your module interactively, using import and attribute references to fetch\nyour exports. Does your PYTHONPATH need to include the directory where you created\nmymod.py? Try running your module on itself: e.g., test(\"mymod.py\"). Note that\ntest opens the file twice; if you’re feeling ambitious, you may be able to improve\nthis by passing an open file object into the two count functions (hint:\nfile.seek(0) is a file rewind).\n2. from/from *. Test your mymod module from exercise 1 interactively by using from to\nload the exports directly, first by name, then using the from * variant to fetch\neverything.\n3. __main__. Add a line in your mymod module that calls the test function automatically only when the module is run as a script, not when it is imported. The line you",
    "file.seek(0) is a file rewind).\n2. from/from *. Test your mymod module from exercise 1 interactively by using from to\nload the exports directly, first by name, then using the from * variant to fetch\neverything.\n3. __main__. Add a line in your mymod module that calls the test function automatically only when the module is run as a script, not when it is imported. The line you\nadd will probably test the value of __name__ for the string \"__main__\", as shown in\nthis chapter. Try running your module from the system command line; then, import the module and test its functions interactively. Does it still work in both\nmodes?\n4. Nested imports. Write a second module, myclient.py, that imports mymod and tests\nits functions; then run myclient from the system command line. If myclient uses\nfrom to fetch from mymod, will mymod’s functions be accessible from the top level of\nmyclient? What if it imports with import instead? Try coding both variations in",
    "modes?\n4. Nested imports. Write a second module, myclient.py, that imports mymod and tests\nits functions; then run myclient from the system command line. If myclient uses\nfrom to fetch from mymod, will mymod’s functions be accessible from the top level of\nmyclient? What if it imports with import instead? Try coding both variations in\nmyclient and test interactively by importing myclient and inspecting its __dict__\nattribute.\n5. Package imports. Import your file from a package. Create a subdirectory called\nmypkg nested in a directory on your module import search path, move the\nmymod.py module file you created in exercise 1 or 3 into the new directory, and\ntry to import it with a package import of the form import mypkg.mymod.\nYou’ll need to add an __init__.py file in the directory your module was moved to\nmake this go, but it should work on all major Python platforms (that’s part of the\nreason Python uses “.” as a path separator). The package directory you create can",
    "mymod.py module file you created in exercise 1 or 3 into the new directory, and\ntry to import it with a package import of the form import mypkg.mymod.\nYou’ll need to add an __init__.py file in the directory your module was moved to\nmake this go, but it should work on all major Python platforms (that’s part of the\nreason Python uses “.” as a path separator). The package directory you create can\nbe simply a subdirectory of the one you’re working in; if it is, it will be found via\nthe home directory component of the search path, and you won’t have to configure\nyour path. Add some code to your __init__.py, and see if it runs on each import.\n6. Reloads. Experiment with module reloads: perform the tests in Chapter 22’s\nchanger.py example, changing the called function’s message and/or behavior repeatedly, without stopping the Python interpreter. Depending on your system, you\nmight be able to edit changer in another window, or suspend the Python interpreter",
    "your path. Add some code to your __init__.py, and see if it runs on each import.\n6. Reloads. Experiment with module reloads: perform the tests in Chapter 22’s\nchanger.py example, changing the called function’s message and/or behavior repeatedly, without stopping the Python interpreter. Depending on your system, you\nmight be able to edit changer in another window, or suspend the Python interpreter\nand edit in the same window (on Unix, a Ctrl-Z key combination usually suspends\nthe current process, and an fg command later resumes it).",
    "606 | Chapter 24: Advanced Module Topics\n\n\f7. Circular imports.‡ In the section on recursive import gotchas, importing recur1\nraised an error. But if you restart Python and import recur2 interactively, the error\ndoesn’t occur—test this and see for yourself. Why do you think it works to import\nrecur2, but not recur1? (Hint: Python stores new modules in the built-in\nsys.modules table—a dictionary—before running their code; later imports fetch\nthe module from this table first, whether the module is “complete” yet or not.)\nNow, try running recur1 as a top-level script file: python recur1.py. Do you get the\nsame error that occurs when recur1 is imported interactively? Why? (Hint: when\nmodules are run as programs, they aren’t imported, so this case has the same effect\nas importing recur2 interactively; recur2 is the first module imported.) What happens when you run recur2 as a script?",
    "‡ Note that circular imports are extremely rare in practice. On the other hand, if you can understand why they\nare a potential problem, you know a lot about Python’s import semantics.\n\nTest Your Knowledge: Part V Exercises | 607\n\n\f\fPART VI\n\nClasses and OOP\n\n\f\fCHAPTER 25\n\nOOP: The Big Picture",
    "So far in this book, we’ve been using the term “object” generically. Really, the code\nwritten up to this point has been object-based—we’ve passed objects around our scripts,\nused them in expressions, called their methods, and so on. For our code to qualify as\nbeing truly object-oriented (OO), though, our objects will generally need to also participate in something called an inheritance hierarchy.\nThis chapter begins our exploration of the Python class—a device used to implement\nnew kinds of objects in Python that support inheritance. Classes are Python’s main\nobject-oriented programming (OOP) tool, so we’ll also look at OOP basics along the\nway in this part of the book. OOP offers a different and often more effective way of\nlooking at programming, in which we factor code to minimize redundancy, and write\nnew programs by customizing existing code instead of changing it in-place.\nIn Python, classes are created with a new statement: the class statement. As you’ll see,",
    "way in this part of the book. OOP offers a different and often more effective way of\nlooking at programming, in which we factor code to minimize redundancy, and write\nnew programs by customizing existing code instead of changing it in-place.\nIn Python, classes are created with a new statement: the class statement. As you’ll see,\nthe objects defined with classes can look a lot like the built-in types we studied earlier\nin the book. In fact, classes really just apply and extend the ideas we’ve already covered;\nroughly, they are packages of functions that use and process built-in object types.\nClasses, though, are designed to create and manage new objects, and they also support\ninheritance—a mechanism of code customization and reuse above and beyond anything we’ve seen so far.\nOne note up front: in Python, OOP is entirely optional, and you don’t need to use",
    "roughly, they are packages of functions that use and process built-in object types.\nClasses, though, are designed to create and manage new objects, and they also support\ninheritance—a mechanism of code customization and reuse above and beyond anything we’ve seen so far.\nOne note up front: in Python, OOP is entirely optional, and you don’t need to use\nclasses just to get started. In fact, you can get plenty of work done with simpler constructs such as functions, or even simple top-level script code. Because using classes\nwell requires some up-front planning, they tend to be of more interest to people who\nwork in strategic mode (doing long-term product development) than to people who\nwork in tactical mode (where time is in very short supply).\nStill, as you’ll see in this part of the book, classes turn out to be one of the most useful\ntools Python provides. When used well, classes can actually cut development time",
    "well requires some up-front planning, they tend to be of more interest to people who\nwork in strategic mode (doing long-term product development) than to people who\nwork in tactical mode (where time is in very short supply).\nStill, as you’ll see in this part of the book, classes turn out to be one of the most useful\ntools Python provides. When used well, classes can actually cut development time\nradically. They’re also employed in popular Python tools like the tkinter GUI API, so\nmost Python programmers will usually find at least a working knowledge of class basics\nhelpful.\n611",
    "Why Use Classes?\nRemember when I told you that programs “do things with stuff”? In simple terms,\nclasses are just a way to define new sorts of stuff, reflecting real objects in a program’s\ndomain. For instance, suppose we decide to implement that hypothetical pizza-making\nrobot we used as an example in Chapter 16. If we implement it using classes, we can\nmodel more of its real-world structure and relationships. Two aspects of OOP prove\nuseful here:\nInheritance\nPizza-making robots are kinds of robots, so they possess the usual robot-y properties. In OOP terms, we say they “inherit” properties from the general category\nof all robots. These common properties need to be implemented only once for the\ngeneral case and can be reused by all types of robots we may build in the future.\nComposition\nPizza-making robots are really collections of components that work together as a\nteam. For instance, for our robot to be successful, it might need arms to roll dough,",
    "of all robots. These common properties need to be implemented only once for the\ngeneral case and can be reused by all types of robots we may build in the future.\nComposition\nPizza-making robots are really collections of components that work together as a\nteam. For instance, for our robot to be successful, it might need arms to roll dough,\nmotors to maneuver to the oven, and so on. In OOP parlance, our robot is an\nexample of composition; it contains other objects that it activates to do its bidding.\nEach component might be coded as a class, which defines its own behavior and\nrelationships.\nGeneral OOP ideas like inheritance and composition apply to any application that can\nbe decomposed into a set of objects. For example, in typical GUI systems, interfaces\nare written as collections of widgets—buttons, labels, and so on—which are all drawn\nwhen their container is drawn (composition). Moreover, we may be able to write our",
    "relationships.\nGeneral OOP ideas like inheritance and composition apply to any application that can\nbe decomposed into a set of objects. For example, in typical GUI systems, interfaces\nare written as collections of widgets—buttons, labels, and so on—which are all drawn\nwhen their container is drawn (composition). Moreover, we may be able to write our\nown custom widgets—buttons with unique fonts, labels with new color schemes, and\nthe like—which are specialized versions of more general interface devices (inheritance).\nFrom a more concrete programming perspective, classes are Python program units, just\nlike functions and modules: they are another compartment for packaging logic and\ndata. In fact, classes also define new namespaces, much like modules. But, compared\nto other program units we’ve already seen, classes have three critical distinctions that\nmake them more useful when it comes to building new objects:\nMultiple instances",
    "like functions and modules: they are another compartment for packaging logic and\ndata. In fact, classes also define new namespaces, much like modules. But, compared\nto other program units we’ve already seen, classes have three critical distinctions that\nmake them more useful when it comes to building new objects:\nMultiple instances\nClasses are essentially factories for generating one or more objects. Every time we\ncall a class, we generate a new object with a distinct namespace. Each object generated from a class has access to the class’s attributes and gets a namespace of its\nown for data that varies per object.\nCustomization via inheritance\nClasses also support the OOP notion of inheritance; we can extend a class by redefining its attributes outside the class itself. More generally, classes can build up\nnamespace hierarchies, which define names to be used by objects created from\nclasses in the hierarchy.\n612 | Chapter 25: OOP: The Big Picture",
    "Operator overloading\nBy providing special protocol methods, classes can define objects that respond to\nthe sorts of operations we saw at work on built-in types. For instance, objects made\nwith classes can be sliced, concatenated, indexed, and so on. Python provides\nhooks that classes can use to intercept and implement any built-in type operation.\n\nOOP from 30,000 Feet\nBefore we see what this all means in terms of code, I’d like to say a few words about\nthe general ideas behind OOP. If you’ve never done anything object-oriented in your\nlife before now, some of the terminology in this chapter may seem a bit perplexing on\nthe first pass. Moreover, the motivation for these terms may be elusive until you’ve had\na chance to study the ways that programmers apply them in larger systems. OOP is as\nmuch an experience as a technology.",
    "Attribute Inheritance Search\nThe good news is that OOP is much simpler to understand and use in Python than in\nother languages, such as C++ or Java. As a dynamically typed scripting language, Python removes much of the syntactic clutter and complexity that clouds OOP in other\ntools. In fact, most of the OOP story in Python boils down to this expression:\nobject.attribute\n\nWe’ve been using this expression throughout the book to access module attributes, call\nmethods of objects, and so on. When we say this to an object that is derived from a\nclass statement, however, the expression kicks off a search in Python—it searches a\ntree of linked objects, looking for the first appearance of attribute that it can find.\nWhen classes are involved, the preceding Python expression effectively translates to\nthe following in natural language:\nFind the first occurrence of attribute by looking in object, then in all classes above it,\nfrom bottom to top and left to right.",
    "In other words, attribute fetches are simply tree searches. The term inheritance is applied because objects lower in a tree inherit attributes attached to objects higher in that\ntree. As the search proceeds from the bottom up, in a sense, the objects linked into a\ntree are the union of all the attributes defined in all their tree parents, all the way up\nthe tree.\nIn Python, this is all very literal: we really do build up trees of linked objects with code,\nand Python really does climb this tree at runtime searching for attributes every time we\nuse the object.attribute expression. To make this more concrete, Figure 25-1 sketches\nan example of one of these trees.\nIn this figure, there is a tree of five objects labeled with variables, all of which have\nattached attributes, ready to be searched. More specifically, this tree links together three\nOOP from 30,000 Feet | 613",
    "Figure 25-1. A class tree, with two instances at the bottom (I1 and I2), a class above them (C1), and\ntwo superclasses at the top (C2 and C3). All of these objects are namespaces (packages of variables),\nand the inheritance search is simply a search of the tree from bottom to top looking for the lowest\noccurrence of an attribute name. Code implies the shape of such trees.",
    "class objects (the ovals C1, C2, and C3) and two instance objects (the rectangles I1 and\nI2) into an inheritance search tree. Notice that in the Python object model, classes and\nthe instances you generate from them are two distinct object types:\nClasses\nServe as instance factories. Their attributes provide behavior—data and\nfunctions—that is inherited by all the instances generated from them (e.g., a function to compute an employee’s salary from pay and hours).\nInstances\nRepresent the concrete items in a program’s domain. Their attributes record data\nthat varies per specific object (e.g., an employee’s Social Security number).\nIn terms of search trees, an instance inherits attributes from its class, and a class inherits\nattributes from all classes above it in the tree.\nIn Figure 25-1, we can further categorize the ovals by their relative positions in the tree.\nWe usually call classes higher in the tree (like C2 and C3) superclasses; classes lower in",
    "In terms of search trees, an instance inherits attributes from its class, and a class inherits\nattributes from all classes above it in the tree.\nIn Figure 25-1, we can further categorize the ovals by their relative positions in the tree.\nWe usually call classes higher in the tree (like C2 and C3) superclasses; classes lower in\nthe tree (like C1) are known as subclasses.* These terms refer to relative tree positions\nand roles. Superclasses provide behavior shared by all their subclasses, but because the\nsearch proceeds from the bottom up, subclasses may override behavior defined in their\nsuperclasses by redefining superclass names lower in the tree.\nAs these last few words are really the crux of the matter of software customization in\nOOP, let’s expand on this concept. Suppose we build up the tree in Figure 25-1, and\nthen say this:\nI2.w",
    "* In other literature, you may also occasionally see the terms base classes and derived classes used to describe\nsuperclasses and subclasses, respectively.\n\n614 | Chapter 25: OOP: The Big Picture\n\n\fRight away, this code invokes inheritance. Because this is an object.attribute expression, it triggers a search of the tree in Figure 25-1—Python will search for the attribute\nw by looking in I2 and above. Specifically, it will search the linked objects in this order:\nI2, C1, C2, C3",
    "and stop at the first attached w it finds (or raise an error if w isn’t found at all). In this\ncase, w won’t be found until C3 is searched because it appears only in that object. In\nother words, I2.w resolves to C3.w by virtue of the automatic search. In OOP terminology, I2 “inherits” the attribute w from C3.\nUltimately, the two instances inherit four attributes from their classes: w, x, y, and z.\nOther attribute references will wind up following different paths in the tree. For\nexample:\n• I1.x and I2.x both find x in C1 and stop because C1 is lower than C2.\n• I1.y and I2.y both find y in C1 because that’s the only place y appears.\n• I1.z and I2.z both find z in C2 because C2 is further to the left than C3.\n• I2.name finds name in I2 without climbing the tree at all.\nTrace these searches through the tree in Figure 25-1 to get a feel for how inheritance\nsearches work in Python.\nThe first item in the preceding list is perhaps the most important to notice—because",
    "• I1.z and I2.z both find z in C2 because C2 is further to the left than C3.\n• I2.name finds name in I2 without climbing the tree at all.\nTrace these searches through the tree in Figure 25-1 to get a feel for how inheritance\nsearches work in Python.\nThe first item in the preceding list is perhaps the most important to notice—because\nC1 redefines the attribute x lower in the tree, it effectively replaces the version above it\nin C2. As you’ll see in a moment, such redefinitions are at the heart of software customization in OOP—by redefining and replacing the attribute, C1 effectively customizes\nwhat it inherits from its superclasses.",
    "Classes and Instances\nAlthough they are technically two separate object types in the Python model, the classes\nand instances we put in these trees are almost identical—each type’s main purpose is\nto serve as another kind of namespace—a package of variables, and a place where we\ncan attach attributes. If classes and instances therefore sound like modules, they should;\nhowever, the objects in class trees also have automatically searched links to other\nnamespace objects, and classes correspond to statements, not entire files.\nThe primary difference between classes and instances is that classes are a kind of factory for generating instances. For example, in a realistic application, we might have an\nEmployee class that defines what it means to be an employee; from that class, we generate\nactual Employee instances. This is another difference between classes and modules: we\nonly ever have one instance of a given module in memory (that’s why we have to reload",
    "Employee class that defines what it means to be an employee; from that class, we generate\nactual Employee instances. This is another difference between classes and modules: we\nonly ever have one instance of a given module in memory (that’s why we have to reload\na module to get its new code), but with classes, we can make as many instances as we\nneed.",
    "OOP from 30,000 Feet | 615\n\n\fOperationally, classes will usually have functions attached to them (e.g.,\ncomputeSalary), and the instances will have more basic data items used by the class’\nfunctions (e.g., hoursWorked). In fact, the object-oriented model is not that different\nfrom the classic data-processing model of programs plus records; in OOP, instances are\nlike records with “data,” and classes are the “programs” for processing those records.\nIn OOP, though, we also have the notion of an inheritance hierarchy, which supports\nsoftware customization better than earlier models.",
    "Class Method Calls\nIn the prior section, we saw how the attribute reference I2.w in our example class tree\nwas translated to C3.w by the inheritance search procedure in Python. Perhaps just as\nimportant to understand as the inheritance of attributes, though, is what happens when\nwe try to call methods (i.e., functions attached to classes as attributes).\nIf this I2.w reference is a function call, what it really means is “call the C3.w function to\nprocess I2.” That is, Python will automatically map the call I2.w() into the call\nC3.w(I2), passing in the instance as the first argument to the inherited function.\nIn fact, whenever we call a function attached to a class in this fashion, an instance of\nthe class is always implied. This implied subject or context is part of the reason we refer\nto this as an object-oriented model—there is always a subject object when an operation\nis run. In a more realistic example, we might invoke a method called giveRaise attached",
    "In fact, whenever we call a function attached to a class in this fashion, an instance of\nthe class is always implied. This implied subject or context is part of the reason we refer\nto this as an object-oriented model—there is always a subject object when an operation\nis run. In a more realistic example, we might invoke a method called giveRaise attached\nas an attribute to an Employee class; such a call has no meaning unless qualified with\nthe employee to whom the raise should be given.\nAs we’ll see later, Python passes in the implied instance to a special first argument\nin the method, called self by convention. As we’ll also learn, methods can be\ncalled through either an instance (e.g., bob.giveRaise()) or a class (e.g.,\nEmployee.giveRaise(bob)), and both forms serve purposes in our scripts. To see how\nmethods receive their subjects, though, we need to move on to some code.",
    "Coding Class Trees\nAlthough we are speaking in the abstract here, there is tangible code behind all these\nideas. We construct trees, and their objects with class statements and class calls, which\nwe’ll meet in more detail later. In short:\n• Each class statement generates a new class object.\n• Each time a class is called, it generates a new instance object.\n• Instances are automatically linked to the classes from which they are created.\n• Classes are linked to their superclasses by listing them in parentheses in a class\nheader line; the left-to-right order there gives the order in the tree.\n\n616 | Chapter 25: OOP: The Big Picture\n\n\fTo build the tree in Figure 25-1, for example, we would run Python code of this form\n(I’ve omitted the guts of the class statements here):\nclass C2: ...\nclass C3: ...\nclass C1(C2, C3): ...\n\n# Make class objects (ovals)\n\nI1 = C1()\nI2 = C1()\n\n# Make instance objects (rectangles)\n# Linked to their classes\n\n# Linked to superclasses",
    "Here, we build the three class objects by running three class statements, and make the\ntwo instance objects by calling the class C1 twice, as though it were a function. The\ninstances remember the class they were made from, and the class C1 remembers its listed\nsuperclasses.\nTechnically, this example is using something called multiple inheritance, which simply\nmeans that a class has more than one superclass above it in the class tree. In Python, if\nthere is more than one superclass listed in parentheses in a class statement (like C1’s\nhere), their left-to-right order gives the order in which those superclasses will be\nsearched for attributes.\nBecause of the way inheritance searches proceed, the object to which you attach an\nattribute turns out to be crucial—it determines the name’s scope. Attributes attached\nto instances pertain only to those single instances, but attributes attached to classes are\nshared by all their subclasses and instances. Later, we’ll study the code that hangs",
    "searched for attributes.\nBecause of the way inheritance searches proceed, the object to which you attach an\nattribute turns out to be crucial—it determines the name’s scope. Attributes attached\nto instances pertain only to those single instances, but attributes attached to classes are\nshared by all their subclasses and instances. Later, we’ll study the code that hangs\nattributes on these objects in depth. As we’ll find:\n• Attributes are usually attached to classes by assignments made within class statements, and not nested inside function def statements.\n• Attributes are usually attached to instances by assignments to a special argument\npassed to functions inside classes, called self.\nFor example, classes provide behavior for their instances with functions created by\ncoding def statements inside class statements. Because such nested defs assign names\nwithin the class, they wind up attaching attributes to the class object that will be inherited by all instances and subclasses:",
    "passed to functions inside classes, called self.\nFor example, classes provide behavior for their instances with functions created by\ncoding def statements inside class statements. Because such nested defs assign names\nwithin the class, they wind up attaching attributes to the class object that will be inherited by all instances and subclasses:\nclass C1(C2, C3):\ndef setname(self, who):\nself.name = who",
    "# Make and link class C1\n# Assign name: C1.setname\n# Self is either I1 or I2\n\nI1 = C1()\nI2 = C1()\nI1.setname('bob')\nI2.setname('mel')\nprint(I1.name)\n\n# Make two instances\n# Sets I1.name to 'bob'\n# Sets I2.name to 'mel'\n# Prints 'bob'\n\nOOP from 30,000 Feet | 617",
    "There’s nothing syntactically unique about def in this context. Operationally, when a\ndef appears inside a class like this, it is usually known as a method, and it automatically\nreceives a special first argument—called self by convention—that provides a handle\nback to the instance to be processed.†\nBecause classes are factories for multiple instances, their methods usually go through\nthis automatically passed-in self argument whenever they need to fetch or set attributes\nof the particular instance being processed by a method call. In the preceding code,\nself is used to store a name in one of two instances.\nLike simple variables, attributes of classes and instances are not declared ahead of time,\nbut spring into existence the first time they are assigned values. When a method assigns\nto a self attribute, it creates or changes an attribute in an instance at the bottom of the\nclass tree (i.e., one of the rectangles) because self automatically refers to the instance\nbeing processed.",
    "Like simple variables, attributes of classes and instances are not declared ahead of time,\nbut spring into existence the first time they are assigned values. When a method assigns\nto a self attribute, it creates or changes an attribute in an instance at the bottom of the\nclass tree (i.e., one of the rectangles) because self automatically refers to the instance\nbeing processed.\nIn fact, because all the objects in class trees are just namespace objects, we can fetch or\nset any of their attributes by going through the appropriate names. Saying C1.setname\nis as valid as saying I1.setname, as long as the names C1 and I1 are in your code’s scopes.\nAs currently coded, our C1 class doesn’t attach a name attribute to an instance until the\nsetname method is called. In fact, referencing I1.name before calling I1.setname would\nproduce an undefined name error. If a class wants to guarantee that an attribute like",
    "is as valid as saying I1.setname, as long as the names C1 and I1 are in your code’s scopes.\nAs currently coded, our C1 class doesn’t attach a name attribute to an instance until the\nsetname method is called. In fact, referencing I1.name before calling I1.setname would\nproduce an undefined name error. If a class wants to guarantee that an attribute like\nname is always set in its instances, it more typically will fill out the attribute at construction time, like this:\nclass C1(C2, C3):\ndef __init__(self, who):\nself.name = who",
    "# Set name when constructed\n# Self is either I1 or I2\n\nI1 = C1('bob')\nI2 = C1('mel')\nprint(I1.name)\n\n# Sets I1.name to 'bob'\n# Sets I2.name to 'mel'\n# Prints 'bob'",
    "If it’s coded and inherited, Python automatically calls a method named __init__ each\ntime an instance is generated from a class. The new instance is passed in to the self\nargument of __init__ as usual, and any values listed in parentheses in the class call go\nto arguments two and beyond. The effect here is to initialize instances when they are\nmade, without requiring extra method calls.\nThe __init__ method is known as the constructor because of when it is run. It’s the\nmost commonly used representative of a larger class of methods called operator overloading methods, which we’ll discuss in more detail in the chapters that follow. Such\nmethods are inherited in class trees as usual and have double underscores at the start\nand end of their names to make them distinct. Python runs them automatically when\ninstances that support them appear in the corresponding operations, and they are",
    "methods are inherited in class trees as usual and have double underscores at the start\nand end of their names to make them distinct. Python runs them automatically when\ninstances that support them appear in the corresponding operations, and they are\n† If you’ve ever used C++ or Java, you’ll recognize that Python’s self is the same as the this pointer, but\nself is always explicit in Python to make attribute accesses more obvious.",
    "618 | Chapter 25: OOP: The Big Picture\n\n\fmostly an alternative to using simple method calls. They’re also optional: if omitted,\nthe operations are not supported.\nFor example, to implement set intersection, a class might either provide a method\nnamed intersect, or overload the & expression operator to dispatch to the required\nlogic by coding a method named __and__. Because the operator scheme makes instances\nlook and feel more like built-in types, it allows some classes to provide a consistent and\nnatural interface, and be compatible with code that expects a built-in type.",
    "OOP Is About Code Reuse\nAnd that, along with a few syntax details, is most of the OOP story in Python. Of course,\nthere’s a bit more to it than just inheritance. For example, operator overloading is much\nmore general than I’ve described so far—classes may also provide their own implementations of operations such as indexing, fetching attributes, printing, and more. By\nand large, though, OOP is about looking up attributes in trees.\nSo why would we be interested in building and searching trees of objects? Although it\ntakes some experience to see how, when used well, classes support code reuse in ways\nthat other Python program components cannot. With classes, we code by customizing\nexisting software, instead of either changing existing code in-place or starting from\nscratch for each new project.\nAt a fundamental level, classes are really just packages of functions and other names,\nmuch like modules. However, the automatic attribute inheritance search that we get",
    "that other Python program components cannot. With classes, we code by customizing\nexisting software, instead of either changing existing code in-place or starting from\nscratch for each new project.\nAt a fundamental level, classes are really just packages of functions and other names,\nmuch like modules. However, the automatic attribute inheritance search that we get\nwith classes supports customization of software above and beyond what we can do\nwith modules and functions. Moreover, classes provide a natural structure for code\nthat localizes logic and names, and so aids in debugging.\nFor instance, because methods are simply functions with a special first argument, we\ncan mimic some of their behavior by manually passing objects to be processed to simple\nfunctions. The participation of methods in class inheritance, though, allows us to naturally customize existing software by coding subclasses with new method definitions,",
    "For instance, because methods are simply functions with a special first argument, we\ncan mimic some of their behavior by manually passing objects to be processed to simple\nfunctions. The participation of methods in class inheritance, though, allows us to naturally customize existing software by coding subclasses with new method definitions,\nrather than changing existing code in-place. There is really no such concept with modules and functions.\nAs an example, suppose you’re assigned the task of implementing an employee database\napplication. As a Python OOP programmer, you might begin by coding a general superclass that defines default behavior common to all the kinds of employees in your\norganization:\nclass Employee:\ndef computeSalary(self): ...\ndef giveRaise(self): ...\ndef promote(self): ...\ndef retire(self): ...",
    "# General superclass\n# Common or default behavior\n\nOOP from 30,000 Feet | 619\n\n\fOnce you’ve coded this general behavior, you can specialize it for each specific kind of\nemployee to reflect how the various types differ from the norm. That is, you can code\nsubclasses that customize just the bits of behavior that differ per employee type; the\nrest of the employee types’ behavior will be inherited from the more general class. For\nexample, if engineers have a unique salary computation rule (i.e., not hours times rate),\nyou can replace just that one method in a subclass:\nclass Engineer(Employee):\ndef computeSalary(self): ...\n\n# Specialized subclass\n# Something custom here\n\nBecause the computeSalary version here appears lower in the class tree, it will replace\n(override) the general version in Employee. You then create instances of the kinds of\nemployee classes that the real employees belong to, to get the correct behavior:\nbob = Employee()\nmel = Engineer()",
    "# Specialized subclass\n# Something custom here\n\nBecause the computeSalary version here appears lower in the class tree, it will replace\n(override) the general version in Employee. You then create instances of the kinds of\nemployee classes that the real employees belong to, to get the correct behavior:\nbob = Employee()\nmel = Engineer()\n\n# Default behavior\n# Custom salary calculator",
    "# Default behavior\n# Custom salary calculator\n\nNotice that you can make instances of any class in a tree, not just the ones at the\nbottom—the class you make an instance from determines the level at which the attribute search will begin. Ultimately, these two instance objects might wind up embedded in a larger container object (e.g., a list, or an instance of another class) that\nrepresents a department or company using the composition idea mentioned at the start\nof this chapter.\nWhen you later ask for these employees’ salaries, they will be computed according to\nthe classes from which the objects were made, due to the principles of the inheritance\nsearch:‡\ncompany = [bob, mel]\nfor emp in company:\nprint(emp.computeSalary())\n\n# A composite object\n# Run this object's version",
    "# A composite object\n# Run this object's version\n\nThis is yet another instance of the idea of polymorphism introduced in Chapter 4 and\nrevisited in Chapter 16. Recall that polymorphism means that the meaning of an operation depends on the object being operated on. Here, the method computeSalary is\nlocated by inheritance search in each object before it is called. In other applications,\npolymorphism might also be used to hide (i.e., encapsulate) interface differences. For\nexample, a program that processes data streams might be coded to expect objects with\ninput and output methods, without caring what those methods actually do:\ndef processor(reader, converter, writer):\nwhile 1:\ndata = reader.read()\nif not data: break",
    "‡ Note that the company list in this example could be stored in a file with Python object pickling, introduced in\nChapter 9 when we met files, to yield a persistent employee database. Python also comes with a module\nnamed shelve, which would allow you to store the pickled representation of the class instances in an accessby-key filesystem; the third-party open source ZODB system does the same but has better support for\nproduction-quality object-oriented databases.\n\n620 | Chapter 25: OOP: The Big Picture\n\n\fdata = converter(data)\nwriter.write(data)",
    "620 | Chapter 25: OOP: The Big Picture\n\n\fdata = converter(data)\nwriter.write(data)\n\nBy passing in instances of subclasses that specialize the required read and write method\ninterfaces for various data sources, we can reuse the processor function for any data\nsource we need to use, both now and in the future:\nclass Reader:\ndef read(self): ...\n# Default behavior and tools\ndef other(self): ...\nclass FileReader(Reader):\ndef read(self): ...\n# Read from a local file\nclass SocketReader(Reader):\ndef read(self): ...\n# Read from a network socket\n...\nprocessor(FileReader(...),\nConverter, FileWriter(...))\nprocessor(SocketReader(...), Converter, TapeWriter(...))\nprocessor(FtpReader(...),\nConverter, XmlWriter(...))",
    "Moreover, because the internal implementations of those read and write methods have\nbeen factored into single locations, they can be changed without impacting code such\nas this that uses them. In fact, the processor function might itself be a class to allow\nthe conversion logic of converter to be filled in by inheritance, and to allow readers\nand writers to be embedded by composition (we’ll see how this works later in this part\nof the book).\nOnce you get used to programming this way (by software customization), you’ll find\nthat when it’s time to write a new program, much of your work may already be done—\nyour task largely becomes one of mixing together existing superclasses that already\nimplement the behavior required by your program. For example, someone else might\nhave written the Employee, Reader, and Writer classes in this example for use in a completely different program. If so, you get all of that person’s code “for free.”",
    "your task largely becomes one of mixing together existing superclasses that already\nimplement the behavior required by your program. For example, someone else might\nhave written the Employee, Reader, and Writer classes in this example for use in a completely different program. If so, you get all of that person’s code “for free.”\nIn fact, in many application domains, you can fetch or purchase collections of superclasses, known as frameworks, that implement common programming tasks as classes,\nready to be mixed into your applications. These frameworks might provide database\ninterfaces, testing protocols, GUI toolkits, and so on. With frameworks, you often\nsimply code a subclass that fills in an expected method or two; the framework classes\nhigher in the tree do most of the work for you. Programming in such an OOP world is\njust a matter of combining and specializing already debugged code by writing subclasses\nof your own.",
    "interfaces, testing protocols, GUI toolkits, and so on. With frameworks, you often\nsimply code a subclass that fills in an expected method or two; the framework classes\nhigher in the tree do most of the work for you. Programming in such an OOP world is\njust a matter of combining and specializing already debugged code by writing subclasses\nof your own.\nOf course, it takes a while to learn how to leverage classes to achieve such OOP utopia.\nIn practice, object-oriented work also entails substantial design work to fully realize\nthe code reuse benefits of classes—to this end, programmers have begun cataloging\ncommon OOP structures, known as design patterns, to help with design issues. The\nactual code you write to do OOP in Python, though, is so simple that it will not in itself\npose an additional obstacle to your OOP quest. To see why, you’ll have to move on to\nChapter 26.",
    "OOP from 30,000 Feet | 621\n\n\fChapter Summary\nWe took an abstract look at classes and OOP in this chapter, taking in the big picture\nbefore we dive into syntax details. As we’ve seen, OOP is mostly about looking up\nattributes in trees of linked objects; we call this lookup an inheritance search. Objects\nat the bottom of the tree inherit attributes from objects higher up in the tree—a feature\nthat enables us to program by customizing code, rather than changing it, or starting\nfrom scratch. When used well, this model of programming can cut development time\nradically.\nThe next chapter will begin to fill in the coding details behind the picture painted here.\nAs we get deeper into Python classes, though, keep in mind that the OOP model in\nPython is very simple; as I’ve already stated, it’s really just about looking up attributes\nin object trees. Before we move on, here’s a quick quiz to review what we’ve covered\nhere.",
    "Test Your Knowledge: Quiz\n1. What is the main point of OOP in Python?\n2. Where does an inheritance search look for an attribute?\n3. What is the difference between a class object and an instance object?\n4. Why is the first argument in a class method function special?\n5. What is the __init__ method used for?\n6. How do you create a class instance?\n7. How do you create a class?\n8. How do you specify a class’s superclasses?",
    "Test Your Knowledge: Answers\n1. OOP is about code reuse—you factor code to minimize redundancy and program\nby customizing what already exists instead of changing code in-place or starting\nfrom scratch.\n2. An inheritance search looks for an attribute first in the instance object, then in the\nclass the instance was created from, then in all higher superclasses, progressing\nfrom the bottom to the top of the object tree, and from left to right (by default).\nThe search stops at the first place the attribute is found. Because the lowest version\nof a name found along the way wins, class hierarchies naturally support customization by extension.\n\n622 | Chapter 25: OOP: The Big Picture",
    "3. Both class and instance objects are namespaces (packages of variables that appear\nas attributes). The main difference between them is that classes are a kind of factory\nfor creating multiple instances. Classes also support operator overloading methods, which instances inherit, and treat any functions nested within them as special\nmethods for processing instances.\n4. The first argument in a class method function is special because it always receives\nthe instance object that is the implied subject of the method call. It’s usually called\nself by convention. Because method functions always have this implied subject\nobject context by default, we say they are “object-oriented”—i.e., designed to\nprocess or change objects.\n5. If the __init__ method is coded or inherited in a class, Python calls it automatically\neach time an instance of that class is created. It’s known as the constructor method;\nit is passed the new instance implicitly, as well as any arguments passed explicitly",
    "object context by default, we say they are “object-oriented”—i.e., designed to\nprocess or change objects.\n5. If the __init__ method is coded or inherited in a class, Python calls it automatically\neach time an instance of that class is created. It’s known as the constructor method;\nit is passed the new instance implicitly, as well as any arguments passed explicitly\nto the class name. It’s also the most commonly used operator overloading method.\nIf no __init__ method is present, instances simply begin life as empty namespaces.\n6. You create a class instance by calling the class name as though it were a function;\nany arguments passed into the class name show up as arguments two and beyond\nin the __init__ constructor method. The new instance remembers the class it was\ncreated from for inheritance purposes.\n7. You create a class by running a class statement; like function definitions, these\nstatements normally run when the enclosing module file is imported (more on this",
    "any arguments passed into the class name show up as arguments two and beyond\nin the __init__ constructor method. The new instance remembers the class it was\ncreated from for inheritance purposes.\n7. You create a class by running a class statement; like function definitions, these\nstatements normally run when the enclosing module file is imported (more on this\nin the next chapter).\n8. You specify a class’s superclasses by listing them in parentheses in the class statement, after the new class’s name. The left-to-right order in which the classes are\nlisted in the parentheses gives the left-to-right inheritance search order in the class\ntree.",
    "Test Your Knowledge: Answers | 623\n\n\f\fCHAPTER 26\n\nClass Coding Basics",
    "Now that we’ve talked about OOP in the abstract, it’s time to see how this translates\nto actual code. This chapter begins to fill in the syntax details behind the class model\nin Python.\nIf you’ve never been exposed to OOP in the past, classes can seem somewhat complicated if taken in a single dose. To make class coding easier to absorb, we’ll begin our\ndetailed exploration of OOP by taking a first look at some basic classes in action in this\nchapter. We’ll expand on the details introduced here in later chapters of this part of\nthe book, but in their basic form, Python classes are easy to understand.\nIn fact, classes have just three primary distinctions. At a base level, they are mostly just\nnamespaces, much like the modules we studied in Part V. Unlike modules, though,\nclasses also have support for generating multiple objects, for namespace inheritance,\nand for operator overloading. Let’s begin our class statement tour by exploring each\nof these three distinctions in turn.",
    "Classes Generate Multiple Instance Objects\nTo understand how the multiple objects idea works, you have to first understand that\nthere are two kinds of objects in Python’s OOP model: class objects and instance objects. Class objects provide default behavior and serve as factories for instance objects.\nInstance objects are the real objects your programs process—each is a namespace in\nits own right, but inherits (i.e., has automatic access to) names in the class from which\nit was created. Class objects come from statements, and instances come from calls; each\ntime you call a class, you get a new instance of that class.\n\n625",
    "625\n\n\fThis object-generation concept is very different from any of the other program constructs we’ve seen so far in this book. In effect, classes are essentially factories for generating multiple instances. By contrast, only one copy of each module is ever imported\ninto a single program (in fact, one reason that we have to call imp.reload is to update\nthe single module object so that changes are reflected once they’ve been made).\nThe following is a quick summary of the bare essentials of Python OOP. As you’ll see,\nPython classes are in some ways similar to both defs and modules, but they may be\nquite different from what you’re used to in other languages.",
    "Class Objects Provide Default Behavior\nWhen we run a class statement, we get a class object. Here’s a rundown of the main\nproperties of Python classes:\n• The class statement creates a class object and assigns it a name. Just like the\nfunction def statement, the Python class statement is an executable statement.\nWhen reached and run, it generates a new class object and assigns it to the name\nin the class header. Also, like defs, class statements typically run when the files\nthey are coded in are first imported.\n• Assignments inside class statements make class attributes. Just like in module\nfiles, top-level assignments within a class statement (not nested in a def) generate\nattributes in a class object. Technically, the class statement scope morphs into the\nattribute namespace of the class object, just like a module’s global scope. After\nrunning a class statement, class attributes are accessed by name qualification:\nobject.name.",
    "files, top-level assignments within a class statement (not nested in a def) generate\nattributes in a class object. Technically, the class statement scope morphs into the\nattribute namespace of the class object, just like a module’s global scope. After\nrunning a class statement, class attributes are accessed by name qualification:\nobject.name.\n• Class attributes provide object state and behavior. Attributes of a class object\nrecord state information and behavior to be shared by all instances created from\nthe class; function def statements nested inside a class generate methods, which\nprocess instances.",
    "Instance Objects Are Concrete Items\nWhen we call a class object, we get an instance object. Here’s an overview of the key\npoints behind class instances:\n• Calling a class object like a function makes a new instance object. Each time\na class is called, it creates and returns a new instance object. Instances represent\nconcrete items in your program’s domain.\n• Each instance object inherits class attributes and gets its own namespace.\nInstance objects created from classes are new namespaces; they start out empty\nbut inherit attributes that live in the class objects from which they were generated.\n\n626 | Chapter 26: Class Coding Basics\n\n\f• Assignments to attributes of self in methods make per-instance attributes.\nInside class method functions, the first argument (called self by convention) references the instance object being processed; assignments to attributes of self create\nor change data in the instance, not the class.",
    "626 | Chapter 26: Class Coding Basics\n\n\f• Assignments to attributes of self in methods make per-instance attributes.\nInside class method functions, the first argument (called self by convention) references the instance object being processed; assignments to attributes of self create\nor change data in the instance, not the class.\n\nA First Example\nLet’s turn to a real example to show how these ideas work in practice. To begin, let’s\ndefine a class named FirstClass by running a Python class statement interactively:\n>>> class FirstClass:\n...\ndef setdata(self, value):\n...\nself.data = value\n...\ndef display(self):\n...\nprint(self.data)\n...\n\n# Define a class object\n# Define class methods\n# self is the instance\n# self.data: per instance",
    "We’re working interactively here, but typically, such a statement would be run when\nthe module file it is coded in is imported. Like functions created with defs, this class\nwon’t even exist until Python reaches and runs this statement.\nLike all compound statements, the class starts with a header line that lists the class\nname, followed by a body of one or more nested and (usually) indented statements.\nHere, the nested statements are defs; they define functions that implement the behavior\nthe class means to export.\nAs we learned in Part IV, def is really an assignment. Here, it assigns function objects\nto the names setdata and display in the class statement’s scope, and so generates\nattributes attached to the class: FirstClass.setdata and FirstClass.display. In fact,\nany name assigned at the top level of the class’s nested block becomes an attribute of\nthe class.\nFunctions inside a class are usually called methods. They’re coded with normal defs,",
    "to the names setdata and display in the class statement’s scope, and so generates\nattributes attached to the class: FirstClass.setdata and FirstClass.display. In fact,\nany name assigned at the top level of the class’s nested block becomes an attribute of\nthe class.\nFunctions inside a class are usually called methods. They’re coded with normal defs,\nand they support everything we’ve learned about functions already (they can have defaults, return values, and so on). But in a method function, the first argument automatically receives an implied instance object when called—the subject of the call. We\nneed to create a couple of instances to see how this works:\n>>> x = FirstClass()\n>>> y = FirstClass()",
    "# Make two instances\n# Each is a new namespace\n\nBy calling the class this way (notice the parentheses), we generate instance objects,\nwhich are just namespaces that have access to their classes’ attributes. Properly speaking, at this point, we have three objects: two instances and a class. Really, we have three\nlinked namespaces, as sketched in Figure 26-1. In OOP terms, we say that x “is a”\nFirstClass, as is y.\n\nClasses Generate Multiple Instance Objects | 627\n\n\fFigure 26-1. Classes and instances are linked namespace objects in a class tree that is searched by\ninheritance. Here, the “data” attribute is found in instances, but “setdata” and “display” are in the\nclass above them.",
    "Classes Generate Multiple Instance Objects | 627\n\n\fFigure 26-1. Classes and instances are linked namespace objects in a class tree that is searched by\ninheritance. Here, the “data” attribute is found in instances, but “setdata” and “display” are in the\nclass above them.\n\nThe two instances start out empty but have links back to the class from which they\nwere generated. If we qualify an instance with the name of an attribute that lives in the\nclass object, Python fetches the name from the class by inheritance search (unless it\nalso lives in the instance):\n>>> x.setdata(\"King Arthur\")\n>>> y.setdata(3.14159)\n\n# Call methods: self is x\n# Runs: FirstClass.setdata(y, 3.14159)",
    "Neither x nor y has a setdata attribute of its own, so to find it, Python follows the link\nfrom instance to class. And that’s about all there is to inheritance in Python: it happens\nat attribute qualification time, and it just involves looking up names in linked objects\n(e.g., by following the is-a links in Figure 26-1).\nIn the setdata function inside FirstClass, the value passed in is assigned to\nself.data. Within a method, self—the name given to the leftmost argument by convention—automatically refers to the instance being processed (x or y), so the assignments store values in the instances’ namespaces, not the class’s (that’s how the data\nnames in Figure 26-1 are created).\nBecause classes can generate multiple instances, methods must go through the self\nargument to get to the instance to be processed. When we call the class’s display\nmethod to print self.data, we see that it’s different in each instance; on the other hand,",
    "names in Figure 26-1 are created).\nBecause classes can generate multiple instances, methods must go through the self\nargument to get to the instance to be processed. When we call the class’s display\nmethod to print self.data, we see that it’s different in each instance; on the other hand,\nthe name display itself is the same in x and y, as it comes (is inherited) from the class:\n>>> x.display()\nKing Arthur\n>>> y.display()\n3.14159",
    "# self.data differs in each instance\n\nNotice that we stored different object types in the data member in each instance (a\nstring, and a floating point). As with everything else in Python, there are no declarations\nfor instance attributes (sometimes called members); they spring into existence the first\ntime they are assigned values, just like simple variables. In fact, if we were to call\ndisplay on one of our instances before calling setdata, we would trigger an undefined\nname error—the attribute named data doesn’t even exist in memory until it is assigned\nwithin the setdata method.\n628 | Chapter 26: Class Coding Basics\n\n\fAs another way to appreciate how dynamic this model is, consider that we can change\ninstance attributes in the class itself, by assigning to self in methods, or outside the\nclass, by assigning to an explicit instance object:\n>>> x.data = \"New value\"\n>>> x.display()\nNew value\n\n# Can get/set attributes\n# Outside the class too",
    "As another way to appreciate how dynamic this model is, consider that we can change\ninstance attributes in the class itself, by assigning to self in methods, or outside the\nclass, by assigning to an explicit instance object:\n>>> x.data = \"New value\"\n>>> x.display()\nNew value\n\n# Can get/set attributes\n# Outside the class too\n\nAlthough less common, we could even generate a brand new attribute in the instance’s\nnamespace by assigning to its name outside the class’s method functions:\n>>> x.anothername = \"spam\"\n\n# Can set new attributes here too!\n\nThis would attach a new attribute called anothername, which may or may not be used\nby any of the class’s methods, to the instance object x. Classes usually create all of the\ninstance’s attributes by assignment to the self argument, but they don’t have to; programs can fetch, change, or create attributes on any objects to which they have\nreferences.",
    "Classes Are Customized by Inheritance\nBesides serving as factories for generating multiple instance objects, classes also allow\nus to make changes by introducing new components (called subclasses), instead of\nchanging existing components in-place. Instance objects generated from a class inherit\nthe class’s attributes. Python also allows classes to inherit from other classes, opening\nthe door to coding hierarchies of classes that specialize behavior—by redefining attributes in subclasses that appear lower in the hierarchy, we override the more general\ndefinitions of those attributes higher in the tree. In effect, the further down the hierarchy\nwe go, the more specific the software becomes. Here, too, there is no parallel with\nmodules: their attributes live in a single, flat namespace that is not as amenable to\ncustomization.\nIn Python, instances inherit from classes, and classes inherit from superclasses. Here\nare the key ideas behind the machinery of attribute inheritance:",
    "we go, the more specific the software becomes. Here, too, there is no parallel with\nmodules: their attributes live in a single, flat namespace that is not as amenable to\ncustomization.\nIn Python, instances inherit from classes, and classes inherit from superclasses. Here\nare the key ideas behind the machinery of attribute inheritance:\n• Superclasses are listed in parentheses in a class header. To inherit attributes\nfrom another class, just list the class in parentheses in a class statement’s header.\nThe class that inherits is usually called a subclass, and the class that is inherited\nfrom is its superclass.\n• Classes inherit attributes from their superclasses. Just as instances inherit the\nattribute names defined in their classes, classes inherit all the attribute names defined in their superclasses; Python finds them automatically when they’re accessed,\nif they don’t exist in the subclasses.\n• Instances inherit attributes from all accessible classes. Each instance gets",
    "from is its superclass.\n• Classes inherit attributes from their superclasses. Just as instances inherit the\nattribute names defined in their classes, classes inherit all the attribute names defined in their superclasses; Python finds them automatically when they’re accessed,\nif they don’t exist in the subclasses.\n• Instances inherit attributes from all accessible classes. Each instance gets\nnames from the class it’s generated from, as well as all of that class’s superclasses.\nWhen looking for a name, Python checks the instance, then its class, then all\nsuperclasses.\nClasses Are Customized by Inheritance | 629",
    "• Each object.attribute reference invokes a new, independent search. Python\nperforms an independent search of the class tree for each attribute fetch expression.\nThis includes references to instances and classes made outside class statements\n(e.g., X.attr), as well as references to attributes of the self instance argument in\nclass method functions. Each self.attr expression in a method invokes a new\nsearch for attr in self and above.\n• Logic changes are made by subclassing, not by changing superclasses. By\nredefining superclass names in subclasses lower in the hierarchy (class tree), subclasses replace and thus customize inherited behavior.\nThe net effect, and the main purpose of all this searching, is that classes support factoring and customization of code better than any other language tool we’ve seen so far.\nOn the one hand, they allow us to minimize code redundancy (and so reduce maintenance costs) by factoring operations into a single, shared implementation; on the other,",
    "The net effect, and the main purpose of all this searching, is that classes support factoring and customization of code better than any other language tool we’ve seen so far.\nOn the one hand, they allow us to minimize code redundancy (and so reduce maintenance costs) by factoring operations into a single, shared implementation; on the other,\nthey allow us to program by customizing what already exists, rather than changing it\nin-place or starting from scratch.",
    "A Second Example\nTo illustrate the role of inheritance, this next example builds on the previous one. First,\nwe’ll define a new class, SecondClass, that inherits all of FirstClass’s names and provides one of its own:\n>>> class SecondClass(FirstClass):\n# Inherits setdata\n...\ndef display(self):\n# Changes display\n...\nprint('Current value = \"%s\"' % self.data)\n...\n\nSecondClass defines the display method to print with a different format. By defining\nan attribute with the same name as an attribute in FirstClass, SecondClass effectively\nreplaces the display attribute in its superclass.",
    "SecondClass defines the display method to print with a different format. By defining\nan attribute with the same name as an attribute in FirstClass, SecondClass effectively\nreplaces the display attribute in its superclass.\n\nRecall that inheritance searches proceed upward from instances, to subclasses, to superclasses, stopping at the first appearance of the attribute name that it finds. In this\ncase, since the display name in SecondClass will be found before the one in First\nClass, we say that SecondClass overrides FirstClass’s display. Sometimes we call this\nact of replacing attributes by redefining them lower in the tree overloading.\nThe net effect here is that SecondClass specializes FirstClass by changing the behavior\nof the display method. On the other hand, SecondClass (and any instances created from\nit) still inherits the setdata method in FirstClass verbatim. Let’s make an instance to\ndemonstrate:\n>>> z = SecondClass()\n>>> z.setdata(42)\n>>> z.display()\nCurrent value = \"42\"",
    "630 | Chapter 26: Class Coding Basics\n\n# Finds setdata in FirstClass\n# Finds overridden method in SecondClass\n\n\fAs before, we make a SecondClass instance object by calling it. The setdata call still\nruns the version in FirstClass, but this time the display attribute comes from Second\nClass and prints a custom message. Figure 26-2 sketches the namespaces involved.\n\nFigure 26-2. Specialization by overriding inherited names by redefining them in extensions lower in\nthe class tree. Here, SecondClass redefines and so customizes the “display” method for its instances.\n\nNow, here’s a very important thing to notice about OOP: the specialization introduced\nin SecondClass is completely external to FirstClass. That is, it doesn’t affect existing\nor future FirstClass objects, like the x from the prior example:\n>>> x.display()\nNew value\n\n# x is still a FirstClass instance (old message)",
    "Now, here’s a very important thing to notice about OOP: the specialization introduced\nin SecondClass is completely external to FirstClass. That is, it doesn’t affect existing\nor future FirstClass objects, like the x from the prior example:\n>>> x.display()\nNew value\n\n# x is still a FirstClass instance (old message)\n\nRather than changing FirstClass, we customized it. Naturally, this is an artificial example, but as a rule, because inheritance allows us to make changes like this in external\ncomponents (i.e., in subclasses), classes often support extension and reuse better than\nfunctions or modules can.",
    "# x is still a FirstClass instance (old message)\n\nRather than changing FirstClass, we customized it. Naturally, this is an artificial example, but as a rule, because inheritance allows us to make changes like this in external\ncomponents (i.e., in subclasses), classes often support extension and reuse better than\nfunctions or modules can.\n\nClasses Are Attributes in Modules\nBefore we move on, remember that there’s nothing magic about a class name. It’s just\na variable assigned to an object when the class statement runs, and the object can be\nreferenced with any normal expression. For instance, if our FirstClass was coded in a\nmodule file instead of being typed interactively, we could import it and use its name\nnormally in a class header line:\nfrom modulename import FirstClass\nclass SecondClass(FirstClass):\ndef display(self): ...\n\n# Copy name into my scope\n# Use class name directly\n\nOr, equivalently:\nimport modulename\nclass SecondClass(modulename.FirstClass):\ndef display(self): ...",
    "# Copy name into my scope\n# Use class name directly\n\nOr, equivalently:\nimport modulename\nclass SecondClass(modulename.FirstClass):\ndef display(self): ...\n\n# Access the whole module\n# Qualify to reference\n\nClasses Are Customized by Inheritance | 631\n\n\fLike everything else, class names always live within a module, so they must follow all\nthe rules we studied in Part V. For example, more than one class can be coded in a\nsingle module file—like other statements in a module, class statements are run during\nimports to define names, and these names become distinct module attributes. More\ngenerally, each module may arbitrarily mix any number of variables, functions, and\nclasses, and all names in a module behave the same way. The file food.py demonstrates:\n# food.py\nvar = 1\ndef func():\n...\nclass spam:\n...\nclass ham:\n...\nclass eggs:\n...\n\n# food.var\n# food.func\n# food.spam\n# food.ham\n# food.eggs",
    "# food.var\n# food.func\n# food.spam\n# food.ham\n# food.eggs\n\nThis holds true even if the module and class happen to have the same name. For example, given the following file, person.py:\nclass person:\n...\n\nwe need to go through the module to fetch the class as usual:\nimport person\nx = person.person()\n\n# Import module\n# Class within module\n\nAlthough this path may look redundant, it’s required: person.person refers to the\nperson class inside the person module. Saying just person gets the module, not the class,\nunless the from statement is used:\nfrom person import person\nx = person()\n\n# Get class from module\n# Use class name",
    "# Import module\n# Class within module\n\nAlthough this path may look redundant, it’s required: person.person refers to the\nperson class inside the person module. Saying just person gets the module, not the class,\nunless the from statement is used:\nfrom person import person\nx = person()\n\n# Get class from module\n# Use class name\n\nAs with any other variable, we can never see a class in a file without first importing and\nsomehow fetching it from its enclosing file. If this seems confusing, don’t use the same\nname for a module and a class within it. In fact, common convention in Python dictates\nthat class names should begin with an uppercase letter, to help make them more\ndistinct:\nimport person\nx = person.Person()\n\n# Lowercase for modules\n# Uppercase for classes",
    "# Lowercase for modules\n# Uppercase for classes\n\nAlso, keep in mind that although classes and modules are both namespaces for attaching attributes, they correspond to very different source code structures: a module reflects an entire file, but a class is a statement within a file. We’ll say more about such\ndistinctions later in this part of the book.\n\n632 | Chapter 26: Class Coding Basics",
    "Classes Can Intercept Python Operators\nLet’s move on to the third major difference between classes and modules: operator\noverloading. In simple terms, operator overloading lets objects coded with classes intercept and respond to operations that work on built-in types: addition, slicing, printing, qualification, and so on. It’s mostly just an automatic dispatch mechanism—\nexpressions and other built-in operations route control to implementations in classes.\nHere, too, there is nothing similar in modules: modules can implement function calls,\nbut not the behavior of expressions.\nAlthough we could implement all class behavior as method functions, operator overloading lets objects be more tightly integrated with Python’s object model. Moreover,\nbecause operator overloading makes our own objects act like built-ins, it tends to foster\nobject interfaces that are more consistent and easier to learn, and it allows class-based",
    "but not the behavior of expressions.\nAlthough we could implement all class behavior as method functions, operator overloading lets objects be more tightly integrated with Python’s object model. Moreover,\nbecause operator overloading makes our own objects act like built-ins, it tends to foster\nobject interfaces that are more consistent and easier to learn, and it allows class-based\nobjects to be processed by code written to expect a built-in type’s interface. Here is a\nquick rundown of the main ideas behind overloading operators:\n• Methods named with double underscores (__X__) are special hooks. Python\noperator overloading is implemented by providing specially named methods to\nintercept operations. The Python language defines a fixed and unchangeable mapping from each of these operations to a specially named method.\n• Such methods are called automatically when instances appear in built-in\noperations. For instance, if an instance object inherits an __add__ method, that",
    "operator overloading is implemented by providing specially named methods to\nintercept operations. The Python language defines a fixed and unchangeable mapping from each of these operations to a specially named method.\n• Such methods are called automatically when instances appear in built-in\noperations. For instance, if an instance object inherits an __add__ method, that\nmethod is called whenever the object appears in a + expression. The method’s\nreturn value becomes the result of the corresponding expression.\n• Classes may override most built-in type operations. There are dozens of special\noperator overloading method names for intercepting and implementing nearly every operation available for built-in types. This includes expressions, but also basic\noperations like printing and object creation.\n• There are no defaults for operator overloading methods, and none are\nrequired. If a class does not define or inherit an operator overloading method, it",
    "operator overloading method names for intercepting and implementing nearly every operation available for built-in types. This includes expressions, but also basic\noperations like printing and object creation.\n• There are no defaults for operator overloading methods, and none are\nrequired. If a class does not define or inherit an operator overloading method, it\njust means that the corresponding operation is not supported for the class’s instances. If there is no __add__, for example, + expressions raise exceptions.\n• Operators allow classes to integrate with Python’s object model. By overloading type operations, user-defined objects implemented with classes can act just\nlike built-ins, and so provide consistency as well as compatibility with expected\ninterfaces.\nOperator overloading is an optional feature; it’s used primarily by people developing\ntools for other Python programmers, not by application developers. And, candidly, you",
    "like built-ins, and so provide consistency as well as compatibility with expected\ninterfaces.\nOperator overloading is an optional feature; it’s used primarily by people developing\ntools for other Python programmers, not by application developers. And, candidly, you\nprobably shouldn’t try to use it just because it seems “cool.” Unless a class needs to\nmimic built-in type interfaces, it should usually stick to simpler named methods. Why\nwould an employee database application support expressions like * and +, for example?\nNamed methods like giveRaise and promote would usually make more sense.\nClasses Can Intercept Python Operators | 633",
    "Because of this, we won’t go into details on every operator overloading method available\nin Python in this book. Still, there is one operator overloading method you are likely\nto see in almost every realistic Python class: the __init__ method, which is known as\nthe constructor method and is used to initialize objects’ state. You should pay special\nattention to this method, because __init__, along with the self argument, turns out\nto be a key requirement to understanding most OOP code in Python.",
    "A Third Example\nOn to another example. This time, we’ll define a subclass of SecondClass that implements three specially named attributes that Python will call automatically:\n• __init__ is run when a new instance object is created (self is the new ThirdClass\nobject).*\n• __add__ is run when a ThirdClass instance appears in a + expression.\n• __str__ is run when an object is printed (technically, when it’s converted to its\nprint string by the str built-in function or its Python internals equivalent).\nOur new subclass also defines a normally named method named mul, which changes\nthe instance object in-place. Here’s the new subclass:\n>>> class ThirdClass(SecondClass):\n# Inherit from SecondClass\n...\ndef __init__(self, value):\n# On \"ThirdClass(value)\"\n...\nself.data = value\n...\ndef __add__(self, other):\n# On \"self + other\"\n...\nreturn ThirdClass(self.data + other)\n...\ndef __str__(self):\n# On \"print(self)\", \"str()\"\n...\nreturn '[ThirdClass: %s]' % self.data\n...\ndef mul(self, other):",
    ">>> class ThirdClass(SecondClass):\n# Inherit from SecondClass\n...\ndef __init__(self, value):\n# On \"ThirdClass(value)\"\n...\nself.data = value\n...\ndef __add__(self, other):\n# On \"self + other\"\n...\nreturn ThirdClass(self.data + other)\n...\ndef __str__(self):\n# On \"print(self)\", \"str()\"\n...\nreturn '[ThirdClass: %s]' % self.data\n...\ndef mul(self, other):\n# In-place change: named\n...\nself.data *= other\n...\n>>> a = ThirdClass('abc')\n# __init__ called\n>>> a.display()\n# Inherited method called\nCurrent value = \"abc\"\n>>> print(a)\n# __str__: returns display string\n[ThirdClass: abc]\n>>> b = a + 'xyz'\n>>> b.display()\nCurrent value = \"abcxyz\"\n>>> print(b)\n[ThirdClass: abcxyz]",
    "# __add__: makes a new instance\n# b has all ThirdClass methods\n\n>>> a.mul(3)\n>>> print(a)\n[ThirdClass: abcabcabc]\n\n# mul: changes instance in-place\n\n# __str__: returns display string\n\n* Not to be confused with the __init__.py files in module packages! See Chapter 23 for more details.\n\n634 | Chapter 26: Class Coding Basics\n\n\fThirdClass “is a” SecondClass, so its instances inherit the customized display method\nfrom SecondClass. This time, though, ThirdClass creation calls pass an argument (e.g.,\n“abc”). This argument is passed to the value argument in the __init__ constructor and\nassigned to self.data there. The net effect is that ThirdClass arranges to set the data\nattribute automatically at construction time, instead of requiring setdata calls after the",
    "fact.\nFurther, ThirdClass objects can now show up in + expressions and print calls. For +,\nPython passes the instance object on the left to the self argument in __add__ and the\nvalue on the right to other, as illustrated in Figure 26-3; whatever __add__ returns becomes the result of the + expression. For print, Python passes the object being printed\nto self in __str__; whatever string this method returns is taken to be the print string\nfor the object. With __str__ we can use a normal print to display objects of this class,\ninstead of calling the special display method.\n\nFigure 26-3. In operator overloading, expression operators and other built-in operations performed\non class instances are mapped back to specially named methods in the class. These special methods\nare optional and may be inherited as usual. Here, a + expression triggers the __add__ method.",
    "Specially named methods such as __init__, __add__, and __str__ are inherited by subclasses and instances, just like any other names assigned in a class. If they’re not coded\nin a class, Python looks for such names in all its superclasses, as usual. Operator overloading method names are also not built-in or reserved words; they are just attributes\nthat Python looks for when objects appear in various contexts. Python usually calls\nthem automatically, but they may occasionally be called by your code as well; the\n__init__ method, for example, is often called manually to trigger superclass constructors (more on this later).\nNotice that the __add__ method makes and returns a new instance object of its class,\nby calling ThirdClass with the result value. By contrast, mul changes the current instance\nobject in-place, by reassigning the self attribute. We could overload the * expression\nto do the latter, but this would be too different from the behavior of * for built-in types",
    "Notice that the __add__ method makes and returns a new instance object of its class,\nby calling ThirdClass with the result value. By contrast, mul changes the current instance\nobject in-place, by reassigning the self attribute. We could overload the * expression\nto do the latter, but this would be too different from the behavior of * for built-in types\nsuch as numbers and strings, for which it always makes new objects. Common practice\ndictates that overloaded operators should work the same way that built-in operator\nimplementations do. Because operator overloading is really just an expression-tomethod dispatch mechanism, though, you can interpret operators any way you like in\nyour own class objects.\nClasses Can Intercept Python Operators | 635",
    "Why Use Operator Overloading?\nAs a class designer, you can choose to use operator overloading or not. Your choice\nsimply depends on how much you want your object to look and feel like built-in types.\nAs mentioned earlier, if you omit an operator overloading method and do not inherit\nit from a superclass, the corresponding operation will not be supported for your instances; if it’s attempted, an exception will be thrown (or a standard default will be\nused).\nFrankly, many operator overloading methods tend to be used only when implementing\nobjects that are mathematical in nature; a vector or matrix class may overload the\naddition operator, for example, but an employee class likely would not. For simpler\nclasses, you might not use overloading at all, and would rely instead on explicit method\ncalls to implement your objects’ behavior.\nOn the other hand, you might decide to use operator overloading if you need to pass",
    "objects that are mathematical in nature; a vector or matrix class may overload the\naddition operator, for example, but an employee class likely would not. For simpler\nclasses, you might not use overloading at all, and would rely instead on explicit method\ncalls to implement your objects’ behavior.\nOn the other hand, you might decide to use operator overloading if you need to pass\na user-defined object to a function that was coded to expect the operators available on\na built-in type like a list or a dictionary. Implementing the same operator set in your\nclass will ensure that your objects support the same expected object interface and so\nare compatible with the function. Although we won’t cover every operator overloading\nmethod in this book, we’ll see some additional operator overloading techniques in\naction in Chapter 29.\nOne overloading method we will explore here is the __init__ constructor method,",
    "class will ensure that your objects support the same expected object interface and so\nare compatible with the function. Although we won’t cover every operator overloading\nmethod in this book, we’ll see some additional operator overloading techniques in\naction in Chapter 29.\nOne overloading method we will explore here is the __init__ constructor method,\nwhich seems to show up in almost every realistic class. Because it allows classes to fill\nout the attributes in their newly created instances immediately, the constructor is useful\nfor almost every kind of class you might code. In fact, even though instance attributes\nare not declared in Python, you can usually find out which attributes an instance will\nhave by inspecting its class’s __init__ method.",
    "The World’s Simplest Python Class\nWe’ve begun studying class statement syntax in detail in this chapter, but I’d again\nlike to remind you that the basic inheritance model that classes produce is very simple—\nall it really involves is searching for attributes in trees of linked objects. In fact, we can\ncreate a class with nothing in it at all. The following statement makes a class with no\nattributes attached (an empty namespace object):\n>>> class rec: pass\n\n# Empty namespace object\n\nWe need the no-operation pass statement (discussed in Chapter 13) here because we\ndon’t have any methods to code. After we make the class by running this statement\ninteractively, we can start attaching attributes to the class by assigning names to it\ncompletely outside of the original class statement:\n>>> rec.name = 'Bob'\n>>> rec.age = 40\n\n636 | Chapter 26: Class Coding Basics\n\n# Just objects with attributes",
    "636 | Chapter 26: Class Coding Basics\n\n# Just objects with attributes\n\n\fAnd, after we’ve created these attributes by assignment, we can fetch them with the\nusual syntax. When used this way, a class is roughly similar to a “struct” in C, or a\n“record” in Pascal. It’s basically an object with field names attached to it (we can do\nsimilar work with dictionary keys, but it requires extra characters):\n>>> print(rec.name)\nBob\n\n# Like a C struct or a record\n\nNotice that this works even though there are no instances of the class yet; classes are\nobjects in their own right, even without instances. In fact, they are just self-contained\nnamespaces, so as long as we have a reference to a class, we can set or change its\nattributes anytime we wish. Watch what happens when we do create two instances,\nthough:\n>>> x = rec()\n>>> y = rec()\n\n# Instances inherit class names",
    "# Instances inherit class names\n\nThese instances begin their lives as completely empty namespace objects. Because they\nremember the class from which they were made, though, they will obtain the attributes\nwe attached to the class by inheritance:\n>>> x.name, y.name\n('Bob', 'Bob')\n\n# name is stored on the class only\n\nReally, these instances have no attributes of their own; they simply fetch the name attribute from the class object where it is stored. If we do assign an attribute to an instance,\nthough, it creates (or changes) the attribute in that object, and no other—attribute\nreferences kick off inheritance searches, but attribute assignments affect only the objects in which the assignments are made. Here, x gets its own name, but y still inherits\nthe name attached to the class above it:\n>>> x.name = 'Sue'\n>>> rec.name, x.name, y.name\n('Bob', 'Sue', 'Bob')\n\n# But assignment changes x only",
    "# But assignment changes x only\n\nIn fact, as we’ll explore in more detail in Chapter 28, the attributes of a namespace\nobject are usually implemented as dictionaries, and class inheritance trees are (generally\nspeaking) just dictionaries with links to other dictionaries. If you know where to look,\nyou can see this explicitly.\nFor example, the __dict__ attribute is the namespace dictionary for most class-based\nobjects (some classes may also define attributes in __slots__, an advanced and seldomused feature that we’ll study in Chapters 30 and 31). The following was run in Python\n3.0; the order of names and set of __X__ internal names present can vary from release\nto release, but the names we assigned are present in all:\n>>> rec.__dict__.keys()\n['__module__', 'name', 'age', '__dict__', '__weakref__', '__doc__']\n>>> list(x.__dict__.keys())\n['name']\n\nThe World’s Simplest Python Class | 637\n\n\f>>> list(y.__dict__.keys())\n[]\n\n# list() not required in Python 2.6",
    "The World’s Simplest Python Class | 637\n\n\f>>> list(y.__dict__.keys())\n[]\n\n# list() not required in Python 2.6\n\nHere, the class’s namespace dictionary shows the name and age attributes we assigned\nto it, x has its own name, and y is still empty. Each instance has a link to its class for\ninheritance, though—it’s called __class__, if you want to inspect it:\n>>> x.__class__\n<class '__main__.rec'>\n\nClasses also have a __bases__ attribute, which is a tuple of their superclasses:\n>>> rec.__bases__\n(<class 'object'>,)\n\n# () empty tuple in Python 2.6",
    "Classes also have a __bases__ attribute, which is a tuple of their superclasses:\n>>> rec.__bases__\n(<class 'object'>,)\n\n# () empty tuple in Python 2.6\n\nThese two attributes are how class trees are literally represented in memory by Python.\nThe main point to take away from this look under the hood is that Python’s class model\nis extremely dynamic. Classes and instances are just namespace objects, with attributes\ncreated on the fly by assignment. Those assignments usually happen within the class\nstatements you code, but they can occur anywhere you have a reference to one of the\nobjects in the tree.\nEven methods, normally created by a def nested in a class, can be created completely\nindependently of any class object. The following, for example, defines a simple function\noutside of any class that takes one argument:\n>>> def upperName(self):\n...\nreturn self.name.upper()\n\n# Still needs a self",
    "# Still needs a self\n\nThere is nothing about a class here yet—it’s a simple function, and it can be called as\nsuch at this point, provided we pass in an object with a name attribute (the name self\ndoes not make this special in any way):\n>>> upperName(x)\n'SUE'\n\n# Call as a simple function\n\nIf we assign this simple function to an attribute of our class, though, it becomes a\nmethod, callable through any instance (as well as through the class name itself, as long\nas we pass in an instance manually):†\n>>> rec.method = upperName\n>>> x.method()\n'SUE'\n\n# Run method to process x\n\n>>> y.method()\n'BOB'\n\n# Same, but pass y to self",
    "# Call as a simple function\n\nIf we assign this simple function to an attribute of our class, though, it becomes a\nmethod, callable through any instance (as well as through the class name itself, as long\nas we pass in an instance manually):†\n>>> rec.method = upperName\n>>> x.method()\n'SUE'\n\n# Run method to process x\n\n>>> y.method()\n'BOB'\n\n# Same, but pass y to self\n\n† In fact, this is one of the reasons the self argument must always be explicit in Python methods—because\nmethods can be created as simple functions independent of a class, they need to make the implied instance\nargument explicit. They can be called as either functions or methods, and Python can neither guess nor\nassume that a simple function might eventually become a class method. The main reason for the explicit\nself argument, though, is to make the meanings of names more obvious: names not referenced through\nself are simple variables, while names referenced through self are obviously instance attributes.",
    "638 | Chapter 26: Class Coding Basics\n\n\f>>> rec.method(x)\n'SUE'\n\n# Can call through instance or class\n\nNormally, classes are filled out by class statements, and instance attributes are created\nby assignments to self attributes in method functions. The point again, though, is that\nthey don’t have to be; OOP in Python really is mostly about looking up attributes in\nlinked namespace objects.",
    "# Can call through instance or class\n\nNormally, classes are filled out by class statements, and instance attributes are created\nby assignments to self attributes in method functions. The point again, though, is that\nthey don’t have to be; OOP in Python really is mostly about looking up attributes in\nlinked namespace objects.\n\nClasses Versus Dictionaries\nAlthough the simple classes of the prior section are meant to illustrate class model\nbasics, the techniques they employ can also be used for real work. For example, Chapter 8 showed how to use dictionaries to record properties of entities in our programs.\nIt turns out that classes can serve this role, too—they package information like dictionaries, but can also bundle processing logic in the form of methods. For reference,\nhere is the example for dictionary-based records we used earlier in the book:\n>>> rec = {}\n>>> rec['name'] = 'mel'\n>>> rec['age'] = 45\n>>> rec['job'] = 'trainer/writer'\n>>>\n>>> print(rec['name'])\nmel",
    "# Dictionary-based record\n\nThis code emulates tools like records in other languages. As we just saw, though, there\nare also multiple ways to do the same with classes. Perhaps the simplest is this—trading\nkeys for attributes:\n>>> class rec: pass\n...\n>>> rec.name = 'mel'\n>>> rec.age = 45\n>>> rec.job = 'trainer/writer'\n>>>\n>>> print(rec.age)\n40\n\n# Class-based record\n\nThis code has substantially less syntax than the dictionary equivalent. It uses an empty\nclass statement to generate an empty namespace object. Once we make the empty\nclass, we fill it out by assigning class attributes over time, as before.\nThis works, but a new class statement will be required for each distinct record we will\nneed. Perhaps more typically, we can instead generate instances of an empty class to\nrepresent each distinct entity:\n>>> class rec: pass\n...\n>>> pers1 = rec()\n>>> pers1.name = 'mel'\n>>> pers1.job = 'trainer'\n\n# Instance-based records\n\nThe World’s Simplest Python Class | 639",
    "# Instance-based records\n\nThe World’s Simplest Python Class | 639\n\n\f>>> pers1.age\n= 40\n>>>\n>>> pers2 = rec()\n>>> pers2.name = 'vls'\n>>> pers2.job = 'developer'\n>>>\n>>> pers1.name, pers2.name\n('mel', 'vls')",
    "Here, we make two records from the same class. Instances start out life empty, just like\nclasses. We then fill in the records by assigning to attributes. This time, though, there\nare two separate objects, and hence two separate name attributes. In fact, instances of\nthe same class don’t even have to have the same set of attribute names; in this example,\none has a unique age name. Instances really are distinct namespaces, so each has a\ndistinct attribute dictionary. Although they are normally filled out consistently by class\nmethods, they are more flexible than you might expect.\nFinally, we might instead code a more full-blown class to implement the record and its\nprocessing:\n>>> class Person:\n...\ndef __init__(self, name, job):\n...\nself.name = name\n...\nself.job = job\n...\ndef info(self):\n...\nreturn (self.name, self.job)\n...\n>>> rec1 = Person('mel', 'trainer')\n>>> rec2 = Person('vls', 'developer')\n>>>\n>>> rec1.job, rec2.info()\n('trainer', ('vls', 'developer'))\n\n# Class = Data + Logic",
    "This scheme also makes multiple instances, but the class is not empty this time: we’ve\nadded logic (methods) to initialize instances at construction time and collect attributes\ninto a tuple. The constructor imposes some consistency on instances here by always\nsetting the name and job attributes. Together, the class’s methods and instance attributes\ncreate a package, which combines both data and logic.\nWe could further extend this code by adding logic to compute salaries, parse names,\nand so on. Ultimately, we might link the class into a larger hierarchy to inherit an\nexisting set of methods via the automatic attribute search of classes, or perhaps even\nstore instances of the class in a file with Python object pickling to make them persistent.\nIn fact, we will—in the next chapter, we’ll expand on this analogy between classes and\nrecords with a more realistic running example that demonstrates class basics in action.",
    "existing set of methods via the automatic attribute search of classes, or perhaps even\nstore instances of the class in a file with Python object pickling to make them persistent.\nIn fact, we will—in the next chapter, we’ll expand on this analogy between classes and\nrecords with a more realistic running example that demonstrates class basics in action.\nIn the end, although types like dictionaries are flexible, classes allow us to add behavior\nto objects in ways that built-in types and simple functions do not directly support.\nAlthough we can store functions in dictionaries, too, using them to process implied\ninstances is nowhere near as natural as it is in classes.",
    "640 | Chapter 26: Class Coding Basics\n\n\fChapter Summary\nThis chapter introduced the basics of coding classes in Python. We studied the syntax\nof the class statement, and we saw how to use it to build up a class inheritance tree.\nWe also studied how Python automatically fills in the first argument in method functions, how attributes are attached to objects in a class tree by simple assignment, and\nhow specially named operator overloading methods intercept and implement built-in\noperations for our instances (e.g., expressions and printing).\nNow that we’ve learned all about the mechanics of coding classes in Python, the next\nchapter turns to a larger and more realistic example that ties together much of what\nwe’ve learned about OOP so far. After that, we’ll continue our look at class coding,\ntaking a second pass over the model to fill in some of the details that were omitted here\nto keep things simple. First, though, let’s work through a quiz to review the basics we’ve\ncovered so far.",
    "Test Your Knowledge: Quiz\n1. How are classes related to modules?\n2. How are instances and classes created?\n3. Where and how are class attributes created?\n4. Where and how are instance attributes created?\n5. What does self mean in a Python class?\n6. How is operator overloading coded in a Python class?\n7. When might you want to support operator overloading in your classes?\n8. Which operator overloading method is most commonly used?\n9. What are the two key concepts required to understand Python OOP code?",
    "Test Your Knowledge: Answers\n1. Classes are always nested inside a module; they are attributes of a module object.\nClasses and modules are both namespaces, but classes correspond to statements\n(not entire files) and support the OOP notions of multiple instances, inheritance,\nand operator overloading. In a sense, a module is like a single-instance class, without inheritance, which corresponds to an entire file of code.\n2. Classes are made by running class statements; instances are created by calling a\nclass as though it were a function.\n\nTest Your Knowledge: Answers | 641",
    "3. Class attributes are created by assigning attributes to a class object. They are normally generated by top-level assignments nested in a class statement—each name\nassigned in the class statement block becomes an attribute of the class object\n(technically, the class statement scope morphs into the class object’s attribute\nnamespace). Class attributes can also be created, though, by assigning attributes\nto the class anywhere a reference to the class object exists—i.e., even outside the\nclass statement.\n4. Instance attributes are created by assigning attributes to an instance object. They\nare normally created within class method functions inside the class statement by\nassigning attributes to the self argument (which is always the implied instance).\nAgain, though, they may be created by assignment anywhere a reference to the\ninstance appears, even outside the class statement. Normally, all instance\nattributes are initialized in the __init__ constructor method; that way, later",
    "are normally created within class method functions inside the class statement by\nassigning attributes to the self argument (which is always the implied instance).\nAgain, though, they may be created by assignment anywhere a reference to the\ninstance appears, even outside the class statement. Normally, all instance\nattributes are initialized in the __init__ constructor method; that way, later\nmethod calls can assume the attributes already exist.\n5. self is the name commonly given to the first (leftmost) argument in a class method\nfunction; Python automatically fills it in with the instance object that is the implied\nsubject of the method call. This argument need not be called self (though this is\na very strong convention); its position is what is significant. (Ex-C++ or Java programmers might prefer to call it this because in those languages that name reflects\nthe same idea; in Python, though, this argument must always be explicit.)",
    "subject of the method call. This argument need not be called self (though this is\na very strong convention); its position is what is significant. (Ex-C++ or Java programmers might prefer to call it this because in those languages that name reflects\nthe same idea; in Python, though, this argument must always be explicit.)\n6. Operator overloading is coded in a Python class with specially named methods;\nthey all begin and end with double underscores to make them unique. These are\nnot built-in or reserved names; Python just runs them automatically when an instance appears in the corresponding operation. Python itself defines the mappings\nfrom operations to special method names.\n7. Operator overloading is useful to implement objects that resemble built-in types\n(e.g., sequences or numeric objects such as matrixes), and to mimic the built-in",
    "not built-in or reserved names; Python just runs them automatically when an instance appears in the corresponding operation. Python itself defines the mappings\nfrom operations to special method names.\n7. Operator overloading is useful to implement objects that resemble built-in types\n(e.g., sequences or numeric objects such as matrixes), and to mimic the built-in\ntype interface expected by a piece of code. Mimicking built-in type interfaces enables you to pass in class instances that also have state information—i.e., attributes\nthat remember data between operation calls. You shouldn’t use operator overloading when a simple named method will suffice, though.\n8. The __init__ constructor method is the most commonly used; almost every class\nuses this method to set initial values for instance attributes and perform other\nstartup tasks.\n9. The special self argument in method functions and the __init__ constructor\nmethod are the two cornerstones of OOP code in Python.",
    "642 | Chapter 26: Class Coding Basics\n\n\fCHAPTER 27\n\nA More Realistic Example",
    "We’ll dig into more class syntax details in the next chapter. Before we do, though, I’d\nlike to show you a more realistic example of classes in action that’s more practical than\nwhat we’ve seen so far. In this chapter, we’re going to build a set of classes that do\nsomething more concrete—recording and processing information about people. As\nyou’ll see, what we call instances and classes in Python programming can often serve\nthe same roles as records and programs in more traditional terms.\nSpecifically, in this chapter we’re going to code two classes:\n• Person—a class that creates and processes information about people\n• Manager—a customization of Person that modifies inherited behavior\nAlong the way, we’ll make instances of both classes and test out their functionality.\nWhen we’re done, I’ll show you a nice example use case for classes—we’ll store our\ninstances in a shelve object-oriented database, to make them permanent. That way, you",
    "• Person—a class that creates and processes information about people\n• Manager—a customization of Person that modifies inherited behavior\nAlong the way, we’ll make instances of both classes and test out their functionality.\nWhen we’re done, I’ll show you a nice example use case for classes—we’ll store our\ninstances in a shelve object-oriented database, to make them permanent. That way, you\ncan use this code as a template for fleshing out a full-blown personal database written\nentirely in Python.\nBesides actual utility, though, our aim here is also educational: this chapter provides a\ntutorial on object-oriented programming in Python. Often, people grasp the last chapter’s class syntax on paper, but have trouble seeing how to get started when confronted\nwith having to code a new class from scratch. Toward this end, we’ll take it one step\nat a time here, to help you learn the basics; we’ll build up the classes gradually, so you",
    "tutorial on object-oriented programming in Python. Often, people grasp the last chapter’s class syntax on paper, but have trouble seeing how to get started when confronted\nwith having to code a new class from scratch. Toward this end, we’ll take it one step\nat a time here, to help you learn the basics; we’ll build up the classes gradually, so you\ncan see how their features come together in complete programs.\nIn the end, our classes will still be relatively small in terms of code, but they will demonstrate all of the main ideas in Python’s OOP model. Despite its syntax details, Python’s class system really is largely just a matter of searching for an attribute in a tree\nof objects, along with a special first argument for functions.",
    "643\n\n\fStep 1: Making Instances\nOK, so much for the design phase—let’s move on to implementation. Our first task is\nto start coding the main class, Person. In your favorite text editor, open a new file for\nthe code we’ll be writing. It’s a fairly strong convention in Python to begin module\nnames with a lowercase letter and class names with an uppercase letter; like the name\nof self arguments in methods, this is not required by the language, but it’s so common\nthat deviating might be confusing to people who later read your code. To conform,\nwe’ll call our new module file person.py and our class within it Person, like this:\n# File person.py (start)\nclass Person:",
    "All our work will be done in this file until later in this chapter. We can code any number\nof functions and classes in a single module file in Python, and this one’s person.py name\nmight not make much sense if we add unrelated components to it later. For now, we’ll\nassume everything in it will be Person-related. It probably should be anyhow—as we’ve\nlearned, modules tend to work best when they have a single, cohesive purpose.",
    "Coding Constructors\nNow, the first thing we want to do with our Person class is record basic information\nabout people—to fill out record fields, if you will. Of course, these are known as instance object attributes in Python-speak, and they generally are created by assignment\nto self attributes in class method functions. The normal way to give instance attributes\ntheir first values is to assign them to self in the __init__ constructor method, which\ncontains code run automatically by Python each time an instance is created. Let’s add\none to our class:\n# Add record field initialization\nclass Person:\ndef __init__(self, name, job, pay):\nself.name = name\nself.job = job\nself.pay = pay\n\n# Constructor takes 3 arguments\n# Fill out fields when created\n# self is the new instance object",
    "# Constructor takes 3 arguments\n# Fill out fields when created\n# self is the new instance object\n\nThis is a very common coding pattern: we pass in the data to be attached to an instance\nas arguments to the constructor method and assign them to self to retain them permanently. In OO terms, self is the newly created instance object, and name, job, and\npay become state information—descriptive data saved on an object for later use. Although other techniques (such as enclosing scope references) can save details, too,\ninstance attributes make this very explicit and easy to understand.\nNotice that the argument names appear twice here. This code might seem a bit redundant at first, but it’s not. The job argument, for example, is a local variable in the scope\nof the __init__ function, but self.job is an attribute of the instance that’s the implied\n\n644 | Chapter 27: A More Realistic Example",
    "subject of the method call. They are two different variables, which happen to have the\nsame name. By assigning the job local to the self.job attribute with self.job=job, we\nsave the passed-in job on the instance for later use. As usual in Python, where a name\nis assigned (or what object it is assigned to) determines what it means.\nSpeaking of arguments, there’s really nothing magical about __init__, apart from the\nfact that it’s called automatically when an instance is made and has a special first argument. Despite its weird name, it’s a normal function and supports all the features of\nfunctions we’ve already covered. We can, for example, provide defaults for some of its\narguments, so they need not be provided in cases where their values aren’t available or\nuseful.\nTo demonstrate, let’s make the job argument optional—it will default to None, meaning\nthe person being created is not (currently) employed. If job defaults to None, we’ll",
    "functions we’ve already covered. We can, for example, provide defaults for some of its\narguments, so they need not be provided in cases where their values aren’t available or\nuseful.\nTo demonstrate, let’s make the job argument optional—it will default to None, meaning\nthe person being created is not (currently) employed. If job defaults to None, we’ll\nprobably want to default pay to 0, too, for consistency (unless some of the people you\nknow manage to get paid without having jobs!). In fact, we have to specify a default\nfor pay because according to Python’s syntax rules, any arguments in a function’s header\nafter the first default must all have defaults, too:\n# Add defaults for constructor arguments\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay",
    "# Normal function args\n\nWhat this code means is that we’ll need to pass in a name when making Persons, but\njob and pay are now optional; they’ll default to None and 0 if omitted. The self argument, as usual, is filled in by Python automatically to refer to the instance object—\nassigning values to attributes of self attaches them to the new instance.",
    "Testing As You Go\nThis class doesn’t do much yet—it essentially just fills out the fields of a new record—\nbut it’s a real working class. At this point we could add more code to it for more features,\nbut we won’t do that yet. As you’ve probably begun to appreciate already, programming\nin Python is really a matter of incremental prototyping—you write some code, test it,\nwrite more code, test again, and so on. Because Python provides both an interactive\nsession and nearly immediate turnaround after code changes, it’s more natural to test\nas you go than to write a huge amount of code to test all at once.\nBefore adding more features, then, let’s test what we’ve got so far by making a few\ninstances of our class and displaying their attributes as created by the constructor. We\ncould do this interactively, but as you’ve also probably surmised by now, interactive\ntesting has its limits—it gets tedious to have to reimport modules and retype test cases",
    "Before adding more features, then, let’s test what we’ve got so far by making a few\ninstances of our class and displaying their attributes as created by the constructor. We\ncould do this interactively, but as you’ve also probably surmised by now, interactive\ntesting has its limits—it gets tedious to have to reimport modules and retype test cases\neach time you start a new testing session. More commonly, Python programmers use",
    "Step 1: Making Instances | 645\n\n\fthe interactive prompt for simple one-off tests but do more substantial testing by writing\ncode at the bottom of the file that contains the objects to be tested, like this:\n# Add incremental self-test code\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob.name, bob.pay)\nprint(sue.name, sue.pay)\n\n# Test the class\n# Runs __init__ automatically\n# Fetch attached attributes\n# sue's and bob's attrs differ",
    "# Test the class\n# Runs __init__ automatically\n# Fetch attached attributes\n# sue's and bob's attrs differ\n\nNotice here that the bob object accepts the defaults for job and pay, but sue provides\nvalues explicitly. Also note how we use keyword arguments when making sue; we could\npass by position instead, but the keywords may help remind us later what the data is\n(and they allow us to pass the arguments in any left-to-right order we like). Again,\ndespite its unusual name, __init__ is a normal function, supporting everything you\nalready know about functions—including both defaults and pass-by-name keyword\narguments.\nWhen this file runs as a script, the test code at the bottom makes two instances of our\nclass and prints two attributes of each (name and pay):\nC:\\misc> person.py\nBob Smith 0\nSue Jones 100000",
    "You can also type this file’s test code at Python’s interactive prompt (assuming you\nimport the Person class there first), but coding canned tests inside the module file like\nthis makes it much easier to rerun them in the future.\nAlthough this is fairly simple code, it’s already demonstrating something important.\nNotice that bob’s name is not sue’s, and sue’s pay is not bob’s. Each is an independent\nrecord of information. Technically, bob and sue are both namespace objects—like all\nclass instances, they each have their own independent copy of the state information\ncreated by the class. Because each instance of a class has its own set of self attributes,\nclasses are a natural for recording information for multiple objects this way; just like\nbuilt-in types, classes serve as a sort of object factory. Other Python program structures,\nsuch as functions and modules, have no such concept.",
    "Using Code Two Ways\nAs is, the test code at the bottom of the file works, but there’s a big catch—its top-level\nprint statements run both when the file is run as a script and when it is imported as a\nmodule. This means if we ever decide to import the class in this file in order to use it\nsomewhere else (and we will later in this chapter), we’ll see the output of its test code\n646 | Chapter 27: A More Realistic Example",
    "every time the file is imported. That’s not very good software citizenship, though: client\nprograms probably don’t care about our internal tests and won’t want to see our output\nmixed in with their own.\nAlthough we could split the test code off into a separate file, it’s often more convenient\nto code tests in the same file as the items to be tested. It would be better to arrange to\nrun the test statements at the bottom only when the file is run for testing, not when the\nfile is imported. That’s exactly what the module __name__ check is designed for, as you\nlearned in the preceding part of this book. Here’s what this addition looks like:\n# Allow this file to be imported as well as run/tested\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\nif __name__ == '__main__':\n# When run for testing only\n# self-test code\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob.name, bob.pay)",
    "# Allow this file to be imported as well as run/tested\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\nif __name__ == '__main__':\n# When run for testing only\n# self-test code\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob.name, bob.pay)\nprint(sue.name, sue.pay)",
    "Now, we get exactly the behavior we’re after—running the file as a top-level script tests\nit because its __name__ is __main__, but importing it as a library of classes later does not:\nC:\\misc> person.py\nBob Smith 0\nSue Jones 100000\nc:\\misc> python\nPython 3.0.1 (r301:69561, Feb 13 2009, 20:04:18) ...\n>>> import person\n>>>\n\nWhen imported, the file now defines the class, but does not use it. When run directly,\nthis file creates two instances of our class as before, and prints two attributes of each;\nagain, because each instance is an independent namespace object, the values of their\nattributes differ.\n\nVersion Portability Note\nI’m running all the code in this chapter under Python 3.0, and using the 3.0 print\nfunction call syntax. If you run under 2.6 the code will work as-is, but you’ll notice\nparentheses around some output lines because the extra parentheses in prints turn\nmultiple items into a tuple:\nc:\\misc> c:\\python26\\python person.py\n('Bob Smith', 0)\n('Sue Jones', 100000)",
    "Version Portability Note\nI’m running all the code in this chapter under Python 3.0, and using the 3.0 print\nfunction call syntax. If you run under 2.6 the code will work as-is, but you’ll notice\nparentheses around some output lines because the extra parentheses in prints turn\nmultiple items into a tuple:\nc:\\misc> c:\\python26\\python person.py\n('Bob Smith', 0)\n('Sue Jones', 100000)\n\nStep 1: Making Instances | 647\n\n\fIf this difference is the sort of detail that might keep you awake at nights, simply remove\nthe parentheses to use 2.6 print statements. You can also avoid the extra parentheses\nportably by using formatting to yield a single object to print. Either of the following\nworks in both 2.6 and 3.0, though the method form is newer:\nprint('{0} {1}'.format(bob.name, bob.pay))\nprint('%s %s' % (bob.name, bob.pay))\n\n# New format method\n# Format expression",
    "Step 2: Adding Behavior Methods\nEverything looks good so far—at this point, our class is essentially a record factory; it\ncreates and fills out fields of records (attributes of instances, in more Pythonic terms).\nEven as limited as it is, though, we can still run some operations on its objects. Although\nclasses add an extra layer of structure, they ultimately do most of their work by embedding and processing basic core data types like lists and strings. In other words, if\nyou already know how to use Python’s simple core types, you already know much of\nthe Python class story; classes are really just a minor structural extension.\nFor example, the name field of our objects is a simple string, so we can extract last names\nfrom our objects by splitting on spaces and indexing. These are all core data type operations, which work whether their subjects are embedded in class instances or not:\n>>> name = 'Bob Smith'\n>>> name.split()\n['Bob', 'Smith']\n>>> name.split()[-1]\n'Smith'",
    "# Simple string, outside class\n# Extract last name\n# Or [1], if always just two parts\n\nSimilarly, we can give an object a pay raise by updating its pay field—that is, by changing\nits state information in-place with an assignment. This task also involves basic operations that work on Python’s core objects, regardless of whether they are standalone or\nembedded in a class structure:\n>>> pay = 100000\n>>> pay *= 1.10\n>>> print(pay)\n110000.0\n\n# Simple variable, outside class\n# Give a 10% raise\n# Or: pay = pay * 1.10, if you like to type\n# Or: pay = pay + (pay * .10), if you _really_ do!",
    "# Simple variable, outside class\n# Give a 10% raise\n# Or: pay = pay * 1.10, if you like to type\n# Or: pay = pay + (pay * .10), if you _really_ do!\n\nTo apply these operations to the Person objects created by our script, simply do to\nbob.name and sue.pay what we just did to name and pay. The operations are the same,\nbut the subject objects are attached to attributes in our class structure:\n# Process embedded built-in types: strings, mutability\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\nif __name__ == '__main__':\n\n648 | Chapter 27: A More Realistic Example\n\n\fbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob.name, bob.pay)\nprint(sue.name, sue.pay)\nprint(bob.name.split()[-1])\n# Extract object's last name\nsue.pay *= 1.10\n# Give this object a raise\nprint(sue.pay)",
    "648 | Chapter 27: A More Realistic Example\n\n\fbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob.name, bob.pay)\nprint(sue.name, sue.pay)\nprint(bob.name.split()[-1])\n# Extract object's last name\nsue.pay *= 1.10\n# Give this object a raise\nprint(sue.pay)\n\nWe’ve added the last two lines here; when they’re run, we extract bob’s last name by\nusing basic string and list operations and give sue a pay raise by modifying her pay\nattribute in-place with basic number operations. In a sense, sue is also a mutable\nobject—her state changes in-place just like a list after an append call:\nBob Smith 0\nSue Jones 100000\nSmith\n110000.0",
    "The preceding code works as planned, but if you show it to a veteran software developer\nhe’ll probably tell you that its general approach is not a great idea in practice. Hardcoding operations like these outside of the class can lead to maintenance problems in\nthe future.\nFor example, what if you’ve hardcoded the last-name-extraction formula at many different places in your program? If you ever need to change the way it works (to support\na new name structure, for instance), you’ll need to hunt down and update every occurrence. Similarly, if the pay-raise code ever changes (e.g., to require approval or\ndatabase updates), you may have multiple copies to modify. Just finding all the appearances of such code may be problematic in larger programs—they may be scattered\nacross many files, split into individual steps, and so on.",
    "Coding Methods\nWhat we really want to do here is employ a software design concept known as encapsulation. The idea with encapsulation is to wrap up operation logic behind interfaces,\nsuch that each operation is coded only once in our program. That way, if our needs\nchange in the future, there is just one copy to update. Moreover, we’re free to change\nthe single copy’s internals almost arbitrarily, without breaking the code that uses it.\nIn Python terms, we want to code operations on objects in class methods, instead of\nlittering them throughout our program. In fact, this is one of the things that classes are\nvery good at—factoring code to remove redundancy and thus optimize maintainability.\nAs an added bonus, turning operations into methods enables them to be applied to any\ninstance of the class, not just those that they’ve been hardcoded to process.",
    "littering them throughout our program. In fact, this is one of the things that classes are\nvery good at—factoring code to remove redundancy and thus optimize maintainability.\nAs an added bonus, turning operations into methods enables them to be applied to any\ninstance of the class, not just those that they’ve been hardcoded to process.\nThis is all simpler in code than it may sound in theory. The following achieves encapsulation by moving the two operations from code outside the class into class methods.\nWhile we’re at it, let’s change our self-test code at the bottom to use the new methods\nwe’re creating, instead of hardcoding operations:",
    "Step 2: Adding Behavior Methods | 649\n\n\f# Add methods to encapsulate operations for maintainability\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\n\n# Behavior methods\n# self is implied subject\n# Must change here only\n\nif __name__ == '__main__':\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob.name, bob.pay)\nprint(sue.name, sue.pay)\nprint(bob.lastName(), sue.lastName())\n# Use the new methods\nsue.giveRaise(.10)\n# instead of hardcoding\nprint(sue.pay)",
    "As we’ve learned, methods are simply normal functions that are attached to classes and\ndesigned to process instances of those classes. The instance is the subject of the method\ncall and is passed to the method’s self argument automatically.\nThe transformation to the methods in this version is straightforward. The new\nlastName method, for example, simply does to self what the previous version hardcoded for bob, because self is the implied subject when the method is called. lastName\nalso returns the result, because this operation is a called function now; it computes a\nvalue for its caller to use, even if it is just to be printed. Similarly, the new giveRaise\nmethod just does to self what we did to sue before.\nWhen run now, our file’s output is similar to before—we’ve mostly just refactored the\ncode to allow for easier changes in the future, not altered its behavior:\nBob Smith 0\nSue Jones 100000\nSmith Jones\n110000",
    "A few coding details are worth pointing out here. First, notice that sue’s pay is now still\nan integer after a pay raise—we convert the math result back to an integer by calling\nthe int built-in within the method. Changing the value to either int or float is probably\nnot a significant concern for most purposes (integer and floating-point objects have the\nsame interfaces and can be mixed within expressions), but we may need to address\nrounding issues in a real system (money probably matters to Persons!).\nAs we learned in Chapter 5, we might handle this by using the round(N, 2) built-in to\nround and retain cents, using the decimal type to fix precision, or storing monetary\nvalues as full floating-point numbers and displaying them with a %.2f or {0:.2f} formatting string to show cents. For this example, we’ll simply truncate any cents with\n\n650 | Chapter 27: A More Realistic Example\n\n\fint. (For another idea, also see the money function in the formats.py module of Chap-",
    "ter 24; you can import this tool to show pay with commas, cents, and dollar signs.)\nSecond, notice that we’re also printing sue’s last name this time—because the last-name\nlogic has been encapsulated in a method, we get to use it on any instance of the class.\nAs we’ve seen, Python tells a method which instance to process by automatically passing it in to the first argument, usually called self. Specifically:\n• In the first call, bob.lastName(), bob is the implied subject passed to self.\n• In the second call, sue.lastName(), sue goes to self instead.\nTrace through these calls to see how the instance winds up in self. The net effect is\nthat the method fetches the name of the implied subject each time. The same happens\nfor giveRaise. We could, for example, give bob a raise by calling giveRaise for both\ninstances this way, too; but unfortunately, bob’s zero pay will prevent him from getting\na raise as the program is currently coded (something we may want to address in a future",
    "that the method fetches the name of the implied subject each time. The same happens\nfor giveRaise. We could, for example, give bob a raise by calling giveRaise for both\ninstances this way, too; but unfortunately, bob’s zero pay will prevent him from getting\na raise as the program is currently coded (something we may want to address in a future\n2.0 release of our software).\nFinally, notice that the giveRaise method assumes that percent is passed in as a floatingpoint number between zero and one. That may be too radical an assumption in the real\nworld (a 1000% raise would probably be a bug for most of us!); we’ll let it pass for this\nprototype, but we might want to test or at least document this in a future iteration of\nthis code. Stay tuned for a rehash of this idea in a later chapter in this book, where we’ll\ncode something called function decorators and explore Python’s assert statement—\nalternatives that can do the validity test for us automatically during development.",
    "Step 3: Operator Overloading\nAt this point, we have a fairly full-featured class that generates and initializes instances,\nalong with two new bits of behavior for processing instances (in the form of methods).\nSo far, so good.\nAs it stands, though, testing is still a bit less convenient than it needs to be—to trace\nour objects, we have to manually fetch and print individual attributes (e.g., bob.name,\nsue.pay). It would be nice if displaying an instance all at once actually gave us some\nuseful information. Unfortunately, the default display format for an instance object\nisn’t very good—it displays the object’s class name, and its address in memory (which\nis essentially useless in Python, except as a unique identifier).\nTo see this, change the last line in the script to print(sue) so it displays the object as a\nwhole. Here’s what you’ll get (the output says that sue is an “object” in 3.0 and an\n“instance” in 2.6):\nBob Smith 0\nSue Jones 100000\nSmith Jones",
    "isn’t very good—it displays the object’s class name, and its address in memory (which\nis essentially useless in Python, except as a unique identifier).\nTo see this, change the last line in the script to print(sue) so it displays the object as a\nwhole. Here’s what you’ll get (the output says that sue is an “object” in 3.0 and an\n“instance” in 2.6):\nBob Smith 0\nSue Jones 100000\nSmith Jones\n<__main__.Person object at 0x02614430>",
    "Step 3: Operator Overloading | 651",
    "Providing Print Displays\nFortunately, it’s easy to do better by employing operator overloading—coding methods\nin a class that intercept and process built-in operations when run on the class’s\ninstances. Specifically, we can make use of what is probably the second most commonly\nused operator overloading method in Python, after __init__: the __str__ method introduced in the preceding chapter. __str__ is run automatically every time an instance\nis converted to its print string. Because that’s what printing an object does, the net\ntransitive effect is that printing an object displays whatever is returned by the object’s\n__str__ method, if it either defines one itself or inherits one from a superclass (doubleunderscored names are inherited just like any other).\nTechnically speaking, the __init__ constructor method we’ve already coded is operator",
    "transitive effect is that printing an object displays whatever is returned by the object’s\n__str__ method, if it either defines one itself or inherits one from a superclass (doubleunderscored names are inherited just like any other).\nTechnically speaking, the __init__ constructor method we’ve already coded is operator\noverloading too—it is run automatically at construction time to initialize a newly created instance. Constructors are so common, though, that they almost seem like a special\ncase. More focused methods like __str__ allow us to tap into specific operations and\nprovide specialized behavior when our objects are used in those contexts.\nLet’s put this into code. The following extends our class to give a custom display that\nlists attributes when our class’s instances are displayed as a whole, instead of relying\non the less useful default display:\n# Add __str__ overload method for printing objects\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name",
    "Let’s put this into code. The following extends our class to give a custom display that\nlists attributes when our class’s instances are displayed as a whole, instead of relying\non the less useful default display:\n# Add __str__ overload method for printing objects\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\ndef __str__(self):\nreturn '[Person: %s, %s]' % (self.name, self.pay)",
    "# Added method\n# String to print\n\nif __name__ == '__main__':\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob)\nprint(sue)\nprint(bob.lastName(), sue.lastName())\nsue.giveRaise(.10)\nprint(sue)\n\nNotice that we’re doing string % formatting to build the display string in __str__ here;\nat the bottom, classes use built-in type objects and operations like these to get their\nwork done. Again, everything you’ve already learned about both built-in types and\nfunctions applies to class-based code. Classes largely just add an additional layer of\nstructure that packages functions and data together and supports extensions.\n\n652 | Chapter 27: A More Realistic Example",
    "652 | Chapter 27: A More Realistic Example\n\n\fWe’ve also changed our self-test code to print objects directly, instead of printing individual attributes. When run, the output is more coherent and meaningful now; the\n“[...]” lines are returned by our new __str__, run automatically by print operations:\n[Person: Bob Smith, 0]\n[Person: Sue Jones, 100000]\nSmith Jones\n[Person: Sue Jones, 110000]\n\nHere’s a subtle point: as we’ll learn in the next chapter, a related overloading method,\n__repr__, provides an as-code low-level display of an object when present. Sometimes\nclasses provide both a __str__ for user-friendly displays and a __repr__ with extra details for developers to view. Because printing runs __str__ and the interactive prompt\nechoes results with __repr__, this can provide both target audiences with an appropriate\ndisplay. Since we’re not interested in displaying an as-code format, __str__ is sufficient\nfor our class.",
    "Step 4: Customizing Behavior by Subclassing\nAt this point, our class captures much of the OOP machinery in Python: it makes\ninstances, provides behavior in methods, and even does a bit of operator overloading\nnow to intercept print operations in __str__. It effectively packages our data and logic\ntogether into a single, self-contained software component, making it easy to locate code\nand straightforward to change it in the future. By allowing us to encapsulate behavior,\nit also allows us to factor that code to avoid redundancy and its associated maintenance\nheadaches.\nThe only major OOP concept it does not yet capture is customization by inheritance.\nIn some sense, we’re already doing inheritance, because instances inherit methods from\ntheir classes. To demonstrate the real power of OOP, though, we need to define a\nsuperclass/subclass relationship that allows us to extend our software and replace bits",
    "headaches.\nThe only major OOP concept it does not yet capture is customization by inheritance.\nIn some sense, we’re already doing inheritance, because instances inherit methods from\ntheir classes. To demonstrate the real power of OOP, though, we need to define a\nsuperclass/subclass relationship that allows us to extend our software and replace bits\nof inherited behavior. That’s the main idea behind OOP, after all; by fostering a coding\nmodel based upon customization of work already done, it can dramatically cut development time.",
    "Coding Subclasses\nAs a next step, then, let’s put OOP’s methodology to use and customize our Person\nclass by extending our software hierarchy. For the purpose of this tutorial, we’ll define\na subclass of Person called Manager that replaces the inherited giveRaise method with\na more specialized version. Our new class begins as follows:\nclass Manager(Person):\n\n# Define a subclass of Person\n\nThis code means that we’re defining a new class named Manager, which inherits from\nand may add customizations to the superclass Person. In plain terms, a Manager is almost\n\nStep 4: Customizing Behavior by Subclassing | 653",
    "Step 4: Customizing Behavior by Subclassing | 653\n\n\flike a Person (admittedly, a very long journey for a very small joke...), but Manager has\na custom way to give raises.\nFor the sake of argument, let’s assume that when a Manager gets a raise, it receives the\npassed-in percentage as usual, but also gets an extra bonus that defaults to 10%. For\ninstance, if a Manager’s raise is specified as 10%, it will really get 20%. (Any relation to\nPersons living or dead is, of course, strictly coincidental.) Our new method begins as\nfollows; because this redefinition of giveRaise will be closer in the class tree to\nManager instances than the original version in Person, it effectively replaces, and thereby\ncustomizes, the operation. Recall that according to the inheritance search rules, the\nlowest version of the name wins:\nclass Manager(Person):\ndef giveRaise(self, percent, bonus=.10):\n\n# Inherit Person attrs\n# Redefine to customize",
    "# Inherit Person attrs\n# Redefine to customize\n\nAugmenting Methods: The Bad Way\nNow, there are two ways we might code this Manager customization: a good way and a\nbad way. Let’s start with the bad way, since it might be a bit easier to understand. The\nbad way is to cut and paste the code of giveRaise in Person and modify it for Manager,\nlike this:\nclass Manager(Person):\ndef giveRaise(self, percent, bonus=.10):\nself.pay = int(self.pay * (1 + percent + bonus))\n\n# Bad: cut-and-paste",
    "# Bad: cut-and-paste\n\nThis works as advertised—when we later call the giveRaise method of a Manager instance, it will run this custom version, which tacks on the extra bonus. So what’s wrong\nwith something that runs correctly?\nThe problem here is a very general one: any time you copy code with cut and paste,\nyou essentially double your maintenance effort in the future. Think about it: because\nwe copied the original version, if we ever have to change the way raises are given (and\nwe probably will), we’ll have to change the code in two places, not one. Although this\nis a small and artificial example, it’s also representative of a universal issue—any time\nyou’re tempted to program by copying code this way, you probably want to look for a\nbetter approach.",
    "Augmenting Methods: The Good Way\nWhat we really want to do here is somehow augment the original giveRaise, instead of\nreplacing it altogether. The good way to do that in Python is by calling to the original\nversion directly, with augmented arguments, like this:\nclass Manager(Person):\ndef giveRaise(self, percent, bonus=.10):\nPerson.giveRaise(self, percent + bonus)\n\n654 | Chapter 27: A More Realistic Example\n\n# Good: augment original\n\n\fThis code leverages the fact that a class method can always be called either through an\ninstance (the usual way, where Python sends the instance to the self argument automatically) or through the class (the less common scheme, where you must pass the\ninstance manually). In more symbolic terms, recall that a normal method call of this\nform:\ninstance.method(args...)\n\nis automatically translated by Python into this equivalent form:\nclass.method(instance, args...)",
    "where the class containing the method to be run is determined by the inheritance search\nrule applied to the method’s name. You can code either form in your script, but there\nis a slight asymmetry between the two—you must remember to pass along the instance\nmanually if you call through the class directly. The method always needs a subject\ninstance one way or another, and Python provides it automatically only for calls made\nthrough an instance. For calls through the class name, you need to send an instance to\nself yourself; for code inside a method like giveRaise, self already is the subject of the\ncall, and hence the instance to pass along.\nCalling through the class directly effectively subverts inheritance and kicks the call\nhigher up the class tree to run a specific version. In our case, we can use this technique\nto invoke the default giveRaise in Person, even though it’s been redefined at the\nManager level. In some sense, we must call through Person this way, because a",
    "call, and hence the instance to pass along.\nCalling through the class directly effectively subverts inheritance and kicks the call\nhigher up the class tree to run a specific version. In our case, we can use this technique\nto invoke the default giveRaise in Person, even though it’s been redefined at the\nManager level. In some sense, we must call through Person this way, because a\nself.giveRaise() inside Manager’s giveRaise code would loop—since self already is a\nManager, self.giveRaise() would resolve again to Manager.giveRaise, and so on and so\nforth until available memory is exhausted.\nThis “good” version may seem like a small difference in code, but it can make a huge\ndifference for future code maintenance—because the giveRaise logic lives in just one\nplace now (Person’s method), we have only one version to change in the future as needs\nevolve. And really, this form captures our intent more directly anyhow—we want to",
    "forth until available memory is exhausted.\nThis “good” version may seem like a small difference in code, but it can make a huge\ndifference for future code maintenance—because the giveRaise logic lives in just one\nplace now (Person’s method), we have only one version to change in the future as needs\nevolve. And really, this form captures our intent more directly anyhow—we want to\nperform the standard giveRaise operation, but simply tack on an extra bonus. Here’s\nour entire module file with this step applied:\n# Add customization of one behavior in a subclass\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\ndef __str__(self):\nreturn '[Person: %s, %s]' % (self.name, self.pay)\nclass Manager(Person):",
    "Step 4: Customizing Behavior by Subclassing | 655\n\n\fdef giveRaise(self, percent, bonus=.10):\nPerson.giveRaise(self, percent + bonus)\nif __name__ == '__main__':\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob)\nprint(sue)\nprint(bob.lastName(), sue.lastName())\nsue.giveRaise(.10)\nprint(sue)\ntom = Manager('Tom Jones', 'mgr', 50000)\ntom.giveRaise(.10)\nprint(tom.lastName())\nprint(tom)\n\n# Redefine at this level\n# Call Person's version\n\n# Make a Manager: __init__\n# Runs custom version\n# Runs inherited method\n# Runs inherited __str__\n\nTo test our Manager subclass customization, we’ve also added self-test code that makes\na Manager, calls its methods, and prints it. Here’s the new version’s output:\n[Person: Bob Smith, 0]\n[Person: Sue Jones, 100000]\nSmith Jones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]",
    "# Make a Manager: __init__\n# Runs custom version\n# Runs inherited method\n# Runs inherited __str__\n\nTo test our Manager subclass customization, we’ve also added self-test code that makes\na Manager, calls its methods, and prints it. Here’s the new version’s output:\n[Person: Bob Smith, 0]\n[Person: Sue Jones, 100000]\nSmith Jones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]\n\nEverything looks good here: bob and sue are as before, and when tom the Manager is\ngiven a 10% raise, he really gets 20% (his pay goes from $50K to $60K), because the\ncustomized giveRaise in Manager is run for him only. Also notice how printing tom as a\nwhole at the end of the test code displays the nice format defined in Person’s __str__:\nManager objects get this, lastName, and the __init__ constructor method’s code “for\nfree” from Person, by inheritance.",
    "Polymorphism in Action\nTo make this acquisition of inherited behavior even more striking, we can add the\nfollowing code at the end of our file:\nif __name__ == '__main__':\n...\nprint('--All three--')\nfor object in (bob, sue, tom):\nobject.giveRaise(.10)\nprint(object)\n\nHere’s the resulting output:\n[Person: Bob Smith, 0]\n[Person: Sue Jones, 100000]\nSmith Jones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]\n--All three--\n\n656 | Chapter 27: A More Realistic Example\n\n# Process objects generically\n# Run this object's giveRaise\n# Run the common __str__\n\n\f[Person: Bob Smith, 0]\n[Person: Sue Jones, 121000]\n[Person: Tom Jones, 72000]",
    "In the added code, object is either a Person or a Manager, and Python runs the appropriate giveRaise automatically—our original version in Person for bob and sue, and our\ncustomized version in Manager for tom. Trace the method calls yourself to see how Python selects the right giveRaise method for each object.\nThis is just Python’s notion of polymorphism, which we met earlier in the book, at work\nagain—what giveRaise does depends on what you do it to. Here, it’s made all the more\nobvious when it selects from code we’ve written ourselves in classes. The practical effect\nin this code is that sue gets another 10% but tom gets another 20%, because\ngiveRaise is dispatched based upon the object’s type. As we’ve learned, polymorphism\nis at the heart of Python’s flexibility. Passing any of our three objects to a function that\ncalls a giveRaise method, for example, would have the same effect: the appropriate\nversion would be run automatically, depending on which type of object was passed.",
    "giveRaise is dispatched based upon the object’s type. As we’ve learned, polymorphism\nis at the heart of Python’s flexibility. Passing any of our three objects to a function that\ncalls a giveRaise method, for example, would have the same effect: the appropriate\nversion would be run automatically, depending on which type of object was passed.\nOn the other hand, printing runs the same __str__ for all three objects, because it’s\ncoded just once in Person. Manager both specializes and applies the code we originally\nwrote in Person. Although this example is small, it’s already leveraging OOP’s talent\nfor code customization and reuse; with classes, this almost seems automatic at times.",
    "Inherit, Customize, and Extend\nIn fact, classes can be even more flexible than our example implies. In general, classes\ncan inherit, customize, or extend existing code in superclasses. For example, although\nwe’re focused on customization here, we can also add unique methods to Manager that\nare not present in Person, if Managers require something completely different (Python\nnamesake reference intended). The following snippet illustrates. Here, giveRaise redefines a superclass method to customize it, but someThingElse defines something new\nto extend:\nclass Person:\ndef lastName(self): ...\ndef giveRaise(self): ...\ndef __str__(self): ...\nclass Manager(Person):\ndef giveRaise(self, ...): ...\ndef someThingElse(self, ...): ...\n\n# Inherit\n# Customize\n# Extend\n\ntom = Manager()\ntom.lastName()\ntom.giveRaise()\ntom.someThingElse()\nprint(tom)\n\n# Inherited verbatim\n# Customized version\n# Extension here\n# Inherited overload method",
    "# Inherit\n# Customize\n# Extend\n\ntom = Manager()\ntom.lastName()\ntom.giveRaise()\ntom.someThingElse()\nprint(tom)\n\n# Inherited verbatim\n# Customized version\n# Extension here\n# Inherited overload method\n\nExtra methods like this code’s someThingElse extend the existing software and are available on Manager objects only, not on Persons. For the purposes of this tutorial, however,\nStep 4: Customizing Behavior by Subclassing | 657\n\n\fwe’ll limit our scope to customizing some of Person’s behavior by redefining it, not\nadding to it.",
    "OOP: The Big Idea\nAs is, our code may be small, but it’s fairly functional. And really, it already illustrates\nthe main point behind OOP in general: in OOP, we program by customizing what has\nalready been done, rather than copying or changing existing code. This isn’t always an\nobvious win to newcomers at first glance, especially given the extra coding requirements\nof classes. But overall, the programming style implied by classes can cut development\ntime radically compared to other approaches.\nFor instance, in our example we could theoretically have implemented a custom\ngiveRaise operation without subclassing, but none of the other options yield code as\noptimal as ours:\n• Although we could have simply coded Manager from scratch as new, independent\ncode, we would have had to reimplement all the behaviors in Person that are the\nsame for Managers.\n• Although we could have simply changed the existing Person class in-place for the",
    "giveRaise operation without subclassing, but none of the other options yield code as\noptimal as ours:\n• Although we could have simply coded Manager from scratch as new, independent\ncode, we would have had to reimplement all the behaviors in Person that are the\nsame for Managers.\n• Although we could have simply changed the existing Person class in-place for the\nrequirements of Manager’s giveRaise, doing so would probably break the places\nwhere we still need the original Person behavior.\n• Although we could have simply copied the Person class in its entirety, renamed the\ncopy to Manager, and changed its giveRaise, doing so would introduce code redundancy that would double our work in the future—changes made to Person in\nthe future would not be picked up automatically, but would have to be manually\npropagated to Manager’s code. As usual, the cut-and-paste approach may seem\nquick now, but it doubles your work in the future.",
    "copy to Manager, and changed its giveRaise, doing so would introduce code redundancy that would double our work in the future—changes made to Person in\nthe future would not be picked up automatically, but would have to be manually\npropagated to Manager’s code. As usual, the cut-and-paste approach may seem\nquick now, but it doubles your work in the future.\nThe customizable hierarchies we can build with classes provide a much better solution\nfor software that will evolve over time. No other tools in Python support this development mode. Because we can tailor and extend our prior work by coding new subclasses,\nwe can leverage what we’ve already done, rather than starting from scratch each time,\nbreaking what already works, or introducing multiple copies of code that may all have\nto be updated in the future. When done right, OOP is a powerful programmer’s ally.",
    "Step 5: Customizing Constructors, Too\nOur code works as it is, but if you study the current version closely, you may be struck\nby something a bit odd—it seems pointless to have to provide a mgr job name for\nManager objects when we create them: this is already implied by the class itself. It would\nbe better if we could somehow fill in this value automatically when a Manager is made.\nThe trick we need to improve on this turns out to be the same as the one we employed\nin the prior section: we want to customize the constructor logic for Managers in such a\n658 | Chapter 27: A More Realistic Example",
    "way as to provide a job name automatically. In terms of code, we want to redefine an\n__init__ method in Manager that provides the mgr string for us. And like with the\ngiveRaise customization, we also want to run the original __init__ in Person by calling\nthrough the class name, so it still initializes our objects’ state information attributes.\nThe following extension will do the job—we’ve coded the new Manager constructor and\nchanged the call that creates tom to not pass in the mgr job name:\n# Add customization of constructor in a subclass\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\ndef __str__(self):\nreturn '[Person: %s, %s]' % (self.name, self.pay)\nclass Manager(Person):\ndef __init__(self, name, pay):\nPerson.__init__(self, name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):",
    "self.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\ndef __str__(self):\nreturn '[Person: %s, %s]' % (self.name, self.pay)\nclass Manager(Person):\ndef __init__(self, name, pay):\nPerson.__init__(self, name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):\nPerson.giveRaise(self, percent + bonus)",
    "# Redefine constructor\n# Run original with 'mgr'\n\nif __name__ == '__main__':\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob)\nprint(sue)\nprint(bob.lastName(), sue.lastName())\nsue.giveRaise(.10)\nprint(sue)\ntom = Manager('Tom Jones', 50000)\ntom.giveRaise(.10)\nprint(tom.lastName())\nprint(tom)\n\n# Job name not needed:\n# Implied/set by class",
    "# Job name not needed:\n# Implied/set by class\n\nAgain, we’re using the same technique to augment the __init__ constructor here that\nwe used for giveRaise earlier—running the superclass version by calling through the\nclass name directly and passing the self instance along explicitly. Although the constructor has a strange name, the effect is identical. Because we need Person’s construction logic to run too (to initialize instance attributes), we really have to call it this way;\notherwise, instances would not have any attributes attached.\nCalling superclass constructors from redefinitions this way turns out to be a very\ncommon coding pattern in Python. By itself, Python uses inheritance to look for and\ncall only one __init__ method at construction time—the lowest one in the class tree. If\nyou need higher __init__ methods to be run at construction time (and you usually do),\n\nStep 5: Customizing Constructors, Too | 659",
    "Step 5: Customizing Constructors, Too | 659\n\n\fyou must call them manually through the superclass’s name. The upside to this is that\nyou can be explicit about which argument to pass up to the superclass’s constructor\nand can choose to not call it at all: not calling the superclass constructor allows you to\nreplace its logic altogether, rather than augmenting it.\nThe output of this file’s self-test code is the same as before—we haven’t changed what\nit does, we’ve simply restructured to get rid of some logical redundancy:\n[Person: Bob Smith, 0]\n[Person: Sue Jones, 100000]\nSmith Jones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]",
    "OOP Is Simpler Than You May Think\nIn this complete form, despite their sizes, our classes capture nearly all the important\nconcepts in Python’s OOP machinery:\n• Instance creation—filling out instance attributes\n• Behavior methods—encapsulating logic in class methods\n• Operator overloading—providing behavior for built-in operations like printing\n• Customizing behavior—redefining methods in subclasses to specialize them\n• Customizing constructors—adding initialization logic to superclass steps\nMost of these concepts are based upon just three simple ideas: the inheritance search\nfor attributes in object trees, the special self argument in methods, and operator overloading’s automatic dispatch to methods.\nAlong the way, we’ve also made our code easy to change in the future, by harnessing\nthe class’s propensity for factoring code to reduce redundancy. For example, we wrapped up logic in methods and called back to superclass methods from extensions to",
    "for attributes in object trees, the special self argument in methods, and operator overloading’s automatic dispatch to methods.\nAlong the way, we’ve also made our code easy to change in the future, by harnessing\nthe class’s propensity for factoring code to reduce redundancy. For example, we wrapped up logic in methods and called back to superclass methods from extensions to\navoid having multiple copies of the same code. Most of these steps were a natural\noutgrowth of the structuring power of classes.\nBy and large, that’s all there is to OOP in Python. Classes certainly can become larger\nthan this, and there are some more advanced class concepts, such as decorators and\nmetaclasses, which we will meet in later chapters. In terms of the basics, though, our\nclasses already do it all. In fact, if you’ve grasped the workings of the classes we’ve\nwritten, most OOP Python code should now be within your reach.",
    "Other Ways to Combine Classes\nHaving said that, I should also tell you that although the basic mechanics of OOP are\nsimple in Python, some of the art in larger programs lies in the way that classes are put\ntogether. We’re focusing on inheritance in this tutorial because that’s the mechanism\n\n660 | Chapter 27: A More Realistic Example",
    "the Python language provides, but programmers sometimes combine classes in other\nways, too. For example, a common coding pattern involves nesting objects inside each\nother to build up composites. We’ll explore this pattern in more detail in Chapter 30,\nwhich is really more about design than about Python; as a quick example, though, we\ncould use this composition idea to code our Manager extension by embedding a\nPerson, instead of inheriting from it.\nThe following alternative does so by using the __getattr__ operator overloading\nmethod we will meet in Chapter 29 to intercept undefined attribute fetches and delegate\nthem to the embedded object with the getattr built-in. The giveRaise method here\nstill achieves customization, by changing the argument passed along to the embedded\nobject. In effect, Manager becomes a controller layer that passes calls down to the embedded object, rather than up to superclass methods:\n# Embedding-based Manager alternative\nclass Person:\n...same...",
    "them to the embedded object with the getattr built-in. The giveRaise method here\nstill achieves customization, by changing the argument passed along to the embedded\nobject. In effect, Manager becomes a controller layer that passes calls down to the embedded object, rather than up to superclass methods:\n# Embedding-based Manager alternative\nclass Person:\n...same...\nclass Manager:\ndef __init__(self, name, pay):\nself.person = Person(name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):\nself.person.giveRaise(percent + bonus)\ndef __getattr__(self, attr):\nreturn getattr(self.person, attr)\ndef __str__(self):\nreturn str(self.person)",
    "# Embed a Person object\n# Intercept and delegate\n# Delegate all other attrs\n# Must overload again (in 3.0)\n\nif __name__ == '__main__':\n...same...",
    "In fact, this Manager alternative is representative of a general coding pattern usually\nknown as delegation—a composite-based structure that manages a wrapped object and\npropagates method calls to it. This pattern works in our example, but it requires about\ntwice as much code and is less well suited than inheritance to the kinds of direct customizations we meant to express (in fact, no reasonable Python programmer would\ncode this example this way in practice, except perhaps those writing general tutorials).\nManager isn’t really a Person here, so we need extra code to manually dispatch method\ncalls to the embedded object; operator overloading methods like __str__ must be redefined (in 3.0, at least, as noted in the upcoming sidebar “Catching Built-in Attributes\nin 3.0” on page 662), and adding new Manager behavior is less straightforward since\nstate information is one level removed.\nStill, object embedding, and design patterns based upon it, can be a very good fit when",
    "calls to the embedded object; operator overloading methods like __str__ must be redefined (in 3.0, at least, as noted in the upcoming sidebar “Catching Built-in Attributes\nin 3.0” on page 662), and adding new Manager behavior is less straightforward since\nstate information is one level removed.\nStill, object embedding, and design patterns based upon it, can be a very good fit when\nembedded objects require more limited interaction with the container than direct customization implies. A controller layer like this alternative Manager, for example, might\ncome in handy if we want to trace or validate calls to another object’s methods (indeed,\nwe will use a nearly identical coding pattern when we study class decorators later in the",
    "Step 5: Customizing Constructors, Too | 661\n\n\fbook). Moreover, a hypothetical Department class like the following could aggregate\nother objects in order to treat them as a set. Add this to the bottom of the person.py file\nto try this on your own:\n# Aggregate embedded objects into a composite\n...\nbob = Person(...)\nsue = Person(...)\ntom = Manager(...)\nclass Department:\ndef __init__(self, *args):\nself.members = list(args)\ndef addMember(self, person):\nself.members.append(person)\ndef giveRaises(self, percent):\nfor person in self.members:\nperson.giveRaise(percent)\ndef showAll(self):\nfor person in self.members:\nprint(person)\ndevelopment = Department(bob, sue)\ndevelopment.addMember(tom)\ndevelopment.giveRaises(.10)\ndevelopment.showAll()\n\n# Embed objects in a composite\n# Runs embedded objects' giveRaise\n# Runs embedded objects' __str__s",
    "Interestingly, this code uses both inheritance and composition—Department is a composite that embeds and controls other objects to aggregate, but the embedded Person\nand Manager objects themselves use inheritance to customize. As another example, a\nGUI might similarly use inheritance to customize the behavior or appearance of labels\nand buttons, but also composition to build up larger packages of embedded widgets,\nsuch as input forms, calculators, and text editors. The class structure to use depends\non the objects you are trying to model.\nDesign issues like composition are explored in Chapter 30, so we’ll postpone further\ninvestigations for now. But again, in terms of the basic mechanics of OOP in Python,\nour Person and Manager classes already tell the entire story. Having mastered the basics\nof OOP, though, developing general tools for applying it more easily in your scripts is\noften a natural next step—and the topic of the next section.",
    "Catching Built-in Attributes in 3.0\nIn Python 3.0 (and 2.6 if new-style classes are used), the alternative delegation-based\nManager class we just coded will not be able to intercept and delegate operator overloading method attributes like __str__ without redefining them. Although we know\nthat __str__ is the only such name used in our specific example, this a general issue for\ndelegation-based classes.\nRecall that built-in operations like printing and indexing implicitly invoke operator\noverloading methods such as __str__ and __getitem__. In 3.0, built-in operations like\n662 | Chapter 27: A More Realistic Example",
    "these do not route their implicit attribute fetches through generic attribute managers:\nneither __getattr__ (run for undefined attributes) nor its cousin __getattribute__ (run\nfor all attributes) is invoked. This is why we have to redefine __str__ redundantly in\nthe alternative Manager, in order to ensure that printing is routed to the embedded\nPerson object when run in Python 3.0.\nTechnically, this happens because classic classes normally look up operator overloading\nnames in instances at runtime, but new-style classes do not—they skip the instance\nentirely and look up such methods in classes. In 2.6 classic classes, built-ins do route\nattributes generically—printing, for example, routes __str__ through __getattr__.\nNew-style classes also inherit a default for __str__ that would foil __getattr__, but\n__getattribute__ doesn’t intercept the name in 3.0 either.",
    "names in instances at runtime, but new-style classes do not—they skip the instance\nentirely and look up such methods in classes. In 2.6 classic classes, built-ins do route\nattributes generically—printing, for example, routes __str__ through __getattr__.\nNew-style classes also inherit a default for __str__ that would foil __getattr__, but\n__getattribute__ doesn’t intercept the name in 3.0 either.\nThis is a change, but isn’t a show-stopper—delegation-based classes can generally redefine operator overloading methods to delegate them to wrapped objects in 3.0, either\nmanually or via tools or superclasses. This topic is too advanced to explore further in\nthis tutorial, though, so don’t sweat the details too much here. Watch for it to be\nrevisited in the attribute management coverage of Chapter 37, and again in the context\nof Private class decorators in Chapter 38.",
    "Step 6: Using Introspection Tools\nLet’s make one final tweak before we throw our objects onto a database. As they are,\nour classes are complete and demonstrate most of the basics of OOP in Python. They\nstill have two remaining issues we probably should iron out, though, before we go live\nwith them:\n• First, if you look at the display of the objects as they are right now, you’ll notice\nthat when you print tom the Manager labels him as a Person. That’s not technically\nincorrect, since Manager is a kind of customized and specialized Person. Still, it\nwould be more accurate to display objects with the most specific (that is, lowest)\nclasses possible.\n• Second, and perhaps more importantly, the current display format shows only the\nattributes we include in our __str__, and that might not account for future goals.\nFor example, we can’t yet verify that tom’s job name has been set to mgr correctly\nby Manager’s constructor, because the __str__ we coded for Person does not print",
    "classes possible.\n• Second, and perhaps more importantly, the current display format shows only the\nattributes we include in our __str__, and that might not account for future goals.\nFor example, we can’t yet verify that tom’s job name has been set to mgr correctly\nby Manager’s constructor, because the __str__ we coded for Person does not print\nthis field. Worse, if we ever expand or otherwise change the set of attributes assigned to our objects in __init__, we’ll have to remember to also update __str__\nfor new names to be displayed, or it will become out of sync over time.\nThe last point means that, yet again, we’ve made potential extra work for ourselves in\nthe future by introducing redundancy in our code. Because any disparity in __str__ will\nbe reflected in the program’s output, this redundancy may be more obvious than the\nother forms we addressed earlier; still, avoiding extra work in the future is generally a\ngood thing.",
    "Step 6: Using Introspection Tools | 663",
    "Special Class Attributes\nWe can address both issues with Python’s introspection tools—special attributes and\nfunctions that give us access to some of the internals of objects’ implementations. These\ntools are somewhat advanced and generally used more by people writing tools for other\nprogrammers to use than by programmers developing applications. Even so, a basic\nknowledge of some of these tools is useful because they allow us to write code that\nprocesses classes in generic ways. In our code, for example, there are two hooks that\ncan help us out, both of which were introduced near the end of the preceding chapter:\n• The built-in instance.__class__ attribute provides a link from an instance to the\nclass from which it was created. Classes in turn have a __name__, just like modules,\nand a __bases__ sequence that provides access to superclasses. We can use these\nhere to print the name of the class from which an instance is made rather than one\nwe’ve hardcoded.",
    "• The built-in instance.__class__ attribute provides a link from an instance to the\nclass from which it was created. Classes in turn have a __name__, just like modules,\nand a __bases__ sequence that provides access to superclasses. We can use these\nhere to print the name of the class from which an instance is made rather than one\nwe’ve hardcoded.\n• The built-in object.__dict__ attribute provides a dictionary with one key/value\npair for every attribute attached to a namespace object (including modules, classes,\nand instances). Because it is a dictionary, we can fetch its keys list, index by key,\niterate over its keys, and so on, to process all attributes generically. We can use this\nhere to print every attribute in any instance, not just those we hardcode in custom\ndisplays.\nHere’s what these tools look like in action at Python’s interactive prompt. Notice how\nwe load Person at the interactive prompt with a from statement here—class names live",
    "iterate over its keys, and so on, to process all attributes generically. We can use this\nhere to print every attribute in any instance, not just those we hardcode in custom\ndisplays.\nHere’s what these tools look like in action at Python’s interactive prompt. Notice how\nwe load Person at the interactive prompt with a from statement here—class names live\nin and are imported from modules, exactly like function names and other variables:\n>>> from person import Person\n>>> bob = Person('Bob Smith')\n>>> print(bob)\n[Person: Bob Smith, 0]",
    "# Show bob's __str__\n\n>>> bob.__class__\n<class 'person.Person'>\n>>> bob.__class__.__name__\n'Person'\n\n# Show bob's class and its name\n\n>>> list(bob.__dict__.keys())\n['pay', 'job', 'name']\n\n# Attributes are really dict keys\n# Use list to force list in 3.0\n\n>>> for key in bob.__dict__:\nprint(key, '=>', bob.__dict__[key])\n\n# Index manually\n\npay => 0\njob => None\nname => Bob Smith\n>>> for key in bob.__dict__:\nprint(key, '=>', getattr(bob, key))\npay => 0\n\n664 | Chapter 27: A More Realistic Example\n\n# obj.attr, but attr is a var\n\n\fjob => None\nname => Bob Smith",
    "# Attributes are really dict keys\n# Use list to force list in 3.0\n\n>>> for key in bob.__dict__:\nprint(key, '=>', bob.__dict__[key])\n\n# Index manually\n\npay => 0\njob => None\nname => Bob Smith\n>>> for key in bob.__dict__:\nprint(key, '=>', getattr(bob, key))\npay => 0\n\n664 | Chapter 27: A More Realistic Example\n\n# obj.attr, but attr is a var\n\n\fjob => None\nname => Bob Smith\n\nAs noted briefly in the prior chapter, some attributes accessible from an instance might\nnot be stored in the __dict__ dictionary if the instance’s class defines __slots__, an\noptional and relatively obscure feature of new-style classes (and all classes in Python\n3.0) that stores attributes in an array and that we’ll discuss in Chapters 30 and 31. Since\nslots really belong to classes instead of instances, and since they are very rarely used in\nany event, we can safely ignore them here and focus on the normal __dict__.",
    "A Generic Display Tool\nWe can put these interfaces to work in a superclass that displays accurate class names\nand formats all attributes of an instance of any class. Open a new file in your text editor\nto code the following—it’s a new, independent module named classtools.py that implements just such a class. Because its __str__ print overload uses generic introspection\ntools, it will work on any instance, regardless of its attributes set. And because this is a\nclass, it automatically becomes a general formatting tool: thanks to inheritance, it can\nbe mixed into any class that wishes to use its display format. As an added bonus, if we\never want to change how instances are displayed we need only change this class, as\nevery class that inherits its __str__ will automatically pick up the new format when it’s\nnext run:\n# File classtools.py (new)\n\"Assorted class utilities and tools\"\nclass AttrDisplay:\n\"\"\"\nProvides an inheritable print overload method that displays",
    "ever want to change how instances are displayed we need only change this class, as\nevery class that inherits its __str__ will automatically pick up the new format when it’s\nnext run:\n# File classtools.py (new)\n\"Assorted class utilities and tools\"\nclass AttrDisplay:\n\"\"\"\nProvides an inheritable print overload method that displays\ninstances with their class names and a name=value pair for\neach attribute stored on the instance itself (but not attrs\ninherited from its classes). Can be mixed into any class,\nand will work on any instance.\n\"\"\"\ndef gatherAttrs(self):\nattrs = []\nfor key in sorted(self.__dict__):\nattrs.append('%s=%s' % (key, getattr(self, key)))\nreturn ', '.join(attrs)\ndef __str__(self):\nreturn '[%s: %s]' % (self.__class__.__name__, self.gatherAttrs())\nif __name__ == '__main__':\nclass TopTest(AttrDisplay):\ncount = 0\ndef __init__(self):\nself.attr1 = TopTest.count\nself.attr2 = TopTest.count+1\nTopTest.count += 2",
    "Step 6: Using Introspection Tools | 665\n\n\fclass SubTest(TopTest):\npass\nX, Y = TopTest(), SubTest()\nprint(X)\nprint(Y)\n\n# Show all instance attrs\n# Show lowest class name\n\nNotice the docstrings here—as a general-purpose tool, we want to add some functional\ndocumentation for potential users to read. As we saw in Chapter 15, docstrings can be\nplaced at the top of simple functions and modules, and also at the start of classes and\ntheir methods; the help function and the PyDoc tool extracts and displays these automatically (we’ll look at docstrings again in Chapter 28).\nWhen run directly, this module’s self-test makes two instances and prints them; the\n__str__ defined here shows the instance’s class, and all its attributes names and values,\nin sorted attribute name order:\nC:\\misc> classtools.py\n[TopTest: attr1=0, attr2=1]\n[SubTest: attr1=2, attr2=3]",
    "Instance Versus Class Attributes\nIf you study the classtools module’s self-test code long enough, you’ll notice that its\nclass displays only instance attributes, attached to the self object at the bottom of the\ninheritance tree; that’s what self’s __dict__ contains. As an intended consequence, we\ndon’t see attributes inherited by the instance from classes above it in the tree (e.g.,\ncount in this file’s self-test code). Inherited class attributes are attached to the class only,\nnot copied down to instances.\nIf you ever do wish to include inherited attributes too, you can climb the __class__ link\nto the instance’s class, use the __dict__ there to fetch class attributes, and then iterate\nthrough the class’s __bases__ attribute to climb to even higher superclasses (repeating\nas necessary). If you’re a fan of simple code, running a built-in dir call on the instance\ninstead of using __dict__ and climbing would have much the same effect, since dir",
    "to the instance’s class, use the __dict__ there to fetch class attributes, and then iterate\nthrough the class’s __bases__ attribute to climb to even higher superclasses (repeating\nas necessary). If you’re a fan of simple code, running a built-in dir call on the instance\ninstead of using __dict__ and climbing would have much the same effect, since dir\nresults include inherited names in the sorted results list:\n>>> from person import Person\n>>> bob = Person('Bob Smith')\n# In Python 2.6:\n>>> bob.__dict__.keys()\n['pay', 'job', 'name']",
    "# Instance attrs only\n\n>>> dir(bob)\n# + inherited attrs in classes\n['__doc__', '__init__', '__module__', '__str__', 'giveRaise', 'job',\n'lastName', 'name', 'pay']\n# In Python 3.0:\n\n666 | Chapter 27: A More Realistic Example\n\n\f# 3.0 keys is a view, not a list\n\n>>> list(bob.__dict__.keys())\n['pay', 'job', 'name']\n\n>>> dir(bob)\n# 3.0 includes class type methods\n['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__',\n'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__',\n...more lines omitted...\n'__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',\n'giveRaise', 'job', 'lastName', 'name', 'pay']",
    "The output here varies between Python 2.6 and 3.0, because 3.0’s dict.keys is not a\nlist, and 3.0’s dir returns extra class-type implementation attributes. Technically, dir\nreturns more in 3.0 because classes are all “new style” and inherit a large set of operator\noverloading names from the class type. In fact, you’ll probably want to filter out most\nof the __X__ names in the 3.0 dir result, since they are internal implementation details\nand not something you’d normally want to display.\nIn the interest of space, we’ll leave optional display of inherited class attributes with\neither tree climbs or dir as suggested experiments for now. For more hints on this front,\nthough, watch for the classtree.py inheritance tree climber we will write in Chapter 28, and the lister.py attribute listers and climbers we’ll code in Chapter 30.",
    "Name Considerations in Tool Classes\nOne last subtlety here: because our AttrDisplay class in the classtools module is a\ngeneral tool designed to be mixed into other arbitrary classes, we have to be aware of\nthe potential for unintended name collisions with client classes. As is, I’ve assumed that\nclient subclasses may want to use both its __str__ and gatherAttrs, but the latter of\nthese may be more than a subclass expects—if a subclass innocently defines a gather\nAttrs name of its own, it will likely break our class, because the lower version in the\nsubclass will be used instead of ours.\nTo see this for yourself, add a gatherAttrs to TopTest in the file’s self-test code; unless\nthe new method is identical, or intentionally customizes the original, our tool class will\nno longer work as planned:\nclass TopTest(AttrDisplay):\n....\ndef gatherAttrs(self):\nreturn 'Spam'\n\n# Replaces method in AttrDisplay!",
    "# Replaces method in AttrDisplay!\n\nThis isn’t necessarily bad—sometimes we want other methods to be available to subclasses, either for direct calls or for customization. If we really meant to provide a\n__str__ only, though, this is less than ideal.\nTo minimize the chances of name collisions like this, Python programmers often prefix\nmethods not meant for external use with a single underscore: _gatherAttrs in our case.\nThis isn’t foolproof (what if another class defines _gatherAttrs, too?), but it’s usually\nsufficient, and it’s a common Python naming convention for methods internal to a class.\n\nStep 6: Using Introspection Tools | 667",
    "Step 6: Using Introspection Tools | 667\n\n\fA better and less commonly used solution would be to use two underscores at the front\nof the method name only: __gatherAttrs for us. Python automatically expands such\nnames to include the enclosing class’s name, which makes them truly unique. This is\na feature usually called pseudoprivate class attributes, which we’ll expand on in Chapter 30. For now, we’ll make both our methods available.\n\nOur Classes’ Final Form\nNow, to use this generic tool in our classes, all we need to do is import it from its\nmodule, mix it in by inheritance in our top-level class, and get rid of the more specific\n__str__ we coded before. The new print overload method will be inherited by instances\nof Person, as well as Manager; Manager gets __str__ from Person, which now obtains it\nfrom the AttrDisplay coded in another module. Here is the final version of our\nperson.py file with these changes applied:\n# File person.py (final)\n# Use generic display tool",
    "from classtools import AttrDisplay\nclass Person(AttrDisplay):\n\"\"\"\nCreate and process person records\n\"\"\"\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\n\n# Assumes last is last\n\nclass Manager(Person):\n\"\"\"\nA customized Person with special requirements\n\"\"\"\ndef __init__(self, name, pay):\nPerson.__init__(self, name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):\nPerson.giveRaise(self, percent + bonus)\n\n# Percent must be 0..1\n\nif __name__ == '__main__':\nbob = Person('Bob Smith')\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(bob)\nprint(sue)\nprint(bob.lastName(), sue.lastName())\nsue.giveRaise(.10)\nprint(sue)\ntom = Manager('Tom Jones', 50000)\ntom.giveRaise(.10)\n\n668 | Chapter 27: A More Realistic Example\n\n\fprint(tom.lastName())\nprint(tom)",
    "668 | Chapter 27: A More Realistic Example\n\n\fprint(tom.lastName())\nprint(tom)\n\nAs this is the final revision, we’ve added a few comments here to document our work—\ndocstrings for functional descriptions and # for smaller notes, per best-practice conventions. When we run this code now, we see all the attributes of our objects, not just\nthe ones we hardcoded in the original __str__. And our final issue is resolved: because\nAttrDisplay takes class names off the self instance directly, each object is shown with\nthe name of its closest (lowest) class—tom displays as a Manager now, not a Person, and\nwe can finally verify that his job name has been correctly filled in by the Manager\nconstructor:\nC:\\misc> person.py\n[Person: job=None, name=Bob Smith, pay=0]\n[Person: job=dev, name=Sue Jones, pay=100000]\nSmith Jones\n[Person: job=dev, name=Sue Jones, pay=110000]\nJones\n[Manager: job=mgr, name=Tom Jones, pay=60000]",
    "This is the more useful display we were after. From a larger perspective, though, our\nattribute display class has become a general tool, which we can mix into any class by\ninheritance to leverage the display format it defines. Further, all its clients will automatically pick up future changes in our tool. Later in the book, we’ll meet even more\npowerful class tool concepts, such as decorators and metaclasses; along with Python’s\nintrospection tools, they allow us to write code that augments and manages classes in\nstructured and maintainable ways.",
    "Step 7 (Final): Storing Objects in a Database\nAt this point, our work is almost complete. We now have a two-module system that not\nonly implements our original design goals for representing people, but also provides a\ngeneral attribute display tool we can use in other programs in the future. By coding\nfunctions and classes in module files, we’ve ensured that they naturally support reuse.\nAnd by coding our software as classes, we’ve ensured that it naturally supports\nextension.\nAlthough our classes work as planned, though, the objects they create are not real\ndatabase records. That is, if we kill Python, our instances will disappear—they’re transient objects in memory and are not stored in a more permanent medium like a file, so\nthey won’t be available in future program runs. It turns out that it’s easy to make\ninstance objects more permanent, with a Python feature called object persistence—\nmaking objects live on after the program that creates them exits. As a final step in this",
    "they won’t be available in future program runs. It turns out that it’s easy to make\ninstance objects more permanent, with a Python feature called object persistence—\nmaking objects live on after the program that creates them exits. As a final step in this\ntutorial, let’s make our objects permanent.",
    "Step 7 (Final): Storing Objects in a Database | 669\n\n\fPickles and Shelves\nObject persistence is implemented by three standard library modules, available in every\nPython:\npickle\n\nSerializes arbitrary Python objects to and from a string of bytes\ndbm (named anydbm in Python 2.6)\nImplements an access-by-key filesystem for storing strings\nshelve",
    "Uses the other two modules to store Python objects on a file by key\nWe met these modules very briefly in Chapter 9 when we studied file basics. They\nprovide powerful data storage options. Although we can’t do them complete justice in\nthis tutorial or book, they are simple enough that a brief introduction is enough to get\nyou started.\nThe pickle module is a sort of super-general object formatting and deformatting tool:\ngiven a nearly arbitrary Python object in memory, it’s clever enough to convert the\nobject to a string of bytes, which it can use later to reconstruct the original object in\nmemory. The pickle module can handle almost any object you can create—lists, dictionaries, nested combinations thereof, and class instances. The latter are especially",
    "given a nearly arbitrary Python object in memory, it’s clever enough to convert the\nobject to a string of bytes, which it can use later to reconstruct the original object in\nmemory. The pickle module can handle almost any object you can create—lists, dictionaries, nested combinations thereof, and class instances. The latter are especially\nuseful things to pickle, because they provide both data (attributes) and behavior (methods); in fact, the combination is roughly equivalent to “records” and “programs.” Because pickle is so general, it can replace extra code you might otherwise write to create\nand parse custom text file representations for your objects. By storing an object’s pickle\nstring on a file, you effectively make it permanent and persistent: simply load and unpickle it later to re-create the original object.\nAlthough it’s easy to use pickle by itself to store objects in simple flat files and load",
    "and parse custom text file representations for your objects. By storing an object’s pickle\nstring on a file, you effectively make it permanent and persistent: simply load and unpickle it later to re-create the original object.\nAlthough it’s easy to use pickle by itself to store objects in simple flat files and load\nthem from there later, the shelve module provides an extra layer of structure that allows\nyou to store pickled objects by key. shelve translates an object to its pickled string with\npickle and stores that string under a key in a dbm file; when later loading, shelve fetches\nthe pickled string by key and re-creates the original object in memory with pickle. This\nis all quite a trick, but to your script a shelve* of pickled objects looks just like a dictionary—you index by key to fetch, assign to keys to store, and use dictionary tools\nsuch as len, in, and dict.keys to get information. Shelves automatically map dictionary\noperations to objects stored in a file.",
    "the pickled string by key and re-creates the original object in memory with pickle. This\nis all quite a trick, but to your script a shelve* of pickled objects looks just like a dictionary—you index by key to fetch, assign to keys to store, and use dictionary tools\nsuch as len, in, and dict.keys to get information. Shelves automatically map dictionary\noperations to objects stored in a file.\nIn fact, to your script the only coding difference between a shelve and a normal dictionary is that you must open shelves initially and must close them after making changes.\nThe net effect is that a shelve provides a simple database for storing and fetching native\nPython objects by keys, and thus makes them persistent across program runs. It does\n* Yes, we use “shelve” as a noun in Python, much to the chagrin of a variety of editors I’ve worked with over\nthe years, both electronic and human.",
    "670 | Chapter 27: A More Realistic Example\n\n\fnot support query tools such as SQL, and it lacks some advanced features found in\nenterprise-level databases (such as true transaction processing), but native Python objects stored on a shelve may be processed with the full power of the Python language\nonce they are fetched back by key.",
    "Storing Objects on a Shelve Database\nPickling and shelves are somewhat advanced topics, and we won’t go into all their\ndetails here; you can read more about them in the standard library manuals, as well as\napplication-focused books such as Programming Python. This is all simpler in Python\nthan in English, though, so let’s jump into some code.\nLet’s write a new script that throws objects of our classes onto a shelve. In your text\neditor, open a new file we’ll call makedb.py. Since this is a new file, we’ll need to import\nour classes in order to create a few instances to store. We used from to load a class at\nthe interactive prompt earlier, but really, as with functions and other variables, there\nare two ways to load a class from a file (class names are variables like any other, and\nnot at all magic in this context):\nimport person\nbob = person.Person(...)\n\n# Load class with import\n# Go through module name\n\nfrom person import Person\nbob = Person(...)",
    "# Load class with import\n# Go through module name\n\nfrom person import Person\nbob = Person(...)\n\n# Load class with from\n# Use name directly",
    "from person import Person\nbob = Person(...)\n\n# Load class with from\n# Use name directly\n\nWe’ll use from to load in our script, just because it’s a bit less to type. Copy or retype\nthis code to make instances of our classes in the new script, so we have something to\nstore (this is a simple demo, so we won’t worry about the test-code redundancy here).\nOnce we have some instances, it’s almost trivial to store them on a shelve. We simply\nimport the shelve module, open a new shelve with an external filename, assign the\nobjects to keys in the shelve, and close the shelve when we’re done because we’ve made\nchanges:\n# File makedb.py: store Person objects on a shelve database\nfrom person import Person, Manager\n# Load our classes\nbob = Person('Bob Smith')\n# Re-create objects to be stored\nsue = Person('Sue Jones', job='dev', pay=100000)\ntom = Manager('Tom Jones', 50000)\nimport shelve\ndb = shelve.open('persondb')\nfor object in (bob, sue, tom):\ndb[object.name] = object\ndb.close()",
    "# Filename where objects are stored\n# Use object's name attr as key\n# Store object on shelve by key\n# Close after making changes\n\nNotice how we assign objects to the shelve using their own names as keys. This is just\nfor convenience; in a shelve, the key can be any string, including one we might create\nto be unique using tools such as process IDs and timestamps (available in the os and\ntime standard library modules). The only rule is that the keys must be strings and should\nStep 7 (Final): Storing Objects in a Database | 671",
    "be unique, since we can store just one object per key (though that object can be a list\nor dictionary containing many objects). The values we store under keys, though, can\nbe Python objects of almost any sort: built-in types like strings, lists, and dictionaries,\nas well as user-defined class instances, and nested combinations of all of these.\nThat’s all there is to it—if this script has no output when run, it means it probably\nworked; we’re not printing anything, just creating and storing objects:\nC:\\misc> makedb.py",
    "Exploring Shelves Interactively\nAt this point, there are one or more real files in the current directory whose names all\nstart with “persondb”. The actual files created can vary per platform, and just like in\nthe built-in open function, the filename in shelve.open() is relative to the current working directory unless it includes a directory path. Wherever they are stored, these files\nimplement a keyed-access file that contains the pickled representation of our three\nPython objects. Don’t delete these files—they are your database, and are what you’ll\nneed to copy or transfer when you back up or move your storage.\nYou can look at the shelve’s files if you want to, either from Windows Explorer or the\nPython shell, but they are binary hash files, and most of their content makes little sense\noutside the context of the shelve module. With Python 3.0 and no extra software installed, our database is stored in three files (in 2.6, it’s just one file, persondb, because",
    "You can look at the shelve’s files if you want to, either from Windows Explorer or the\nPython shell, but they are binary hash files, and most of their content makes little sense\noutside the context of the shelve module. With Python 3.0 and no extra software installed, our database is stored in three files (in 2.6, it’s just one file, persondb, because\nthe bsddb extension module is preinstalled with Python for shelves; in 3.0, bsddb is a\nthird-party open source add-on):\n# Directory listing module: verify files are present\n>>> import glob\n>>> glob.glob('person*')\n['person.py', 'person.pyc', 'persondb.bak', 'persondb.dat', 'persondb.dir']\n# Type the file: text mode for string, binary mode for bytes\n>>> print(open('persondb.dir').read())\n'Tom Jones', (1024, 91)\n...more omitted...\n>>> print(open('persondb.dat', 'rb').read())\nb'\\x80\\x03cperson\\nPerson\\nq\\x00)\\x81q\\x01}q\\x02(X\\x03\\x00\\x00\\x00payq\\x03K...\n...more omitted...",
    "This content isn’t impossible to decipher, but it can vary on different platforms and\ndoesn’t exactly qualify as a user-friendly database interface! To verify our work better,\nwe can write another script, or poke around our shelve at the interactive prompt. Because shelves are Python objects containing Python objects, we can process them with\nnormal Python syntax and development modes. Here, the interactive prompt effectively\nbecomes a database client:\n\n672 | Chapter 27: A More Realistic Example\n\n\f>>> import shelve\n>>> db = shelve.open('persondb')\n\n# Reopen the shelve\n\n>>> len(db)\n3\n>>> list(db.keys())\n['Tom Jones', 'Sue Jones', 'Bob Smith']\n\n# Three 'records' stored\n\n>>> bob = db['Bob Smith']\n>>> print(bob)\n[Person: job=None, name=Bob Smith, pay=0]\n\n# Fetch bob by key\n# Runs __str__ from AttrDisplay\n\n>>> bob.lastName()\n'Smith'\n\n# Runs lastName from Person\n\n>>> for key in db:\nprint(key, '=>', db[key])\n\n# Iterate, fetch, print\n\n# keys is the index\n# list to make a list in 3.0",
    "# Three 'records' stored\n\n>>> bob = db['Bob Smith']\n>>> print(bob)\n[Person: job=None, name=Bob Smith, pay=0]\n\n# Fetch bob by key\n# Runs __str__ from AttrDisplay\n\n>>> bob.lastName()\n'Smith'\n\n# Runs lastName from Person\n\n>>> for key in db:\nprint(key, '=>', db[key])\n\n# Iterate, fetch, print\n\n# keys is the index\n# list to make a list in 3.0\n\nTom Jones => [Manager: job=mgr, name=Tom Jones, pay=50000]\nSue Jones => [Person: job=dev, name=Sue Jones, pay=100000]\nBob Smith => [Person: job=None, name=Bob Smith, pay=0]\n>>> for key in sorted(db):\nprint(key, '=>', db[key])\n\n# Iterate by sorted keys\n\nBob Smith => [Person: job=None, name=Bob Smith, pay=0]\nSue Jones => [Person: job=dev, name=Sue Jones, pay=100000]\nTom Jones => [Manager: job=mgr, name=Tom Jones, pay=50000]",
    "Notice that we don’t have to import our Person or Manager classes here in order to load\nor use our stored objects. For example, we can call bob’s lastName method freely, and\nget his custom print display format automatically, even though we don’t have his\nPerson class in our scope here. This works because when Python pickles a class instance,\nit records its self instance attributes, along with the name of the class it was created\nfrom and the module where the class lives. When bob is later fetched from the shelve\nand unpickled, Python will automatically reimport the class and link bob to it.\nThe upshot of this scheme is that class instances automatically acquire all their class\nbehavior when they are loaded in the future. We have to import our classes only to\nmake new instances, not to process existing ones. Although a deliberate feature, this\nscheme has somewhat mixed consequences:\n• The downside is that classes and their module’s files must be importable when an",
    "The upshot of this scheme is that class instances automatically acquire all their class\nbehavior when they are loaded in the future. We have to import our classes only to\nmake new instances, not to process existing ones. Although a deliberate feature, this\nscheme has somewhat mixed consequences:\n• The downside is that classes and their module’s files must be importable when an\ninstance is later loaded. More formally, pickleable classes must be coded at the top\nlevel of a module file accessible from a directory listed on the sys.path module\nsearch path (and shouldn’t live in the most script files’ module __main__ unless\nthey’re always in that module when used). Because of this external module file\nrequirement, some applications choose to pickle simpler objects such as dictionaries or lists, especially if they are to be transferred across the Internet.",
    "Step 7 (Final): Storing Objects in a Database | 673\n\n\f• The upside is that changes in a class’s source code file are automatically picked up\nwhen instances of the class are loaded again; there is often no need to update stored\nobjects themselves, since updating their class’s code changes their behavior.\nShelves also have well-known limitations (the database suggestions at the end of this\nchapter mention a few of these). For simple object storage, though, shelves and pickles\nare remarkably easy-to-use tools.",
    "Updating Objects on a Shelve\nNow for one last script: let’s write a program that updates an instance (record) each\ntime it runs, to prove the point that our objects really are persistent (i.e., that their\ncurrent values are available every time a Python program runs). The following file,\nupdatedb.py, prints the database and gives a raise to one of our stored objects each time.\nIf you trace through what’s going on here, you’ll notice that we’re getting a lot of utility\n“for free”—printing our objects automatically employs the general __str__ overloading\nmethod, and we give raises by calling the giveRaise method we wrote earlier. This all\n“just works” for objects based on OOP’s inheritance model, even when they live in a file:\n# File updatedb.py: update Person object on database\nimport shelve\ndb = shelve.open('persondb')\n\n# Reopen shelve with same filename\n\nfor key in sorted(db):\nprint(key, '\\t=>', db[key])\n\n# Iterate to display database objects\n# Prints with custom format",
    "# Reopen shelve with same filename\n\nfor key in sorted(db):\nprint(key, '\\t=>', db[key])\n\n# Iterate to display database objects\n# Prints with custom format\n\nsue = db['Sue Jones']\nsue.giveRaise(.10)\ndb['Sue Jones'] = sue\ndb.close()\n\n# Index by key to fetch\n# Update in memory using class method\n# Assign to key to update in shelve\n# Close after making changes",
    "# Index by key to fetch\n# Update in memory using class method\n# Assign to key to update in shelve\n# Close after making changes\n\nBecause this script prints the database when it starts up, we have to run it a few times\nto see our objects change. Here it is in action, displaying all records and increasing\nsue’s pay each time it’s run (it’s a pretty good script for sue...):\nc:\\misc> updatedb.py\nBob Smith\n=> [Person: job=None, name=Bob Smith, pay=0]\nSue Jones\n=> [Person: job=dev, name=Sue Jones, pay=100000]\nTom Jones\n=> [Manager: job=mgr, name=Tom Jones, pay=50000]\nc:\\misc> updatedb.py\nBob Smith\n=> [Person: job=None, name=Bob Smith, pay=0]\nSue Jones\n=> [Person: job=dev, name=Sue Jones, pay=110000]\nTom Jones\n=> [Manager: job=mgr, name=Tom Jones, pay=50000]\nc:\\misc> updatedb.py\nBob Smith\n=> [Person: job=None, name=Bob Smith, pay=0]\nSue Jones\n=> [Person: job=dev, name=Sue Jones, pay=121000]\nTom Jones\n=> [Manager: job=mgr, name=Tom Jones, pay=50000]\nc:\\misc> updatedb.py",
    "674 | Chapter 27: A More Realistic Example\n\n\fBob Smith\nSue Jones\nTom Jones\n\n=> [Person: job=None, name=Bob Smith, pay=0]\n=> [Person: job=dev, name=Sue Jones, pay=133100]\n=> [Manager: job=mgr, name=Tom Jones, pay=50000]\n\nAgain, what we see here is a product of the shelve and pickle tools we get from Python,\nand of the behavior we coded in our classes ourselves. And once again, we can verify\nour script’s work at the interactive prompt (the shelve’s equivalent of a database client):\nc:\\misc> python\n>>> import shelve\n>>> db = shelve.open('persondb')\n# Reopen database\n>>> rec = db['Sue Jones']\n# Fetch object by key\n>>> print(rec)\n[Person: job=dev, name=Sue Jones, pay=146410]\n>>> rec.lastName()\n'Jones'\n>>> rec.pay\n146410",
    "For another example of object persistence in this book, see the sidebar in Chapter 30\ntitled “Why You Will Care: Classes and Persistence” on page 744. It stores a somewhat larger composite object in a flat file with pickle instead of shelve, but the effect\nis similar. For more details on both pickles and shelves, see other books or Python’s\nmanuals.",
    "Future Directions\nAnd that’s a wrap for this tutorial. At this point, you’ve seen all the basics of Python’s\nOOP machinery in action, and you’ve learned ways to avoid redundancy and its associated maintenance issues in your code. You’ve built full-featured classes that do real\nwork. As an added bonus, you’ve made them real database records by storing them in\na Python shelve, so their information lives on persistently.\nThere is much more we could explore here, of course. For example, we could extend\nour classes to make them more realistic, add new kinds of behavior to them, and so on.\nGiving a raise, for instance, should in practice verify that pay increase rates are between\nzero and one—an extension we’ll add when we meet decorators later in this book. You\nmight also mutate this example into a personal contacts database, by changing the state\ninformation stored on objects, as well as the class methods used to process it. We’ll\nleave this a suggested exercise open to your imagination.",
    "zero and one—an extension we’ll add when we meet decorators later in this book. You\nmight also mutate this example into a personal contacts database, by changing the state\ninformation stored on objects, as well as the class methods used to process it. We’ll\nleave this a suggested exercise open to your imagination.\nWe could also expand our scope to use tools that either come with Python or are freely\navailable in the open source world:\nGUIs\nAs is, we can only process our database with the interactive prompt’s commandbased interface, and scripts. We could also work on expanding our object database’s usability by adding a graphical user interface for browsing and updating its\nrecords. GUIs can be built portably with either Python’s tkinter (Tkinter in 2.6)",
    "Future Directions | 675",
    "standard library support, or third-party toolkits such as WxPython and PyQt.\ntkinter ships with Python, lets you build simple GUIs quickly, and is ideal for\nlearning GUI programming techniques; WxPython and PyQt tend to be more\ncomplex to use but often produce higher-grade GUIs in the end.\nWebsites\nAlthough GUIs are convenient and fast, the Web is hard to beat in terms of accessibility. We might also implement a website for browsing and updating records,\ninstead of or in addition to GUIs and the interactive prompt. Websites can be\nconstructed with either basic CGI scripting tools that come with Python, or fullfeatured third-party web frameworks such as Django, TurboGears, Pylons,\nweb2Py, Zope, or Google’s App Engine. On the Web, your data can still be stored\nin a shelve, pickle file, or other Python-based medium; the scripts that process it\nare simply run automatically on a server in response to requests from web browsers",
    "constructed with either basic CGI scripting tools that come with Python, or fullfeatured third-party web frameworks such as Django, TurboGears, Pylons,\nweb2Py, Zope, or Google’s App Engine. On the Web, your data can still be stored\nin a shelve, pickle file, or other Python-based medium; the scripts that process it\nare simply run automatically on a server in response to requests from web browsers\nand other clients, and they produce HTML to interact with a user, either directly\nor by interfacing with Framework APIs.\nWeb services\nAlthough web clients can often parse information in the replies from websites (a\ntechnique colorfully known as “screen scraping”), we might go further and provide\na more direct way to fetch records on the Web via a web services interface such as\nSOAP or XML-RPC calls—APIs supported by either Python itself or the third-party\nopen source domain. Such APIs return data in a more direct form, rather than\nembedded in the HTML of a reply page.\nDatabases",
    "technique colorfully known as “screen scraping”), we might go further and provide\na more direct way to fetch records on the Web via a web services interface such as\nSOAP or XML-RPC calls—APIs supported by either Python itself or the third-party\nopen source domain. Such APIs return data in a more direct form, rather than\nembedded in the HTML of a reply page.\nDatabases\nIf our database becomes higher-volume or critical, we might eventually move it\nfrom shelves to a more full-featured storage mechanism such as the open source\nZODB object-oriented database system (OODB), or a more traditional SQL-based\nrelational database system such as MySQL, Oracle, PostgreSQL, or SQLite. Python\nitself comes with the in-process SQLite database system built-in, but other open\nsource options are freely available on the Web. ZODB, for example, is similar to\nPython’s shelve but addresses many of its limitations, supporting larger databases,",
    "relational database system such as MySQL, Oracle, PostgreSQL, or SQLite. Python\nitself comes with the in-process SQLite database system built-in, but other open\nsource options are freely available on the Web. ZODB, for example, is similar to\nPython’s shelve but addresses many of its limitations, supporting larger databases,\nconcurrent updates, transaction processing, and automatic write-through on inmemory changes. SQL-based systems like MySQL offer enterprise-level tools for\ndatabase storage and may be directly used from a within a Python script.\nORMs\nIf we do migrate to a relational database system for storage, we don’t have to sacrifice Python’s OOP tools. Object-relational mappers (ORMs) like SQLObject and\nSQLAlchemy can automatically map relational tables and rows to and from Python\nclasses and instances, such that we can process the stored data using normal Python\nclass syntax. This approach provides an alternative to OODBs like shelve and",
    "SQLAlchemy can automatically map relational tables and rows to and from Python\nclasses and instances, such that we can process the stored data using normal Python\nclass syntax. This approach provides an alternative to OODBs like shelve and\nZODB and leverages the power of both relational databases and Python’s class\nmodel.",
    "676 | Chapter 27: A More Realistic Example\n\n\fWhile I hope this introduction whets your appetite for future exploration, all of these\ntopics are of course far beyond the scope of this tutorial and this book at large. If you\nwant to explore any of them on your own, see the Web, Python’s standard library\nmanuals, and application-focused books such as Programming Python. In the latter I\npick up this example where we’ve stopped here, showing how to add both a GUI and\na website on top of the database to allow for browsing and updating instance records.\nI hope to see you there eventually, but first, let’s return to class fundamentals and finish\nup the rest of the core Python language story.",
    "Chapter Summary\nIn this chapter, we explored all the fundamentals of Python classes and OOP in action,\nby building upon a simple but real example, step by step. We added constructors,\nmethods, operator overloading, customization with subclasses, and introspection\ntools, and we met other concepts (such as composition, delegation, and polymorphism)\nalong the way.\nIn the end, we took objects created by our classes and made them persistent by storing\nthem on a shelve object database—an easy-to-use system for saving and retrieving native Python objects by key. While exploring class basics, we also encountered multiple\nways to factor our code to reduce redundancy and minimize future maintenance costs.\nFinally, we briefly previewed ways to extend our code with application-programming\ntools such as GUIs and databases, covered in follow-up books.\nIn the next chapters of this part of the book we’ll return to our study of the details",
    "ways to factor our code to reduce redundancy and minimize future maintenance costs.\nFinally, we briefly previewed ways to extend our code with application-programming\ntools such as GUIs and databases, covered in follow-up books.\nIn the next chapters of this part of the book we’ll return to our study of the details\nbehind Python’s class model and investigate its application to some of the design concepts used to combine classes in larger programs. Before we move ahead, though, let’s\nwork through this chapter’s quiz to review what we covered here. Since we’ve already\ndone a lot of hands-on work in this chapter, we’ll close with a set of mostly theoryoriented questions designed to make you trace through some of the code and ponder\nsome of the bigger ideas behind it.",
    "Test Your Knowledge: Quiz\n1. When we fetch a Manager object from the shelve and print it, where does the display\nformat logic come from?\n2. When we fetch a Person object from a shelve without importing its module, how\ndoes the object know that it has a giveRaise method that we can call?\n3. Why is it so important to move processing into methods, instead of hardcoding it\noutside the class?\n\nTest Your Knowledge: Quiz | 677",
    "Test Your Knowledge: Quiz | 677\n\n\f4. Why is it better to customize by subclassing rather than copying the original and\nmodifying?\n5. Why is it better to call back to a superclass method to run default actions, instead\nof copying and modifying its code in a subclass?\n6. Why is it better to use tools like __dict__ that allow objects to be processed\ngenerically than to write more custom code for each type of class?\n7. In general terms, when might you choose to use object embedding and composition\ninstead of inheritance?\n8. How might you modify the classes in this chapter to implement a personal contacts\ndatabase in Python?",
    "Test Your Knowledge: Answers\n1. In the final version of our classes, Manager ultimately inherits its __str__ printing\nmethod from AttrDisplay in the separate classtools module. Manager doesn’t have\none itself, so the inheritance search climbs to its Person superclass; because there\nis no __str__ there either, the search climbs higher and finds it in AttrDisplay. The\nclass names listed in parentheses in a class statement’s header line provide\nthe links to higher superclasses.\n2. Shelves (really, the pickle module they use) automatically relink an instance to the\nclass it was created from when that instance is later loaded back into memory.\nPython reimports the class from its module internally, creates an instance with its\nstored attributes, and sets the instance’s __class__ link to point to its original class.\nThis way, loaded instances automatically obtain all their original methods (like\nlastName, giveRaise, and __str__), even if we have not imported the instance’s class",
    "Python reimports the class from its module internally, creates an instance with its\nstored attributes, and sets the instance’s __class__ link to point to its original class.\nThis way, loaded instances automatically obtain all their original methods (like\nlastName, giveRaise, and __str__), even if we have not imported the instance’s class\ninto our scope.\n3. It’s important to move processing into methods so that there is only one copy to\nchange in the future, and so that the methods can be run on any instance. This is\nPython’s notion of encapsulation—wrapping up logic behind interfaces, to better\nsupport future code maintenance. If you don’t do so, you create code redundancy\nthat can multiply your work effort as the code evolves in the future.\n4. Customizing with subclasses reduces development effort. In OOP, we code by\ncustomizing what has already been done, rather than copying or changing existing\ncode. This is the real “big idea” in OOP—because we can easily extend our prior",
    "support future code maintenance. If you don’t do so, you create code redundancy\nthat can multiply your work effort as the code evolves in the future.\n4. Customizing with subclasses reduces development effort. In OOP, we code by\ncustomizing what has already been done, rather than copying or changing existing\ncode. This is the real “big idea” in OOP—because we can easily extend our prior\nwork by coding new subclasses, we can leverage what we’ve already done. This is\nmuch better than either starting from scratch each time, or introducing multiple\nredundant copies of code that may all have to be updated in the future.",
    "678 | Chapter 27: A More Realistic Example",
    "5. Copying and modifying code doubles your potential work effort in the future, regardless of the context. If a subclass needs to perform default actions coded in a\nsuperclass method, it’s much better to call back to the original through the superclass’s name than to copy its code. This also holds true for superclass constructors.\nAgain, copying code creates redundancy, which is a major issue as code evolves.\n6. Generic tools can avoid hardcoded solutions that must be kept in sync with the\nrest of the class as it evolves over time. A generic __str__ print method, for example,\nneed not be updated each time a new attribute is added to instances in an\n__init__ constructor. In addition, a generic print method inherited by all classes\nonly appears, and need only be modified, in one place—changes in the generic\nversion are picked up by all classes that inherit from the generic class. Again, eliminating code redundancy cuts future development effort; that’s one of the primary",
    "__init__ constructor. In addition, a generic print method inherited by all classes\nonly appears, and need only be modified, in one place—changes in the generic\nversion are picked up by all classes that inherit from the generic class. Again, eliminating code redundancy cuts future development effort; that’s one of the primary\nassets classes bring to the table.\n7. Inheritance is best at coding extensions based on direct customization (like our\nManager specialization of Person). Composition is well suited to scenarios where\nmultiple objects are aggregated into a whole and directed by a controller layer class.\nInheritance passes calls up to reuse, and composition passes down to delegate.\nInheritance and composition are not mutually exclusive; often, the objects embedded in a controller are themselves customizations based upon inheritance.\n8. The classes in this chapter could be used as boilerplate “template” code to",
    "multiple objects are aggregated into a whole and directed by a controller layer class.\nInheritance passes calls up to reuse, and composition passes down to delegate.\nInheritance and composition are not mutually exclusive; often, the objects embedded in a controller are themselves customizations based upon inheritance.\n8. The classes in this chapter could be used as boilerplate “template” code to\nimplement a variety of types of databases. Essentially, you can repurpose them by\nmodifying the constructors to record different attributes and providing whatever\nmethods are appropriate for the target application. For instance, you might use\nattributes such as name, address, birthday, phone, email, and so on for a contacts\ndatabase, and methods appropriate for this purpose. A method named sendmail,\nfor example, might use Python’s standard library smptlib module to send an email",
    "methods are appropriate for the target application. For instance, you might use\nattributes such as name, address, birthday, phone, email, and so on for a contacts\ndatabase, and methods appropriate for this purpose. A method named sendmail,\nfor example, might use Python’s standard library smptlib module to send an email\nto one of the contacts automatically when called (see Python’s manuals or application-level books for more details on such tools). The AttrDisplay tool we wrote\nhere could be used verbatim to print your objects, because it is intentionally generic. Most of the shelve database code here can be used to store your objects, too,\nwith minor changes.",
    "Test Your Knowledge: Answers | 679\n\n\f\fCHAPTER 28\n\nClass Coding Details\n\nIf you haven’t quite gotten all of Python OOP yet, don’t worry; now that we’ve had a\nquick tour, we’re going to dig a bit deeper and study the concepts introduced earlier in\nfurther detail. In this and the following chapter, we’ll take another look at class mechanics. Here, we’re going to study classes, methods, and inheritance, formalizing and\nexpanding on some of the coding ideas introduced in Chapter 26. Because the class is\nour last namespace tool, we’ll summarize Python’s namespace concepts here as well.\nThe next chapter continues this in-depth second pass over class mechanics by covering\none specific aspect: operator overloading. Besides presenting the details, this chapter\nand the next also give us an opportunity to explore some larger classes than those we\nhave studied so far.",
    "The class Statement\nAlthough the Python class statement may seem similar to tools in other OOP languages\non the surface, on closer inspection, it is quite different from what some programmers\nare used to. For example, as in C++, the class statement is Python’s main OOP tool,\nbut unlike in C++, Python’s class is not a declaration. Like a def, a class statement is\nan object builder, and an implicit assignment—when run, it generates a class object\nand stores a reference to it in the name used in the header. Also like a def, a class\nstatement is true executable code—your class doesn’t exist until Python reaches and\nruns the class statement that defines it (typically while importing the module it is coded\nin, but not before).\n\nGeneral Form\nclass is a compound statement, with a body of indented statements typically appearing",
    "General Form\nclass is a compound statement, with a body of indented statements typically appearing\n\nunder the header. In the header, superclasses are listed in parentheses after the class\nname, separated by commas. Listing more than one superclass leads to multiple inheritance (which we’ll discuss more formally in Chapter 30). Here is the statement’s\ngeneral form:\n681\n\n\fclass <name>(superclass,...):\ndata = value\ndef method(self,...):\nself.member = value\n\n# Assign to name\n# Shared class data\n# Methods\n# Per-instance data\n\nWithin the class statement, any assignments generate class attributes, and specially\nnamed methods overload operators; for instance, a function called __init__ is called\nat instance object construction time, if defined.",
    "Example\nAs we’ve seen, classes are mostly just namespaces—that is, tools for defining names\n(i.e., attributes) that export data and logic to clients. So, how do you get from the\nclass statement to a namespace?\nHere’s how. Just like in a module file, the statements nested in a class statement body\ncreate its attributes. When Python executes a class statement (not a call to a class), it\nruns all the statements in its body, from top to bottom. Assignments that happen during\nthis process create names in the class’s local scope, which become attributes in the\nassociated class object. Because of this, classes resemble both modules and functions:\n• Like functions, class statements are local scopes where names created by nested\nassignments live.\n• Like names in a module, names assigned in a class statement become attributes\nin a class object.\nThe main distinction for classes is that their namespaces are also the basis of inheritance",
    "associated class object. Because of this, classes resemble both modules and functions:\n• Like functions, class statements are local scopes where names created by nested\nassignments live.\n• Like names in a module, names assigned in a class statement become attributes\nin a class object.\nThe main distinction for classes is that their namespaces are also the basis of inheritance\nin Python; reference attributes that are not found in a class or instance object are fetched\nfrom other classes.\nBecause class is a compound statement, any sort of statement can be nested inside its\nbody—print, =, if, def, and so on. All the statements inside the class statement run\nwhen the class statement itself runs (not when the class is later called to make an\ninstance). Assigning names inside the class statement makes class attributes, and\nnested defs make class methods, but other assignments make attributes, too.\nFor example, assignments of simple nonfunction objects to class attributes produce",
    "when the class statement itself runs (not when the class is later called to make an\ninstance). Assigning names inside the class statement makes class attributes, and\nnested defs make class methods, but other assignments make attributes, too.\nFor example, assignments of simple nonfunction objects to class attributes produce\ndata attributes, shared by all instances:\n>>> class SharedData:\n...\nspam = 42\n...\n>>> x = SharedData()\n>>> y = SharedData()\n>>> x.spam, y.spam\n(42, 42)",
    "682 | Chapter 28: Class Coding Details\n\n# Generates a class data attribute\n# Make two instances\n# They inherit and share 'spam'\n\n\fHere, because the name spam is assigned at the top level of a class statement, it is\nattached to the class and so will be shared by all instances. We can change it by going\nthrough the class name, and we can refer to it through either instances or the class.*\n>>> SharedData.spam = 99\n>>> x.spam, y.spam, SharedData.spam\n(99, 99, 99)\n\nSuch class attributes can be used to manage information that spans all the instances—\na counter of the number of instances generated, for example (we’ll expand on this idea\nby example in Chapter 31). Now, watch what happens if we assign the name spam\nthrough an instance instead of the class:\n>>> x.spam = 88\n>>> x.spam, y.spam, SharedData.spam\n(88, 99, 99)",
    "Assignments to instance attributes create or change the names in the instance, rather\nthan in the shared class. More generally, inheritance searches occur only on attribute\nreferences, not on assignment: assigning to an object’s attribute always changes that\nobject, and no other.† For example, y.spam is looked up in the class by inheritance, but\nthe assignment to x.spam attaches a name to x itself.\nHere’s a more comprehensive example of this behavior that stores the same name in\ntwo places. Suppose we run the following class:\nclass MixedNames:\ndata = 'spam'\ndef __init__(self, value):\nself.data = value\ndef display(self):\nprint(self.data, MixedNames.data)\n\n# Define class\n# Assign class attr\n# Assign method name\n# Assign instance attr\n# Instance attr, class attr",
    "# Define class\n# Assign class attr\n# Assign method name\n# Assign instance attr\n# Instance attr, class attr\n\nThis class contains two defs, which bind class attributes to method functions. It also\ncontains an = assignment statement; because this assignment assigns the name data\ninside the class, it lives in the class’s local scope and becomes an attribute of the class\nobject. Like all class attributes, this data is inherited and shared by all instances of the\nclass that don’t have data attributes of their own.\nWhen we make instances of this class, the name data is attached to those instances by\nthe assignment to self.data in the constructor method:\n>>> x = MixedNames(1)\n>>> y = MixedNames(2)\n\n# Make two instance objects\n# Each has its own data",
    "# Make two instance objects\n# Each has its own data\n\n* If you’ve used C++ you may recognize this as similar to the notion of C++’s “static” data members—members\nthat are stored in the class, independent of instances. In Python, it’s nothing special: all class attributes are\njust names assigned in the class statement, whether they happen to reference functions (C++’s “methods”)\nor something else (C++’s “members”). In Chapter 31, we’ll also meet Python static methods (akin to those\nin C++), which are just self-less functions that usually process class attributes.\n† Unless the class has redefined the attribute assignment operation to do something unique with the\n__setattr__ operator overloading method (discussed in Chapter 29).\n\nThe class Statement | 683\n\n\f>>> x.display(); y.display()\n1 spam\n2 spam\n\n# self.data differs, MixedNames.data is the same",
    "The net result is that data lives in two places: in the instance objects (created by the\nself.data assignment in __init__), and in the class from which they inherit names\n(created by the data assignment in the class). The class’s display method prints both\nversions, by first qualifying the self instance, and then the class.\nBy using these techniques to store attributes in different objects, we determine their\nscope of visibility. When attached to classes, names are shared; in instances, names\nrecord per-instance data, not shared behavior or data. Although inheritance searches\nlook up names for us, we can always get to an attribute anywhere in a tree by accessing\nthe desired object directly.\nIn the preceding example, for instance, specifying x.data or self.data will return an\ninstance name, which normally hides the same name in the class; however, Mixed",
    "record per-instance data, not shared behavior or data. Although inheritance searches\nlook up names for us, we can always get to an attribute anywhere in a tree by accessing\nthe desired object directly.\nIn the preceding example, for instance, specifying x.data or self.data will return an\ninstance name, which normally hides the same name in the class; however, Mixed\nNames.data grabs the class name explicitly. We’ll see various roles for such coding patterns later; the next section describes one of the most common.",
    "Methods\nBecause you already know about functions, you also know about methods in classes.\nMethods are just function objects created by def statements nested in a class statement’s body. From an abstract perspective, methods provide behavior for instance\nobjects to inherit. From a programming perspective, methods work in exactly the same\nway as simple functions, with one crucial exception: a method’s first argument always\nreceives the instance object that is the implied subject of the method call.\nIn other words, Python automatically maps instance method calls to class method\nfunctions as follows. Method calls made through an instance, like this:\ninstance.method(args...)\n\nare automatically translated to class method function calls of this form:\nclass.method(instance, args...)",
    "are automatically translated to class method function calls of this form:\nclass.method(instance, args...)\n\nwhere the class is determined by locating the method name using Python’s inheritance\nsearch procedure. In fact, both call forms are valid in Python.\nBesides the normal inheritance of method attribute names, the special first argument\nis the only real magic behind method calls. In a class method, the first argument is\nusually called self by convention (technically, only its position is significant, not its\nname). This argument provides methods with a hook back to the instance that is the\nsubject of the call—because classes generate many instance objects, they need to use\nthis argument to manage data that varies per instance.\n\n684 | Chapter 28: Class Coding Details",
    "684 | Chapter 28: Class Coding Details\n\n\fC++ programmers may recognize Python’s self argument as being similar to C++’s\nthis pointer. In Python, though, self is always explicit in your code: methods must\nalways go through self to fetch or change attributes of the instance being processed\nby the current method call. This explicit nature of self is by design—the presence of\nthis name makes it obvious that you are using instance attribute names in your script,\nnot names in the local or global scope.\n\nMethod Example\nTo clarify these concepts, let’s turn to an example. Suppose we define the following\nclass:\nclass NextClass:\ndef printer(self, text):\nself.message = text\nprint(self.message)\n\n# Define class\n# Define method\n# Change instance\n# Access instance",
    "Method Example\nTo clarify these concepts, let’s turn to an example. Suppose we define the following\nclass:\nclass NextClass:\ndef printer(self, text):\nself.message = text\nprint(self.message)\n\n# Define class\n# Define method\n# Change instance\n# Access instance\n\nThe name printer references a function object; because it’s assigned in the class statement’s scope, it becomes a class object attribute and is inherited by every instance made\nfrom the class. Normally, because methods like printer are designed to process instances, we call them through instances:\n>>> x = NextClass()\n\n# Make instance\n\n>>> x.printer('instance call')\ninstance call\n\n# Call its method\n\n>>> x.message\n'instance call'\n\n# Instance changed",
    "# Make instance\n\n>>> x.printer('instance call')\ninstance call\n\n# Call its method\n\n>>> x.message\n'instance call'\n\n# Instance changed\n\nWhen we call the method by qualifying an instance like this, printer is first located by\ninheritance, and then its self argument is automatically assigned the instance object\n(x); the text argument gets the string passed at the call ('instance call'). Notice that\nbecause Python automatically passes the first argument to self for us, we only actually\nhave to pass in one argument. Inside printer, the name self is used to access or set\nper-instance data because it refers back to the instance currently being processed.\nMethods may be called in one of two ways—through an instance, or through the class\nitself. For example, we can also call printer by going through the class name, provided\nwe pass an instance to the self argument explicitly:\n>>> NextClass.printer(x, 'class call')\nclass call\n\n# Direct class call\n\n>>> x.message\n'class call'",
    "# Direct class call\n\n>>> x.message\n'class call'\n\n# Instance changed again\n\nMethods | 685\n\n\fCalls routed through the instance and the class have the exact same effect, as long as\nwe pass the same instance object ourselves in the class form. By default, in fact, you get\nan error message if you try to call a method without any instance:\n>>> NextClass.printer('bad call')\nTypeError: unbound method printer() must be called with NextClass instance...",
    "Calling Superclass Constructors\nMethods are normally called through instances. Calls to methods through a class,\nthough, do show up in a variety of special roles. One common scenario involves the\nconstructor method. The __init__ method, like all attributes, is looked up by inheritance. This means that at construction time, Python locates and calls just one\n__init__. If subclass constructors need to guarantee that superclass construction-time\nlogic runs, too, they generally must call the superclass’s __init__ method explicitly\nthrough the class:\nclass Super:\ndef __init__(self, x):\n...default code...\nclass Sub(Super):\ndef __init__(self, x, y):\nSuper.__init__(self, x)\n...custom code...\n\n# Run superclass __init__\n# Do my init actions\n\nI = Sub(1, 2)",
    "# Run superclass __init__\n# Do my init actions\n\nI = Sub(1, 2)\n\nThis is one of the few contexts in which your code is likely to call an operator overloading method directly. Naturally, you should only call the superclass constructor this\nway if you really want it to run—without the call, the subclass replaces it completely.\nFor a more realistic illustration of this technique in action, see the Manager class example\nin the prior chapter’s tutorial.‡",
    "Other Method Call Possibilities\nThis pattern of calling methods through a class is the general basis of extending (instead\nof completely replacing) inherited method behavior. In Chapter 31, we’ll also meet a\nnew option added in Python 2.2, static methods, that allow you to code methods that\ndo not expect instance objects in their first arguments. Such methods can act like simple\ninstanceless functions, with names that are local to the classes in which they are coded,\nand may be used to manage class data. A related concept, the class method, receives a\nclass when called instead of an instance and can be used to manage per-class data. These\nare advanced and optional extensions, though; normally, you must always pass an\ninstance to a method, whether it is called through an instance or a class.\n‡ On a somewhat related note, you can also code multiple __init__ methods within the same class, but only",
    "class when called instead of an instance and can be used to manage per-class data. These\nare advanced and optional extensions, though; normally, you must always pass an\ninstance to a method, whether it is called through an instance or a class.\n‡ On a somewhat related note, you can also code multiple __init__ methods within the same class, but only\nthe last definition will be used; see Chapter 30 for more details on multiple method definitions.",
    "686 | Chapter 28: Class Coding Details\n\n\fInheritance\nThe whole point of a namespace tool like the class statement is to support name inheritance. This section expands on some of the mechanisms and roles of attribute inheritance in Python.\nIn Python, inheritance happens when an object is qualified, and it involves searching\nan attribute definition tree (one or more namespaces). Every time you use an expression\nof the form object.attr (where object is an instance or class object), Python searches\nthe namespace tree from bottom to top, beginning with object, looking for the first\nattr it can find. This includes references to self attributes in your methods. Because\nlower definitions in the tree override higher ones, inheritance forms the basis of\nspecialization.",
    "Attribute Tree Construction\nFigure 28-1 summarizes the way namespace trees are constructed and populated with\nnames. Generally:\n• Instance attributes are generated by assignments to self attributes in methods.\n• Class attributes are created by statements (assignments) in class statements.\n• Superclass links are made by listing classes in parentheses in a class statement\nheader.\nThe net result is a tree of attribute namespaces that leads from an instance, to the class\nit was generated from, to all the superclasses listed in the class header. Python searches\nupward in this tree, from instances to superclasses, each time you use qualification to\nfetch an attribute name from an instance object.§",
    "Specializing Inherited Methods\nThe tree-searching model of inheritance just described turns out to be a great way to\nspecialize systems. Because inheritance finds names in subclasses before it checks superclasses, subclasses can replace default behavior by redefining their superclasses’\nattributes. In fact, you can build entire systems as hierarchies of classes, which are\nextended by adding new external subclasses rather than changing existing logic\nin-place.\n\n§ This description isn’t 100% complete, because we can also create instance and class attributes by assigning\nto objects outside class statements—but that’s a much less common and sometimes more error-prone\napproach (changes aren’t isolated to class statements). In Python, all attributes are always accessible by\ndefault. We’ll talk more about attribute name privacy in Chapter 29 when we study __setattr__, in\nChapter 30 when we meet __X names, and again in Chapter 38, where we’ll implement it with a class\ndecorator.",
    "Inheritance | 687\n\n\fThe idea of redefining inherited names leads to a variety of specialization techniques.\nFor instance, subclasses may replace inherited attributes completely, provide attributes\nthat a superclass expects to find, and extend superclass methods by calling back to the\nsuperclass from an overridden method. We’ve already seen replacement in action.\nHere’s an example that shows how extension works:\n>>> class Super:\n...\ndef method(self):\n...\nprint('in Super.method')\n...\n>>> class Sub(Super):\n...\ndef method(self):\n...\nprint('starting Sub.method')\n...\nSuper.method(self)\n...\nprint('ending Sub.method')\n...\n\n# Override method\n# Add actions here\n# Run default action",
    "# Override method\n# Add actions here\n# Run default action\n\nFigure 28-1. Program code creates a tree of objects in memory to be searched by attribute inheritance.\nCalling a class creates a new instance that remembers its class, running a class statement creates a\nnew class, and superclasses are listed in parentheses in the class statement header. Each attribute\nreference triggers a new bottom-up tree search—even references to self attributes within a class’s\nmethods.\n\nDirect superclass method calls are the crux of the matter here. The Sub class replaces\nSuper’s method function with its own specialized version, but within the replacement,\nSub calls back to the version exported by Super to carry out the default behavior. In\nother words, Sub.method just extends Super.method’s behavior, rather than replacing it\ncompletely:\n\n688 | Chapter 28: Class Coding Details\n\n\f>>> x = Super()\n>>> x.method()\nin Super.method\n\n# Make a Super instance\n# Runs Super.method",
    "688 | Chapter 28: Class Coding Details\n\n\f>>> x = Super()\n>>> x.method()\nin Super.method\n\n# Make a Super instance\n# Runs Super.method\n\n>>> x = Sub()\n>>> x.method()\nstarting Sub.method\nin Super.method\nending Sub.method\n\n# Make a Sub instance\n# Runs Sub.method, calls Super.method\n\nThis extension coding pattern is also commonly used with constructors; see the section\n“Methods” on page 684 for an example.\n\nClass Interface Techniques\nExtension is only one way to interface with a superclass. The file shown in this section,\nspecialize.py, defines multiple classes that illustrate a variety of common techniques:\nSuper\n\nDefines a method function and a delegate that expects an action in a subclass.\nInheritor\n\nDoesn’t provide any new names, so it gets everything defined in Super.\nReplacer\n\nOverrides Super’s method with a version of its own.\nExtender\n\nCustomizes Super’s method by overriding and calling back to run the default.\nProvider",
    "Defines a method function and a delegate that expects an action in a subclass.\nInheritor\n\nDoesn’t provide any new names, so it gets everything defined in Super.\nReplacer\n\nOverrides Super’s method with a version of its own.\nExtender\n\nCustomizes Super’s method by overriding and calling back to run the default.\nProvider\n\nImplements the action method expected by Super’s delegate method.\nStudy each of these subclasses to get a feel for the various ways they customize their\ncommon superclass. Here’s the file:\nclass Super:\ndef method(self):\nprint('in Super.method')\ndef delegate(self):\nself.action()\n\n# Default behavior\n# Expected to be defined\n\nclass Inheritor(Super):\npass\n\n# Inherit method verbatim\n\nclass Replacer(Super):\ndef method(self):\nprint('in Replacer.method')\n\n# Replace method completely\n\nclass Extender(Super):\ndef method(self):\nprint('starting Extender.method')\nSuper.method(self)\nprint('ending Extender.method')\n\n# Extend method behavior\n\nInheritance | 689",
    "# Default behavior\n# Expected to be defined\n\nclass Inheritor(Super):\npass\n\n# Inherit method verbatim\n\nclass Replacer(Super):\ndef method(self):\nprint('in Replacer.method')\n\n# Replace method completely\n\nclass Extender(Super):\ndef method(self):\nprint('starting Extender.method')\nSuper.method(self)\nprint('ending Extender.method')\n\n# Extend method behavior\n\nInheritance | 689\n\n\fclass Provider(Super):\ndef action(self):\nprint('in Provider.action')\n\n# Fill in a required method\n\nif __name__ == '__main__':\nfor klass in (Inheritor, Replacer, Extender):\nprint('\\n' + klass.__name__ + '...')\nklass().method()\nprint('\\nProvider...')\nx = Provider()\nx.delegate()",
    "# Extend method behavior\n\nInheritance | 689\n\n\fclass Provider(Super):\ndef action(self):\nprint('in Provider.action')\n\n# Fill in a required method\n\nif __name__ == '__main__':\nfor klass in (Inheritor, Replacer, Extender):\nprint('\\n' + klass.__name__ + '...')\nklass().method()\nprint('\\nProvider...')\nx = Provider()\nx.delegate()\n\nA few things are worth pointing out here. First, the self-test code at the end of this\nexample creates instances of three different classes in a for loop. Because classes are\nobjects, you can put them in a tuple and create instances generically (more on this idea\nlater). Classes also have the special __name__ attribute, like modules; it’s preset to a\nstring containing the name in the class header. Here’s what happens when we run the\nfile:\n% python specialize.py\nInheritor...\nin Super.method\nReplacer...\nin Replacer.method\nExtender...\nstarting Extender.method\nin Super.method\nending Extender.method\nProvider...\nin Provider.action",
    "Abstract Superclasses\nNotice how the Provider class in the prior example works. When we call the\ndelegate method through a Provider instance, two independent inheritance searches\noccur:\n1. On the initial x.delegate call, Python finds the delegate method in Super by\nsearching the Provider instance and above. The instance x is passed into the\nmethod’s self argument as usual.\n2. Inside the Super.delegate method, self.action invokes a new, independent inheritance search of self and above. Because self references a Provider instance,\nthe action method is located in the Provider subclass.\nThis “filling in the blanks” sort of coding structure is typical of OOP frameworks. At\nleast in terms of the delegate method, the superclass in this example is what is sometimes called an abstract superclass—a class that expects parts of its behavior to be\n690 | Chapter 28: Class Coding Details",
    "provided by its subclasses. If an expected method is not defined in a subclass, Python\nraises an undefined name exception when the inheritance search fails.\nClass coders sometimes make such subclass requirements more obvious with assert\nstatements, or by raising the built-in NotImplementedError exception with raise statements (we’ll study statements that may trigger exceptions in depth in the next part of\nthis book). As a quick preview, here’s the assert scheme in action:\nclass Super:\ndef delegate(self):\nself.action()\ndef action(self):\nassert False, 'action must be defined!'\n\n# If this version is called\n\n>>> X = Super()\n>>> X.delegate()\nAssertionError: action must be defined!",
    "# If this version is called\n\n>>> X = Super()\n>>> X.delegate()\nAssertionError: action must be defined!\n\nWe’ll meet assert in Chapters 32 and 33; in short, if its first expression evaluates\nto false, it raises an exception with the provided error message. Here, the expression\nis always false so as to trigger an error message if a method is not redefined, and inheritance locates the version here. Alternatively, some classes simply raise a\nNotImplementedError exception directly in such method stubs to signal the mistake:\nclass Super:\ndef delegate(self):\nself.action()\ndef action(self):\nraise NotImplementedError('action must be defined!')\n>>> X = Super()\n>>> X.delegate()\nNotImplementedError: action must be defined!",
    "For instances of subclasses, we still get the exception unless the subclass provides the\nexpected method to replace the default in the superclass:\n>>> class Sub(Super): pass\n...\n>>> X = Sub()\n>>> X.delegate()\nNotImplementedError: action must be defined!\n>>> class Sub(Super):\n...\ndef action(self): print('spam')\n...\n>>> X = Sub()\n>>> X.delegate()\nspam\n\nFor a somewhat more realistic example of this section’s concepts in action, see the “Zoo\nanimal hierarchy” exercise (exercise 8) at the end of Chapter 31, and its solution in\n“Part VI, Classes and OOP” on page 1122 in Appendix B. Such taxonomies are a\n\nInheritance | 691\n\n\ftraditional way to introduce OOP, but they’re a bit removed from most developers’ job\ndescriptions.",
    "For a somewhat more realistic example of this section’s concepts in action, see the “Zoo\nanimal hierarchy” exercise (exercise 8) at the end of Chapter 31, and its solution in\n“Part VI, Classes and OOP” on page 1122 in Appendix B. Such taxonomies are a\n\nInheritance | 691\n\n\ftraditional way to introduce OOP, but they’re a bit removed from most developers’ job\ndescriptions.\n\nPython 2.6 and 3.0 Abstract Superclasses\nAs of Python 2.6 and 3.0, the prior section’s abstract superclasses (a.k.a. “abstract base\nclasses”), which require methods to be filled in by subclasses, may also be implemented\nwith special class syntax. The way we code this varies slightly depending on the version.\nIn Python 3.0, we use a keyword argument in a class header, along with special @\ndecorator syntax, both of which we’ll study in detail later in this book:\nfrom abc import ABCMeta, abstractmethod\nclass Super(metaclass=ABCMeta):\n@abstractmethod\ndef method(self, ...):\npass",
    "But in Python 2.6, we use a class attribute instead:\nclass Super:\n__metaclass__ = ABCMeta\n@abstractmethod\ndef method(self, ...):\npass\n\nEither way, the effect is the same—we can’t make an instance unless the method is\ndefined lower in the class tree. In 3.0, for example, here is the special syntax equivalent\nof the prior section’s example:\n>>> from abc import ABCMeta, abstractmethod\n>>>\n>>> class Super(metaclass=ABCMeta):\n...\ndef delegate(self):\n...\nself.action()\n...\n@abstractmethod\n...\ndef action(self):\n...\npass\n...\n>>> X = Super()\nTypeError: Can't instantiate abstract class Super with abstract methods action\n>>> class Sub(Super): pass\n...\n>>> X = Sub()\nTypeError: Can't instantiate abstract class Sub with abstract methods action\n>>> class Sub(Super):\n...\ndef action(self): print('spam')\n...\n>>> X = Sub()\n>>> X.delegate()\nspam\n\n692 | Chapter 28: Class Coding Details",
    "692 | Chapter 28: Class Coding Details\n\n\fCoded this way, a class with an abstract method cannot be instantiated (that is, we\ncannot create an instance by calling it) unless all of its abstract methods have been\ndefined in subclasses. Although this requires more code, the advantage of this approach\nis that errors for missing methods are issued when we attempt to make an instance of\nthe class, not later when we try to call a missing method. This feature may also be used\nto define an expected interface, automatically verified in client classes.\nUnfortunately, this scheme also relies on two advanced language tools we have not met\nyet—function decorators, introduced in Chapter 31 and covered in depth in Chapter 38, as well as metaclass declarations, mentioned in Chapter 31 and covered in\nChapter 39—so we will finesse other facets of this option here. See Python’s standard\nmanuals for more on this, as well as precoded abstract superclasses Python provides.",
    "Namespaces: The Whole Story\nNow that we’ve examined class and instance objects, the Python namespace story is\ncomplete. For reference, I’ll quickly summarize all the rules used to resolve names here.\nThe first things you need to remember are that qualified and unqualified names are\ntreated differently, and that some scopes serve to initialize object namespaces:\n• Unqualified names (e.g., X) deal with scopes.\n• Qualified attribute names (e.g., object.X) use object namespaces.\n• Some scopes initialize object namespaces (for modules and classes).\n\nSimple Names: Global Unless Assigned\nUnqualified simple names follow the LEGB lexical scoping rule outlined for functions\nin Chapter 17:\nAssignment (X = value)\nMakes names local: creates or changes the name X in the current local scope, unless\ndeclared global.\nReference (X)\nLooks for the name X in the current local scope, then any and all enclosing functions, then the current global scope, then the built-in scope.",
    "Attribute Names: Object Namespaces\nQualified attribute names refer to attributes of specific objects and obey the rules for\nmodules and classes. For class and instance objects, the reference rules are augmented\nto include the inheritance search procedure:\n\nNamespaces: The Whole Story | 693\n\n\fAssignment (object.X = value)\nCreates or alters the attribute name X in the namespace of the object being qualified, and none other. Inheritance-tree climbing happens only on attribute reference, not on attribute assignment.\nReference (object.X)\nFor class-based objects, searches for the attribute name X in object, then in all\naccessible classes above it, using the inheritance search procedure. For nonclass\nobjects such as modules, fetches X from object directly.",
    "The “Zen” of Python Namespaces: Assignments Classify Names\nWith distinct search procedures for qualified and unqualified names, and multiple\nlookup layers for both, it can sometimes be difficult to tell where a name will wind up\ngoing. In Python, the place where you assign a name is crucial—it fully determines the\nscope or object in which a name will reside. The file manynames.py illustrates how this\nprinciple translates to code and summarizes the namespace ideas we have seen throughout this book:\n# manynames.py\nX = 11\n\n# Global (module) name/attribute (X, or manynames.X)\n\ndef f():\nprint(X)\n\n# Access global X (11)\n\ndef g():\nX = 22\nprint(X)\nclass C:\nX = 33\ndef m(self):\nX = 44\nself.X = 55\n\n# Local (function) variable (X, hides module X)\n\n# Class attribute (C.X)\n# Local variable in method (X)\n# Instance attribute (instance.X)",
    "This file assigns the same name, X, five times. Because this name is assigned in five\ndifferent locations, though, all five Xs in this program are completely different variables.\nFrom top to bottom, the assignments to X here generate: a module attribute (11), a local\nvariable in a function (22), a class attribute (33), a local variable in a method (44), and\nan instance attribute (55). Although all five are named X, the fact that they are all assigned at different places in the source code or to different objects makes all of these\nunique variables.\nYou should take the time to study this example carefully because it collects ideas we’ve\nbeen exploring throughout the last few parts of this book. When it makes sense to you,\nyou will have achieved a sort of Python namespace nirvana. Of course, an alternative\nroute to nirvana is to simply run the program and see what happens. Here’s the remainder of this source file, which makes an instance and prints all the Xs that it can fetch:",
    "694 | Chapter 28: Class Coding Details\n\n\f# manynames.py, continued\nif __name__ == '__main__':\nprint(X)\nf()\ng()\nprint(X)\n\n# 11: module (a.k.a. manynames.X outside file)\n# 11: global\n# 22: local\n# 11: module name unchanged\n\nobj = C()\nprint(obj.X)\n\n# Make instance\n# 33: class name inherited by instance\n\nobj.m()\nprint(obj.X)\nprint(C.X)\n\n# Attach attribute name X to instance now\n# 55: instance\n# 33: class (a.k.a. obj.X if no X in instance)\n\n#print(C.m.X)\n#print(g.X)\n\n# FAILS: only visible in method\n# FAILS: only visible in function",
    "# Attach attribute name X to instance now\n# 55: instance\n# 33: class (a.k.a. obj.X if no X in instance)\n\n#print(C.m.X)\n#print(g.X)\n\n# FAILS: only visible in method\n# FAILS: only visible in function\n\nThe outputs that are printed when the file is run are noted in the comments in the code;\ntrace through them to see which variable named X is being accessed each time. Notice\nin particular that we can go through the class to fetch its attribute (C.X), but we can\nnever fetch local variables in functions or methods from outside their def statements.\nLocals are visible only to other code within the def, and in fact only live in memory\nwhile a call to the function or method is executing.\nSome of the names defined by this file are visible outside the file to other modules, but\nrecall that we must always import before we can access names in another file—that is\nthe main point of modules, after all:\n# otherfile.py\nimport manynames\nX = 66\nprint(X)\nprint(manynames.X)",
    "# 66: the global here\n# 11: globals become attributes after imports\n\nmanynames.f()\nmanynames.g()\n\n# 11: manynames's X, not the one here!\n# 22: local in other file's function\n\nprint(manynames.C.X)\nI = manynames.C()\nprint(I.X)\nI.m()\nprint(I.X)\n\n# 33: attribute of class in other module\n# 33: still from class here\n# 55: now from instance!\n\nNotice here how manynames.f() prints the X in manynames, not the X assigned in this file—\nscopes are always determined by the position of assignments in your source code (i.e.,\nlexically) and are never influenced by what imports what or who imports whom. Also,\nnotice that the instance’s own X is not created until we call I.m()—attributes, like all\nvariables, spring into existence when assigned, and not before. Normally we create\ninstance attributes by assigning them in class __init__ constructor methods, but this\nisn’t the only option.\nNamespaces: The Whole Story | 695",
    "Finally, as we learned in Chapter 17, it’s also possible for a function to change names\noutside itself, with global and (in Python 3.0) nonlocal statements—these statements\nprovide write access, but also modify assignment’s namespace binding rules:\nX = 11\n\n# Global in module\n\ndef g1():\nprint(X)\n\n# Reference global in module\n\ndef g2():\nglobal X\nX = 22\n\n# Change global in module\n\ndef h1():\nX = 33\ndef nested():\nprint(X)\ndef h2():\nX = 33\ndef nested():\nnonlocal X\nX = 44\n\n# Local in function\n# Reference local in enclosing scope\n# Local in function\n# Python 3.0 statement\n# Change local in enclosing scope\n\nOf course, you generally shouldn’t use the same name for every variable in your script—\nbut as this example demonstrates, even if you do, Python’s namespaces will work to\nkeep names used in one context from accidentally clashing with those used in another.",
    "Namespace Dictionaries\nIn Chapter 22, we learned that module namespaces are actually implemented as dictionaries and exposed with the built-in __dict__ attribute. The same holds for class and\ninstance objects: attribute qualification is really a dictionary indexing operation internally, and attribute inheritance is just a matter of searching linked dictionaries. In fact,\ninstance and class objects are mostly just dictionaries with links inside Python. Python\nexposes these dictionaries, as well as the links between them, for use in advanced roles\n(e.g., for coding tools).\nTo help you understand how attributes work internally, let’s work through an interactive session that traces the way namespace dictionaries grow when classes are involved. We saw a simpler version of this type of code in Chapter 26, but now that we\nknow more about methods and superclasses, let’s embellish it here. First, let’s define\na superclass and a subclass with methods that will store data in their instances:",
    "know more about methods and superclasses, let’s embellish it here. First, let’s define\na superclass and a subclass with methods that will store data in their instances:\n>>> class super:\n...\ndef hello(self):\n...\nself.data1 = 'spam'\n...\n>>> class sub(super):\n...\ndef hola(self):",
    "696 | Chapter 28: Class Coding Details\n\n\f...\n...\n\nself.data2 = 'eggs'\n\nWhen we make an instance of the subclass, the instance starts out with an empty\nnamespace dictionary, but it has links back to the class for the inheritance search to\nfollow. In fact, the inheritance tree is explicitly available in special attributes, which\nyou can inspect. Instances have a __class__ attribute that links to their class, and classes\nhave a __bases__ attribute that is a tuple containing links to higher superclasses (I’m\nrunning this on Python 3.0; name formats and some internal attributes vary slightly in\n2.6):\n>>> X = sub()\n>>> X.__dict__\n{}\n\n# Instance namespace dict\n\n>>> X.__class__\n<class '__main__.sub'>\n\n# Class of instance\n\n>>> sub.__bases__\n(<class '__main__.super'>,)\n\n# Superclasses of class\n\n>>> super.__bases__\n(<class 'object'>,)\n\n# () empty tuple in Python 2.6",
    "# Instance namespace dict\n\n>>> X.__class__\n<class '__main__.sub'>\n\n# Class of instance\n\n>>> sub.__bases__\n(<class '__main__.super'>,)\n\n# Superclasses of class\n\n>>> super.__bases__\n(<class 'object'>,)\n\n# () empty tuple in Python 2.6\n\nAs classes assign to self attributes, they populate the instance objects—that is, attributes wind up in the instances’ attribute namespace dictionaries, not in the classes’.\nAn instance object’s namespace records data that can vary from instance to instance,\nand self is a hook into that namespace:\n>>> Y = sub()\n>>> X.hello()\n>>> X.__dict__\n{'data1': 'spam'}\n>>> X.hola()\n>>> X.__dict__\n{'data1': 'spam', 'data2': 'eggs'}\n>>> sub.__dict__.keys()\n['__module__', '__doc__', 'hola']\n>>> super.__dict__.keys()\n['__dict__', '__module__', '__weakref__', 'hello', '__doc__']\n>>> Y.__dict__\n{}",
    "Notice the extra underscore names in the class dictionaries; Python sets these automatically. Most are not used in typical programs, but there are tools that use some of\nthem (e.g., __doc__ holds the docstrings discussed in Chapter 15).\n\nNamespaces: The Whole Story | 697",
    "Namespaces: The Whole Story | 697\n\n\fAlso, observe that Y, a second instance made at the start of this series, still has an empty\nnamespace dictionary at the end, even though X’s dictionary has been populated by\nassignments in methods. Again, each instance has an independent namespace dictionary, which starts out empty and can record completely different attributes than\nthose recorded by the namespace dictionaries of other instances of the same class.\nBecause attributes are actually dictionary keys inside Python, there are really two ways\nto fetch and assign their values—by qualification, or by key indexing:\n>>> X.data1, X.__dict__['data1']\n('spam', 'spam')\n>>> X.data3 = 'toast'\n>>> X.__dict__\n{'data1': 'spam', 'data3': 'toast', 'data2': 'eggs'}\n>>> X.__dict__['data3'] = 'ham'\n>>> X.data3\n'ham'",
    "This equivalence applies only to attributes actually attached to the instance, though.\nBecause attribute fetch qualification also performs an inheritance search, it can access\nattributes that namespace dictionary indexing cannot. The inherited attribute\nX.hello, for instance, cannot be accessed by X.__dict__['hello'].\nFinally, here is the built-in dir function we met in Chapters 4 and 15 at work on class\nand instance objects. This function works on anything with attributes: dir(object) is\nsimilar to an object.__dict__.keys() call. Notice, though, that dir sorts its list and\nincludes some system attributes. As of Python 2.2, dir also collects inherited attributes\nautomatically, and in 3.0 it includes names inherited from the object class that is an\nimplied superclass of all classes:‖\n>>> X.__dict__, Y.__dict__\n({'data1': 'spam', 'data3': 'ham', 'data2': 'eggs'}, {})\n>>> list(X.__dict__.keys())\n['data1', 'data3', 'data2']\n\n# Need list in 3.0",
    "# Need list in 3.0\n\n# In Python 2.6:\n>>>> dir(X)\n['__doc__', '__module__', 'data1', 'data2', 'data3', 'hello', 'hola']\n>>> dir(sub)\n['__doc__', '__module__', 'hello', 'hola']\n>>> dir(super)\n['__doc__', '__module__', 'hello']\n\n‖ As you can see, the contents of attribute dictionaries and dir call results may change over time. For example,\nbecause Python now allows built-in types to be subclassed like classes, the contents of dir results for builtin types have expanded to include operator overloading methods, just like our dir results here for user-defined\nclasses under Python 3.0. In general, attribute names with leading and trailing double underscores are\ninterpreter-specific. Type subclasses will be discussed further in Chapter 31.\n\n698 | Chapter 28: Class Coding Details",
    "698 | Chapter 28: Class Coding Details\n\n\f# In Python 3.0:\n>>> dir(X)\n['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__',\n...more omitted...\n'data1', 'data2', 'data3', 'hello', 'hola']\n>>> dir(sub)\n['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__',\n...more omitted...\n'hello', 'hola']\n>>> dir(super)\n['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__',\n...more omitted...\n'hello'\n]\n\nExperiment with these special attributes on your own to get a better feel for how namespaces actually do their attribute business. Even if you will never use these in the kinds\nof programs you write, seeing that they are just normal dictionaries will help demystify\nthe notion of namespaces in general.",
    "Experiment with these special attributes on your own to get a better feel for how namespaces actually do their attribute business. Even if you will never use these in the kinds\nof programs you write, seeing that they are just normal dictionaries will help demystify\nthe notion of namespaces in general.\n\nNamespace Links\nThe prior section introduced the special __class__ and __bases__ instance and class\nattributes, without really explaining why you might care about them. In short, these\nattributes allow you to inspect inheritance hierarchies within your own code. For example, they can be used to display a class tree, as in the following example:\n# classtree.py\n\"\"\"\nClimb inheritance trees using namespace links,\ndisplaying higher superclasses with indentation\n\"\"\"\ndef classtree(cls, indent):\nprint('.' * indent + cls.__name__)\nfor supercls in cls.__bases__:\nclasstree(supercls, indent+3)\n\n# Print class name here\n# Recur to all superclasses\n# May visit super > once",
    "# Print class name here\n# Recur to all superclasses\n# May visit super > once\n\ndef instancetree(inst):\nprint('Tree of %s' % inst)\nclasstree(inst.__class__, 3)\n\n# Show instance\n# Climb to its class\n\ndef selftest():\nclass A:\npass\nclass B(A):\npass\nclass C(A):\npass\nclass D(B,C): pass\nclass E:\npass\nclass F(D,E): pass\n\nNamespaces: The Whole Story | 699\n\n\finstancetree(B())\ninstancetree(F())\nif __name__ == '__main__': selftest()",
    "Namespaces: The Whole Story | 699\n\n\finstancetree(B())\ninstancetree(F())\nif __name__ == '__main__': selftest()\n\nThe classtree function in this script is recursive—it prints a class’s name using\n__name__, then climbs up to the superclasses by calling itself. This allows the function\nto traverse arbitrarily shaped class trees; the recursion climbs to the top, and stops at\nroot superclasses that have empty __bases__ attributes. When using recursion, each\nactive level of a function gets its own copy of the local scope; here, this means that\ncls and indent are different at each classtree level.\nMost of this file is self-test code. When run standalone in Python 3.0, it builds an empty\nclass tree, makes two instances from it, and prints their class tree structures:\nC:\\misc> c:\\python26\\python classtree.py\nTree of <__main__.B instance at 0x02557328>\n...B\n......A\nTree of <__main__.F instance at 0x02557328>\n...F\n......D\n.........B\n............A\n.........C\n............A\n......E",
    "When run under Python 3.0, the tree includes the implied object superclasses that are\nautomatically added above standalone classes, because all classes are “new style” in 3.0\n(more on this change in Chapter 31):\nC:\\misc> c:\\python30\\python classtree.py\nTree of <__main__.B object at 0x02810650>\n...B\n......A\n.........object\nTree of <__main__.F object at 0x02810650>\n...F\n......D\n.........B\n............A\n...............object\n.........C\n............A\n...............object\n......E\n.........object\n\nHere, indentation marked by periods is used to denote class tree height. Of course, we\ncould improve on this output format, and perhaps even sketch it in a GUI display. Even\nas is, though, we can import these functions anywhere we want a quick class tree\ndisplay:\n\n700 | Chapter 28: Class Coding Details",
    "Here, indentation marked by periods is used to denote class tree height. Of course, we\ncould improve on this output format, and perhaps even sketch it in a GUI display. Even\nas is, though, we can import these functions anywhere we want a quick class tree\ndisplay:\n\n700 | Chapter 28: Class Coding Details\n\n\fC:\\misc> c:\\python30\\python\n>>> class Emp: pass\n...\n>>> class Person(Emp): pass\n>>> bob = Person()\n>>> import classtree\n>>> classtree.instancetree(bob)\nTree of <__main__.Person object at 0x028203B0>\n...Person\n......Emp\n.........object",
    "700 | Chapter 28: Class Coding Details\n\n\fC:\\misc> c:\\python30\\python\n>>> class Emp: pass\n...\n>>> class Person(Emp): pass\n>>> bob = Person()\n>>> import classtree\n>>> classtree.instancetree(bob)\nTree of <__main__.Person object at 0x028203B0>\n...Person\n......Emp\n.........object\n\nRegardless of whether you will ever code or use such tools, this example demonstrates\none of the many ways that you can make use of special attributes that expose interpreter\ninternals. You’ll see another when we code the lister.py general-purpose class display\ntools in the section “Multiple Inheritance: “Mix-in” Classes” on page 756—there, we\nwill extend this technique to also display attributes in each object in a class tree. And\nin the last part of this book, we’ll revisit such tools in the context of Python tool building\nat large, to code tools that implement attribute privacy, argument validation, and more.\nWhile not for every Python programmer, access to internals enables powerful development tools.",
    "Documentation Strings Revisited\nThe last section’s example includes a docstring for its module, but remember that docstrings can be used for class components as well. Docstrings, which we covered in detail\nin Chapter 15, are string literals that show up at the top of various structures and are\nautomatically saved by Python in the corresponding objects’ __doc__ attributes. This\nworks for module files, function defs, and classes and methods.\nNow that we know more about classes and methods, the following file, docstr.py, provides a quick but comprehensive example that summarizes the places where docstrings\ncan show up in your code. All of these can be triple-quoted blocks:\n\"I am: docstr.__doc__\"\ndef func(args):\n\"I am: docstr.func.__doc__\"\npass\nclass spam:\n\"I am: spam.__doc__ or docstr.spam.__doc__\"\ndef method(self, arg):\n\"I am: spam.method.__doc__ or self.method.__doc__\"\npass\n\nDocumentation Strings Revisited | 701",
    "Documentation Strings Revisited | 701\n\n\fThe main advantage of documentation strings is that they stick around at runtime.\nThus, if it’s been coded as a docstring, you can qualify an object with its __doc__ attribute to fetch its documentation:\n>>> import docstr\n>>> docstr.__doc__\n'I am: docstr.__doc__'\n>>> docstr.func.__doc__\n'I am: docstr.func.__doc__'\n>>> docstr.spam.__doc__\n'I am: spam.__doc__ or docstr.spam.__doc__'\n>>> docstr.spam.method.__doc__\n'I am: spam.method.__doc__ or self.method.__doc__'\n\nA discussion of the PyDoc tool, which knows how to format all these strings in reports,\nappears in Chapter 15. Here it is running on our code under Python 2.6 (Python 3.0\nshows additional attributes inherited from the implied object superclass in the newstyle class model—run this on your own to see the 3.0 extras, and watch for more about\nthis difference in Chapter 31):\n>>> help(docstr)\nHelp on module docstr:\nNAME\n\ndocstr - I am: docstr.__doc__\n\nFILE\n\nc:\\misc\\docstr.py",
    "docstr - I am: docstr.__doc__\n\nFILE\n\nc:\\misc\\docstr.py\n\nCLASSES\nspam\nclass spam\n| I am: spam.__doc__ or docstr.spam.__doc__\n|\n| Methods defined here:\n|\n| method(self, arg)\n|\nI am: spam.method.__doc__ or self.method.__doc__\nFUNCTIONS\nfunc(args)\nI am: docstr.func.__doc__\n\nDocumentation strings are available at runtime, but they are less flexible syntactically\nthan # comments (which can appear anywhere in a program). Both forms are useful\ntools, and any program documentation is good (as long as it’s accurate, of course!). As\na best-practice rule of thumb, use docstrings for functional documentation (what your\nobjects do) and hash-mark comments for more micro-level documentation (how arcane\nexpressions work).\n\n702 | Chapter 28: Class Coding Details",
    "702 | Chapter 28: Class Coding Details\n\n\fClasses Versus Modules\nLet’s wrap up this chapter by briefly comparing the topics of this book’s last two parts:\nmodules and classes. Because they’re both about namespaces, the distinction can be\nconfusing. In short:\n• Modules\n— Are data/logic packages\n— Are created by writing Python files or C extensions\n— Are used by being imported\n• Classes\n— Implement new objects\n— Are created by class statements\n— Are used by being called\n— Always live within a module\nClasses also support extra features that modules don’t, such as operator overloading,\nmultiple instance generation, and inheritance. Although both classes and modules are\nnamespaces, you should be able to tell by now that they are very different things.",
    "Chapter Summary\nThis chapter took us on a second, more in-depth tour of the OOP mechanisms of the\nPython language. We learned more about classes, methods, and inheritance, and we\nwrapped up the namespace story in Python by extending it to cover its application to\nclasses. Along the way, we looked at some more advanced concepts, such as abstract\nsuperclasses, class data attributes, namespace dictionaries and links, and manual calls\nto superclass methods and constructors.\nNow that we’ve learned all about the mechanics of coding classes in Python, Chapter 29 turns to a specific facet of those mechanics: operator overloading. After that we’ll\nexplore common design patterns, looking at some of the ways that classes are commonly used and combined to optimize code reuse. Before you read ahead, though, be\nsure to work though the usual chapter quiz to review what we’ve covered here.",
    "Test Your Knowledge: Quiz\n1. What is an abstract superclass?\n2. What happens when a simple assignment statement appears at the top level of a\nclass statement?\n\nTest Your Knowledge: Quiz | 703\n\n\f3. Why might a class need to manually call the __init__ method in a superclass?\n4. How can you augment, instead of completely replacing, an inherited method?\n5. What...was the capital of Assyria?",
    "Test Your Knowledge: Answers\n1. An abstract superclass is a class that calls a method, but does not inherit or define\nit—it expects the method to be filled in by a subclass. This is often used as a way\nto generalize classes when behavior cannot be predicted until a more specific subclass is coded. OOP frameworks also use this as a way to dispatch to client-defined,\ncustomizable operations.\n2. When a simple assignment statement (X = Y) appears at the top level of a class\nstatement, it attaches a data attribute to the class (Class.X). Like all class attributes,\nthis will be shared by all instances; data attributes are not callable method functions, though.\n3. A class must manually call the __init__ method in a superclass if it defines an\n__init__ constructor of its own, but it also must still kick off the superclass’s construction code. Python itself automatically runs just one constructor—the lowest\none in the tree. Superclass constructors are called through the class name, passing",
    "3. A class must manually call the __init__ method in a superclass if it defines an\n__init__ constructor of its own, but it also must still kick off the superclass’s construction code. Python itself automatically runs just one constructor—the lowest\none in the tree. Superclass constructors are called through the class name, passing\nin the self instance manually: Superclass.__init__(self, ...).\n4. To augment instead of completely replacing an inherited method, redefine it in a\nsubclass, but call back to the superclass’s version of the method manually from the\nnew version of the method in the subclass. That is, pass the self instance to the\nsuperclass’s version of the method manually: Superclass.method(self, ...).\n5. Ashur (or Qalat Sherqat), Calah (or Nimrud), the short-lived Dur Sharrukin (or\nKhorsabad), and finally Nineveh.",
    "704 | Chapter 28: Class Coding Details\n\n\fCHAPTER 29\n\nOperator Overloading\n\nThis chapter continues our in-depth survey of class mechanics by focusing on operator\noverloading. We looked briefly at operator overloading in prior chapters; here, we’ll\nfill in more details and look at a handful of commonly used overloading methods.\nAlthough we won’t demonstrate each of the many operator overloading methods available, those we will code here are a representative sample large enough to uncover the\npossibilities of this Python class feature.",
    "The Basics\nReally “operator overloading” simply means intercepting built-in operations in class\nmethods—Python automatically invokes your methods when instances of the class\nappear in built-in operations, and your method’s return value becomes the result of the\ncorresponding operation. Here’s a review of the key ideas behind overloading:\n• Operator overloading lets classes intercept normal Python operations.\n• Classes can overload all Python expression operators.\n• Classes can also overload built-in operations such as printing, function calls, attribute access, etc.\n• Overloading makes class instances act more like built-in types.\n• Overloading is implemented by providing specially named class methods.\nIn other words, when certain specially named methods are provided in a class, Python\nautomatically calls them when instances of the class appear in their associated expressions. As we’ve learned, operator overloading methods are never required and generally",
    "• Overloading makes class instances act more like built-in types.\n• Overloading is implemented by providing specially named class methods.\nIn other words, when certain specially named methods are provided in a class, Python\nautomatically calls them when instances of the class appear in their associated expressions. As we’ve learned, operator overloading methods are never required and generally\ndon’t have defaults; if you don’t code or inherit one, it just means that your class does\nnot support the corresponding operation. When used, though, these methods allow\nclasses to emulate the interfaces of built-in objects, and so appear more consistent.",
    "705\n\n\fConstructors and Expressions: __init__ and __sub__\nConsider the following simple example: its Number class, coded in the file number.py,\nprovides a method to intercept instance construction (__init__), as well as one for\ncatching subtraction expressions (__sub__). Special methods such as these are the hooks\nthat let you tie into built-in operations:\nclass Number:\ndef __init__(self, start):\nself.data = start\ndef __sub__(self, other):\nreturn Number(self.data - other)\n\n# On Number(start)\n# On instance - other\n# Result is a new instance\n# Fetch class from module\n# Number.__init__(X, 5)\n# Number.__sub__(X, 2)\n# Y is new Number instance\n\n>>> from number import Number\n>>> X = Number(5)\n>>> Y = X – 2\n>>> Y.data\n3",
    "# On Number(start)\n# On instance - other\n# Result is a new instance\n# Fetch class from module\n# Number.__init__(X, 5)\n# Number.__sub__(X, 2)\n# Y is new Number instance\n\n>>> from number import Number\n>>> X = Number(5)\n>>> Y = X – 2\n>>> Y.data\n3\n\nAs discussed previously, the __init__ constructor method seen in this code is the most\ncommonly used operator overloading method in Python; it’s present in most classes.\nIn this chapter, we will tour some of the other tools available in this domain and look\nat example code that applies them in common use cases.",
    ">>> from number import Number\n>>> X = Number(5)\n>>> Y = X – 2\n>>> Y.data\n3\n\nAs discussed previously, the __init__ constructor method seen in this code is the most\ncommonly used operator overloading method in Python; it’s present in most classes.\nIn this chapter, we will tour some of the other tools available in this domain and look\nat example code that applies them in common use cases.\n\nCommon Operator Overloading Methods\nJust about everything you can do to built-in objects such as integers and lists has a\ncorresponding specially named method for overloading in classes. Table 29-1 lists a\nfew of the most common; there are many more. In fact, many overloading methods\ncome in multiple versions (e.g., __add__, __radd__, and __iadd__ for addition), which\nis one reason there are so many. See other Python books, or the Python language reference manual, for an exhaustive list of the special method names available.\nTable 29-1. Common operator overloading methods\nMethod\n\nImplements",
    "Implements\n\nCalled for\n\n__init__\n\nConstructor\n\nObject creation: X = Class(args)\n\n__del__\n\nDestructor\n\nObject reclamation of X\n\n__add__\n\nOperator +\n\nX + Y, X += Y if no __iadd__\n\n__or__\n\nOperator | (bitwise OR)\n\nX | Y, X |= Y if no __ior__\n\n__repr__, __str__\n\nPrinting, conversions\n\nprint(X), repr(X), str(X)\n\n__call__\n\nFunction calls\n\nX(*args, **kargs)\n\n__getattr__\n\nAttribute fetch\n\nX.undefined\n\n__setattr__\n\nAttribute assignment\n\nX.any = value\n\n__delattr__\n\nAttribute deletion\n\ndel X.any\n\n__getattribute__\n\nAttribute fetch\n\nX.any\n\n706 | Chapter 29: Operator Overloading\n\n\fMethod\n\nImplements\n\nCalled for\n\n__getitem__\n\nIndexing, slicing, iteration\n\nX[key], X[i:j], for loops and other iterations if no\n__iter__\n\n__setitem__\n\nIndex and slice assignment\n\nX[key] = value, X[i:j] = sequence\n\n__delitem__\n\nIndex and slice deletion\n\ndel X[key], del X[i:j]\n\n__len__\n\nLength\n\nlen(X), truth tests if no __bool__\n\n__bool__\n\nBoolean tests\n\nbool(X), truth tests (named __nonzero__ in 2.6)",
    "Implements\n\nCalled for\n\n__getitem__\n\nIndexing, slicing, iteration\n\nX[key], X[i:j], for loops and other iterations if no\n__iter__\n\n__setitem__\n\nIndex and slice assignment\n\nX[key] = value, X[i:j] = sequence\n\n__delitem__\n\nIndex and slice deletion\n\ndel X[key], del X[i:j]\n\n__len__\n\nLength\n\nlen(X), truth tests if no __bool__\n\n__bool__\n\nBoolean tests\n\nbool(X), truth tests (named __nonzero__ in 2.6)\n\n__lt__, __gt__,\n__le__, __ge__,\n__eq__, __ne__\n\nComparisons\n\nX < Y, X > Y, X <= Y, X >= Y, X == Y, X != Y (or\nelse __cmp__ in 2.6 only)\n\n__radd__\n\nRight-side operators\n\nOther + X\n\n__iadd__\n\nIn-place augmented operators\n\nX += Y (or else __add__)\n\n__iter__, __next__\n\nIteration contexts\n\nI=iter(X), next(I); for loops, in if no\n__contains__, all comprehensions, map(F,X), others\n(__next__ is named next in 2.6)\n\n__contains__\n\nMembership test\n\nitem in X (any iterable)\n\n__index__\n\nInteger value\n\nhex(X), bin(X), oct(X), O[X], O[X:] (replaces Python 2 __oct__, __hex__)\n\n__enter__, __exit__",
    "In-place augmented operators\n\nX += Y (or else __add__)\n\n__iter__, __next__\n\nIteration contexts\n\nI=iter(X), next(I); for loops, in if no\n__contains__, all comprehensions, map(F,X), others\n(__next__ is named next in 2.6)\n\n__contains__\n\nMembership test\n\nitem in X (any iterable)\n\n__index__\n\nInteger value\n\nhex(X), bin(X), oct(X), O[X], O[X:] (replaces Python 2 __oct__, __hex__)\n\n__enter__, __exit__\n\nContext manager (Chapter 33)\n\nwith obj as var:\n\n__get__, __set__,\n__delete__\n\nDescriptor attributes (Chapter 37)\n\nX.attr, X.attr = value, del X.attr\n\n__new__\n\nCreation (Chapter 39)\n\nObject creation, before __init__",
    "All overloading methods have names that start and end with two underscores to keep\nthem distinct from other names you define in your classes. The mappings from special\nmethod names to expressions or operations are predefined by the Python language (and\ndocumented in the standard language manual). For example, the name __add__ always\nmaps to + expressions by Python language definition, regardless of what an __add__\nmethod’s code actually does.\nOperator overloading methods may be inherited from superclasses if not defined, just\nlike any other methods. Operator overloading methods are also all optional—if you\ndon’t code or inherit one, that operation is simply unsupported by your class, and\nattempting it will raise an exception. Some built-in operations, like printing, have defaults (inherited for the implied object class in Python 3.0), but most built-ins fail for\nclass instances if no corresponding operator overloading method is present.",
    "don’t code or inherit one, that operation is simply unsupported by your class, and\nattempting it will raise an exception. Some built-in operations, like printing, have defaults (inherited for the implied object class in Python 3.0), but most built-ins fail for\nclass instances if no corresponding operator overloading method is present.\nMost overloading methods are used only in advanced programs that require objects to\nbehave like built-ins; the __init__ constructor tends to appear in most classes, however,\nso pay special attention to it. We’ve already met the __init__ initialization-time constructor method, and a few of the others in Table 29-1. Let’s explore some of the additional methods in the table by example.",
    "The Basics | 707\n\n\fIndexing and Slicing: __getitem__ and __setitem__\nIf defined in a class (or inherited by it), the __getitem__ method is called automatically\nfor instance-indexing operations. When an instance X appears in an indexing expression\nlike X[i], Python calls the __getitem__ method inherited by the instance, passing X to\nthe first argument and the index in brackets to the second argument. For example, the\nfollowing class returns the square of an index value:\n>>> class Indexer:\n...\ndef __getitem__(self, index):\n...\nreturn index ** 2\n...\n>>> X = Indexer()\n>>> X[2]\n4\n>>> for i in range(5):\n...\nprint(X[i], end=' ')\n...\n0 1 4 9 16\n\n# X[i] calls X.__getitem__(i)\n\n# Runs __getitem__(X, i) each time",
    "# X[i] calls X.__getitem__(i)\n\n# Runs __getitem__(X, i) each time\n\nIntercepting Slices\nInterestingly, in addition to indexing, __getitem__ is also called for slice expressions.\nFormally speaking, built-in types handle slicing the same way. Here, for example, is\nslicing at work on a built-in list, using upper and lower bounds and a stride (see Chapter 7 if you need a refresher on slicing):\n>>> L = [5, 6, 7, 8, 9]\n>>> L[2:4]\n[7, 8]\n>>> L[1:]\n[6, 7, 8, 9]\n>>> L[:-1]\n[5, 6, 7, 8]\n>>> L[::2]\n[5, 7, 9]\n\n# Slice with slice syntax\n\nReally, though, slicing bounds are bundled up into a slice object and passed to the list’s\nimplementation of indexing. In fact, you can always pass a slice object manually—slice\nsyntax is mostly syntactic sugar for indexing with a slice object:\n>>> L[slice(2, 4)]\n[7, 8]\n>>> L[slice(1, None)]\n[6, 7, 8, 9]\n>>> L[slice(None, −1)]\n[5, 6, 7, 8]\n>>> L[slice(None, None, 2)]\n[5, 7, 9]\n\n708 | Chapter 29: Operator Overloading\n\n# Slice with slice objects",
    "708 | Chapter 29: Operator Overloading\n\n# Slice with slice objects\n\n\fThis matters in classes with a __getitem__ method—the method will be called both for\nbasic indexing (with an index) and for slicing (with a slice object). Our previous class\nwon’t handle slicing because its math assumes integer indexes are passed, but the following class will. When called for indexing, the argument is an integer as before:\n>>> class Indexer:\n...\ndata = [5, 6, 7, 8, 9]\n...\ndef __getitem__(self, index):\n...\nprint('getitem:', index)\n...\nreturn self.data[index]\n...\n>>> X = Indexer()\n>>> X[0]\ngetitem: 0\n5\n>>> X[1]\ngetitem: 1\n6\n>>> X[-1]\ngetitem: −1\n9\n\n# Called for index or slice\n# Perform index or slice\n# Indexing sends __getitem__ an integer",
    "# Called for index or slice\n# Perform index or slice\n# Indexing sends __getitem__ an integer\n\nWhen called for slicing, though, the method receives a slice object, which is simply\npassed along to the embedded list indexer in a new index expression:\n>>> X[2:4]\ngetitem: slice(2, 4, None)\n[7, 8]\n>>> X[1:]\ngetitem: slice(1, None, None)\n[6, 7, 8, 9]\n>>> X[:-1]\ngetitem: slice(None, −1, None)\n[5, 6, 7, 8]\n>>> X[::2]\ngetitem: slice(None, None, 2)\n[5, 7, 9]\n\n# Slicing sends __getitem__ a slice object\n\nIf used, the __setitem__ index assignment method similarly intercepts both index and\nslice assignments—it receives a slice object for the latter, which may be passed along\nin another index assignment in the same way:\ndef __setitem__(self, index, value):\n...\nself.data[index] = value\n\n# Intercept index or slice assignment\n# Assign index or slice\n\nIn fact, __getitem__ may be called automatically in even more contexts than indexing\nand slicing, as the next section explains.",
    "# Intercept index or slice assignment\n# Assign index or slice\n\nIn fact, __getitem__ may be called automatically in even more contexts than indexing\nand slicing, as the next section explains.\n\nSlicing and Indexing in Python 2.6\nPrior to Python 3.0, classes could also define __getslice__ and __setslice__ methods\nto intercept slice fetches and assignments specifically; they were passed the bounds of\nthe slice expression and were preferred over __getitem__ and __setitem__ for slices.\nIndexing and Slicing: __getitem__ and __setitem__ | 709",
    "These slice-specific methods have been removed in 3.0, so you should use\n__getitem__ and __setitem__ instead and allow for both indexes and slice objects as\narguments. In most classes, this works without any special code, because indexing\nmethods can manually pass along the slice object in the square brackets of another\nindex expression (as in our example). See the section “Membership: __contains__,\n__iter__, and __getitem__” on page 716 for another example of slice interception at\nwork.\nAlso, don’t confuse the (arguably unfortunately named) __index__ method in Python\n3.0 for index interception; this method returns an integer value for an instance when\nneeded and is used by built-ins that convert to digit strings:\n>>> class C:\n...\ndef __index__(self):\n...\nreturn 255\n...\n>>> X = C()\n>>> hex(X)\n# Integer value\n'0xff'\n>>> bin(X)\n'0b11111111'\n>>> oct(X)\n'0o377'",
    "Although this method does not intercept instance indexing like __getitem__, it is also\nused in contexts that require an integer—including indexing:\n>>> ('C' * 256)[255]\n'C'\n>>> ('C' * 256)[X]\n'C'\n>>> ('C' * 256)[X:]\n'C'\n\n# As index (not X[i])\n# As index (not X[i:])\n\nThis method works the same way in Python 2.6, except that it is not called for the\nhex and oct built-in functions (use __hex__ and __oct__ in 2.6 instead to intercept these\ncalls).",
    "# As index (not X[i])\n# As index (not X[i:])\n\nThis method works the same way in Python 2.6, except that it is not called for the\nhex and oct built-in functions (use __hex__ and __oct__ in 2.6 instead to intercept these\ncalls).\n\nIndex Iteration: __getitem__\nHere’s a trick that isn’t always obvious to beginners, but turns out to be surprisingly\nuseful. The for statement works by repeatedly indexing a sequence from zero to higher\nindexes, until an out-of-bounds exception is detected. Because of that, __getitem__ also\nturns out to be one way to overload iteration in Python—if this method is defined,\nfor loops call the class’s __getitem__ each time through, with successively higher offsets. It’s a case of “buy one, get one free”—any built-in or user-defined object that\nresponds to indexing also responds to iteration:\n>>> class stepper:\n...\ndef __getitem__(self, i):\n...\nreturn self.data[i]\n...\n\n710 | Chapter 29: Operator Overloading",
    "710 | Chapter 29: Operator Overloading\n\n\f>>> X = stepper()\n>>> X.data = \"Spam\"\n>>>\n>>> X[1]\n'p'\n>>> for item in X:\n...\nprint(item, end=' ')\n...\nS p a m\n\n# X is a stepper object\n# Indexing calls __getitem__\n# for loops call __getitem__\n# for indexes items 0..N\n\nIn fact, it’s really a case of “buy one, get a bunch free.” Any class that supports for loops\nautomatically supports all iteration contexts in Python, many of which we’ve seen in\nearlier chapters (iteration contexts were presented in Chapter 14). For example, the\nin membership test, list comprehensions, the map built-in, list and tuple assignments,\nand type constructors will also call __getitem__ automatically, if it’s defined:\n>>> 'p' in X\nTrue\n\n# All call __getitem__ too\n\n>>> [c for c in X]\n['S', 'p', 'a', 'm']\n\n# List comprehension\n\n>>> list(map(str.upper, X))\n['S', 'P', 'A', 'M']\n\n# map calls (use list() in 3.0)\n\n>>> (a, b, c, d) = X\n>>> a, c, d\n('S', 'a', 'm')\n\n# Sequence assignments",
    "# All call __getitem__ too\n\n>>> [c for c in X]\n['S', 'p', 'a', 'm']\n\n# List comprehension\n\n>>> list(map(str.upper, X))\n['S', 'P', 'A', 'M']\n\n# map calls (use list() in 3.0)\n\n>>> (a, b, c, d) = X\n>>> a, c, d\n('S', 'a', 'm')\n\n# Sequence assignments\n\n>>> list(X), tuple(X), ''.join(X)\n(['S', 'p', 'a', 'm'], ('S', 'p', 'a', 'm'), 'Spam')\n>>> X\n<__main__.stepper object at 0x00A8D5D0>\n\nIn practice, this technique can be used to create objects that provide a sequence interface\nand to add logic to built-in sequence type operations; we’ll revisit this idea when extending built-in types in Chapter 31.",
    "Iterator Objects: __iter__ and __next__\nAlthough the __getitem__ technique of the prior section works, it’s really just a fallback\nfor iteration. Today, all iteration contexts in Python will try the __iter__ method first,\nbefore trying __getitem__. That is, they prefer the iteration protocol we learned about\nin Chapter 14 to repeatedly indexing an object; only if the object does not support the\niteration protocol is indexing attempted instead. Generally speaking, you should prefer\n__iter__ too—it supports general iteration contexts better than __getitem__ can.\nTechnically, iteration contexts work by calling the iter built-in function to try to find\nan __iter__ method, which is expected to return an iterator object. If it’s provided,\nPython then repeatedly calls this iterator object’s __next__ method to produce items\nIterator Objects: __iter__ and __next__ | 711",
    "until a StopIteration exception is raised. If no such __iter__ method is found, Python\nfalls back on the __getitem__ scheme and repeatedly indexes by offsets as before, until\nan IndexError exception is raised. A next built-in function is also available as a convenience for manual iterations: next(I) is the same as I.__next__().\nVersion skew note: As described in Chapter 14, if you are using Python\n2.6, the I.__next__() method just described is named I.next() in your\nPython, and the next(I) built-in is present for portability: it calls\nI.next() in 2.6 and I.__next__() in 3.0. Iteration works the same in 2.6\nin all other respects.",
    "User-Defined Iterators\nIn the __iter__ scheme, classes implement user-defined iterators by simply implementing the iteration protocol introduced in Chapters 14 and 20 (refer back to those\nchapters for more background details on iterators). For example, the following file,\niters.py, defines a user-defined iterator class that generates squares:\nclass Squares:\ndef __init__(self, start, stop):\nself.value = start - 1\nself.stop = stop\ndef __iter__(self):\nreturn self\ndef __next__(self):\nif self.value == self.stop:\nraise StopIteration\nself.value += 1\nreturn self.value ** 2\n% python\n>>> from iters import Squares\n>>> for i in Squares(1, 5):\n...\nprint(i, end=' ')\n...\n1 4 9 16 25\n\n# Save state when created\n# Get iterator object on iter\n# Return a square on each iteration\n# Also called by next built-in\n\n# for calls iter, which calls __iter__\n# Each iteration calls __next__",
    "# Save state when created\n# Get iterator object on iter\n# Return a square on each iteration\n# Also called by next built-in\n\n# for calls iter, which calls __iter__\n# Each iteration calls __next__\n\nHere, the iterator object is simply the instance self, because the __next__ method is\npart of this class. In more complex scenarios, the iterator object may be defined as a\nseparate class and object with its own state information to support multiple active\niterations over the same data (we’ll see an example of this in a moment). The end of\nthe iteration is signaled with a Python raise statement (more on raising exceptions in\nthe next part of this book). Manual iterations work as for built-in types as well:\n>>> X = Squares(1, 5)\n>>> I = iter(X)\n>>> next(I)\n1\n>>> next(I)\n4\n\n712 | Chapter 29: Operator Overloading\n\n# Iterate manually: what loops do\n# iter calls __iter__\n# next calls __next__\n\n\f...more omitted...\n>>> next(I)\n25\n>>> next(I)\nStopIteration\n\n# Can catch this in try statement",
    "712 | Chapter 29: Operator Overloading\n\n# Iterate manually: what loops do\n# iter calls __iter__\n# next calls __next__\n\n\f...more omitted...\n>>> next(I)\n25\n>>> next(I)\nStopIteration\n\n# Can catch this in try statement\n\nAn equivalent coding of this iterator with __getitem__ might be less natural, because\nthe for would then iterate through all offsets zero and higher; the offsets passed in\nwould be only indirectly related to the range of values produced (0..N would need to\nmap to start..stop). Because __iter__ objects retain explicitly managed state between\nnext calls, they can be more general than __getitem__.\nOn the other hand, using iterators based on __iter__ can sometimes be more complex\nand less convenient than using __getitem__. They are really designed for iteration, not\nrandom indexing—in fact, they don’t overload the indexing expression at all:\n>>> X = Squares(1, 5)\n>>> X[1]\nAttributeError: Squares instance has no attribute '__getitem__'",
    "The __iter__ scheme is also the implementation for all the other iteration contexts we\nsaw in action for __getitem__ (membership tests, type constructors, sequence assignment, and so on). However, unlike our prior __getitem__ example, we also need to be\naware that a class’s __iter__ may be designed for a single traversal, not many. For\nexample, the Squares class is a one-shot iteration; once you’ve iterated over an instance\nof that class, it’s empty. You need to make a new iterator object for each new iteration:\n>>> X = Squares(1, 5)\n>>> [n for n in X]\n[1, 4, 9, 16, 25]\n>>> [n for n in X]\n[]\n>>> [n for n in Squares(1, 5)]\n[1, 4, 9, 16, 25]\n>>> list(Squares(1, 3))\n[1, 4, 9]\n\n# Exhausts items\n# Now it's empty\n# Make a new iterator object",
    "# Exhausts items\n# Now it's empty\n# Make a new iterator object\n\nNotice that this example would probably be simpler if it were coded with generator\nfunctions (topics or expressions introduced in Chapter 20 and related to iterators):\n>>> def gsquares(start, stop):\n...\nfor i in range(start, stop+1):\n...\nyield i ** 2\n...\n>>> for i in gsquares(1, 5):\n...\nprint(i, end=' ')\n...\n1 4 9 16 25\n\n# or: (x ** 2 for x in range(1, 5))\n\nUnlike the class, the function automatically saves its state between iterations. Of course,\nfor this artificial example, you could in fact skip both techniques and simply use a\nfor loop, map, or a list comprehension to build the list all at once. The best and fastest\nway to accomplish a task in Python is often also the simplest:\n\nIterator Objects: __iter__ and __next__ | 713\n\n\f>>> [x ** 2 for x in range(1, 6)]\n[1, 4, 9, 16, 25]",
    "Iterator Objects: __iter__ and __next__ | 713\n\n\f>>> [x ** 2 for x in range(1, 6)]\n[1, 4, 9, 16, 25]\n\nHowever, classes may be better at modeling more complex iterations, especially when\nthey can benefit from state information and inheritance hierarchies. The next section\nexplores one such use case.\n\nMultiple Iterators on One Object\nEarlier, I mentioned that the iterator object may be defined as a separate class with its\nown state information to support multiple active iterations over the same data. Consider what happens when we step across a built-in type like a string:\n>>> S = 'ace'\n>>> for x in S:\n...\nfor y in S:\n...\nprint(x + y, end=' ')\n...\naa ac ae ca cc ce ea ec ee",
    "Here, the outer loop grabs an iterator from the string by calling iter, and each nested\nloop does the same to get an independent iterator. Because each active iterator has its\nown state information, each loop can maintain its own position in the string, regardless\nof any other active loops.\nWe saw related examples earlier, in Chapters 14 and 20. For instance, generator functions and expressions, as well as built-ins like map and zip, proved to be single-iterator\nobjects; by contrast, the range built-in and other built-in types, like lists, support multiple active iterators with independent positions.\nWhen we code user-defined iterators with classes, it’s up to us to decide whether we\nwill support a single active iteration or many. To achieve the multiple-iterator effect,\n__iter__ simply needs to define a new stateful object for the iterator, instead of returning self.\nThe following, for example, defines an iterator class that skips every other item on",
    "When we code user-defined iterators with classes, it’s up to us to decide whether we\nwill support a single active iteration or many. To achieve the multiple-iterator effect,\n__iter__ simply needs to define a new stateful object for the iterator, instead of returning self.\nThe following, for example, defines an iterator class that skips every other item on\niterations. Because the iterator object is created anew for each iteration, it supports\nmultiple active loops:\nclass SkipIterator:\ndef __init__(self, wrapped):\nself.wrapped = wrapped\nself.offset = 0\ndef __next__(self):\nif self.offset >= len(self.wrapped):\nraise StopIteration\nelse:\nitem = self.wrapped[self.offset]\nself.offset += 2\nreturn item\nclass SkipObject:",
    "714 | Chapter 29: Operator Overloading\n\n# Iterator state information\n# Terminate iterations\n# else return and skip\n\n\fdef __init__(self, wrapped):\nself.wrapped = wrapped\ndef __iter__(self):\nreturn SkipIterator(self.wrapped)\nif __name__ == '__main__':\nalpha = 'abcdef'\nskipper = SkipObject(alpha)\nI = iter(skipper)\nprint(next(I), next(I), next(I))\nfor x in skipper:\nfor y in skipper:\nprint(x + y, end=' ')\n\n# Save item to be used\n# New iterator each time\n\n# Make container object\n# Make an iterator on it\n# Visit offsets 0, 2, 4\n# for calls __iter__ automatically\n# Nested fors call __iter__ again each time\n# Each iterator has its own state, offset\n\nWhen run, this example works like the nested loops with built-in strings. Each active\nloop has its own position in the string because each obtains an independent iterator\nobject that records its own state information:\n% python skipper.py\na c e\naa ac ae ca cc ce ea ec ee",
    "When run, this example works like the nested loops with built-in strings. Each active\nloop has its own position in the string because each obtains an independent iterator\nobject that records its own state information:\n% python skipper.py\na c e\naa ac ae ca cc ce ea ec ee\n\nBy contrast, our earlier Squares example supports just one active iteration, unless we\ncall Squares again in nested loops to obtain new objects. Here, there is just one\nSkipObject, with multiple iterator objects created from it.\nAs before, we could achieve similar results with built-in tools—for example, slicing\nwith a third bound to skip items:\n>>> S = 'abcdef'\n>>> for x in S[::2]:\n...\nfor y in S[::2]:\n...\nprint(x + y, end=' ')\n...\naa ac ae ca cc ce ea ec ee\n\n# New objects on each iteration",
    "# New objects on each iteration\n\nThis isn’t quite the same, though, for two reasons. First, each slice expression here will\nphysically store the result list all at once in memory; iterators, on the other hand, produce just one value at a time, which can save substantial space for large result lists.\nSecond, slices produce new objects, so we’re not really iterating over the same object\nin multiple places here. To be closer to the class, we would need to make a single object\nto step across by slicing ahead of time:\n>>> S = 'abcdef'\n>>> S = S[::2]\n>>> S\n'ace'\n>>> for x in S:\n...\nfor y in S:\n...\nprint(x + y, end=' ')\n...\naa ac ae ca cc ce ea ec ee\n\n# Same object, new iterators\n\nIterator Objects: __iter__ and __next__ | 715",
    "# Same object, new iterators\n\nIterator Objects: __iter__ and __next__ | 715\n\n\fThis is more similar to our class-based solution, but it still stores the slice result in\nmemory all at once (there is no generator form of built-in slicing today), and it’s only\nequivalent for this particular case of skipping every other item.\nBecause iterators can do anything a class can do, they are much more general than this\nexample may imply. Regardless of whether our applications require such generality,\nuser-defined iterators are a powerful tool—they allow us to make arbitrary objects look\nand feel like the other sequences and iterables we have met in this book. We could use\nthis technique with a database object, for example, to support iterations over database\nfetches, with multiple cursors into the same query result.",
    "Membership: __contains__, __iter__, and __getitem__\nThe iteration story is even richer than we’ve seen thus far. Operator overloading is often\nlayered: classes may provide specific methods, or more general alternatives used as\nfallback options. For example:\n• Comparisons in Python 2.6 use specific methods such as __lt__ for less than if\npresent, or else the general __cmp__. Python 3.0 uses only specific methods, not\n__cmp__, as discussed later in this chapter.\n• Boolean tests similarly try a specific __bool__ first (to give an explicit True/False\nresult), and if it’s absent fall back on the more general __len__ (a nonzero length\nmeans True). As we’ll also see later in this chapter, Python 2.6 works the same but\nuses the name __nonzero__ instead of __bool__.\nIn the iterations domain, classes normally implement the in membership operator as\nan iteration, using either the __iter__ method or the __getitem__ method. To support",
    "result), and if it’s absent fall back on the more general __len__ (a nonzero length\nmeans True). As we’ll also see later in this chapter, Python 2.6 works the same but\nuses the name __nonzero__ instead of __bool__.\nIn the iterations domain, classes normally implement the in membership operator as\nan iteration, using either the __iter__ method or the __getitem__ method. To support\nmore specific membership, though, classes may code a __contains__ method—when\npresent, this method is preferred over __iter__, which is preferred over __getitem__.\nThe __contains__ method should define membership as applying to keys for a mapping (and can use quick lookups), and as a search for sequences.\nConsider the following class, which codes all three methods and tests membership and\nvarious iteration contexts applied to an instance. Its methods print trace messages when\ncalled:\nclass Iters:\ndef __init__(self, value):\nself.data = value\ndef __getitem__(self, i):\nprint('get[%s]:' % i, end='')",
    "Consider the following class, which codes all three methods and tests membership and\nvarious iteration contexts applied to an instance. Its methods print trace messages when\ncalled:\nclass Iters:\ndef __init__(self, value):\nself.data = value\ndef __getitem__(self, i):\nprint('get[%s]:' % i, end='')\nreturn self.data[i]\ndef __iter__(self):\nprint('iter=> ', end='')\nself.ix = 0\nreturn self\ndef __next__(self):\nprint('next:', end='')",
    "716 | Chapter 29: Operator Overloading\n\n# Fallback for iteration\n# Also for index, slice\n# Preferred for iteration\n# Allows only 1 active iterator\n\n\fif self.ix == len(self.data): raise StopIteration\nitem = self.data[self.ix]\nself.ix += 1\nreturn item\ndef __contains__(self, x):\n# Preferred for 'in'\nprint('contains: ', end='')\nreturn x in self.data\nX = Iters([1, 2, 3, 4, 5])\nprint(3 in X)\nfor i in X:\nprint(i, end=' | ')\nprint()\nprint([i ** 2 for i in X])\nprint( list(map(bin, X)) )\nI = iter(X)\nwhile True:\ntry:\nprint(next(I), end=' @ ')\nexcept StopIteration:\nbreak\n\n# Make instance\n# Membership\n# For loops\n\n# Other iteration contexts\n# Manual iteration (what other contexts do)",
    "# Make instance\n# Membership\n# For loops\n\n# Other iteration contexts\n# Manual iteration (what other contexts do)\n\nWhen run as it is, this script’s output is as follows—the specific __contains__ intercepts\nmembership, the general __iter__ catches other iteration contexts such that __next__\nis called repeatedly, and __getitem__ is never called:\ncontains: True\niter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:\niter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]\niter=> next:next:next:next:next:next:['0b1', '0b10', '0b11', '0b100', '0b101']\niter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:",
    "Watch what happens to this code’s output if we comment out its __contains__ method,\nthough—membership is now routed to the general __iter__ instead:\niter=> next:next:next:True\niter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:\niter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]\niter=> next:next:next:next:next:next:['0b1', '0b10', '0b11', '0b100', '0b101']\niter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:\n\nAnd finally, here is the output if both __contains__ and __iter__ are commented out—\nthe indexing __getitem__ fallback is called with successively higher indexes for membership and other iteration contexts:\nget[0]:get[1]:get[2]:True\nget[0]:1 | get[1]:2 | get[2]:3 | get[3]:4 | get[4]:5 | get[5]:\nget[0]:get[1]:get[2]:get[3]:get[4]:get[5]:[1, 4, 9, 16, 25]\nget[0]:get[1]:get[2]:get[3]:get[4]:get[5]:['0b1', '0b10', '0b11', '0b100','0b101']\nget[0]:1 @ get[1]:2 @ get[2]:3 @ get[3]:4 @ get[4]:5 @ get[5]:\n\nMembership: __contains__, __iter__, and __getitem__ | 717",
    "Membership: __contains__, __iter__, and __getitem__ | 717\n\n\fAs we’ve seen, the __getitem__ method is even more general: besides iterations, it also\nintercepts explicit indexing as well as slicing. Slice expressions trigger __getitem__ with\na slice object containing bounds, both for built-in types and user-defined classes, so\nslicing is automatic in our class:\n>>> X = Iters('spam')\n>>> X[0]\nget[0]:'s'\n\n# Indexing\n# __getitem__(0)\n\n>>> 'spam'[1:]\n'pam'\n>>> 'spam'[slice(1, None)]\n'pam'\n\n# Slice syntax\n\n>>> X[1:]\nget[slice(1, None, None)]:'pam'\n>>> X[:-1]\nget[slice(None, −1, None)]:'spa'\n\n# __getitem__(slice(..))\n\n# Slice object\n\nIn more realistic iteration use cases that are not sequence-oriented, though, the\n__iter__ method may be easier to write since it must not manage an integer index, and\n__contains__ allows for membership optimization as a special case.",
    "# __getitem__(slice(..))\n\n# Slice object\n\nIn more realistic iteration use cases that are not sequence-oriented, though, the\n__iter__ method may be easier to write since it must not manage an integer index, and\n__contains__ allows for membership optimization as a special case.\n\nAttribute Reference: __getattr__ and __setattr__\nThe __getattr__ method intercepts attribute qualifications. More specifically, it’s\ncalled with the attribute name as a string whenever you try to qualify an instance with\nan undefined (nonexistent) attribute name. It is not called if Python can find the attribute\nusing its inheritance tree search procedure. Because of its behavior, __getattr__ is useful as a hook for responding to attribute requests in a generic fashion. For example:\n>>> class empty:\n...\ndef __getattr__(self, attrname):\n...\nif attrname == \"age\":\n...\nreturn 40\n...\nelse:\n...\nraise AttributeError, attrname\n...\n>>> X = empty()\n>>> X.age\n40\n>>> X.name\n...error text omitted...\nAttributeError: name",
    "Here, the empty class and its instance X have no real attributes of their own, so the access\nto X.age gets routed to the __getattr__ method; self is assigned the instance (X), and\nattrname is assigned the undefined attribute name string (\"age\"). The class makes age\nlook like a real attribute by returning a real value as the result of the X.age qualification\nexpression (40). In effect, age becomes a dynamically computed attribute.\n\n718 | Chapter 29: Operator Overloading",
    "For attributes that the class doesn’t know how to handle, __getattr__ raises the builtin AttributeError exception to tell Python that these are bona fide undefined names;\nasking for X.name triggers the error. You’ll see __getattr__ again when we see delegation\nand properties at work in the next two chapters, and I’ll say more about exceptions in\nPart VII.\nA related overloading method, __setattr__, intercepts all attribute assignments. If this\nmethod is defined, self.attr = value becomes self.__setattr__('attr', value). This\nis a bit trickier to use because assigning to any self attributes within __setattr__ calls\n__setattr__ again, causing an infinite recursion loop (and eventually, a stack overflow\nexception!). If you want to use this method, be sure that it assigns any instance attributes by indexing the attribute dictionary, discussed in the next section. That is, use\nself.__dict__['name'] = x, not self.name = x:\n>>> class accesscontrol:\n...\ndef __setattr__(self, attr, value):",
    "__setattr__ again, causing an infinite recursion loop (and eventually, a stack overflow\nexception!). If you want to use this method, be sure that it assigns any instance attributes by indexing the attribute dictionary, discussed in the next section. That is, use\nself.__dict__['name'] = x, not self.name = x:\n>>> class accesscontrol:\n...\ndef __setattr__(self, attr, value):\n...\nif attr == 'age':\n...\nself.__dict__[attr] = value\n...\nelse:\n...\nraise AttributeError, attr + ' not allowed'\n...\n>>> X = accesscontrol()\n>>> X.age = 40\n# Calls __setattr__\n>>> X.age\n40\n>>> X.name = 'mel'\n...text omitted...\nAttributeError: name not allowed",
    "These two attribute-access overloading methods allow you to control or specialize access to attributes in your objects. They tend to play highly specialized roles, some of\nwhich we’ll explore later in this book.",
    "Other Attribute Management Tools\nFor future reference, also note that there are other ways to manage attribute access in\nPython:\n• The __getattribute__ method intercepts all attribute fetches, not just those that\nare undefined, but when using it you must be more cautious than with\n__getattr__ to avoid loops.\n• The property built-in function allows us to associate methods with fetch and set\noperations on a specific class attribute.\n• Descriptors provide a protocol for associating __get__ and __set__ methods of a\nclass with accesses to a specific class attribute.\nBecause these are somewhat advanced tools not of interest to every Python programmer, we’ll defer a look at properties until Chapter 31 and detailed coverage of all the\nattribute management techniques until Chapter 37.\nAttribute Reference: __getattr__ and __setattr__ | 719",
    "Emulating Privacy for Instance Attributes: Part 1\nThe following code generalizes the previous example, to allow each subclass to have\nits own list of private names that cannot be assigned to its instances:\nclass PrivateExc(Exception): pass\nclass Privacy:\ndef __setattr__(self, attrname, value):\nif attrname in self.privates:\nraise PrivateExc(attrname, self)\nelse:\nself.__dict__[attrname] = value\n\n# More on exceptions later\n# On self.attrname = value\n\n# self.attrname = value loops!\n\nclass Test1(Privacy):\nprivates = ['age']\nclass Test2(Privacy):\nprivates = ['name', 'pay']\ndef __init__(self):\nself.__dict__['name'] = 'Tom'\nx = Test1()\ny = Test2()\nx.name = 'Bob'\ny.name = 'Sue'\n\n# Fails\n\ny.age\nx.age\n\n# Fails\n\n= 30\n= 40",
    "In fact, this is a first-cut solution for an implementation of attribute privacy in Python\n(i.e., disallowing changes to attribute names outside a class). Although Python doesn’t\nsupport private declarations per se, techniques like this can emulate much of their\npurpose. This is a partial solution, though; to make it more effective, it must be augmented to allow subclasses to set private attributes more naturally, too, and to use\n__getattr__ and a wrapper (sometimes called a proxy) class to check for private attribute fetches.\nWe’ll postpone a more complete solution to attribute privacy until Chapter 38, where\nwe’ll use class decorators to intercept and validate attributes more generally. Even\nthough privacy can be emulated this way, though, it almost never is in practice. Python\nprogrammers are able to write large OOP frameworks and applications without private\ndeclarations—an interesting finding about access controls in general that is beyond the\nscope of our purposes here.",
    "we’ll use class decorators to intercept and validate attributes more generally. Even\nthough privacy can be emulated this way, though, it almost never is in practice. Python\nprogrammers are able to write large OOP frameworks and applications without private\ndeclarations—an interesting finding about access controls in general that is beyond the\nscope of our purposes here.\nCatching attribute references and assignments is generally a useful technique; it supports delegation, a design technique that allows controller objects to wrap up embedded\nobjects, add new behaviors, and route other operations back to the wrapped objects\n(more on delegation and wrapper classes in Chapter 30).",
    "720 | Chapter 29: Operator Overloading\n\n\fString Representation: __repr__ and __str__\nThe next example exercises the __init__ constructor and the __add__ overload method,\nboth of which we’ve already seen, as well as defining a __repr__ method that returns a\nstring representation for instances. String formatting is used to convert the managed\nself.data object to a string. If defined, __repr__ (or its sibling, __str__) is called automatically when class instances are printed or converted to strings. These methods allow\nyou to define a better display format for your objects than the default instance display.\nThe default display of instance objects is neither useful nor pretty:\n>>> class adder:\n...\ndef __init__(self, value=0):\n...\nself.data = value\n...\ndef __add__(self, other):\n...\nself.data += other\n...\n>>> x = adder()\n>>> print(x)\n<__main__.adder object at 0x025D66B0>\n>>> x\n<__main__.adder object at 0x025D66B0>\n\n# Initialize data\n# Add other in-place (bad!)\n# Default displays",
    "# Initialize data\n# Add other in-place (bad!)\n# Default displays\n\nBut coding or inheriting string representation methods allows us to customize the\ndisplay:\n>>> class addrepr(adder):\n...\ndef __repr__(self):\n...\nreturn 'addrepr(%s)' % self.data\n...\n>>> x = addrepr(2)\n>>> x + 1\n>>> x\naddrepr(3)\n>>> print(x)\naddrepr(3)\n>>> str(x), repr(x)\n('addrepr(3)', 'addrepr(3)')\n\n# Inherit __init__, __add__\n# Add string representation\n# Convert to as-code string\n# Runs __init__\n# Runs __add__\n# Runs __repr__\n# Runs __repr__\n# Runs __repr__ for both",
    "# Inherit __init__, __add__\n# Add string representation\n# Convert to as-code string\n# Runs __init__\n# Runs __add__\n# Runs __repr__\n# Runs __repr__\n# Runs __repr__ for both\n\nSo why two display methods? Mostly, to support different audiences. In full detail:\n• __str__ is tried first for the print operation and the str built-in function (the internal equivalent of which print runs). It generally should return a user-friendly\ndisplay.\n• __repr__ is used in all other contexts: for interactive echoes, the repr function, and\nnested appearances, as well as by print and str if no __str__ is present. It should\ngenerally return an as-code string that could be used to re-create the object, or a\ndetailed display for developers.\nIn a nutshell, __repr__ is used everywhere, except by print and str when a __str__ is\ndefined. Note, however, that while printing falls back on __repr__ if no __str__ is\n\nString Representation: __repr__ and __str__ | 721",
    "String Representation: __repr__ and __str__ | 721\n\n\fdefined, the inverse is not true—other contexts, such as interactive echoes, use\n__repr__ only and don’t try __str__ at all:\n>>> class addstr(adder):\n...\ndef __str__(self):\n# __str__ but no __repr__\n...\nreturn '[Value: %s]' % self.data\n# Convert to nice string\n...\n>>> x = addstr(3)\n>>> x + 1\n>>> x\n# Default __repr__\n<__main__.addstr object at 0x00B35EF0>\n>>> print(x)\n# Runs __str__\n[Value: 4]\n>>> str(x), repr(x)\n('[Value: 4]', '<__main__.addstr object at 0x00B35EF0>')",
    "Because of this, __repr__ may be best if you want a single display for all contexts. By\ndefining both methods, though, you can support different displays in different\ncontexts—for example, an end-user display with __str__, and a low-level display for\nprogrammers to use during development with __repr__. In effect, __str__ simply overrides __repr__ for user-friendly display contexts:\n>>> class addboth(adder):\n...\ndef __str__(self):\n...\nreturn '[Value: %s]' % self.data\n...\ndef __repr__(self):\n...\nreturn 'addboth(%s)' % self.data\n...\n>>> x = addboth(4)\n>>> x + 1\n>>> x\naddboth(5)\n>>> print(x)\n[Value: 5]\n>>> str(x), repr(x)\n('[Value: 5]', 'addboth(5)')\n\n# User-friendly string\n# As-code string\n\n# Runs __repr__\n# Runs __str__",
    "# User-friendly string\n# As-code string\n\n# Runs __repr__\n# Runs __str__\n\nI should mention two usage notes here. First, keep in mind that __str__ and\n__repr__ must both return strings; other result types are not converted and raise errors,\nso be sure to run them through a converter if needed. Second, depending on a container’s string-conversion logic, the user-friendly display of __str__ might only apply\nwhen objects appear at the top level of a print operation; objects nested in larger objects\nmight still print with their __repr__ or its default. The following illustrates both of these\npoints:\n>>> class Printer:\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __str__(self):\n...\nreturn str(self.val)\n...\n>>> objs = [Printer(2), Printer(3)]\n>>> for x in objs: print(x)\n...\n\n722 | Chapter 29: Operator Overloading\n\n# Used for instance itself\n# Convert to a string result\n# __str__ run when instance printed\n# But not when instance in a list!",
    "722 | Chapter 29: Operator Overloading\n\n# Used for instance itself\n# Convert to a string result\n# __str__ run when instance printed\n# But not when instance in a list!\n\n\f2\n3\n>>> print(objs)\n[<__main__.Printer object at 0x025D06F0>, <__main__.Printer object at ...more...\n>>> objs\n[<__main__.Printer object at 0x025D06F0>, <__main__.Printer object at ...more...\n\nTo ensure that a custom display is run in all contexts regardless of the container, code\n__repr__, not __str__; the former is run in all cases if the latter doesn’t apply:\n>>> class Printer:\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __repr__(self):\n...\nreturn str(self.val)\n...\n>>> objs = [Printer(2), Printer(3)]\n>>> for x in objs: print(x)\n...\n2\n3\n>>> print(objs)\n[2, 3]\n>>> objs\n[2, 3]\n\n# __repr__ used by print if no __str__\n# __repr__ used if echoed or nested\n# No __str__: runs __repr__\n\n# Runs __repr__, not ___str__",
    "# __repr__ used by print if no __str__\n# __repr__ used if echoed or nested\n# No __str__: runs __repr__\n\n# Runs __repr__, not ___str__\n\nIn practice, __str__ (or its low-level relative, __repr__) seems to be the second most\ncommonly used operator overloading method in Python scripts, behind __init__. Any\ntime you can print an object and see a custom display, one of these two tools is probably\nin use.",
    "Right-Side and In-Place Addition: __radd__ and __iadd__\nTechnically, the __add__ method that appeared in the prior example does not support\nthe use of instance objects on the right side of the + operator. To implement such\nexpressions, and hence support commutative-style operators, code the __radd__\nmethod as well. Python calls __radd__ only when the object on the right side of the + is\nyour class instance, but the object on the left is not an instance of your class. The\n__add__ method for the object on the left is called instead in all other cases:\n>>> class Commuter:\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __add__(self, other):\n...\nprint('add', self.val, other)\n...\nreturn self.val + other\n...\ndef __radd__(self, other):\n...\nprint('radd', self.val, other)\n...\nreturn other + self.val\n...\n>>> x = Commuter(88)\n>>> y = Commuter(99)\n\nRight-Side and In-Place Addition: __radd__ and __iadd__ | 723",
    "Right-Side and In-Place Addition: __radd__ and __iadd__ | 723\n\n\f>>> x + 1\n# __add__: instance + noninstance\nadd 88 1\n89\n>>> 1 + y\n# __radd__: noninstance + instance\nradd 99 1\n100\n>>> x + y\n# __add__: instance + instance, triggers __radd__\nadd 88 <__main__.Commuter object at 0x02630910>\nradd 99 88\n187",
    "Notice how the order is reversed in __radd__: self is really on the right of the +, and\nother is on the left. Also note that x and y are instances of the same class here; when\ninstances of different classes appear mixed in an expression, Python prefers the class\nof the one on the left. When we add the two instances together, Python runs __add__,\nwhich in turn triggers __radd__ by simplifying the left operand.\nIn more realistic classes where the class type may need to be propagated in results,\nthings can become trickier: type testing may be required to tell whether it’s safe to\nconvert and thus avoid nesting. For instance, without the isinstance test in the following, we could wind up with a Commuter whose val is another Commuter when two\ninstances are added and __add__ triggers __radd__:\n>>> class Commuter:\n# Propagate class type in results\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __add__(self, other):\n...\nif isinstance(other, Commuter): other = other.val\n...",
    "instances are added and __add__ triggers __radd__:\n>>> class Commuter:\n# Propagate class type in results\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __add__(self, other):\n...\nif isinstance(other, Commuter): other = other.val\n...\nreturn Commuter(self.val + other)\n...\ndef __radd__(self, other):\n...\nreturn Commuter(other + self.val)\n...\ndef __str__(self):\n...\nreturn '<Commuter: %s>' % self.val\n...\n>>> x = Commuter(88)\n>>> y = Commuter(99)\n>>> print(x + 10)\n# Result is another Commuter instance\n<Commuter: 98>\n>>> print(10 + y)\n<Commuter: 109>\n>>> z = x + y\n>>> print(z)\n<Commuter: 187>\n>>> print(z + 10)\n<Commuter: 197>\n>>> print(z + z)\n<Commuter: 374>",
    "724 | Chapter 29: Operator Overloading\n\n# Not nested: doesn't recur to __radd__\n\n\fIn-Place Addition\nTo also implement += in-place augmented addition, code either an __iadd__ or an\n__add__. The latter is used if the former is absent. In fact, the prior section’s Commuter\nclass supports += already for this reason, but __iadd__ allows for more efficient in-place\nchanges:\n>>> class Number:\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __iadd__(self, other):\n...\nself.val += other\n...\nreturn self\n...\n>>> x = Number(5)\n>>> x += 1\n>>> x += 1\n>>> x.val\n7\n>>> class Number:\n...\ndef __init__(self, val):\n...\nself.val = val\n...\ndef __add__(self, other):\n...\nreturn Number(self.val + other)\n...\n>>> x = Number(5)\n>>> x += 1\n>>> x += 1\n>>> x.val\n7\n\n# __iadd__ explicit: x += y\n# Usually returns self\n\n# __add__ fallback: x = (x + y)\n# Propagates class type",
    "# __iadd__ explicit: x += y\n# Usually returns self\n\n# __add__ fallback: x = (x + y)\n# Propagates class type\n\nEvery binary operator has similar right-side and in-place overloading methods that\nwork the same (e.g., __mul__, __rmul__, and __imul__). Right-side methods are an advanced topic and tend to be fairly rarely used in practice; you only code them when\nyou need operators to be commutative, and then only if you need to support such\noperators at all. For instance, a Vector class may use these tools, but an Employee or\nButton class probably would not.\n\nCall Expressions: __call__\nThe __call__ method is called when your instance is called. No, this isn’t a circular\ndefinition—if defined, Python runs a __call__ method for function call expressions\napplied to your instances, passing along whatever positional or keyword arguments\nwere sent:\n>>> class Callee:\n...\ndef __call__(self, *pargs, **kargs):\n...\nprint('Called:', pargs, kargs)\n...\n>>> C = Callee()\n>>> C(1, 2, 3)",
    "# Intercept instance calls\n# Accept arbitrary arguments\n# C is a callable object\n\nCall Expressions: __call__ | 725\n\n\fCalled: (1, 2, 3) {}\n>>> C(1, 2, 3, x=4, y=5)\nCalled: (1, 2, 3) {'y': 5, 'x': 4}\n\nMore formally, all the argument-passing modes we explored in Chapter 18 are supported by the __call__ method—whatever is passed to the instance is passed to this\nmethod, along with the usual implied instance argument. For example, the method\ndefinitions:\nclass C:\ndef __call__(self, a, b, c=5, d=6): ...\n\n# Normals and defaults\n\nclass C:\ndef __call__(self, *pargs, **kargs): ...\n\n# Collect arbitrary arguments\n\nclass C:\ndef __call__(self, *pargs, d=6, **kargs): ... # 3.0 keyword-only argument\n\nall match all the following instance calls:\nX = C()\nX(1, 2)\nX(1, 2, 3, 4)\nX(a=1, b=2, d=4)\nX(*[1, 2], **dict(c=3, d=4))\nX(1, *(2,), c=3, **dict(d=4))\n\n# Omit defaults\n# Positionals\n# Keywords\n# Unpack arbitrary arguments\n# Mixed modes",
    "# Collect arbitrary arguments\n\nclass C:\ndef __call__(self, *pargs, d=6, **kargs): ... # 3.0 keyword-only argument\n\nall match all the following instance calls:\nX = C()\nX(1, 2)\nX(1, 2, 3, 4)\nX(a=1, b=2, d=4)\nX(*[1, 2], **dict(c=3, d=4))\nX(1, *(2,), c=3, **dict(d=4))\n\n# Omit defaults\n# Positionals\n# Keywords\n# Unpack arbitrary arguments\n# Mixed modes\n\nThe net effect is that classes and instances with a __call__ support the exact same\nargument syntax and semantics as normal functions and methods.\nIntercepting call expression like this allows class instances to emulate the look and feel\nof things like functions, but also retain state information for use during calls (we saw\na similar example while exploring scopes in Chapter 17, but you should be more familiar with operator overloading here):\n>>> class Prod:\n...\ndef __init__(self, value):\n...\nself.value = value\n...\ndef __call__(self, other):\n...\nreturn self.value * other\n...\n>>> x = Prod(2)\n>>> x(3)\n6\n>>> x(4)\n8",
    "# Accept just one argument\n\n# \"Remembers\" 2 in state\n# 3 (passed) * 2 (state)\n\nIn this example, the __call__ may seem a bit gratuitous at first glance. A simple method\ncan provide similar utility:\n>>> class Prod:\n...\ndef __init__(self, value):\n...\nself.value = value\n...\ndef comp(self, other):\n...\nreturn self.value * other\n...\n\n726 | Chapter 29: Operator Overloading\n\n\f>>> x = Prod(3)\n>>> x.comp(3)\n9\n>>> x.comp(4)\n12\n\nHowever, __call__ can become more useful when interfacing with APIs that expect\nfunctions—it allows us to code objects that conform to an expected function call interface, but also retain state information. In fact, it’s probably the third most commonly\nused operator overloading method, behind the __init__ constructor and the __str__\nand __repr__ display-format alternatives.",
    "Function Interfaces and Callback-Based Code\nAs an example, the tkinter GUI toolkit (named Tkinter in Python 2.6) allows you to\nregister functions as event handlers (a.k.a. callbacks); when events occur, tkinter calls\nthe registered objects. If you want an event handler to retain state between events, you\ncan register either a class’s bound method or an instance that conforms to the expected\ninterface with __call__. In this section’s code, both x.comp from the second example\nand x from the first can pass as function-like objects this way.\nI’ll have more to say about bound methods in the next chapter, but for now, here’s a\nhypothetical example of __call__ applied to the GUI domain. The following class defines an object that supports a function-call interface, but also has state information\nthat remembers the color a button should change to when it is later pressed:\nclass Callback:\ndef __init__(self, color):\nself.color = color\ndef __call__(self):\nprint('turn', self.color)",
    "# Function + state information\n# Support calls with no arguments\n\nNow, in the context of a GUI, we can register instances of this class as event handlers\nfor buttons, even though the GUI expects to be able to invoke event handlers as simple\nfunctions with no arguments:\ncb1 = Callback('blue')\ncb2 = Callback('green')\n\n# Remember blue\n\nB1 = Button(command=cb1)\nB2 = Button(command=cb2)\n\n# Register handlers\n# Register handlers\n\nWhen the button is later pressed, the instance object is called as a simple function,\nexactly like in the following calls. Because it retains state as instance attributes, though,\nit remembers what to do:\ncb1()\ncb2()\n\n# On events: prints 'blue'\n# Prints 'green'\n\nIn fact, this is probably the best way to retain state information in the Python\nlanguage—better than the techniques discussed earlier for functions (global variables,\n\nCall Expressions: __call__ | 727",
    "# On events: prints 'blue'\n# Prints 'green'\n\nIn fact, this is probably the best way to retain state information in the Python\nlanguage—better than the techniques discussed earlier for functions (global variables,\n\nCall Expressions: __call__ | 727\n\n\fenclosing function scope references, and default mutable arguments). With OOP, the\nstate remembered is made explicit with attribute assignments.\nBefore we move on, there are two other ways that Python programmers sometimes tie\ninformation to a callback function like this. One option is to use default arguments in\nlambda functions:\ncb3 = (lambda color='red': 'turn ' + color) # Or: defaults\nprint(cb3())",
    "The other is to use bound methods of a class. A bound method object is a kind of object\nthat remembers the self instance and the referenced function. A bound method may\ntherefore be called as a simple function without an instance later:\nclass Callback:\ndef __init__(self, color):\nself.color = color\ndef changeColor(self):\nprint('turn', self.color)\n\n# Class with state information\n# A normal named method\n\ncb1 = Callback('blue')\ncb2 = Callback('yellow')\nB1 = Button(command=cb1.changeColor)\nB2 = Button(command=cb2.changeColor)\n\n# Reference, but don't call\n# Remembers function+self\n\nIn this case, when this button is later pressed it’s as if the GUI does this, which invokes\nthe changeColor method to process the object’s state information:\nobject = Callback('blue')\ncb = object.changeColor\ncb()\n\n# Registered event handler\n# On event prints 'blue'",
    "# Reference, but don't call\n# Remembers function+self\n\nIn this case, when this button is later pressed it’s as if the GUI does this, which invokes\nthe changeColor method to process the object’s state information:\nobject = Callback('blue')\ncb = object.changeColor\ncb()\n\n# Registered event handler\n# On event prints 'blue'\n\nThis technique is simpler, but less general than overloading calls with __call__; again,\nwatch for more about bound methods in the next chapter.\nYou’ll also see another __call__ example in Chapter 31, where we will use it to implement something known as a function decorator—a callable object often used to add a\nlayer of logic on top of an embedded function. Because __call__ allows us to attach\nstate information to a callable object, it’s a natural implementation technique for a\nfunction that must remember and call another function.",
    "Comparisons: __lt__, __gt__, and Others\nAs suggested in Table 29-1, classes can define methods to catch all six comparison\noperators: <, >, <=, >=, ==, and !=. These methods are generally straightforward to use,\nbut keep the following qualifications in mind:\n\n728 | Chapter 29: Operator Overloading",
    "• Unlike the __add__/__radd__ pairings discussed earlier, there are no right-side\nvariants of comparison methods. Instead, reflective methods are used when only\none operand supports comparison (e.g., __lt__ and __gt__ are each other’s\nreflection).\n• There are no implicit relationships among the comparison operators. The truth of\n== does not imply that != is false, for example, so both __eq__ and __ne__ should\nbe defined to ensure that both operators behave correctly.\n• In Python 2.6, a __cmp__ method is used by all comparisons if no more specific\ncomparison methods are defined; it returns a number that is less than, equal to, or\ngreater than zero, to signal less than, equal, and greater than results for the comparison of its two arguments (self and another operand). This method often uses\nthe cmp(x, y) built-in to compute its result. Both the __cmp__ method and the\ncmp built-in function are removed in Python 3.0: use the more specific methods\ninstead.",
    "greater than zero, to signal less than, equal, and greater than results for the comparison of its two arguments (self and another operand). This method often uses\nthe cmp(x, y) built-in to compute its result. Both the __cmp__ method and the\ncmp built-in function are removed in Python 3.0: use the more specific methods\ninstead.\nWe don’t have space for an in-depth exploration of comparison methods, but as a quick\nintroduction, consider the following class and test code:\nclass C:\ndata = 'spam'\ndef __gt__(self, other):\nreturn self.data > other\ndef __lt__(self, other):\nreturn self.data < other\nX = C()\nprint(X > 'ham')\nprint(X < 'ham')",
    "# 3.0 and 2.6 version\n\n# True (runs __gt__)\n# False (runs __lt__)\n\nWhen run under Python 3.0 or 2.6, the prints at the end display the expected results\nnoted in their comments, because the class’s methods intercept and implement comparison expressions.\n\nThe 2.6 __cmp__ Method (Removed in 3.0)\nIn Python 2.6, the __cmp__ method is used as a fallback if more specific methods are\nnot defined: its integer result is used to evaluate the operator being run. The following\nproduces the same result under 2.6, for example, but fails in 3.0 because __cmp__ is no\nlonger used:\nclass C:\ndata = 'spam'\ndef __cmp__(self, other):\nreturn cmp(self.data, other)\n\n# 2.6 only\n# __cmp__ not used in 3.0\n# cmp not defined in 3.0\n\nX = C()\nprint(X > 'ham')\nprint(X < 'ham')\n\n# True (runs __cmp__)\n# False (runs __cmp__)\n\nComparisons: __lt__, __gt__, and Others | 729",
    "# 2.6 only\n# __cmp__ not used in 3.0\n# cmp not defined in 3.0\n\nX = C()\nprint(X > 'ham')\nprint(X < 'ham')\n\n# True (runs __cmp__)\n# False (runs __cmp__)\n\nComparisons: __lt__, __gt__, and Others | 729\n\n\fNotice that this fails in 3.0 because __cmp__ is no longer special, not because the cmp\nbuilt-in function is no longer present. If we change the prior class to the following to\ntry to simulate the cmp call, the code still works in 2.6 but fails in 3.0:\nclass C:\ndata = 'spam'\ndef __cmp__(self, other):\nreturn (self.data > other) - (self.data < other)",
    "Comparisons: __lt__, __gt__, and Others | 729\n\n\fNotice that this fails in 3.0 because __cmp__ is no longer special, not because the cmp\nbuilt-in function is no longer present. If we change the prior class to the following to\ntry to simulate the cmp call, the code still works in 2.6 but fails in 3.0:\nclass C:\ndata = 'spam'\ndef __cmp__(self, other):\nreturn (self.data > other) - (self.data < other)\n\nSo why, you might be asking, did I just show you a comparison method\nthat is no longer supported in 3.0? While it would be easier to erase\nhistory entirely, this book is designed to support both 2.6 and 3.0 readers. Because __cmp__ may appear in code 2.6 readers must reuse or\nmaintain, it’s fair game in this book. Moreover, __cmp__ was removed\nmore abruptly than the __getslice__ method described earlier, and so\nmay endure longer. If you use 3.0, though, or care about running your\ncode under 3.0 in the future, don’t use __cmp__ anymore: use the more\nspecific comparison methods instead.",
    "Boolean Tests: __bool__ and __len__\nAs mentioned earlier, classes may also define methods that give the Boolean nature of\ntheir instances—in Boolean contexts, Python first tries __bool__ to obtain a direct\nBoolean value and then, if that’s missing, tries __len__ to determine a truth value from\nthe object length. The first of these generally uses object state or other information to\nproduce a Boolean result:\n>>> class Truth:\n...\ndef __bool__(self): return True\n...\n>>> X = Truth()\n>>> if X: print('yes!')\n...\nyes!\n>>> class Truth:\n...\ndef __bool__(self): return False\n...\n>>> X = Truth()\n>>> bool(X)\nFalse\n\nIf this method is missing, Python falls back on length because a nonempty object is\nconsidered true (i.e., a nonzero length is taken to mean the object is true, and a zero\nlength means it is false):\n>>> class Truth:\n...\ndef __len__(self): return 0\n...\n>>> X = Truth()\n>>> if not X: print('no!')\n\n730 | Chapter 29: Operator Overloading\n\n\f...\nno!",
    "If this method is missing, Python falls back on length because a nonempty object is\nconsidered true (i.e., a nonzero length is taken to mean the object is true, and a zero\nlength means it is false):\n>>> class Truth:\n...\ndef __len__(self): return 0\n...\n>>> X = Truth()\n>>> if not X: print('no!')\n\n730 | Chapter 29: Operator Overloading\n\n\f...\nno!\n\nIf both methods are present Python prefers __bool__ over __len__, because it is more\nspecific:\n>>> class Truth:\n...\ndef __bool__(self): return True\n...\ndef __len__(self): return 0\n...\n>>> X = Truth()\n>>> if X: print('yes!')\n...\nyes!\n\n# 3.0 tries __bool__ first\n# 2.6 tries __len__ first\n\nIf neither truth method is defined, the object is vacuously considered true (which has\npotential implications for metaphysically inclined readers!):\n>>> class Truth:\n...\npass\n...\n>>> X = Truth()\n>>> bool(X)\nTrue\n\nAnd now that we’ve managed to cross over into the realm of philosophy, let’s move on\nto look at one last overloading context: object demise.",
    "And now that we’ve managed to cross over into the realm of philosophy, let’s move on\nto look at one last overloading context: object demise.\n\nBooleans in Python 2.6\nPython 2.6 users should use __nonzero__ instead of __bool__ in all of the code in the\nsection “Boolean Tests: __bool__ and __len__” on page 730. Python 3.0 renamed the\n2.6 __nonzero__ method to __bool__, but Boolean tests work the same otherwise (both\n3.0 and 2.6 use __len__ as a fallback).\nIf you don’t use the 2.6 name, the very first test in this section will work the same for\nyou anyhow, but only because __bool__ is not recognized as a special method name in\n2.6, and objects are considered true by default!\nTo witness this version difference live, you need to return False:\nC:\\misc> c:\\python30\\python\n>>> class C:\n...\ndef __bool__(self):\n...\nprint('in bool')\n...\nreturn False\n...\n>>> X = C()\n>>> bool(X)\nin bool\nFalse\n>>> if X: print(99)\n...\nin bool\n\nBoolean Tests: __bool__ and __len__ | 731",
    "Boolean Tests: __bool__ and __len__ | 731\n\n\fThis works as advertised in 3.0. In 2.6, though, __bool__ is ignored and the object is\nalways considered true:\nC:\\misc> c:\\python26\\python\n>>> class C:\n...\ndef __bool__(self):\n...\nprint('in bool')\n...\nreturn False\n...\n>>> X = C()\n>>> bool(X)\nTrue\n>>> if X: print(99)\n...\n99\n\nIn 2.6, use __nonzero__ for Boolean values (or return 0 from the __len__ fallback method\nto designate false):\nC:\\misc> c:\\python26\\python\n>>> class C:\n...\ndef __nonzero__(self):\n...\nprint('in nonzero')\n...\nreturn False\n...\n>>> X = C()\n>>> bool(X)\nin nonzero\nFalse\n>>> if X: print(99)\n...\nin nonzero\n\nBut keep in mind that __nonzero__ works in 2.6 only; if used in 3.0 it will be silently\nignored and the object will be classified as true by default—just like using __bool__ in\n2.6!",
    "But keep in mind that __nonzero__ works in 2.6 only; if used in 3.0 it will be silently\nignored and the object will be classified as true by default—just like using __bool__ in\n2.6!\n\nObject Destruction: __del__\nWe’ve seen how the __init__ constructor is called whenever an instance is generated.\nIts counterpart, the destructor method __del__, is run automatically when an instance’s\nspace is being reclaimed (i.e., at “garbage collection” time):\n>>> class Life:\n...\ndef __init__(self, name='unknown'):\n...\nprint('Hello', name)\n...\nself.name = name\n...\ndef __del__(self):\n...\nprint('Goodbye', self.name)\n...\n>>> brian = Life('Brian')\nHello Brian\n>>> brian = 'loretta'\nGoodbye Brian\n\n732 | Chapter 29: Operator Overloading",
    "Here, when brian is assigned a string, we lose the last reference to the Life instance\nand so trigger its destructor method. This works, and it may be useful for implementing\nsome cleanup activities (such as terminating server connections). However, destructors\nare not as commonly used in Python as in some OOP languages, for a number of\nreasons.\nFor one thing, because Python automatically reclaims all space held by an instance\nwhen the instance is reclaimed, destructors are not necessary for space management.*\nFor another, because you cannot always easily predict when an instance will be\nreclaimed, it’s often better to code termination activities in an explicitly called method\n(or try/finally statement, described in the next part of the book); in some cases, there\nmay be lingering references to your objects in system tables that prevent destructors\nfrom running.",
    "For another, because you cannot always easily predict when an instance will be\nreclaimed, it’s often better to code termination activities in an explicitly called method\n(or try/finally statement, described in the next part of the book); in some cases, there\nmay be lingering references to your objects in system tables that prevent destructors\nfrom running.\nIn fact, __del__ can be tricky to use for even more subtle reasons. Exceptions raised within it, for example, simply print a warning message\nto sys.stderr (the standard error stream) rather than triggering an exception event, because of the unpredictable context under which it is\nrun by the garbage collector. In addition, cyclic (a.k.a. circular) references among objects may prevent garbage collection from happening\nwhen you expect it to; an optional cycle detector, enabled by default,\ncan automatically collect such objects eventually, but only if they do not",
    "run by the garbage collector. In addition, cyclic (a.k.a. circular) references among objects may prevent garbage collection from happening\nwhen you expect it to; an optional cycle detector, enabled by default,\ncan automatically collect such objects eventually, but only if they do not\nhave __del__ methods. Since this is relatively obscure, we’ll ignore further details here; see Python’s standard manuals’ coverage of both\n__del__ and the gc garbage collector module for more information.",
    "Chapter Summary\nThat’s as many overloading examples as we have space for here. Most of the other\noperator overloading methods work similarly to the ones we’ve explored, and all are\njust hooks for intercepting built-in type operations; some overloading methods, for\nexample, have unique argument lists or return values. We’ll see a few others in action\nlater in the book:\n• Chapter 33 uses the __enter__ and __exit__ with statement context manager\nmethods.\n• Chapter 37 uses the __get__ and __set__ class descriptor fetch/set methods.\n• Chapter 39 uses the __new__ object creation method in the context of metaclasses.",
    "* In the current C implementation of Python, you also don’t need to close file objects held by the instance in\ndestructors because they are automatically closed when reclaimed. However, as mentioned in Chapter 9, it’s\nbetter to explicitly call file close methods because auto-close-on-reclaim is a feature of the implementation,\nnot of the language itself (this behavior can vary under Jython, for instance).\n\nChapter Summary | 733",
    "Chapter Summary | 733\n\n\fIn addition, some of the methods we’ve studied here, such as __call__ and __str__,\nwill be employed by later examples in this book. For complete coverage, though, I’ll\ndefer to other documentation sources—see Python’s standard language manual or reference books for details on additional overloading methods.\nIn the next chapter, we leave the realm of class mechanics behind to explore common\ndesign patterns—the ways that classes are commonly used and combined to optimize\ncode reuse. Before you read on, though, take a moment to work though the chapter\nquiz below to review the concepts we’ve covered.\n\nTest Your Knowledge: Quiz\n1. What two operator overloading methods can you use to support iteration in your\nclasses?\n2. What two operator overloading methods handle printing, and in what contexts?\n3. How can you intercept slice operations in a class?\n4. How can you catch in-place addition in a class?\n5. When should you provide operator overloading?",
    "Test Your Knowledge: Answers\n1. Classes can support iteration by defining (or inheriting) __getitem__ or __iter__.\nIn all iteration contexts, Python tries to use __iter__ (which returns an object that\nsupports the iteration protocol with a __next__ method) first: if no __iter__ is\nfound by inheritance search, Python falls back on the __getitem__ indexing method\n(which is called repeatedly, with successively higher indexes).\n2. The __str__ and __repr__ methods implement object print displays. The former is\ncalled by the print and str built-in functions; the latter is called by print and str\nif there is no __str__, and always by the repr built-in, interactive echoes, and nested\nappearances. That is, __repr__ is used everywhere, except by print and str when\na __str__ is defined. A __str__ is usually used for user-friendly displays;\n__repr__ gives extra details or the object’s as-code form.\n3. Slicing is caught by the __getitem__ indexing method: it is called with a slice object,",
    "if there is no __str__, and always by the repr built-in, interactive echoes, and nested\nappearances. That is, __repr__ is used everywhere, except by print and str when\na __str__ is defined. A __str__ is usually used for user-friendly displays;\n__repr__ gives extra details or the object’s as-code form.\n3. Slicing is caught by the __getitem__ indexing method: it is called with a slice object,\ninstead of a simple index. In Python 2.6, __getslice__ (defunct in 3.0) may be used\nas well.\n4. In-place addition tries __iadd__ first, and __add__ with an assignment second. The\nsame pattern holds true for all binary operators. The __radd__ method is also available for right-side addition.",
    "734 | Chapter 29: Operator Overloading\n\n\f5. When a class naturally matches, or needs to emulate, a built-in type’s interfaces.\nFor example, collections might imitate sequence or mapping interfaces. You generally shouldn’t implement expression operators if they don’t naturally map to\nyour objects, though—use normally named methods instead.\n\nTest Your Knowledge: Answers | 735\n\n\f\fCHAPTER 30\n\nDesigning with Classes",
    "Test Your Knowledge: Answers | 735\n\n\f\fCHAPTER 30\n\nDesigning with Classes\n\nSo far in this part of the book, we’ve concentrated on using Python’s OOP tool, the\nclass. But OOP is also about design issues—i.e., how to use classes to model useful\nobjects. This chapter will touch on a few core OOP ideas and present some additional\nexamples that are more realistic than those shown so far.\nAlong the way, we’ll code some common OOP design patterns in Python, such as\ninheritance, composition, delegation, and factories. We’ll also investigate some designfocused class concepts, such as pseudoprivate attributes, multiple inheritance, and\nbound methods. Many of the design terms mentioned here require more explanation\nthan I can provide in this book; if this material sparks your curiosity, I suggest exploring\na text on OOP design or design patterns as a next step.",
    "Python and OOP\nLet’s begin with a review—Python’s implementation of OOP can be summarized by\nthree ideas:\nInheritance\nInheritance is based on attribute lookup in Python (in X.name expressions).\nPolymorphism\nIn X.method, the meaning of method depends on the type (class) of X.\nEncapsulation\nMethods and operators implement behavior; data hiding is a convention by default.\nBy now, you should have a good feel for what inheritance is all about in Python. We’ve\nalso talked about Python’s polymorphism a few times already; it flows from Python’s\nlack of type declarations. Because attributes are always resolved at runtime, objects that\nimplement the same interfaces are interchangeable; clients don’t need to know what\nsorts of objects are implementing the methods they call.\n\n737",
    "737\n\n\fEncapsulation means packaging in Python—that is, hiding implementation details behind an object’s interface. It does not mean enforced privacy, though that can be\nimplemented with code, as we’ll see in Chapter 38. Encapsulation allows the implementation of an object’s interface to be changed without impacting the users of that\nobject.\n\nOverloading by Call Signatures (or Not)\nSome OOP languages also define polymorphism to mean overloading functions based\non the type signatures of their arguments. But because there are no type declarations\nin Python, this concept doesn’t really apply; polymorphism in Python is based on object\ninterfaces, not types.\nYou can try to overload methods by their argument lists, like this:\nclass C:\ndef meth(self, x):\n...\ndef meth(self, x, y, z):\n...",
    "This code will run, but because the def simply assigns an object to a name in the class’s\nscope, the last definition of the method function is the only one that will be retained\n(it’s just as if you say X = 1 and then X = 2; X will be 2).\nType-based selections can always be coded using the type-testing ideas we met in\nChapters 4 and 9, or the argument list tools introduced in Chapter 18:\nclass C:\ndef meth(self, *args):\nif len(args) == 1:\n...\nelif type(arg[0]) == int:\n...\n\nYou normally shouldn’t do this, though—as described in Chapter 16, you should write\nyour code to expect an object interface, not a specific data type. That way, it will be\nuseful for a broader category of types and applications, both now and in the future:\nclass C:\ndef meth(self, x):\nx.operation()\n\n# Assume x does the right thing",
    "You normally shouldn’t do this, though—as described in Chapter 16, you should write\nyour code to expect an object interface, not a specific data type. That way, it will be\nuseful for a broader category of types and applications, both now and in the future:\nclass C:\ndef meth(self, x):\nx.operation()\n\n# Assume x does the right thing\n\nIt’s also generally considered better to use distinct method names for distinct operations, rather than relying on call signatures (no matter what language you code in).\nAlthough Python’s object model is straightforward, much of the art in OOP is in the\nway we combine classes to achieve a program’s goals. The next section begins a tour\nof some of the ways larger programs use classes to their advantage.\n\n738 | Chapter 30: Designing with Classes",
    "OOP and Inheritance: “Is-a” Relationships\nWe’ve explored the mechanics of inheritance in depth already, but I’d like to show you\nan example of how it can be used to model real-world relationships. From a programmer’s point of view, inheritance is kicked off by attribute qualifications, which trigger\nsearches for names in instances, their classes, and then any superclasses. From a designer’s point of view, inheritance is a way to specify set membership: a class defines a\nset of properties that may be inherited and customized by more specific sets (i.e.,\nsubclasses).\nTo illustrate, let’s put that pizza-making robot we talked about at the start of this part\nof the book to work. Suppose we’ve decided to explore alternative career paths and\nopen a pizza restaurant. One of the first things we’ll need to do is hire employees to\nserve customers, prepare the food, and so on. Being engineers at heart, we’ve decided",
    "subclasses).\nTo illustrate, let’s put that pizza-making robot we talked about at the start of this part\nof the book to work. Suppose we’ve decided to explore alternative career paths and\nopen a pizza restaurant. One of the first things we’ll need to do is hire employees to\nserve customers, prepare the food, and so on. Being engineers at heart, we’ve decided\nto build a robot to make the pizzas; but being politically and cybernetically correct,\nwe’ve also decided to make our robot a full-fledged employee with a salary.\nOur pizza shop team can be defined by the four classes in the example file,\nemployees.py. The most general class, Employee, provides common behavior such as\nbumping up salaries (giveRaise) and printing (__repr__). There are two kinds of employees, and so two subclasses of Employee: Chef and Server. Both override the inherited\nwork method to print more specific messages. Finally, our pizza robot is modeled by an",
    "employees.py. The most general class, Employee, provides common behavior such as\nbumping up salaries (giveRaise) and printing (__repr__). There are two kinds of employees, and so two subclasses of Employee: Chef and Server. Both override the inherited\nwork method to print more specific messages. Finally, our pizza robot is modeled by an\neven more specific class: PizzaRobot is a kind of Chef, which is a kind of Employee. In\nOOP terms, we call these relationships “is-a” links: a robot is a chef, which is a(n)\nemployee. Here’s the employees.py file:\nclass Employee:\ndef __init__(self, name, salary=0):\nself.name\n= name\nself.salary = salary\ndef giveRaise(self, percent):\nself.salary = self.salary + (self.salary * percent)\ndef work(self):\nprint(self.name, \"does stuff\")\ndef __repr__(self):\nreturn \"<Employee: name=%s, salary=%s>\" % (self.name, self.salary)\nclass Chef(Employee):\ndef __init__(self, name):\nEmployee.__init__(self, name, 50000)\ndef work(self):\nprint(self.name, \"makes food\")",
    "self.name\n= name\nself.salary = salary\ndef giveRaise(self, percent):\nself.salary = self.salary + (self.salary * percent)\ndef work(self):\nprint(self.name, \"does stuff\")\ndef __repr__(self):\nreturn \"<Employee: name=%s, salary=%s>\" % (self.name, self.salary)\nclass Chef(Employee):\ndef __init__(self, name):\nEmployee.__init__(self, name, 50000)\ndef work(self):\nprint(self.name, \"makes food\")\nclass Server(Employee):\ndef __init__(self, name):\nEmployee.__init__(self, name, 40000)\ndef work(self):\nprint(self.name, \"interfaces with customer\")\nclass PizzaRobot(Chef):",
    "OOP and Inheritance: “Is-a” Relationships | 739\n\n\fdef __init__(self, name):\nChef.__init__(self, name)\ndef work(self):\nprint(self.name, \"makes pizza\")\nif __name__ == \"__main__\":\nbob = PizzaRobot('bob')\nprint(bob)\nbob.work()\nbob.giveRaise(0.20)\nprint(bob); print()\n\n# Make a robot named bob\n# Run inherited __repr__\n# Run type-specific action\n# Give bob a 20% raise\n\nfor klass in Employee, Chef, Server, PizzaRobot:\nobj = klass(klass.__name__)\nobj.work()",
    "# Make a robot named bob\n# Run inherited __repr__\n# Run type-specific action\n# Give bob a 20% raise\n\nfor klass in Employee, Chef, Server, PizzaRobot:\nobj = klass(klass.__name__)\nobj.work()\n\nWhen we run the self-test code included in this module, we create a pizza-making robot\nnamed bob, which inherits names from three classes: PizzaRobot, Chef, and Employee.\nFor instance, printing bob runs the Employee.__repr__ method, and giving bob a raise\ninvokes Employee.giveRaise because that’s where the inheritance search finds that\nmethod:\nC:\\python\\examples> python employees.py\n<Employee: name=bob, salary=50000>\nbob makes pizza\n<Employee: name=bob, salary=60000.0>\nEmployee does stuff\nChef makes food\nServer interfaces with customer\nPizzaRobot makes pizza",
    "In a class hierarchy like this, you can usually make instances of any of the classes, not\njust the ones at the bottom. For instance, the for loop in this module’s self-test code\ncreates instances of all four classes; each responds differently when asked to work because the work method is different in each. Really, these classes just simulate real-world\nobjects; work prints a message for the time being, but it could be expanded to do real\nwork later.",
    "OOP and Composition: “Has-a” Relationships\nThe notion of composition was introduced in Chapter 25. From a programmer’s point\nof view, composition involves embedding other objects in a container object, and activating them to implement container methods. To a designer, composition is another\nway to represent relationships in a problem domain. But, rather than set membership,\ncomposition has to do with components—parts of a whole.\nComposition also reflects the relationships between parts, called a “has-a” relationships. Some OOP design texts refer to composition as aggregation (or distinguish between the two terms by using aggregation to describe a weaker dependency between\n\n740 | Chapter 30: Designing with Classes",
    "container and contained); in this text, a “composition” simply refers to a collection of\nembedded objects. The composite class generally provides an interface all its own and\nimplements it by directing the embedded objects.\nNow that we’ve implemented our employees, let’s put them in the pizza shop and let\nthem get busy. Our pizza shop is a composite object: it has an oven, and it has employees\nlike servers and chefs. When a customer enters and places an order, the components\nof the shop spring into action—the server takes the order, the chef makes the pizza,\nand so on. The following example (the file pizzashop.py) simulates all the objects and\nrelationships in this scenario:\nfrom employees import PizzaRobot, Server\nclass Customer:\ndef __init__(self, name):\nself.name = name\ndef order(self, server):\nprint(self.name, \"orders from\", server)\ndef pay(self, server):\nprint(self.name, \"pays for item to\", server)\nclass Oven:\ndef bake(self):\nprint(\"oven bakes\")\nclass PizzaShop:",
    "relationships in this scenario:\nfrom employees import PizzaRobot, Server\nclass Customer:\ndef __init__(self, name):\nself.name = name\ndef order(self, server):\nprint(self.name, \"orders from\", server)\ndef pay(self, server):\nprint(self.name, \"pays for item to\", server)\nclass Oven:\ndef bake(self):\nprint(\"oven bakes\")\nclass PizzaShop:\ndef __init__(self):\nself.server = Server('Pat')\nself.chef\n= PizzaRobot('Bob')\nself.oven\n= Oven()\ndef order(self, name):\ncustomer = Customer(name)\ncustomer.order(self.server)\nself.chef.work()\nself.oven.bake()\ncustomer.pay(self.server)\nif __name__ == \"__main__\":\nscene = PizzaShop()\nscene.order('Homer')\nprint('...')\nscene.order('Shaggy')",
    "# Embed other objects\n# A robot named bob\n\n# Activate other objects\n# Customer orders from server\n\n# Make the composite\n# Simulate Homer's order\n# Simulate Shaggy's order\n\nThe PizzaShop class is a container and controller; its constructor makes and embeds\ninstances of the employee classes we wrote in the last section, as well as an Oven class\ndefined here. When this module’s self-test code calls the PizzaShop order method, the\nembedded objects are asked to carry out their actions in turn. Notice that we make a\nnew Customer object for each order, and we pass on the embedded Server object to\nCustomer methods; customers come and go, but the server is part of the pizza shop\ncomposite. Also notice that employees are still involved in an inheritance relationship;\ncomposition and inheritance are complementary tools.\nOOP and Composition: “Has-a” Relationships | 741",
    "When we run this module, our pizza shop handles two orders—one from Homer, and\nthen one from Shaggy:\nC:\\python\\examples> python pizzashop.py\nHomer orders from <Employee: name=Pat, salary=40000>\nBob makes pizza\noven bakes\nHomer pays for item to <Employee: name=Pat, salary=40000>\n...\nShaggy orders from <Employee: name=Pat, salary=40000>\nBob makes pizza\noven bakes\nShaggy pays for item to <Employee: name=Pat, salary=40000>\n\nAgain, this is mostly just a toy simulation, but the objects and interactions are representative of composites at work. As a rule of thumb, classes can represent just about\nany objects and relationships you can express in a sentence; just replace nouns with\nclasses, and verbs with methods, and you’ll have a first cut at a design.",
    "Again, this is mostly just a toy simulation, but the objects and interactions are representative of composites at work. As a rule of thumb, classes can represent just about\nany objects and relationships you can express in a sentence; just replace nouns with\nclasses, and verbs with methods, and you’ll have a first cut at a design.\n\nStream Processors Revisited\nFor a more realistic composition example, recall the generic data stream processor\nfunction we partially coded in the introduction to OOP in Chapter 25:\ndef processor(reader, converter, writer):\nwhile 1:\ndata = reader.read()\nif not data: break\ndata = converter(data)\nwriter.write(data)",
    "Stream Processors Revisited\nFor a more realistic composition example, recall the generic data stream processor\nfunction we partially coded in the introduction to OOP in Chapter 25:\ndef processor(reader, converter, writer):\nwhile 1:\ndata = reader.read()\nif not data: break\ndata = converter(data)\nwriter.write(data)\n\nRather than using a simple function here, we might code this as a class that uses composition to do its work to provide more structure and support inheritance. The following file, streams.py, demonstrates one way to code the class:\nclass Processor:\ndef __init__(self, reader, writer):\nself.reader = reader\nself.writer = writer\ndef process(self):\nwhile 1:\ndata = self.reader.readline()\nif not data: break\ndata = self.converter(data)\nself.writer.write(data)\ndef converter(self, data):\nassert False, 'converter must be defined'\n\n# Or raise exception",
    "# Or raise exception\n\nThis class defines a converter method that it expects subclasses to fill in; it’s an example\nof the abstract superclass model we outlined in Chapter 28 (more on assert in\nPart VII). Coded this way, reader and writer objects are embedded within the class\ninstance (composition), and we supply the conversion logic in a subclass rather than\npassing in a converter function (inheritance). The file converters.py shows how:\n742 | Chapter 30: Designing with Classes\n\n\ffrom streams import Processor\nclass Uppercase(Processor):\ndef converter(self, data):\nreturn data.upper()\nif __name__ == '__main__':\nimport sys\nobj = Uppercase(open('spam.txt'), sys.stdout)\nobj.process()",
    "from streams import Processor\nclass Uppercase(Processor):\ndef converter(self, data):\nreturn data.upper()\nif __name__ == '__main__':\nimport sys\nobj = Uppercase(open('spam.txt'), sys.stdout)\nobj.process()\n\nHere, the Uppercase class inherits the stream-processing loop logic (and anything else\nthat may be coded in its superclasses). It needs to define only what is unique about it—\nthe data conversion logic. When this file is run, it makes and runs an instance that reads\nfrom the file spam.txt and writes the uppercase equivalent of that file to the stdout\nstream:\nC:\\lp4e> type spam.txt\nspam\nSpam\nSPAM!\nC:\\lp4e> python converters.py\nSPAM\nSPAM\nSPAM!\n\nTo process different sorts of streams, pass in different sorts of objects to the class construction call. Here, we use an output file instead of a stream:\nC:\\lp4e> python\n>>> import converters\n>>> prog = converters.Uppercase(open('spam.txt'), open('spamup.txt', 'w'))\n>>> prog.process()\nC:\\lp4e> type spamup.txt\nSPAM\nSPAM\nSPAM!",
    "To process different sorts of streams, pass in different sorts of objects to the class construction call. Here, we use an output file instead of a stream:\nC:\\lp4e> python\n>>> import converters\n>>> prog = converters.Uppercase(open('spam.txt'), open('spamup.txt', 'w'))\n>>> prog.process()\nC:\\lp4e> type spamup.txt\nSPAM\nSPAM\nSPAM!\n\nBut, as suggested earlier, we could also pass in arbitrary objects wrapped up in classes\nthat define the required input and output method interfaces. Here’s a simple example\nthat passes in a writer class that wraps up the text inside HTML tags:\nC:\\lp4e> python\n>>> from converters import Uppercase\n>>>\n>>> class HTMLize:\n...\ndef write(self, line):\n...\nprint('<PRE>%s</PRE>' % line.rstrip())\n...\n>>> Uppercase(open('spam.txt'), HTMLize()).process()\n<PRE>SPAM</PRE>\n<PRE>SPAM</PRE>\n<PRE>SPAM!</PRE>\n\nOOP and Composition: “Has-a” Relationships | 743",
    "If you trace through this example’s control flow, you’ll see that we get both uppercase\nconversion (by inheritance) and HTML formatting (by composition), even though the\ncore processing logic in the original Processor superclass knows nothing about either\nstep. The processing code only cares that writers have a write method and that a method\nnamed convert is defined; it doesn’t care what those methods do when they are called.\nSuch polymorphism and encapsulation of logic is behind much of the power of classes.\nAs is, the Processor superclass only provides a file-scanning loop. In more realistic\nwork, we might extend it to support additional programming tools for its subclasses,\nand, in the process, turn it into a full-blown framework. Coding such a tool once in a\nsuperclass enables you to reuse it in all of your programs. Even in this simple example,\nbecause so much is packaged and inherited with classes, all we had to code was the\nHTML formatting step; the rest was free.",
    "work, we might extend it to support additional programming tools for its subclasses,\nand, in the process, turn it into a full-blown framework. Coding such a tool once in a\nsuperclass enables you to reuse it in all of your programs. Even in this simple example,\nbecause so much is packaged and inherited with classes, all we had to code was the\nHTML formatting step; the rest was free.\nFor another example of composition at work, see exercise 9 at the end of Chapter 31\nand its solution in Appendix B; it’s similar to the pizza shop example. We’ve focused\non inheritance in this book because that is the main tool that the Python language itself\nprovides for OOP. But, in practice, composition is used as much as inheritance as a\nway to structure classes, especially in larger systems. As we’ve seen, inheritance and\ncomposition are often complementary (and sometimes alternative) techniques. Because\ncomposition is a design issue outside the scope of the Python language and this book,",
    "provides for OOP. But, in practice, composition is used as much as inheritance as a\nway to structure classes, especially in larger systems. As we’ve seen, inheritance and\ncomposition are often complementary (and sometimes alternative) techniques. Because\ncomposition is a design issue outside the scope of the Python language and this book,\nthough, I’ll defer to other resources for more on this topic.",
    "Why You Will Care: Classes and Persistence\nI’ve mentioned Python’s pickle and shelve object persistence support a few times in\nthis part of the book because it works especially well with class instances. In fact, these\ntools are often compelling enough to motivate the use of classes in general—by picking\nor shelving a class instance, we get data storage that contains both data and logic\ncombined.\nFor example, besides allowing us to simulate real-world interactions, the pizza shop\nclasses developed in this chapter could also be used as the basis of a persistent restaurant\ndatabase. Instances of classes can be stored away on disk in a single step using Python’s\npickle or shelve modules. We used shelves to store instances of classes in the OOP\ntutorial in Chapter 27, but the object pickling interface is remarkably easy to use as well:\nimport pickle\nobject = someClass()\nfile = open(filename, 'wb')\npickle.dump(object, file)\n\n# Create external file\n# Save object in file",
    "# Create external file\n# Save object in file\n\nimport pickle\nfile = open(filename, 'rb')\nobject = pickle.load(file)\n\n# Fetch it back later\n\n744 | Chapter 30: Designing with Classes\n\n\fPickling converts in-memory objects to serialized byte streams (really, strings), which\nmay be stored in files, sent across a network, and so on; unpickling converts back from\nbyte streams to identical in-memory objects. Shelves are similar, but they automatically\npickle objects to an access-by-key database, which exports a dictionary-like interface:\nimport shelve\nobject = someClass()\ndbase = shelve.open('filename')\ndbase['key'] = object\n# Save under key\nimport shelve\ndbase = shelve.open('filename')\nobject = dbase['key']\n# Fetch it back later",
    "In our pizza shop example, using classes to model employees means we can get a simple\ndatabase of employees and shops with little extra work—pickling such instance objects\nto a file makes them persistent across Python program executions:\n>>> from pizzashop import PizzaShop\n>>> shop = PizzaShop()\n>>> shop.server, shop.chef\n(<Employee: name=Pat, salary=40000>, <Employee: name=Bob, salary=50000>)\n>>> import pickle\n>>> pickle.dump(shop, open('shopfile.dat', 'wb'))",
    "This stores an entire composite shop object in a file all at once. To bring it back later in\nanother session or program, a single step suffices as well. In fact, objects restored this\nway retain both state and behavior:\n>>> import pickle\n>>> obj = pickle.load(open('shopfile.dat', 'rb'))\n>>> obj.server, obj.chef\n(<Employee: name=Pat, salary=40000>, <Employee: name=Bob, salary=50000>)\n>>> obj.order('Sue')\nSue orders from <Employee: name=Pat, salary=40000>\nBob makes pizza\noven bakes\nSue pays for item to <Employee: name=Pat, salary=40000>\n\nSee the standard library manual and later examples for more on pickles and shelves.",
    "See the standard library manual and later examples for more on pickles and shelves.\n\nOOP and Delegation: “Wrapper” Objects\nBeside inheritance and composition, object-oriented programmers often also talk about\nsomething called delegation, which usually implies controller objects that embed other\nobjects to which they pass off operation requests. The controllers can take care of\nadministrative activities, such as keeping track of accesses and so on. In Python, delegation is often implemented with the __getattr__ method hook; because it intercepts\naccesses to nonexistent attributes, a wrapper class (sometimes called a proxy class) can\nuse __getattr__ to route arbitrary accesses to a wrapped object. The wrapper class\nretains the interface of the wrapped object and may add additional operations of its\nown.\n\nOOP and Delegation: “Wrapper” Objects | 745",
    "OOP and Delegation: “Wrapper” Objects | 745\n\n\fConsider the file trace.py, for instance:\nclass wrapper:\ndef __init__(self, object):\nself.wrapped = object\ndef __getattr__(self, attrname):\nprint('Trace:', attrname)\nreturn getattr(self.wrapped, attrname)\n\n# Save object\n# Trace fetch\n# Delegate fetch",
    "Recall from Chapter 29 that __getattr__ gets the attribute name as a string. This code\nmakes use of the getattr built-in function to fetch an attribute from the wrapped object\nby name string—getattr(X,N) is like X.N, except that N is an expression that evaluates\nto a string at runtime, not a variable. In fact, getattr(X,N) is similar to X.__dict__[N],\nbut the former also performs an inheritance search, like X.N, while the latter does not\n(see “Namespace Dictionaries” on page 696 for more on the __dict__ attribute).\nYou can use the approach of this module’s wrapper class to manage access to any object\nwith attributes—lists, dictionaries, and even classes and instances. Here, the wrapper\nclass simply prints a trace message on each attribute access and delegates the attribute\nrequest to the embedded wrapped object:\n>>> from trace import wrapper\n>>> x = wrapper([1,2,3])\n>>> x.append(4)\nTrace: append\n>>> x.wrapped\n[1, 2, 3, 4]\n>>> x = wrapper({\"a\": 1, \"b\": 2})\n>>> x.keys()\nTrace: keys",
    "with attributes—lists, dictionaries, and even classes and instances. Here, the wrapper\nclass simply prints a trace message on each attribute access and delegates the attribute\nrequest to the embedded wrapped object:\n>>> from trace import wrapper\n>>> x = wrapper([1,2,3])\n>>> x.append(4)\nTrace: append\n>>> x.wrapped\n[1, 2, 3, 4]\n>>> x = wrapper({\"a\": 1, \"b\": 2})\n>>> x.keys()\nTrace: keys\n['a', 'b']",
    "# Wrap a list\n# Delegate to list method\n# Print my member\n# Wrap a dictionary\n# Delegate to dictionary method\n\nThe net effect is to augment the entire interface of the wrapped object, with additional\ncode in the wrapper class. We can use this to log our method calls, route method calls\nto extra or custom logic, and so on.\nWe’ll revive the notions of wrapped objects and delegated operations as one way to\nextend built-in types in Chapter 31. If you are interested in the delegation design pattern, also watch for the discussions in Chapters 31 and 38 of function decorators, a\nstrongly related concept designed to augment a specific function or method call rather\nthan the entire interface of an object, and class decorators, which serve as a way to\nautomatically add such delegation-based wrappers to all instances of a class.\n\n746 | Chapter 30: Designing with Classes",
    "746 | Chapter 30: Designing with Classes\n\n\fVersion skew note: In Python 2.6, operator overloading methods run by\nbuilt-in operations are routed through generic attribute interception\nmethods like __getattr__. Printing a wrapped object directly, for example, calls this method for __repr__ or __str__, which then passes the\ncall on to the wrapped object. In Python 3.0, this no longer happens:\nprinting does not trigger __getattr__, and a default display is used instead. In 3.0, new-style classes look up operator overloading methods\nin classes and skip the normal instance lookup entirely. We’ll return to\nthis issue in Chapter 37, in the context of managed attributes; for now,\nkeep in mind that you may need to redefine operator overloading methods in wrapper classes (either by hand, by tools, or by superclasses) if\nyou want them to be intercepted in 3.0.",
    "Pseudoprivate Class Attributes\nBesides larger structuring goals, class designs often must address name usage too. In\nPart V, we learned that every name assigned at the top level of a module file is exported.\nBy default, the same holds for classes—data hiding is a convention, and clients may\nfetch or change any class or instance attribute they like. In fact, attributes are all “public” and “virtual,” in C++ terms; they’re all accessible everywhere and are looked up\ndynamically at runtime.*\nThat said, Python today does support the notion of name “mangling” (i.e., expansion)\nto localize some names in classes. Mangled names are sometimes misleadingly called\n“private attributes,” but really this is just a way to localize a name to the class that\ncreated it—name mangling does not prevent access by code outside the class. This\nfeature is mostly intended to avoid namespace collisions in instances, not to restrict",
    "to localize some names in classes. Mangled names are sometimes misleadingly called\n“private attributes,” but really this is just a way to localize a name to the class that\ncreated it—name mangling does not prevent access by code outside the class. This\nfeature is mostly intended to avoid namespace collisions in instances, not to restrict\naccess to names in general; mangled names are therefore better called “pseudoprivate”\nthan “private.”\nPseudoprivate names are an advanced and entirely optional feature, and you probably\nwon’t find them very useful until you start writing general tools or larger class hierarchies for use in multiprogrammer projects. In fact, they are not always used even when\nthey probably should be—more commonly, Python programmers code internal names\nwith a single underscore (e.g., _X), which is just an informal convention to let you know\nthat a name shouldn’t be changed (it means nothing to Python itself).",
    "they probably should be—more commonly, Python programmers code internal names\nwith a single underscore (e.g., _X), which is just an informal convention to let you know\nthat a name shouldn’t be changed (it means nothing to Python itself).\nBecause you may see this feature in other people’s code, though, you need to be somewhat aware of it, even if you don’t use it yourself.",
    "* This tends to scare people with a C++ background unnecessarily. In Python, it’s even possible to change or\ncompletely delete a class method at runtime. On the other hand, almost nobody ever does this in practical\nprograms. As a scripting language, Python is more about enabling than restricting. Also, recall from our\ndiscussion of operator overloading in Chapter 29 that __getattr__ and __setattr__ can be used to emulate\nprivacy, but are generally not used for this purpose in practice. More on this when we code a more realistic\nprivacy decorator Chapter 38.\n\nPseudoprivate Class Attributes | 747",
    "Name Mangling Overview\nHere’s how name mangling works: names inside a class statement that start with two\nunderscores but don’t end with two underscores are automatically expanded to include\nthe name of the enclosing class. For instance, a name like __X within a class named\nSpam is changed to _Spam__X automatically: the original name is prefixed with a single\nunderscore and the enclosing class’s name. Because the modified name contains the\nname of the enclosing class, it’s somewhat unique; it won’t clash with similar names\ncreated by other classes in a hierarchy.\nName mangling happens only in class statements, and only for names that begin with\ntwo leading underscores. However, it happens for every name preceded with double\nunderscores—both class attributes (like method names) and instance attribute names\nassigned to self attributes. For example, in a class named Spam, a method named",
    "created by other classes in a hierarchy.\nName mangling happens only in class statements, and only for names that begin with\ntwo leading underscores. However, it happens for every name preceded with double\nunderscores—both class attributes (like method names) and instance attribute names\nassigned to self attributes. For example, in a class named Spam, a method named\n__meth is mangled to _Spam__meth, and an instance attribute reference self.__X is transformed to self._Spam__X. Because more than one class may add attributes to an instance, this mangling helps avoid clashes—but we need to move on to an example to\nsee how.",
    "Why Use Pseudoprivate Attributes?\nOne of the main problems that the pseudoprivate attribute feature is meant to alleviate\nhas to do with the way instance attributes are stored. In Python, all instance attributes\nwind up in the single instance object at the bottom of the class tree. This is different\nfrom the C++ model, where each class gets its own space for data members it defines.\nWithin a class method in Python, whenever a method assigns to a self attribute (e.g.,\nself.attr = value), it changes or creates an attribute in the instance (inheritance\nsearches happen only on reference, not on assignment). Because this is true even if\nmultiple classes in a hierarchy assign to the same attribute, collisions are possible.\nFor example, suppose that when a programmer codes a class, she assumes that she\nowns the attribute name X in the instance. In this class’s methods, the name is set, and\nlater fetched:\nclass C1:\ndef meth1(self): self.X = 88\ndef meth2(self): print(self.X)",
    "# I assume X is mine\n\nSuppose further that another programmer, working in isolation, makes the same assumption in a class that he codes:\nclass C2:\ndef metha(self): self.X = 99\ndef methb(self): print(self.X)\n\n# Me too\n\nBoth of these classes work by themselves. The problem arises if the two classes are ever\nmixed together in the same class tree:\n\n748 | Chapter 30: Designing with Classes\n\n\fclass C3(C1, C2): ...\nI = C3()\n\n# Only 1 X in I!",
    "# Me too\n\nBoth of these classes work by themselves. The problem arises if the two classes are ever\nmixed together in the same class tree:\n\n748 | Chapter 30: Designing with Classes\n\n\fclass C3(C1, C2): ...\nI = C3()\n\n# Only 1 X in I!\n\nNow, the value that each class gets back when it says self.X will depend on which class\nassigned it last. Because all assignments to self.X refer to the same single instance,\nthere is only one X attribute—I.X—no matter how many classes use that attribute name.\nTo guarantee that an attribute belongs to the class that uses it, prefix the name with\ndouble underscores everywhere it is used in the class, as in this file, private.py:\nclass C1:\ndef meth1(self): self.__X = 88\ndef meth2(self): print(self.__X)\nclass C2:\ndef metha(self): self.__X = 99\ndef methb(self): print(self.__X)\nclass C3(C1, C2): pass\nI = C3()\n\n# Now X is mine\n# Becomes _C1__X in I\n# Me too\n# Becomes _C2__X in I\n# Two X names in I\n\nI.meth1(); I.metha()\nprint(I.__dict__)\nI.meth2(); I.methb()",
    "# Now X is mine\n# Becomes _C1__X in I\n# Me too\n# Becomes _C2__X in I\n# Two X names in I\n\nI.meth1(); I.metha()\nprint(I.__dict__)\nI.meth2(); I.methb()\n\nWhen thus prefixed, the X attributes will be expanded to include the names of their\nclasses before being added to the instance. If you run a dir call on I or inspect its\nnamespace dictionary after the attributes have been assigned, you’ll see the expanded\nnames, _C1__X and _C2__X, but not X. Because the expansion makes the names unique\nwithin the instance, the class coders can safely assume that they truly own any names\nthat they prefix with two underscores:\n% python private.py\n{'_C2__X': 99, '_C1__X': 88}\n88\n99",
    "This trick can avoid potential name collisions in the instance, but note that it does not\namount to true privacy. If you know the name of the enclosing class, you can still access\neither of these attributes anywhere you have a reference to the instance by using the\nfully expanded name (e.g., I._C1__X = 77). On the other hand, this feature makes it\nless likely that you will accidentally step on a class’s names.\nPseudoprivate attributes are also useful in larger frameworks or tools, both to avoid\nintroducing new method names that might accidentally hide definitions elsewhere in\nthe class tree and to reduce the chance of internal methods being replaced by names\ndefined lower in the tree. If a method is intended for use only within a class that may\nbe mixed into other classes, the double underscore prefix ensures that the method won’t\ninterfere with other names in the tree, especially in multiple-inheritance scenarios:\nclass Super:\ndef method(self): ...\n\n# A real application method",
    "# A real application method\n\nclass Tool:\n\nPseudoprivate Class Attributes | 749\n\n\fdef __method(self): ...\ndef other(self): self.__method()\n\n# Becomes _Tool__method\n# Use my internal method\n\nclass Sub1(Tool, Super): ...\ndef actions(self): self.method()\n\n# Runs Super.method as expected\n\nclass Sub2(Tool):\ndef __init__(self): self.method = 99\n\n# Doesn't break Tool.__method",
    "We met multiple inheritance briefly in Chapter 25 and will explore it in more detail\nlater in this chapter. Recall that superclasses are searched according to their left-to-right\norder in class header lines. Here, this means Sub1 prefers Tool attributes to those in\nSuper. Although in this example we could force Python to pick the application class’s\nmethods first by switching the order of the superclasses listed in the Sub1 class header,\npseudoprivate attributes resolve the issue altogether. Pseudoprivate names also prevent\nsubclasses from accidentally redefining the internal method’s names, as in Sub2.\nAgain, I should note that this feature tends to be of use primarily for larger,\nmultiprogrammer projects, and then only for selected names. Don’t be tempted to\nclutter your code unnecessarily; only use this feature for names that truly need to be\ncontrolled by a single class. For simpler programs, it’s probably overkill.",
    "Again, I should note that this feature tends to be of use primarily for larger,\nmultiprogrammer projects, and then only for selected names. Don’t be tempted to\nclutter your code unnecessarily; only use this feature for names that truly need to be\ncontrolled by a single class. For simpler programs, it’s probably overkill.\nFor more examples that make use of the __X naming feature, see the lister.py\nmix-in classes introduced later in this chapter, in the section on multiple inheritance,\nas well as the discussion of Private class decorators in Chapter 38. If you\ncare about privacy in general, you might want to review the emulation of\nprivate instance attributes sketched in the section “Attribute Reference: __getattr__\nand __setattr__” on page 718 in Chapter 29, and watch for the Private class decorator\nin Chapter 38 that we will base upon this special method. Although it’s possible to\nemulate true access controls in Python classes, this is rarely done in practice, even for\nlarge systems.",
    "Methods Are Objects: Bound or Unbound\nMethods in general, and bound methods in particular, simplify the implementation of\nmany design goals in Python. We met bound methods briefly while studying __call__ in\nChapter 29. The full story, which we’ll flesh out here, turns out to be more general and\nflexible than you might expect.\nIn Chapter 19, we learned how functions can be processed as normal objects. Methods\nare a kind of object too, and can be used generically in much the same way as other\nobjects—they can be assigned, passed to functions, stored in data structures, and so\non. Because class methods can be accessed from an instance or a class, though, they\nactually come in two flavors in Python:\n\n750 | Chapter 30: Designing with Classes",
    "Unbound class method objects: no self\nAccessing a function attribute of a class by qualifying the class returns an unbound\nmethod object. To call the method, you must provide an instance object explicitly\nas the first argument. In Python 3.0, an unbound method is the same as a simple\nfunction and can be called though the class’s name; in 2.6 it’s a distinct type and\ncannot be called without providing an instance.\nBound instance method objects: self + function pairs\nAccessing a function attribute of a class by qualifying an instance returns a bound\nmethod object. Python automatically packages the instance with the function in\nthe bound method object, so you don’t need to pass an instance to call the method.\nBoth kinds of methods are full-fledged objects; they can be transferred around a program at will, just like strings and numbers. Both also require an instance in their first\nargument when run (i.e., a value for self). This is why we had to pass in an instance",
    "the bound method object, so you don’t need to pass an instance to call the method.\nBoth kinds of methods are full-fledged objects; they can be transferred around a program at will, just like strings and numbers. Both also require an instance in their first\nargument when run (i.e., a value for self). This is why we had to pass in an instance\nexplicitly when calling superclass methods from subclass methods in the previous\nchapter; technically, such calls produce unbound method objects.\nWhen calling a bound method object, Python provides an instance for you automatically—the instance used to create the bound method object. This means that bound\nmethod objects are usually interchangeable with simple function objects, and makes\nthem especially useful for interfaces originally written for functions (see the sidebar\n“Why You Will Care: Bound Methods and Callbacks” on page 756 for a realistic\nexample).\nTo illustrate, suppose we define the following class:\nclass Spam:\ndef doit(self, message):",
    "method objects are usually interchangeable with simple function objects, and makes\nthem especially useful for interfaces originally written for functions (see the sidebar\n“Why You Will Care: Bound Methods and Callbacks” on page 756 for a realistic\nexample).\nTo illustrate, suppose we define the following class:\nclass Spam:\ndef doit(self, message):\nprint(message)",
    "Now, in normal operation, we make an instance and call its method in a single step to\nprint the passed-in argument:\nobject1 = Spam()\nobject1.doit('hello world')\n\nReally, though, a bound method object is generated along the way, just before the\nmethod call’s parentheses. In fact, we can fetch a bound method without actually calling it. An object.name qualification is an object expression. In the following, it returns\na bound method object that packages the instance (object1) with the method function\n(Spam.doit). We can assign this bound method pair to another name and then call it as\nthough it were a simple function:\nobject1 = Spam()\nx = object1.doit\nx('hello world')\n\n# Bound method object: instance+function\n# Same effect as object1.doit('...')\n\nMethods Are Objects: Bound or Unbound | 751",
    "# Bound method object: instance+function\n# Same effect as object1.doit('...')\n\nMethods Are Objects: Bound or Unbound | 751\n\n\fOn the other hand, if we qualify the class to get to doit, we get back an unbound method\nobject, which is simply a reference to the function object. To call this type of method,\nwe must pass in an instance as the leftmost argument:\nobject1 = Spam()\nt = Spam.doit\nt(object1, 'howdy')\n\n# Unbound method object (a function in 3.0: see ahead)\n# Pass in instance (if the method expects one in 3.0)\n\nBy extension, the same rules apply within a class’s method if we reference self attributes\nthat refer to functions in the class. A self.method expression is a bound method object\nbecause self is an instance object:\nclass Eggs:\ndef m1(self, n):\nprint(n)\ndef m2(self):\nx = self.m1\nx(42)\n\n# Another bound method object\n# Looks like a simple function\n\nEggs().m2()\n\n# Prints 42",
    "By extension, the same rules apply within a class’s method if we reference self attributes\nthat refer to functions in the class. A self.method expression is a bound method object\nbecause self is an instance object:\nclass Eggs:\ndef m1(self, n):\nprint(n)\ndef m2(self):\nx = self.m1\nx(42)\n\n# Another bound method object\n# Looks like a simple function\n\nEggs().m2()\n\n# Prints 42\n\nMost of the time, you call methods immediately after fetching them with attribute\nqualification, so you don’t always notice the method objects generated along the way.\nBut if you start writing code that calls objects generically, you need to be careful to treat\nunbound methods specially—they normally require an explicit instance object to be\npassed in.†",
    "Unbound Methods are Functions in 3.0\nIn Python 3.0, the language has dropped the notion of unbound methods. What we\ndescribe as an unbound method here is treated as a simple function in 3.0. For most\npurposes, this makes no difference to your code; either way, an instance will be passed\nto a method’s first argument when it’s called through an instance.\nPrograms that do explicit type testing might be impacted, though—if you print the type\nof an instance-less class method, it displays “unbound method” in 2.6, and “function”\nin 3.0.\nMoreover, in 3.0 it is OK to call a method without an instance, as long as the method\ndoes not expect one and you call it only through the class and never through an instance.\nThat is, Python 3.0 will pass along an instance to methods only for through-instance\ncalls. When calling through a class, you must pass an instance manually only if the\nmethod expects one:\nC:\\misc> c:\\python30\\python\n>>> class Selfless:",
    "† See the discussion of static and class methods in Chapter 31 for an optional exception to this rule. Like bound\nmethods, static methods can masquerade as basic functions because they do not expect instances when called.\nPython supports three kinds of class methods—instance, static, and class—and 3.0 allows simple functions\nin classes, too.\n\n752 | Chapter 30: Designing with Classes\n\n\f...\ndef __init__(self, data):\n...\nself.data = data\n...\ndef selfless(arg1, arg2):\n# A simple function in 3.0\n...\nreturn arg1 + arg2\n...\ndef normal(self, arg1, arg2):\n# Instance expected when called\n...\nreturn self.data + arg1 + arg2\n...\n>>> X = Selfless(2)\n>>> X.normal(3, 4)\n# Instance passed to self automatically\n9\n>>> Selfless.normal(X, 3, 4)\n# self expected by method: pass manually\n9\n>>> Selfless.selfless(3, 4)\n# No instance: works in 3.0, fails in 2.6!\n7",
    "The last test in this fails in 2.6, because unbound methods require an instance to be\npassed by default; it works in 3.0 because such methods are treated as simple functions\nnot requiring an instance. Although this removes some potential error trapping in 3.0\n(what if a programmer accidentally forgets to pass an instance?), it allows class methods\nto be used as simple functions as long as they are not passed and do not expect a “self”\ninstance argument.\nThe following two calls still fail in both 3.0 and 2.6, though—the first (calling through\nan instance) automatically passes an instance to a method that does not expect one,\nwhile the second (calling through a class) does not pass an instance to a method that\ndoes expect one:\n>>> X.selfless(3, 4)\nTypeError: selfless() takes exactly 2 positional arguments (3 given)\n>>> Selfless.normal(3, 4)\nTypeError: normal() takes exactly 3 positional arguments (2 given)",
    "Because of this change, the staticmethod decorator described in the next chapter is not\nneeded in 3.0 for methods without a self argument that are called only through the\nclass name, and never through an instance—such methods are run as simple functions,\nwithout receiving an instance argument. In 2.6, such calls are errors unless an instance\nis passed manually (more on static methods in the next chapter).\nIt’s important to be aware of the differences in behavior in 3.0, but bound methods are\ngenerally more important from a practical perspective anyway. Because they pair together the instance and function in a single object, they can be treated as callables\ngenerically. The next section demonstrates what this means in code.\nFor a more visual illustration of unbound method treatment in Python\n3.0 and 2.6, see also the lister.py example in the multiple inheritance\nsection later in this chapter. Its classes print the value of methods fetched",
    "generically. The next section demonstrates what this means in code.\nFor a more visual illustration of unbound method treatment in Python\n3.0 and 2.6, see also the lister.py example in the multiple inheritance\nsection later in this chapter. Its classes print the value of methods fetched\nfrom both instances and classes, in both versions of Python.",
    "Methods Are Objects: Bound or Unbound | 753\n\n\fBound Methods and Other Callable Objects\nAs mentioned earlier, bound methods can be processed as generic objects, just like\nsimple functions—they can be passed around a program arbitrarily. Moreover, because\nbound methods combine both a function and an instance in a single package, they can\nbe treated like any other callable object and require no special syntax when invoked.\nThe following, for example, stores four bound method objects in a list and calls them\nlater with normal call expressions:\n>>> class Number:\n...\ndef __init__(self, base):\n...\nself.base = base\n...\ndef double(self):\n...\nreturn self.base * 2\n...\ndef triple(self):\n...\nreturn self.base * 3\n...\n>>> x = Number(2)\n>>> y = Number(3)\n>>> z = Number(4)\n>>> x.double()\n4\n\n# Class instance objects\n# State + methods\n# Normal immediate calls\n\n>>> acts = [x.double, y.double, y.triple, z.double]\n>>> for act in acts:\n...\nprint(act())\n...\n4\n6\n9\n8",
    "# Class instance objects\n# State + methods\n# Normal immediate calls\n\n>>> acts = [x.double, y.double, y.triple, z.double]\n>>> for act in acts:\n...\nprint(act())\n...\n4\n6\n9\n8\n\n# List of bound methods\n# Calls are deferred\n# Call as though functions\n\nLike simple functions, bound method objects have introspection information of their\nown, including attributes that give access to the instance object and method function\nthey pair. Calling the bound method simply dispatches the pair:\n>>> bound = x.double\n>>> bound.__self__, bound.__func__\n(<__main__.Number object at 0x0278F610>, <function double at 0x027A4ED0>)\n>>> bound.__self__.base\n2\n>>> bound()\n# Calls bound.__func__(bound.__self__, ...)\n4",
    "In fact, bound methods are just one of a handful of callable object types in Python. As\nthe following demonstrates, simple functions coded with a def or lambda, instances that\ninherit a __call__, and bound instance methods can all be treated and called the same\nway:\n>>> def square(arg):\n...\nreturn arg ** 2\n...\n>>> class Sum:\n...\ndef __init__(self, val):\n\n754 | Chapter 30: Designing with Classes\n\n# Simple functions (def or lambda)\n# Callable instances\n\n\f...\nself.val = val\n...\ndef __call__(self, arg):\n...\nreturn self.val + arg\n...\n>>> class Product:\n...\ndef __init__(self, val):\n# Bound methods\n...\nself.val = val\n...\ndef method(self, arg):\n...\nreturn self.val * arg\n...\n>>> sobject = Sum(2)\n>>> pobject = Product(3)\n>>> actions = [square, sobject, pobject.method] # Function, instance, method\n>>> for act in actions:\n...\nprint(act(5))\n...\n25\n7\n15\n>>> actions[-1](5)\n15\n>>> [act(5) for act in actions]\n[25, 7, 15]\n>>> list(map(lambda act: act(5), actions))\n[25, 7, 15]",
    "# All 3 called same way\n# Call any 1-arg callable\n\n# Index, comprehensions, maps",
    "# Index, comprehensions, maps\n\nTechnically speaking, classes belong in the callable objects category too, but we normally call them to generate instances rather than to do actual work, as shown here:\n>>> class Negate:\n...\ndef __init__(self, val):\n# Classes are callables too\n...\nself.val = -val\n# But called for object, not work\n...\ndef __repr__(self):\n# Instance print format\n...\nreturn str(self.val)\n...\n>>> actions = [square, sobject, pobject.method, Negate]\n# Call a class too\n>>> for act in actions:\n...\nprint(act(5))\n...\n25\n7\n15\n-5\n>>> [act(5) for act in actions]\n# Runs __repr__ not __str__!\n[25, 7, 15, −5]\n>>> table = {act(5): act for act in actions}\n# 2.6/3.0 dict comprehension\n>>> for (key, value) in table.items():\n...\nprint('{0:2} => {1}'.format(key, value))\n# 2.6/3.0 str.format\n...\n-5 => <class '__main__.Negate'>\n25 => <function square at 0x025D4978>\n15 => <bound method Product.method of <__main__.Product object at 0x025D0F90>>\n7 => <__main__.Sum object at 0x025D0F70>",
    "Methods Are Objects: Bound or Unbound | 755\n\n\fAs you can see, bound methods, and Python’s callable objects model in general, are\nsome of the many ways that Python’s design makes for an incredibly flexible language.\nYou should now understand the method object model. For other examples of bound\nmethods at work, see the upcoming sidebar “Why You Will Care: Bound Methods and\nCallbacks” as well as the prior chapter’s discussion of callback handlers in the section\non the method __call__.\n\nWhy You Will Care: Bound Methods and Callbacks\nBecause bound methods automatically pair an instance with a class method function,\nyou can use them anywhere a simple function is expected. One of the most common\nplaces you’ll see this idea put to work is in code that registers methods as event callback\nhandlers in the tkinter GUI interface (named Tkinter in Python 2.6). Here’s the simple\ncase:\ndef handler():\n...use globals for state...\n...\nwidget = Button(text='spam', command=handler)",
    "To register a handler for button click events, we usually pass a callable object that takes\nno arguments to the command keyword argument. Function names (and lambdas) work\nhere, and so do class methods, as long as they are bound methods:\nclass MyWidget:\ndef handler(self):\n...use self.attr for state...\ndef makewidgets(self):\nb = Button(text='spam', command=self.handler)\n\nHere, the event handler is self.handler—a bound method object that remembers both\nself and MyGui.handler. Because self will refer to the original instance when handler\nis later invoked on events, the method will have access to instance attributes that can\nretain state between events. With simple functions, state normally must be retained in\nglobal variables or enclosing function scopes instead. See also the discussion of\n__call__ operator overloading in Chapter 29 for another way to make classes compatible with function-based APIs.",
    "Multiple Inheritance: “Mix-in” Classes\nMany class-based designs call for combining disparate sets of methods. In a class\nstatement, more than one superclass can be listed in parentheses in the header line.\nWhen you do this, you use something called multiple inheritance—the class and its\ninstances inherit names from all the listed superclasses.\n\n756 | Chapter 30: Designing with Classes",
    "When searching for an attribute, Python’s inheritance search traverses all superclasses\nin the class header from left to right until a match is found. Technically, because any\nof the superclasses may have superclasses of its own, this search can be a bit more\ncomplex for larger class tress:\n• In classic classes (the default until Python 3.0), the attribute search proceeds depthfirst all the way to the top of the inheritance tree, and then from left to right.\n• In new-style classes (and all classes in 3.0), the attribute search proceeds across by\ntree levels, in a more breadth-first fashion (see the new-style class discussion in the\nnext chapter).\nIn either model, though, when a class has multiple superclasses, they are searched from\nleft to right according to the order listed in the class statement header lines.\nIn general, multiple inheritance is good for modeling objects that belong to more than",
    "tree levels, in a more breadth-first fashion (see the new-style class discussion in the\nnext chapter).\nIn either model, though, when a class has multiple superclasses, they are searched from\nleft to right according to the order listed in the class statement header lines.\nIn general, multiple inheritance is good for modeling objects that belong to more than\none set. For instance, a person may be an engineer, a writer, a musician, and so on, and\ninherit properties from all such sets. With multiple inheritance, objects obtain the\nunion of the behavior in all their superclasses.\nPerhaps the most common way multiple inheritance is used is to “mix in” generalpurpose methods from superclasses. Such superclasses are usually called mix-in\nclasses—they provide methods you add to application classes by inheritance. In a sense,\nmix-in classes are similar to modules: they provide packages of methods for use in their",
    "union of the behavior in all their superclasses.\nPerhaps the most common way multiple inheritance is used is to “mix in” generalpurpose methods from superclasses. Such superclasses are usually called mix-in\nclasses—they provide methods you add to application classes by inheritance. In a sense,\nmix-in classes are similar to modules: they provide packages of methods for use in their\nclient subclasses. Unlike simple functions in modules, though, methods in mix-ins also\nhave access to the self instance, for using state information and other methods. The\nnext section demonstrates one common use case for such tools.",
    "Coding Mix-in Display Classes\nAs we’ve seen, Python’s default way to print a class instance object isn’t incredibly\nuseful:\n>>> class Spam:\n...\ndef __init__(self):\n...\nself.data1 = \"food\"\n...\n>>> X = Spam()\n>>> print(X)\n<__main__.Spam object at 0x00864818>\n\n# No __repr__ or __str__\n\n# Default: class, address\n# Displays \"instance\" in Python 2.6\n\nAs you saw in Chapter 29 when studying operator overloading, you can provide a\n__str__ or __repr__ method to implement a custom string representation of your own.\nBut, rather than coding one of these in each and every class you wish to print, why not\ncode it once in a general-purpose tool class and inherit it in all your classes?\nThat’s what mix-ins are for. Defining a display method in a mix-in superclass once\nenables us to reuse it anywhere we want to see a custom display format. We’ve already\nseen tools that do related work:\n\nMultiple Inheritance: “Mix-in” Classes | 757",
    "Multiple Inheritance: “Mix-in” Classes | 757\n\n\f• Chapter 27’s AttrDisplay class formatted instance attributes in a generic __str__\nmethod, but it did not climb class trees and was used in single-inheritance mode\nonly.\n• Chapter 28’s classtree.py module defined functions for climbing and sketching\nclass trees, but it did not display object attributes along the way and was not architected as an inheritable class.\nHere, we’re going to revisit these examples’ techniques and expand upon them to code\na set of three mix-in classes that serve as generic display tools for listing instance attributes, inherited attributes, and attributes on all objects in a class tree. We’ll also use\nour tools in multiple-inheritance mode and deploy coding techniques that make classes\nbetter suited to use as generic tools.",
    "Listing instance attributes with __dict__\nLet’s get started with the simple case—listing attributes attached to an instance. The\nfollowing class, coded in the file lister.py, defines a mix-in called ListInstance that\noverloads the __str__ method for all classes that include it in their header lines. Because\nthis is coded as a class, ListInstance is a generic tool whose formatting logic can be\nused for instances of any subclass:\n# File lister.py\nclass ListInstance:\n\"\"\"\nMix-in class that provides a formatted print() or str() of\ninstances via inheritance of __str__, coded here; displays\ninstance attrs only; self is the instance of lowest class;\nuses __X names to avoid clashing with client's attrs\n\"\"\"\ndef __str__(self):\nreturn '<Instance of %s, address %s:\\n%s>' % (\nself.__class__.__name__,\n# My class's name\nid(self),\n# My address\nself.__attrnames())\n# name=value list\ndef __attrnames(self):\nresult = ''\nfor attr in sorted(self.__dict__):\n# Instance attr dict",
    "instance attrs only; self is the instance of lowest class;\nuses __X names to avoid clashing with client's attrs\n\"\"\"\ndef __str__(self):\nreturn '<Instance of %s, address %s:\\n%s>' % (\nself.__class__.__name__,\n# My class's name\nid(self),\n# My address\nself.__attrnames())\n# name=value list\ndef __attrnames(self):\nresult = ''\nfor attr in sorted(self.__dict__):\n# Instance attr dict\nresult += '\\tname %s=%s\\n' % (attr, self.__dict__ [attr])\nretubrn result",
    "ListInstance uses some previously explored tricks to extract the instance’s class name\n\nand attributes:\n• Each instance has a built-in __class__ attribute that references the class from which\nit was created, and each class has a __name__ attribute that references the name in\nthe header, so the expression self.__class__.__name__ fetches the name of an instance’s class.\n\n758 | Chapter 30: Designing with Classes",
    "• This class does most of its work by simply scanning the instance’s attribute dictionary (remember, it’s exported in __dict__) to build up a string showing the\nnames and values of all instance attributes. The dictionary’s keys are sorted to\nfinesse any ordering differences across Python releases.\nIn these respects, ListInstance is similar to Chapter 27’s attribute display; in fact, it’s\nlargely just a variation on a theme. Our class here uses two additional techniques,\nthough:\n• It displays the instance’s memory address by calling the id built-function, which\nreturns any object’s address (by definition, a unique object identifier, which will\nbe useful in later mutations of this code).\n• It uses the pseudoprivate naming pattern for its worker method: __attrnames. As\nwe learned earlier in his chapter, Python automatically localizes any such name to\nits enclosing class by expanding the attribute name to include the class name (in",
    "returns any object’s address (by definition, a unique object identifier, which will\nbe useful in later mutations of this code).\n• It uses the pseudoprivate naming pattern for its worker method: __attrnames. As\nwe learned earlier in his chapter, Python automatically localizes any such name to\nits enclosing class by expanding the attribute name to include the class name (in\nthis case, it becomes _ListInstance__attrnames). This holds true for both class\nattributes (like methods) and instance attributes attached to self. This behavior is\nuseful in a general tool like this, as it ensures that its names don’t clash with any\nnames used in its client subclasses.\nBecause ListInstance defines a __str__ operator overloading method, instances derived from this class display their attributes automatically when printed, giving a bit\nmore information than a simple address. Here is the class in action, in single-inheritance\nmode (this code works the same in both Python 3.0 and 2.6):",
    "names used in its client subclasses.\nBecause ListInstance defines a __str__ operator overloading method, instances derived from this class display their attributes automatically when printed, giving a bit\nmore information than a simple address. Here is the class in action, in single-inheritance\nmode (this code works the same in both Python 3.0 and 2.6):\n>>> from lister import ListInstance\n>>> class Spam(ListInstance):\n...\ndef __init__(self):\n...\nself.data1 = 'food'\n...\n>>> x = Spam()\n>>> print(x)\n<Instance of Spam, address 40240880:\nname data1=food\n>",
    "# Inherit a __str__ method\n\n# print() and str() run __str__\n\nYou can also fetch the listing output as a string without printing it with str, and interactive echoes still use the default format:\n>>> str(x)\n'<Instance of Spam, address 40240880:\\n\\tname data1=food\\n>'\n>>> x\n# The __repr__ still is a default\n<__main__.Spam object at 0x026606F0>\n\nThe ListInstance class is useful for any classes you write—even classes that already\nhave one or more superclasses. This is where multiple inheritance comes in handy: by\nadding ListInstance to the list of superclasses in a class header (i.e., mixing it in), you\nget its __str__ “for free” while still inheriting from the existing superclass(es). The file\ntestmixin.py demonstrates:\n\nMultiple Inheritance: “Mix-in” Classes | 759",
    "Multiple Inheritance: “Mix-in” Classes | 759\n\n\f# File testmixin.py\nfrom lister import *\nclass Super:\ndef __init__(self):\nself.data1 = 'spam'\ndef ham(self):\npass\nclass Sub(Super, ListInstance):\ndef __init__(self):\nSuper.__init__(self)\nself.data2 = 'eggs'\nself.data3 = 42\ndef spam(self):\npass\nif __name__ == '__main__':\nX = Sub()\nprint(X)\n\n# Get lister tool classes\n# Superclass __init__\n# Create instance attrs\n\n# Mix in ham and a __str__\n# listers have access to self\n# More instance attrs\n# Define another method here\n\n# Run mixed-in __str__",
    "# Get lister tool classes\n# Superclass __init__\n# Create instance attrs\n\n# Mix in ham and a __str__\n# listers have access to self\n# More instance attrs\n# Define another method here\n\n# Run mixed-in __str__\n\nHere, Sub inherits names from both Super and ListInstance; it’s a composite of its own\nnames and names in both its superclasses. When you make a Sub instance and print it,\nyou automatically get the custom representation mixed in from ListInstance (in this\ncase, this script’s output is the same under both Python 3.0 and 2.6, except for object\naddresses):\nC:\\misc> C:\\python30\\python testmixin.py\n<Instance of Sub, address 40962576:\nname data1=spam\nname data2=eggs\nname data3=42\n>\n\nListInstance works in any class it’s mixed into because self refers to an instance of",
    "ListInstance works in any class it’s mixed into because self refers to an instance of\n\nthe subclass that pulls this class in, whatever that may be. In a sense, mix-in classes are\nthe class equivalent of modules—packages of methods useful in a variety of clients. For\nexample, here is Lister working again in single-inheritance mode on a different class’s\ninstances, with import and attributes set outside the class:\n>>> import lister\n>>> class C(lister.ListInstance): pass\n...\n>>> x = C()\n>>> x.a = 1; x.b = 2; x.c = 3\n>>> print(x)\n<Instance of C, address 40961776:\nname a=1\nname b=2\nname c=3\n>\n\n760 | Chapter 30: Designing with Classes",
    "760 | Chapter 30: Designing with Classes\n\n\fBesides the utility they provide, mix-ins optimize code maintenance, like all classes do.\nFor example, if you later decide to extend ListInstance’s __str__ to also print all the\nclass attributes that an instance inherits, you’re safe; because it’s an inherited method,\nchanging __str__ automatically updates the display of each subclass that imports the\nclass and mixes it in. Since it’s now officially “later,” let’s move on to the next section\nto see what such an extension might look like.",
    "Listing inherited attributes with dir\nAs it is, our Lister mix-in displays instance attributes only (i.e., names attached to the\ninstance object itself). It’s trivial to extend the class to display all the attributes accessible from an instance, though—both its own and those it inherits from its classes. The\ntrick is to use the dir built-in function instead of scanning the instance’s __dict__ dictionary; the latter holds instance attributes only, but the former also collects all inherited attributes in Python 2.2 and later.\nThe following mutation codes this scheme; I’ve renamed it to facilitate simple testing,\nbut if this were to replace the original version, all existing clients would pick up the new\ndisplay automatically:\n# File lister.py, continued\nclass ListInherited:\n\"\"\"\nUse dir() to collect both instance attrs and names\ninherited from its classes; Python 3.0 shows more\nnames than 2.6 because of the implied object superclass",
    "but if this were to replace the original version, all existing clients would pick up the new\ndisplay automatically:\n# File lister.py, continued\nclass ListInherited:\n\"\"\"\nUse dir() to collect both instance attrs and names\ninherited from its classes; Python 3.0 shows more\nnames than 2.6 because of the implied object superclass\nin the new-style class model; getattr() fetches inherited\nnames not in self.__dict__; use __str__, not __repr__,\nor else this loops when printing bound methods!\n\"\"\"\ndef __str__(self):\nreturn '<Instance of %s, address %s:\\n%s>' % (\nself.__class__.__name__,\n# My class's name\nid(self),\n# My address\nself.__attrnames())\n# name=value list\ndef __attrnames(self):\nresult = ''\nfor attr in dir(self):\n# Instance dir()\nif attr[:2] == '__' and attr[-2:] == '__':\n# Skip internals\nresult += '\\tname %s=<>\\n' % attr\nelse:\nresult += '\\tname %s=%s\\n' % (attr, getattr(self, attr))\nreturn result",
    "Notice that this code skips __X__ names’ values; most of these are internal names that\nwe don’t generally care about in a generic listing like this. This version also must use\nthe getattr built-in function to fetch attributes by name string instead of using instance\nattribute dictionary indexing—getattr employs the inheritance search protocol, and\nsome of the names we’re listing here are not stored on the instance itself.\n\nMultiple Inheritance: “Mix-in” Classes | 761\n\n\fTo test the new version, change the testmixin.py file to use this new class instead:\nclass Sub(Super, ListInherited):\n\n# Mix in a __str__",
    "Multiple Inheritance: “Mix-in” Classes | 761\n\n\fTo test the new version, change the testmixin.py file to use this new class instead:\nclass Sub(Super, ListInherited):\n\n# Mix in a __str__\n\nThis file’s output varies per release. In Python 2.6, we get the following; notice the name\nmangling at work in the lister’s method name (I shortened its full value display to fit\non this page):\nC:\\misc> c:\\python26\\python testmixin.py\n<Instance of Sub, address 40073136:\nname _ListInherited__attrnames=<bound method Sub.__attrnames of <...more...>>\nname __doc__=<>\nname __init__=<>\nname __module__=<>\nname __str__=<>\nname data1=spam\nname data2=eggs\nname data3=42\nname ham=<bound method Sub.ham of <__main__.Sub instance at 0x026377B0>>\nname spam=<bound method Sub.spam of <__main__.Sub instance at 0x026377B0>>\n>",
    "In Python 3.0, more attributes are displayed because all classes are “new-style” and\ninherit names from the implied object superclass (more on this in Chapter 31). Because\nso many names are inherited from the default superclass, I’ve omitted many here; run\nthis on your own for the full listing:\nC:\\misc> c:\\python30\\python testmixin.py\n<Instance of Sub, address 40831792:\nname _ListInherited__attrnames=<bound method Sub.__attrnames of <...more...>>\nname __class__=<>\nname __delattr__=<>\nname __dict__=<>\nname __doc__=<>\nname __eq__=<>\n...more names omitted...\nname __repr__=<>\nname __setattr__=<>\nname __sizeof__=<>\nname __str__=<>\nname __subclasshook__=<>\nname __weakref__=<>\nname data1=spam\nname data2=eggs\nname data3=42\nname ham=<bound method Sub.ham of <__main__.Sub object at 0x026F0B30>>\nname spam=<bound method Sub.spam of <__main__.Sub object at 0x026F0B30>>\n>",
    "One caution here—now that we’re displaying inherited methods too, we have to use\n__str__ instead of __repr__ to overload printing. With __repr__, this code will loop—\ndisplaying the value of a method triggers the __repr__ of the method’s class, in order\nto display the class. That is, if the lister’s __repr__ tries to display a method, displaying\nthe method’s class will trigger the lister’s __repr__ again. Subtle, but true! Change\n\n762 | Chapter 30: Designing with Classes\n\n\f__str__ to __repr__ here to see this for yourself. If you must use __repr__ in such a\ncontext, you can avoid the loops by using isinstance to compare the type of attribute\nvalues against types.MethodType in the standard library, to know which items to skip.",
    "Listing attributes per object in class trees\nLet’s code one last extension. As it is, our lister doesn’t tell us which class an inherited\nname comes from. As we saw in the classtree.py example near the end of Chapter 28,\nthough, it’s straightforward to climb class inheritance trees in code. The following mixin class makes use of this same technique to display attributes grouped by the classes\nthey live in—it sketches the full class tree, displaying attributes attached to each object\nalong the way. It does so by traversing the inheritance tree from an instance’s\n__class__ to its class, and then from the class’s __bases__ to all superclasses recursively,\nscanning object __dicts__s along the way:\n# File lister.py, continued\nclass ListTree:\n\"\"\"\nMix-in that returns an __str__ trace of the entire class\ntree and all its objects' attrs at and above self;\nrun by print(), str() returns constructed string;\nuses __X attr names to avoid impacting clients;",
    "__class__ to its class, and then from the class’s __bases__ to all superclasses recursively,\nscanning object __dicts__s along the way:\n# File lister.py, continued\nclass ListTree:\n\"\"\"\nMix-in that returns an __str__ trace of the entire class\ntree and all its objects' attrs at and above self;\nrun by print(), str() returns constructed string;\nuses __X attr names to avoid impacting clients;\nuses generator expr to recurse to superclasses;\nuses str.format() to make substitutions clearer\n\"\"\"\ndef __str__(self):\nself.__visited = {}\nreturn '<Instance of {0}, address {1}:\\n{2}{3}>'.format(\nself.__class__.__name__,\nid(self),\nself.__attrnames(self, 0),\nself.__listclass(self.__class__, 4))\ndef __listclass(self, aClass, indent):\ndots = '.' * indent\nif aClass in self.__visited:\nreturn '\\n{0}<Class {1}:, address {2}: (see above)>\\n'.format(\ndots,\naClass.__name__,\nid(aClass))\nelse:\nself.__visited[aClass] = True\ngenabove = (self.__listclass(c, indent+4) for c in aClass.__bases__)",
    "self.__class__.__name__,\nid(self),\nself.__attrnames(self, 0),\nself.__listclass(self.__class__, 4))\ndef __listclass(self, aClass, indent):\ndots = '.' * indent\nif aClass in self.__visited:\nreturn '\\n{0}<Class {1}:, address {2}: (see above)>\\n'.format(\ndots,\naClass.__name__,\nid(aClass))\nelse:\nself.__visited[aClass] = True\ngenabove = (self.__listclass(c, indent+4) for c in aClass.__bases__)\nreturn '\\n{0}<Class {1}, address {2}:\\n{3}{4}{5}>\\n'.format(\ndots,\naClass.__name__,\nid(aClass),\nself.__attrnames(aClass, indent),\n''.join(genabove),\ndots)\ndef __attrnames(self, obj, indent):",
    "Multiple Inheritance: “Mix-in” Classes | 763\n\n\fspaces = ' ' * (indent + 4)\nresult = ''\nfor attr in sorted(obj.__dict__):\nif attr.startswith('__') and attr.endswith('__'):\nresult += spaces + '{0}=<>\\n'.format(attr)\nelse:\nresult += spaces + '{0}={1}\\n'.format(attr, getattr(obj, attr))\nreturn result\n\nNote the use of a generator expression to direct the recursive calls for superclasses; it’s\nactivated by the nested string join method. Also see how this version uses the Python\n3.0 and 2.6 string format method instead of % formatting expressions, to make substitutions clearer; when many substitutions are applied like this, explicit argument numbers may make the code easier to decipher. In short, in this version we exchange the\nfirst of the following lines for the second:\nreturn '<Instance of %s, address %s:\\n%s%s>' % (...)\n# Expression\nreturn '<Instance of {0}, address {1}:\\n{2}{3}>'.format(...) # Method",
    "Now, change testmixin.py to inherit from this new class again to test:\nclass Sub(Super, ListTree):\n\n# Mix in a __str__\n\nThe file’s tree-sketcher output in Python 2.6 is then as follows:\nC:\\misc> c:\\python26\\python testmixin.py\n<Instance of Sub, address 40728496:\n_ListTree__visited={}\ndata1=spam\ndata2=eggs\ndata3=42\n....<Class Sub, address 40701168:\n__doc__=<>\n__init__=<>\n__module__=<>\nspam=<unbound method Sub.spam>\n........<Class Super, address 40701120:\n__doc__=<>\n__init__=<>\n__module__=<>\nham=<unbound method Super.ham>\n........>\n........<Class ListTree, address 40700688:\n_ListTree__attrnames=<unbound method ListTree.__attrnames>\n_ListTree__listclass=<unbound method ListTree.__listclass>\n__doc__=<>\n__module__=<>\n__str__=<>\n........>\n....>\n>\n\n764 | Chapter 30: Designing with Classes",
    "Notice in this output how methods are unbound now under 2.6, because we fetch them\nfrom classes directly, instead of from instances. Also observe how the lister’s\n__visited table has its name mangled in the instance’s attribute dictionary; unless we’re\nvery unlucky, this won’t clash with other data there.\nUnder Python 3.0, we get extra attributes and superclasses again. Notice that unbound\nmethods are simple functions in 3.0, as described in an earlier note in this chapter (and\nthat again, I’ve deleted most built-in attributes in object to save space here; run this on\nyour own for the complete listing):\nC:\\misc> c:\\python30\\python testmixin.py\n<Instance of Sub, address 40635216:\n_ListTree__visited={}\ndata1=spam\ndata2=eggs\ndata3=42\n....<Class Sub, address 40914752:\n__doc__=<>\n__init__=<>\n__module__=<>\nspam=<function spam at 0x026D53D8>\n........<Class Super, address 40829952:\n__dict__=<>\n__doc__=<>\n__init__=<>\n__module__=<>\n__weakref__=<>\nham=<function ham at 0x026D5228>",
    "C:\\misc> c:\\python30\\python testmixin.py\n<Instance of Sub, address 40635216:\n_ListTree__visited={}\ndata1=spam\ndata2=eggs\ndata3=42\n....<Class Sub, address 40914752:\n__doc__=<>\n__init__=<>\n__module__=<>\nspam=<function spam at 0x026D53D8>\n........<Class Super, address 40829952:\n__dict__=<>\n__doc__=<>\n__init__=<>\n__module__=<>\n__weakref__=<>\nham=<function ham at 0x026D5228>\n............<Class object, address 505114624:\n__class__=<>\n__delattr__=<>\n__doc__=<>\n__eq__=<>\n...more omitted...\n__repr__=<>\n__setattr__=<>\n__sizeof__=<>\n__str__=<>\n__subclasshook__=<>\n............>\n........>\n........<Class ListTree, address 40829496:\n_ListTree__attrnames=<function __attrnames at 0x026D5660>\n_ListTree__listclass=<function __listclass at 0x026D56A8>\n__dict__=<>\n__doc__=<>\n__module__=<>\n__str__=<>\n__weakref__=<>",
    "Multiple Inheritance: “Mix-in” Classes | 765\n\n\f............<Class object:, address 505114624: (see above)>\n........>\n....>\n>",
    "This version avoids listing the same class object twice by keeping a table of classes\nvisited so far (this is why an object’s id is included—to serve as a key for a previously\ndisplayed item). Like the transitive module reloader of Chapter 24, a dictionary works\nto avoid repeats and cycles here because class objects may be dictionary keys; a set\nwould provide similar functionality.\nThis version also takes care to avoid large internal objects by skipping __X__ names\nagain. If you comment out the test for these names, their values will display normally.\nHere’s an excerpt from the output in 2.6 with this temporary change made (it’s much\nlarger in its entirety, and it gets even worse in 3.0, which is why these names are probably\nbetter skipped!):\nC:\\misc> c:\\python26\\python testmixin.py\n...more omitted...\n........<Class ListTree, address 40700688:\n_ListTree__attrnames=<unbound method ListTree.__attrnames>\n_ListTree__listclass=<unbound method ListTree.__listclass>\n__doc__=",
    "larger in its entirety, and it gets even worse in 3.0, which is why these names are probably\nbetter skipped!):\nC:\\misc> c:\\python26\\python testmixin.py\n...more omitted...\n........<Class ListTree, address 40700688:\n_ListTree__attrnames=<unbound method ListTree.__attrnames>\n_ListTree__listclass=<unbound method ListTree.__listclass>\n__doc__=\nMix-in that returns the __str__ trace of the entire class\ntree and all its objects' attrs at and above self;\nrun by print, str returns constructed string;\nuses __X attr names to avoid impacting clients;\nuses generator expr to recurse to superclasses;\nuses str.format() to make substitutions clearer",
    "........>\n\n__module__=lister\n__str__=<unbound method ListTree.__str__>\n\nFor more fun, try mixing this class into something more substantial, like the Button\nclass of Python’s tkinter GUI toolkit module. In general, you’ll want to name List\nTree first (leftmost) in a class header, so its __str__ is picked up; Button has one, too,\nand the leftmost superclass is searched first in multiple inheritance. The output of\nthe following is fairly massive (18K characters), so run this code on your own to see\nthe full listing (and if you’re using Python 2.6, recall that you should use Tkinter for\nthe module name instead of tkinter):\n>>> from lister import ListTree\n>>> from tkinter import Button\n>>> class MyButton(ListTree, Button): pass\n...\n>>> B = MyButton(text='spam')\n>>> open('savetree.txt', 'w').write(str(B))\n18247\n>>> print(B)\n<Instance of MyButton, address 44355632:\n_ListTree__visited={}\n\n766 | Chapter 30: Designing with Classes",
    "766 | Chapter 30: Designing with Classes\n\n# Both classes have a __str__\n# ListTree first: use its __str__\n# Save to a file for later viewing\n# Print the display here\n\n\f>\n\n_name=44355632\n_tclCommands=[]\n...much more omitted...",
    "Of course, there’s much more we could do here (sketching the tree in a GUI might be\na natural next step), but we’ll leave further work as a suggested exercise. We’ll also\nextend this code in the exercises at the end of this part of the book, to list superclass\nnames in parentheses at the start of instance and class displays.\nThe main point here is that OOP is all about code reuse, and mix-in classes are a\npowerful example. Like almost everything else in programming, multiple inheritance\ncan be a useful device when applied well. In practice, though, it is an advanced feature\nand can become complicated if used carelessly or excessively. We’ll revisit this topic as\na gotcha at the end of the next chapter. In that chapter, we’ll also meet the new-style\nclass model, which modifies the search order for one special multiple inheritance case.\nSupporting slots: Because they scan instance dictionaries, the\nListInstance and ListTree classes presented here don’t directly support",
    "a gotcha at the end of the next chapter. In that chapter, we’ll also meet the new-style\nclass model, which modifies the search order for one special multiple inheritance case.\nSupporting slots: Because they scan instance dictionaries, the\nListInstance and ListTree classes presented here don’t directly support\nattributes stored in slots—a newer and relatively rarely used option we’ll\nmeet in the next chapter, where instance attributes are declared in a\n__slots__ class attribute. For example, if in textmixin.py we assign\n__slots__=['data1'] in Super and __slots__=['data3'] in Sub, only the\ndata2 attribute is displayed in the instance by these two lister classes;\nListTree also displays data1 and data3, but as attributes of the Super\nand Sub class objects and with a special format for their values (technically, they are class-level descriptors).\nTo better support slot attributes in these classes, change the __dict__",
    "data2 attribute is displayed in the instance by these two lister classes;\nListTree also displays data1 and data3, but as attributes of the Super\nand Sub class objects and with a special format for their values (technically, they are class-level descriptors).\nTo better support slot attributes in these classes, change the __dict__\nscanning loops to also iterate through __slots__ lists using code the next\nchapter will present, and use the getattr built-in function to fetch values\ninstead of __dict__ indexing (ListTree already does). Since instances\ninherit only the lowest class’s __slots__, you may also need to come up\nwith a policy when __slots__ lists appear in multiple superclasses\n(ListTree already displays them as class attributes). ListInherited is\nimmune to all this, because dir results combine both __dict__ names\nand all classes’ __slots__ names.\nAlternatively, as a policy we could simply let our code handle slot-based",
    "inherit only the lowest class’s __slots__, you may also need to come up\nwith a policy when __slots__ lists appear in multiple superclasses\n(ListTree already displays them as class attributes). ListInherited is\nimmune to all this, because dir results combine both __dict__ names\nand all classes’ __slots__ names.\nAlternatively, as a policy we could simply let our code handle slot-based\nattributes as it currently does, rather than complicating it for a rare,\nadvanced feature. Slots and normal instance attributes are different\nkinds of names. We’ll investigate slots further in the next chapter; I\nomitted addressing them in these examples to avoid a forward\ndependency (not counting this note, of course!)—not exactly a valid\ndesign goal, but reasonable for a book.",
    "Multiple Inheritance: “Mix-in” Classes | 767\n\n\fClasses Are Objects: Generic Object Factories\nSometimes, class-based designs require objects to be created in response to conditions\nthat can’t be predicted when a program is written. The factory design pattern allows\nsuch a deferred approach. Due in large part to Python’s flexibility, factories can take\nmultiple forms, some of which don’t seem special at all.\nBecause classes are objects, it’s easy to pass them around a program, store them in data\nstructures, and so on. You can also pass classes to functions that generate arbitrary\nkinds of objects; such functions are sometimes called factories in OOP design circles.\nFactories are a major undertaking in a strongly typed language such as C++ but are\nalmost trivial to implement in Python. The call syntax we met in Chapter 18 can call\nany class with any number of constructor arguments in one step to generate any sort\nof instance:‡\ndef factory(aClass, *args):\nreturn aClass(*args)",
    "# Varargs tuple\n# Call aClass (or apply in 2.6 only)\n\nclass Spam:\ndef doit(self, message):\nprint(message)\nclass Person:\ndef __init__(self, name, job):\nself.name = name\nself.job = job\nobject1 = factory(Spam)\nobject2 = factory(Person, \"Guido\", \"guru\")\n\n# Make a Spam object\n# Make a Person object",
    "# Make a Spam object\n# Make a Person object\n\nIn this code, we define an object generator function called factory. It expects to be\npassed a class object (any class will do) along with one or more arguments for the class’s\nconstructor. The function uses special “varargs” call syntax to call the function and\nreturn an instance.\nThe rest of the example simply defines two classes and generates instances of both by\npassing them to the factory function. And that’s the only factory function you’ll ever\nneed to write in Python; it works for any class and any constructor arguments.\nOne possible improvement worth noting is that to support keyword arguments in constructor calls, the factory can collect them with a **args argument and pass them along\nin the class call, too:\ndef factory(aClass, *args, **kwargs):\nreturn aClass(*args, **kwargs)\n\n# +kwargs dict\n# Call aClass",
    "# +kwargs dict\n# Call aClass\n\n‡ Actually, this syntax can invoke any callable object, including functions, classes, and methods. Hence, the\nfactory function here can also run any callable object, not just a class (despite the argument name). Also, as\nwe learned in Chapter 18, Python 2.6 has an alternative to aClass(*args): the apply(aClass, args) built-in\ncall, which has been removed in Python 3.0 because of its redundancy and limitations.\n\n768 | Chapter 30: Designing with Classes\n\n\fBy now, you should know that everything is an “object” in Python, including things\nlike classes, which are just compiler input in languages like C++. However, as mentioned at the start of this part of the book, only objects derived from classes are OOP\nobjects in Python.",
    "Why Factories?\nSo what good is the factory function (besides providing an excuse to illustrate class\nobjects in this book)? Unfortunately, it’s difficult to show applications of this design\npattern without listing much more code than we have space for here. In general, though,\nsuch a factory might allow code to be insulated from the details of dynamically configured object construction.\nFor instance, recall the processor example presented in the abstract in Chapter 25, and\nthen again as a composition example in this chapter. It accepts reader and writer objects\nfor processing arbitrary data streams. The original version of this example manually\npassed in instances of specialized classes like FileWriter and SocketReader to customize\nthe data streams being processed; later, we passed in hardcoded file, stream, and\nformatter objects. In a more dynamic scenario, external devices such as configuration\nfiles or GUIs might be used to configure the streams.",
    "for processing arbitrary data streams. The original version of this example manually\npassed in instances of specialized classes like FileWriter and SocketReader to customize\nthe data streams being processed; later, we passed in hardcoded file, stream, and\nformatter objects. In a more dynamic scenario, external devices such as configuration\nfiles or GUIs might be used to configure the streams.\nIn such a dynamic world, we might not be able to hardcode the creation of stream\ninterface objects in our scripts, but might instead create them at runtime according to\nthe contents of a configuration file.\nFor example, the file might simply give the string name of a stream class to be imported\nfrom a module, plus an optional constructor call argument. Factory-style functions or\ncode might come in handy here because they would allow us to fetch and pass in classes\nthat are not hardcoded in our program ahead of time. Indeed, those classes might not\neven have existed at all when we wrote our code:",
    "For example, the file might simply give the string name of a stream class to be imported\nfrom a module, plus an optional constructor call argument. Factory-style functions or\ncode might come in handy here because they would allow us to fetch and pass in classes\nthat are not hardcoded in our program ahead of time. Indeed, those classes might not\neven have existed at all when we wrote our code:\nclassname = ...parse from config file...\nclassarg = ...parse from config file...\nimport streamtypes\naclass = getattr(streamtypes, classname)\nreader = factory(aclass, classarg)\nprocessor(reader, ...)",
    "# Customizable code\n# Fetch from module\n# Or aclass(classarg)\n\nHere, the getattr built-in is again used to fetch a module attribute given a string name\n(it’s like saying obj.attr, but attr is a string). Because this code snippet assumes a\nsingle constructor argument, it doesn’t strictly need factory or apply—we could make\nan instance with just aclass(classarg). They may prove more useful in the presence\nof unknown argument lists, however, and the general factory coding pattern can improve the code’s flexibility.\n\nClasses Are Objects: Generic Object Factories | 769",
    "Classes Are Objects: Generic Object Factories | 769\n\n\fOther Design-Related Topics\nIn this chapter, we’ve seen inheritance, composition, delegation, multiple inheritance,\nbound methods, and factories—all common patterns used to combine classes in Python\nprograms. We’ve really only scratched the surface here in the design patterns domain,\nthough. Elsewhere in this book you’ll find coverage of other design-related topics, such\nas:\n• Abstract superclasses (Chapter 28)\n• Decorators (Chapters 31 and 38)\n• Type subclasses (Chapter 31)\n• Static and class methods (Chapter 31)\n• Managed attributes (Chapter 37)\n• Metaclasses (Chapters 31 and 39)\nFor more details on design patterns, though, we’ll delegate to other resources on OOP\nat large. Although patterns are important in OOP work, and are often more natural in\nPython than other languages, they are not specific to Python itself.",
    "Chapter Summary\nIn this chapter, we sampled common ways to use and combine classes to optimize their\nreusability and factoring benefits—what are usually considered design issues that are\noften independent of any particular programming language (though Python can make\nthem easier to implement). We studied delegation (wrapping objects in proxy classes),\ncomposition (controlling embedded objects), and inheritance (acquiring behavior from\nother classes), as well as some more esoteric concepts such as pseudoprivate attributes,\nmultiple inheritance, bound methods, and factories.\nThe next chapter ends our look at classes and OOP by surveying more advanced classrelated topics; some of its material may be of more interest to tool writers than application programmers, but it still merits a review by most people who will do OOP in\nPython. First, though, another quick chapter quiz.\n\nTest Your Knowledge: Quiz\n1. What is multiple inheritance?\n2. What is delegation?\n3. What is composition?",
    "Test Your Knowledge: Quiz\n1. What is multiple inheritance?\n2. What is delegation?\n3. What is composition?\n\n770 | Chapter 30: Designing with Classes\n\n\f4. What are bound methods?\n5. What are pseudoprivate attributes used for?",
    "Test Your Knowledge: Answers\n1. Multiple inheritance occurs when a class inherits from more than one superclass;\nit’s useful for mixing together multiple packages of class-based code. The left-toright order in class statement headers determines the order of attribute searches.\n2. Delegation involves wrapping an object in a proxy class, which adds extra behavior\nand passes other operations to the wrapped object. The proxy retains the interface\nof the wrapped object.\n3. Composition is a technique whereby a controller class embeds and directs a number of objects, and provides an interface all its own; it’s a way to build up larger\nstructures with classes.\n4. Bound methods combine an instance and a method function; you can call them\nwithout passing in an instance object explicitly because the original instance is still\navailable.\n5. Pseudoprivate attributes (whose names begin with two leading underscores: __X)",
    "structures with classes.\n4. Bound methods combine an instance and a method function; you can call them\nwithout passing in an instance object explicitly because the original instance is still\navailable.\n5. Pseudoprivate attributes (whose names begin with two leading underscores: __X)\nare used to localize names to the enclosing class. This includes both class attributes\nlike methods defined inside the class, and self instance attributes assigned inside\nthe class. Such names are expanded to include the class name, which makes them\nunique.",
    "Test Your Knowledge: Answers | 771\n\n\f\fCHAPTER 31\n\nAdvanced Class Topics",
    "This chapter concludes our look at OOP in Python by presenting a few more advanced\nclass-related topics: we will survey subclassing built-in types, “new-style” class changes\nand extensions, static and class methods, function decorators, and more.\nAs we’ve seen, Python’s OOP model is, at its core, very simple, and some of the topics\npresented in this chapter are so advanced and optional that you may not encounter\nthem very often in your Python applications-programming career. In the interest of\ncompleteness, though, we’ll round out our discussion of classes with a brief look at\nthese advanced tools for OOP work.\nAs usual, because this is the last chapter in this part of the book, it ends with a section\non class-related “gotchas,” and the set of lab exercises for this part. I encourage you to\nwork through the exercises to help cement the ideas we’ve studied here. I also suggest\nworking on or studying larger OOP Python projects as a supplement to this book. As",
    "these advanced tools for OOP work.\nAs usual, because this is the last chapter in this part of the book, it ends with a section\non class-related “gotchas,” and the set of lab exercises for this part. I encourage you to\nwork through the exercises to help cement the ideas we’ve studied here. I also suggest\nworking on or studying larger OOP Python projects as a supplement to this book. As\nwith much in computing, the benefits of OOP tend to become more apparent with\npractice.\nContent note: This chapter collects advanced class topics, but some are\neven too advanced for this chapter to cover well. Topics such as properties, descriptors, decorators, and metaclasses are only briefly mentioned here, and are covered more fully in the final part of this book. Be\nsure to look ahead for more complete examples and extended coverage\nof some of the subjects that fall into this chapter’s category.",
    "Extending Built-in Types\nBesides implementing new kinds of objects, classes are sometimes used to extend the\nfunctionality of Python’s built-in types to support more exotic data structures. For\ninstance, to add queue insert and delete methods to lists, you can code classes that wrap\n(embed) a list object and export insert and delete methods that process the list specially,\nlike the delegation technique we studied in Chapter 30. As of Python 2.2, you can also\n\n773\n\n\fuse inheritance to specialize built-in types. The next two sections show both techniques\nin action.",
    "773\n\n\fuse inheritance to specialize built-in types. The next two sections show both techniques\nin action.\n\nExtending Types by Embedding\nRemember those set functions we wrote in Chapters 16 and 18? Here’s what they look\nlike brought back to life as a Python class. The following example (the file\nsetwrapper.py) implements a new set object type by moving some of the set functions\nto methods and adding some basic operator overloading. For the most part, this class\njust wraps a Python list with extra set operations. But because it’s a class, it also supports\nmultiple instances and customization by inheritance in subclasses. Unlike our earlier\nfunctions, using classes here allows us to make multiple self-contained set objects with\npreset data and behavior, rather than passing lists into functions manually:\nclass Set:\ndef __init__(self, value = []):\nself.data = []\nself.concat(value)\n\n# Constructor\n# Manages a list",
    "# Constructor\n# Manages a list\n\ndef intersect(self, other):\nres = []\nfor x in self.data:\nif x in other:\nres.append(x)\nreturn Set(res)\n\n# other is any sequence\n# self is the subject\n\ndef union(self, other):\nres = self.data[:]\nfor x in other:\nif not x in res:\nres.append(x)\nreturn Set(res)\n\n# other is any sequence\n# Copy of my list\n# Add items in other\n\ndef concat(self, value):\nfor x in value:\nif not x in self.data:\nself.data.append(x)\n\n# value: list, Set...\n# Removes duplicates\n\n# Pick common items\n# Return a new Set\n\ndef __len__(self):\nreturn len(self.data)\ndef __getitem__(self, key): return self.data[key]\ndef __and__(self, other):\nreturn self.intersect(other)\ndef __or__(self, other):\nreturn self.union(other)\ndef __repr__(self):\nreturn 'Set:' + repr(self.data)\n\n# len(self)\n# self[i]\n# self & other\n# self | other\n# print()",
    "# value: list, Set...\n# Removes duplicates\n\n# Pick common items\n# Return a new Set\n\ndef __len__(self):\nreturn len(self.data)\ndef __getitem__(self, key): return self.data[key]\ndef __and__(self, other):\nreturn self.intersect(other)\ndef __or__(self, other):\nreturn self.union(other)\ndef __repr__(self):\nreturn 'Set:' + repr(self.data)\n\n# len(self)\n# self[i]\n# self & other\n# self | other\n# print()\n\nTo use this class, we make instances, call methods, and run defined operators as usual:\nx = Set([1, 3, 5, 7])\nprint(x.union(Set([1, 4, 7])))\nprint(x | Set([1, 4, 6]))\n\n774 | Chapter 31: Advanced Class Topics\n\n# prints Set:[1, 3, 5, 7, 4]\n# prints Set:[1, 3, 5, 7, 4, 6]\n\n\fOverloading operations such as indexing enables instances of our Set class to masquerade as real lists. Because you will interact with and extend this class in an exercise\nat the end of this chapter, I won’t say much more about this code until Appendix B.",
    "Extending Types by Subclassing\nBeginning with Python 2.2, all the built-in types in the language can now be subclassed\ndirectly. Type-conversion functions such as list, str, dict, and tuple have become\nbuilt-in type names—although transparent to your script, a type-conversion call (e.g.,\nlist('spam')) is now really an invocation of a type’s object constructor.\nThis change allows you to customize or extend the behavior of built-in types with userdefined class statements: simply subclass the new type names to customize them. Instances of your type subclasses can be used anywhere that the original built-in type can\nappear. For example, suppose you have trouble getting used to the fact that Python list\noffsets begin at 0 instead of 1. Not to worry—you can always code your own subclass\nthat customizes this core behavior of lists. The file typesubclass.py shows how:\n# Subclass built-in list type/class\n# Map 1..N to 0..N-1; call back to built-in version.\nclass MyList(list):",
    "appear. For example, suppose you have trouble getting used to the fact that Python list\noffsets begin at 0 instead of 1. Not to worry—you can always code your own subclass\nthat customizes this core behavior of lists. The file typesubclass.py shows how:\n# Subclass built-in list type/class\n# Map 1..N to 0..N-1; call back to built-in version.\nclass MyList(list):\ndef __getitem__(self, offset):\nprint('(indexing %s at %s)' % (self, offset))\nreturn list.__getitem__(self, offset - 1)\nif __name__ == '__main__':\nprint(list('abc'))\nx = MyList('abc')\nprint(x)",
    "# __init__ inherited from list\n# __repr__ inherited from list\n\nprint(x[1])\nprint(x[3])\n\n# MyList.__getitem__\n# Customizes list superclass method\n\nx.append('spam'); print(x)\nx.reverse();\nprint(x)\n\n# Attributes from list superclass\n\nIn this file, the MyList subclass extends the built-in list’s __getitem__ indexing method\nonly to map indexes 1 to N back to the required 0 to N−1. All it really does is decrement\nthe submitted index and call back to the superclass’s version of indexing, but it’s\nenough to do the trick:\n% python typesubclass.py\n['a', 'b', 'c']\n['a', 'b', 'c']\n(indexing ['a', 'b', 'c'] at 1)\na\n(indexing ['a', 'b', 'c'] at 3)\nc\n['a', 'b', 'c', 'spam']\n['spam', 'c', 'b', 'a']\n\nExtending Built-in Types | 775",
    "This output also includes tracing text the class prints on indexing. Of course, whether\nchanging indexing this way is a good idea in general is another issue—users of your\nMyList class may very well be confused by such a core departure from Python sequence\nbehavior. The ability to customize built-in types this way can be a powerful asset,\nthough.\nFor instance, this coding pattern gives rise to an alternative way to code a set—as a\nsubclass of the built-in list type, rather than a standalone class that manages an embedded list object, as shown earlier in this section. As we learned in Chapter 5, Python\ntoday comes with a powerful built-in set object, along with literal and comprehension\nsyntax for making new sets. Coding one yourself, though, is still a great way to learn\nabout type subclassing in general.\nThe following class, coded in the file setsubclass.py, customizes lists to add just methods",
    "today comes with a powerful built-in set object, along with literal and comprehension\nsyntax for making new sets. Coding one yourself, though, is still a great way to learn\nabout type subclassing in general.\nThe following class, coded in the file setsubclass.py, customizes lists to add just methods\nand operators related to set processing. Because all other behavior is inherited from the\nbuilt-in list superclass, this makes for a shorter and simpler alternative:\nclass Set(list):\ndef __init__(self, value = []):\nlist.__init__([])\nself.concat(value)",
    "# Constructor\n# Customizes list\n# Copies mutable defaults\n\ndef intersect(self, other):\nres = []\nfor x in self:\nif x in other:\nres.append(x)\nreturn Set(res)\n\n# other is any sequence\n# self is the subject\n\ndef union(self, other):\nres = Set(self)\nres.concat(other)\nreturn res\n\n# other is any sequence\n# Copy me and my list\n\ndef concat(self, value):\nfor x in value:\nif not x in self:\nself.append(x)\n\n# value: list, Set . . .\n# Removes duplicates\n\n# Pick common items\n# Return a new Set\n\ndef __and__(self, other): return self.intersect(other)\ndef __or__(self, other): return self.union(other)\ndef __repr__(self):\nreturn 'Set:' + list.__repr__(self)\nif __name__ == '__main__':\nx = Set([1,3,5,7])\ny = Set([2,1,4,5,6])\nprint(x, y, len(x))\nprint(x.intersect(y), y.union(x))\nprint(x & y, x | y)\nx.reverse(); print(x)\n\n776 | Chapter 31: Advanced Class Topics",
    "def __and__(self, other): return self.intersect(other)\ndef __or__(self, other): return self.union(other)\ndef __repr__(self):\nreturn 'Set:' + list.__repr__(self)\nif __name__ == '__main__':\nx = Set([1,3,5,7])\ny = Set([2,1,4,5,6])\nprint(x, y, len(x))\nprint(x.intersect(y), y.union(x))\nprint(x & y, x | y)\nx.reverse(); print(x)\n\n776 | Chapter 31: Advanced Class Topics\n\n\fHere is the output of the self-test code at the end of this file. Because subclassing core\ntypes is an advanced feature, I’ll omit further details here, but I invite you to trace\nthrough these results in the code to study its behavior:\n% python setsubclass.py\nSet:[1, 3, 5, 7] Set:[2, 1, 4, 5, 6] 4\nSet:[1, 5] Set:[2, 1, 4, 5, 6, 3, 7]\nSet:[1, 5] Set:[1, 3, 5, 7, 2, 4, 6]\nSet:[7, 5, 3, 1]",
    "There are more efficient ways to implement sets with dictionaries in Python, which\nreplace the linear scans in the set implementations shown here with dictionary index\noperations (hashing) and so run much quicker. (For more details, see Programming\nPython.) If you’re interested in sets, also take another look at the set object type we\nexplored in Chapter 5; this type provides extensive set operations as built-in tools. Set\nimplementations are fun to experiment with, but they are no longer strictly required in\nPython today.\nFor another type subclassing example, see the implementation of the bool type in Python 2.3 and later. As mentioned earlier in the book, bool is a subclass of int with two\ninstances (True and False) that behave like the integers 1 and 0 but inherit custom stringrepresentation methods that display their names.",
    "The “New-Style” Class Model\nIn Release 2.2, Python introduced a new flavor of classes, known as “new-style” classes;\nclasses following the original model became known as “classic classes” when compared\nto the new kind. In 3.0 the class story has merged, but it remains split for Python 2.X\nusers:\n• As of Python 3.0, all classes are automatically what we used to call “new-style,”\nwhether they explicitly inherit from object or not. All classes inherit from object,\nwhether implicitly or explicitly, and all objects are instances of object.\n• In Python 2.6 and earlier, classes must inherit from object (or another built-in type)\nto be considered “new-style” and obtain all new-style features.\nBecause all classes are automatically new-style in 3.0, the features of new-style classes\nare simply normal class features. I’ve opted to keep their descriptions in this section\nseparate, however, in deference to users of Python 2.X code—classes in such code",
    "to be considered “new-style” and obtain all new-style features.\nBecause all classes are automatically new-style in 3.0, the features of new-style classes\nare simply normal class features. I’ve opted to keep their descriptions in this section\nseparate, however, in deference to users of Python 2.X code—classes in such code\nacquire new-style features only when they are derived from object.\nIn other words, when Python 3.0 users see descriptions of “new-style” features in this\nsection, they should take them to be descriptions of existing features of their classes.\nFor 2.6 readers, these are a set of optional extensions.\nIn Python 2.6 and earlier, the only syntactic difference for new-style classes is that they\nare derived from either a built-in type, such as list, or a special built-in class known",
    "The “New-Style” Class Model | 777\n\n\fas object. The built-in name object is provided to serve as a superclass for new-style\nclasses if no other built-in type is appropriate to use:\nclass newstyle(object):\n...normal code...",
    "Any class derived from object, or any other built-in type, is automatically treated as a\nnew-style class. As long as a built-in type is somewhere in the superclass tree, the new\nclass is treated as a new-style class. Classes not derived from built-ins such as object\nare considered classic.\nNew-style classes are only slightly different from classic classes, and the ways in which\nthey differ are irrelevant to the vast majority of Python users. Moreover, the classic class\nmodel still available in 2.6 works exactly as it has for almost two decades.\nIn fact, new-style classes are almost completely backward compatible with classic\nclasses in syntax and behavior; they mostly just add a few advanced new features.\nHowever, because they modify a handful of class behaviors, they had to be introduced\nas a distinct tool so as to avoid impacting any existing code that depends on the prior\nbehaviors. For example, some subtle differences, such as diamond pattern inheritance",
    "classes in syntax and behavior; they mostly just add a few advanced new features.\nHowever, because they modify a handful of class behaviors, they had to be introduced\nas a distinct tool so as to avoid impacting any existing code that depends on the prior\nbehaviors. For example, some subtle differences, such as diamond pattern inheritance\nsearch and the behavior of built-in operations with managed attribute methods such\nas __getattr__, can cause some legacy code to fail if left unchanged.\nThe next two sections provide overviews of the ways the new-style classes differ and\nthe new tools they provide. Again, because all classes are new-style today, these topics\nrepresent changes to Python 2.X readers but simply additional advanced class topics\nto Python 3.0 readers.",
    "New-Style Class Changes\nNew-style classes differ from classic classes in a number of ways, some of which are\nsubtle but can impact existing 2.X code and coding styles. Here are some of the most\nprominent ways they differ:\nClasses and types merged\nClasses are now types, and types are now classes. In fact, the two are essentially\nsynonyms. The type(I) built-in returns the class an instance is made from, instead\nof a generic instance type, and is normally the same as I.__class__. Moreover,\nclasses are instances of the type class, type may be subclassed to customize class\ncreation, and all classes (and hence types) inherit from object.\nInheritance search order\nDiamond patterns of multiple inheritance have a slightly different search order—\nroughly, they are searched across before up, and more breadth-first than depthfirst.\n\n778 | Chapter 31: Advanced Class Topics",
    "778 | Chapter 31: Advanced Class Topics\n\n\fAttribute fetch for built-ins\nThe __getattr__ and __getattribute__ methods are no longer run for attributes\nimplicitly fetched by built-in operations. This means that they are not called for\n__X__ operator overloading method names—the search for such names begins at\nclasses, not instances.\nNew advanced tools\nNew-style classes have a set of new class tools, including slots, properties, descriptors, and the __getattribute__ method. Most of these have very specific toolbuilding purposes.\nWe discussed the third of these changes briefly in a sidebar in Chapter 27, and we’ll\nrevisit it in depth in the contexts of attribute management in Chapter 37 and privacy\ndecorators in Chapter 38. Because the first and second of the changes just listed can\nbreak existing 2.X code, though, let’s explore these in more detail before moving on to\nnew-style additions.",
    "Type Model Changes\nIn new-style classes, the distinction between type and class has vanished entirely.\nClasses themselves are types: the type object generates classes as its instances, and\nclasses generate instances of their type. If fact, there is no real difference between builtin types like lists and strings and user-defined types coded as classes. This is why we\ncan subclass built-in types, as shown earlier in this chapter—because subclassing a\nbuilt-in type such as list qualifies a class as new-style, it becomes a user-defined type.\nBesides allowing us to subclass built-in types, one of the contexts where this becomes\nmost obvious is when we do explicit type testing. With Python 2.6’s classic classes, the\ntype of a class instance is a generic “instance,” but the types of built-in objects are more\nspecific:\nC:\\misc> c:\\python26\\python\n>>> class C: pass\n...\n>>> I = C()\n>>> type(I)\n<type 'instance'>\n>>> I.__class__\n<class __main__.C at 0x025085A0>",
    "# Classic classes in 2.6\n# Instances are made from classes\n\n>>> type(C)\n# But classes are not the same as types\n<type 'classobj'>\n>>> C.__class__\nAttributeError: class C has no attribute '__class__'\n>>> type([1, 2, 3])\n<type 'list'>\n>>> type(list)\n<type 'type'>\n\nNew-Style Class Changes | 779\n\n\f>>> list.__class__\n<type 'type'>\n\nBut with new-style classes in 2.6, the type of a class instance is the class it’s created\nfrom, since classes are simply user-defined types—the type of an instance is its class,\nand the type of a user-defined class is the same as the type of a built-in object type.\nClasses have a __class__ attribute now, too, because they are instances of type:\nC:\\misc> c:\\python26\\python\n>>> class C(object): pass\n...\n>>> I = C()\n>>> type(I)\n<class '__main__.C'>\n>>> I.__class__\n<class '__main__.C'>\n\n# New-style classes in 2.6\n# Type of instance is class it's made from\n\n>>> type(C)\n<type 'type'>\n>>> C.__class__\n<type 'type'>\n\n# Classes are user-defined types",
    "# New-style classes in 2.6\n# Type of instance is class it's made from\n\n>>> type(C)\n<type 'type'>\n>>> C.__class__\n<type 'type'>\n\n# Classes are user-defined types\n\n>>> type([1, 2, 3])\n<type 'list'>\n>>> type(list)\n<type 'type'>\n>>> list.__class__\n<type 'type'>\n\n# Built-in types work the same way\n\nThe same is true for all classes in Python 3.0, since all classes are automatically newstyle, even if they have no explicit superclasses. In fact, the distinction between builtin types and user-defined class types melts away altogether in 3.0:\nC:\\misc> c:\\python30\\python\n>>> class C: pass\n...\n>>> I = C()\n>>> type(I)\n<class '__main__.C'>\n>>> I.__class__\n<class '__main__.C'>\n\n# All classes are new-style in 3.0\n# Type of instance is class it's made from\n\n>>> type(C)\n<class 'type'>\n>>> C.__class__\n<class 'type'>\n\n# Class is a type, and type is a class\n\n>>> type([1, 2, 3])\n<class 'list'>\n>>> type(list)\n<class 'type'>\n>>> list.__class__\n<class 'type'>\n\n# Classes and built-in types work the same",
    "# All classes are new-style in 3.0\n# Type of instance is class it's made from\n\n>>> type(C)\n<class 'type'>\n>>> C.__class__\n<class 'type'>\n\n# Class is a type, and type is a class\n\n>>> type([1, 2, 3])\n<class 'list'>\n>>> type(list)\n<class 'type'>\n>>> list.__class__\n<class 'type'>\n\n# Classes and built-in types work the same\n\n780 | Chapter 31: Advanced Class Topics\n\n\fAs you can see, in 3.0 classes are types, but types are also classes. Technically, each\nclass is generated by a metaclass—a class that is normally either type itself, or a subclass\nof it customized to augment or manage generated classes. Besides impacting code that\ndoes type testing, this turns out to be an important hook for tool developers. We’ll talk\nmore about metaclasses later in this chapter, and again in more detail in Chapter 39.",
    "Implications for type testing\nBesides providing for built-in type customization and metaclass hooks, the merging of\nclasses and types in the new-style class model can impact code that does type testing.\nIn Python 3.0, for example, the types of class instances compare directly and meaningfully, and in the same way as built-in type objects. This follows from the fact that\nclasses are now types, and an instance’s type is the instance’s class:\nC:\\misc> c:\\python30\\python\n>>> class C: pass\n...\n>>> class D: pass\n...\n>>> c = C()\n>>> d = D()\n>>> type(c) == type(d)\nFalse\n\n# 3.0: compares the instances' classes\n\n>>> type(c), type(d)\n(<class '__main__.C'>, <class '__main__.D'>)\n>>> c.__class__, d.__class__\n(<class '__main__.C'>, <class '__main__.D'>)\n>>> c1, c2 = C(), C()\n>>> type(c1) == type(c2)\nTrue",
    "# 3.0: compares the instances' classes\n\n>>> type(c), type(d)\n(<class '__main__.C'>, <class '__main__.D'>)\n>>> c.__class__, d.__class__\n(<class '__main__.C'>, <class '__main__.D'>)\n>>> c1, c2 = C(), C()\n>>> type(c1) == type(c2)\nTrue\n\nWith classic classes in 2.6 and earlier, though, comparing instance types is almost useless, because all instances have the same “instance” type. To truly compare types, the\ninstance __class__ attributes must be compared (if you care about portability, this\nworks in 3.0, too, but it’s not required there):\nC:\\misc> c:\\python26\\python\n>>> class C: pass\n...\n>>> class D: pass\n...\n>>> c = C()\n>>> d = D()\n>>> type(c) == type(d)\nTrue\n>>> c.__class__ == d.__class__\nFalse\n\n# 2.6: all instances are same type\n# Must compare classes explicitly\n\n>>> type(c), type(d)\n(<type 'instance'>, <type 'instance'>)\n\nNew-Style Class Changes | 781\n\n\f>>> c.__class__, d.__class__\n(<class __main__.C at 0x024585A0>, <class __main__.D at 0x024588D0>)",
    "# 2.6: all instances are same type\n# Must compare classes explicitly\n\n>>> type(c), type(d)\n(<type 'instance'>, <type 'instance'>)\n\nNew-Style Class Changes | 781\n\n\f>>> c.__class__, d.__class__\n(<class __main__.C at 0x024585A0>, <class __main__.D at 0x024588D0>)\n\nAnd as you should expect by now, new-style classes in 2.6 work the same as all classes\nin 3.0 in this regard—comparing instance types compares the instances’ classes\nautomatically:\nC:\\misc> c:\\python26\\python\n>>> class C(object): pass\n...\n>>> class D(object): pass\n...\n>>> c = C()\n>>> d = D()\n>>> type(c) == type(d)\nFalse\n\n# 2.6 new-style: same as all in 3.0\n\n>>> type(c), type(d)\n(<class '__main__.C'>, <class '__main__.D'>)\n>>> c.__class__, d.__class__\n(<class '__main__.C'>, <class '__main__.D'>)",
    "# 2.6 new-style: same as all in 3.0\n\n>>> type(c), type(d)\n(<class '__main__.C'>, <class '__main__.D'>)\n>>> c.__class__, d.__class__\n(<class '__main__.C'>, <class '__main__.D'>)\n\nOf course, as I’ve pointed out numerous times in this book, type checking is usually\nthe wrong thing to do in Python programs (we code to object interfaces, not object\ntypes), and the more general isinstance built-in is more likely what you’ll want to use\nin the rare cases where instance class types must be queried. However, knowledge of\nPython’s type model can help demystify the class model in general.",
    "All objects derive from “object”\nOne other ramification of the type change in the new-style class model is that because\nall classes derive (inherit) from the class object either implicitly or explicitly, and because all types are now classes, every object derives from the object built-in class,\nwhether directly or through a superclass. Consider the following interaction in Python\n3.0 (code an explicit object superclass in 2.6 to make this work equivalently):\n>>> class C: pass\n...\n>>> X = C()\n>>> type(X)\n<class '__main__.C'>\n>>> type(C)\n<class 'type'>\n\n# Type is now class instance was created from\n\nAs before, the type of a class instance is the class it was made from, and the type of a\nclass is the type class because classes and types have merged. It is also true, though,\nthat the instance and class are both derived from the built-in object class, since this is\nan implicit or explicit superclass of every class:\n\n782 | Chapter 31: Advanced Class Topics",
    "As before, the type of a class instance is the class it was made from, and the type of a\nclass is the type class because classes and types have merged. It is also true, though,\nthat the instance and class are both derived from the built-in object class, since this is\nan implicit or explicit superclass of every class:\n\n782 | Chapter 31: Advanced Class Topics\n\n\f>>> isinstance(X, object)\nTrue\n>>> isinstance(C, object)\nTrue\n\n# Classes always inherit from object\n\nThe same holds true for built-in types like lists and strings, because types are classes in\nthe new-style model—built-in types are now classes, and their instances derive from\nobject, too:\n>>> type('spam')\n<class 'str'>\n>>> type(str)\n<class 'type'>\n>>> isinstance('spam', object)\nTrue\n>>> isinstance(str, object)\nTrue\n\n# Same for built-in types (classes)",
    "# Classes always inherit from object\n\nThe same holds true for built-in types like lists and strings, because types are classes in\nthe new-style model—built-in types are now classes, and their instances derive from\nobject, too:\n>>> type('spam')\n<class 'str'>\n>>> type(str)\n<class 'type'>\n>>> isinstance('spam', object)\nTrue\n>>> isinstance(str, object)\nTrue\n\n# Same for built-in types (classes)\n\nIn fact, type itself derives from object, and object derives from type, even though the\ntwo are different objects—a circular relationship that caps the object model and stems\nfrom the fact that types are classes that generate classes:\n>>> type(type)\n<class 'type'>\n>>> type(object)\n<class 'type'>\n\n# All classes are types, and vice versa\n\n>>> isinstance(type, object)\nTrue\n>>> isinstance(object, type)\nTrue\n>>> type is object\nFalse\n\n# All classes derive from object, even type\n# Types make classes, and type is a class",
    "# All classes are types, and vice versa\n\n>>> isinstance(type, object)\nTrue\n>>> isinstance(object, type)\nTrue\n>>> type is object\nFalse\n\n# All classes derive from object, even type\n# Types make classes, and type is a class\n\nIn practical terms, this model makes for fewer special cases than the prior type/class\ndistinction of classic classes, and it allows us to write code that assumes and uses an\nobject superclass. We’ll see examples of the latter later in the book; for now, let’s move\non to explore other new-style changes.",
    "Diamond Inheritance Change\nOne of the most visible changes in new-style classes is their slightly different inheritance\nsearch procedures for the so-called diamond pattern of multiple inheritance trees, where\nmore than one superclass leads to the same higher superclass further above. The diamond pattern is an advanced design concept, is coded only rarely in Python practice,\nand has not been discussed in this book, so we won’t dwell on this topic in depth.\nIn short, though, with classic classes, the inheritance search procedure is strictly depth\nfirst, and then left to right—Python climbs all the way to the top, hugging the left side\nof the tree, before it backs up and begins to look further to the right. In new-style classes,\nthe search is more breadth-first in such cases—Python first looks in any superclasses\nNew-Style Class Changes | 783",
    "to the right of the first one searched before ascending all the way to the common\nsuperclass at the top. In other words, the search proceeds across by levels before moving\nup. The search algorithm is a bit more complex than this, but this is as much as most\nprogrammers need to know.\nBecause of this change, lower superclasses can overload attributes of higher superclasses, regardless of the sort of multiple inheritance trees they are mixed into. Moreover, the new-style search rule avoids visiting the same superclass more than once when\nit is accessible from multiple subclasses.\n\nDiamond inheritance example\nTo illustrate, consider this simplistic incarnation of the diamond multiple inheritance\npattern for classic classes. Here, D’s superclasses B and C both lead to the same common\nancestor, A:\n>>> class A:\nattr = 1\n>>> class B(A):\npass\n\n# Classic (Python 2.6)\n# B and C both lead to A\n\n>>> class C(A):\nattr = 2\n>>> class D(B, C):\npass\n>>> x = D()\n>>> x.attr\n1",
    "Diamond inheritance example\nTo illustrate, consider this simplistic incarnation of the diamond multiple inheritance\npattern for classic classes. Here, D’s superclasses B and C both lead to the same common\nancestor, A:\n>>> class A:\nattr = 1\n>>> class B(A):\npass\n\n# Classic (Python 2.6)\n# B and C both lead to A\n\n>>> class C(A):\nattr = 2\n>>> class D(B, C):\npass\n>>> x = D()\n>>> x.attr\n1\n\n# Tries A before C\n# Searches x, D, B, A\n\nThe attribute here is found in superclass A, because with classic classes, the inheritance\nsearch climbs as high as it can before backing up and moving right—Python will search\nD, B, A, and then C, but will stop when attr is found in A, above B.\nHowever, with new-style classes derived from a built-in like object, and all classes in\n3.0, the search order is different: Python looks in C (to the right of B) before A (above\nB). That is, it searches D, B, C, and then A, and in this case, stops in C:\n>>> class A(object):\nattr = 1",
    "# New-style (\"object\" not required in 3.0)\n\n>>> class B(A):\npass\n>>> class C(A):\nattr = 2\n>>> class D(B, C):\npass\n\n# Tries C before A\n\n>>> x = D()\n\n784 | Chapter 31: Advanced Class Topics\n\n\f>>> x.attr\n2\n\n# Searches x, D, B, C\n\nThis change in the inheritance search procedure is based upon the assumption that if\nyou mix in C lower in the tree, you probably intend to grab its attributes in preference\nto A’s. It also assumes that C is always intended to override A’s attributes in all contexts,\nwhich is probably true when it’s used standalone but may not be when it’s mixed into\na diamond with classic classes—you might not even know that C may be mixed in like\nthis when you code it.\nSince it is most likely that the programmer meant that C should override A in this case,\nthough, new-style classes visit C first. Otherwise, C could be essentially pointless in a\ndiamond context: it could not customize A and would be used only for names unique\nto C.",
    "Explicit conflict resolution\nOf course, the problem with assumptions is that they assume things. If this search order\ndeviation seems too subtle to remember, or if you want more control over the search\nprocess, you can always force the selection of an attribute from anywhere in the tree\nby assigning or otherwise naming the one you want at the place where the classes are\nmixed together:\n>>> class A:\nattr = 1\n\n# Classic\n\n>>> class B(A):\npass\n>>> class C(A):\nattr = 2\n>>> class D(B, C):\nattr = C.attr\n>>> x = D()\n>>> x.attr\n2\n\n# Choose C, to the right\n# Works like new-style (all 3.0)\n\nHere, a tree of classic classes is emulating the search order of new-style classes: the\nassignment to the attribute in D picks the version in C, thereby subverting the normal\ninheritance search path (D.attr will be lowest in the tree). New-style classes can similarly emulate classic classes by choosing the attribute above at the place where the\nclasses are mixed together:\n>>> class A(object):\nattr = 1",
    "# New-style\n\n>>> class B(A):\npass\n>>> class C(A):\n\nNew-Style Class Changes | 785\n\n\fattr = 2\n>>> class D(B, C):\nattr = B.attr\n>>> x = D()\n>>> x.attr\n1\n\n# Choose A.attr, above\n# Works like classic (default 2.6)\n\nIf you are willing to always resolve conflicts like this, you can largely ignore the search\norder difference and not rely on assumptions about what you meant when you coded\nyour classes.\nNaturally, attributes picked this way can also be method functions—methods are normal, assignable objects:\n>>> class A:\ndef meth(s): print('A.meth')\n>>> class C(A):\ndef meth(s): print('C.meth')\n>>> class B(A):\npass\n>>> class D(B, C): pass\n>>> x = D()\n>>> x.meth()\nA.meth\n\n# Use default search order\n# Will vary per class type\n# Defaults to classic order in 2.6\n\n>>> class D(B, C): meth = C.meth\n>>> x = D()\n>>> x.meth()\nC.meth\n\n# Pick C's method: new-style (and 3.0)\n\n>>> class D(B, C): meth = B.meth\n>>> x = D()\n>>> x.meth()\nA.meth\n\n# Pick B's method: classic",
    "# Use default search order\n# Will vary per class type\n# Defaults to classic order in 2.6\n\n>>> class D(B, C): meth = C.meth\n>>> x = D()\n>>> x.meth()\nC.meth\n\n# Pick C's method: new-style (and 3.0)\n\n>>> class D(B, C): meth = B.meth\n>>> x = D()\n>>> x.meth()\nA.meth\n\n# Pick B's method: classic\n\nHere, we select methods by explicitly assigning to names lower in the tree. We might\nalso simply call the desired class explicitly; in practice, this pattern might be more\ncommon, especially for things like constructors:\nclass D(B, C):\ndef meth(self):\n...\nC.meth(self)\n\n# Redefine lower\n# Pick C's method by calling\n\nSuch selections by assignment or call at mix-in points can effectively insulate your code\nfrom this difference in class flavors. Explicitly resolving the conflicts this way ensures\nthat your code won’t vary per Python version in the future (apart from perhaps needing\nto derive classes from object or a built-in type for the new-style tools in 2.6).\n\n786 | Chapter 31: Advanced Class Topics",
    "Even without the classic/new-style class divergence, the explicit method\nresolution technique shown here may come in handy in multiple inheritance scenarios in general. For instance, if you want part of a superclass\non the left and part of a superclass on the right, you might need to tell\nPython which same-named attributes to choose by using explicit assignments in subclasses. We’ll revisit this notion in a “gotcha” at the\nend of this chapter.\nAlso note that diamond inheritance patterns might be more problematic\nin some cases than I’ve implied here (e.g., what if B and C both have\nrequired constructors that call to the constructor in A?). Since such contexts are rare in real-world Python, we’ll leave this topic outside this\nbook’s scope (but see the super built-in function for hints—besides\nproviding generic access to superclasses in single inheritance trees,\nsuper supports a cooperative mode for resolving some conflicts in multiple inheritance trees).",
    "Scope of search order change\nIn sum, by default, the diamond pattern is searched differently for classic and new-style\nclasses, and this is a nonbackward-compatible change. Keep in mind, though, that this\nchange primarily affects diamond pattern cases of multiple inheritance; new-style class\ninheritance works unchanged for most other inheritance tree structures. Further, it’s\nnot impossible that this entire issue may be of more theoretical than practical\nimportance—because the new-style search wasn’t significant enough to address until\nPython 2.2 and didn’t become standard until 3.0, it seems unlikely to impact much\nPython code.\nHaving said that, I should also note that even though you might not code diamond\npatterns in classes you write yourself, because the implied object superclass is above\nevery class in 3.0, every case of multiple inheritance exhibits the diamond pattern today.\nThat is, in new-style classes, object automatically plays the role that the class A does in",
    "Python code.\nHaving said that, I should also note that even though you might not code diamond\npatterns in classes you write yourself, because the implied object superclass is above\nevery class in 3.0, every case of multiple inheritance exhibits the diamond pattern today.\nThat is, in new-style classes, object automatically plays the role that the class A does in\nthe example we just considered. Hence the new-style search rule not only modifies\nlogical semantics, but also optimizes performance by avoiding visiting the same class\nmore than once.\nJust as important, the implied object superclass in the new-style model provides default\nmethods for a variety of built-in operations, including the __str__ and __repr__ display\nformat methods. Run a dir(object) to see which methods are provided. Without the\nnew-style search order, in multiple inheritance cases the defaults in object would always override redefinitions in user-coded classes, unless they were always made in the",
    "methods for a variety of built-in operations, including the __str__ and __repr__ display\nformat methods. Run a dir(object) to see which methods are provided. Without the\nnew-style search order, in multiple inheritance cases the defaults in object would always override redefinitions in user-coded classes, unless they were always made in the\nleftmost superclass. In other words, the new-style class model itself makes using the\nnew-style search order more critical!\nFor a more visual example of the implied object superclass in 3.0, and other examples\nof diamond patterns created by it, see the ListTree class’s output in the lister.py example\nin the preceding chapter, as well as the classtree.py tree walker example in Chapter 28.",
    "New-Style Class Changes | 787\n\n\fNew-Style Class Extensions\nBeyond the changes described in the prior section (which, frankly, may be too academic\nand obscure to matter to many readers of this book), new-style classes provide a handful\nof more advanced class tools that have more direct and practical application. The following sections provide an overview of each of these additional features, available for\nnew-style class in Python 2.6 and all classes in Python 3.0.",
    "Instance Slots\nBy assigning a sequence of string attribute names to a special __slots__ class attribute,\nit is possible for a new-style class to both limit the set of legal attributes that instances\nof the class will have and optimize memory and speed performance.\nThis special attribute is typically set by assigning a sequence of string names to the\nvariable __slots__ at the top level of a class statement: only those names in the\n__slots__ list can be assigned as instance attributes. However, like all names in Python,\ninstance attribute names must still be assigned before they can be referenced, even if\nthey’re listed in __slots__. For example:\n>>> class limiter(object):\n...\n__slots__ = ['age', 'name', 'job']\n...\n>>> x = limiter()\n>>> x.age\nAttributeError: age\n\n# Must assign before use\n\n>>> x.age = 40\n>>> x.age\n40\n>>> x.ape = 1000\n# Illegal: not in __slots__\nAttributeError: 'limiter' object has no attribute 'ape'",
    "# Must assign before use\n\n>>> x.age = 40\n>>> x.age\n40\n>>> x.ape = 1000\n# Illegal: not in __slots__\nAttributeError: 'limiter' object has no attribute 'ape'\n\nSlots are something of a break with Python’s dynamic nature, which dictates that any\nname may be created by assignment. However, this feature is envisioned as both a way\nto catch “typo” errors like this (assignments to illegal attribute names not in\n__slots__ are detected), as well as an optimization mechanism. Allocating a namespace\ndictionary for every instance object can become expensive in terms of memory if many\ninstances are created and only a few attributes are required. To save space and speed\nexecution (to a degree that can vary per program), instead of allocating a dictionary for\neach instance, slot attributes are stored sequentially for quicker lookup.",
    "Slots and generic code\nIn fact, some instances with slots may not have a __dict__ attribute dictionary at all,\nwhich can make some metaprograms more complex (including some coded in this\nbook). Tools that generically list attributes or access attributes by string name, for\nexample, must be careful to use more storage-neutral tools than __dict__, such as the\n\n788 | Chapter 31: Advanced Class Topics\n\n\fgetattr, setattr, and dir built-in functions, which apply to attributes based on either\n__dict__ or __slots__ storage. In some cases, both attribute sources may need to be",
    "getattr, setattr, and dir built-in functions, which apply to attributes based on either\n__dict__ or __slots__ storage. In some cases, both attribute sources may need to be\n\nqueried for completeness.\nFor example, when slots are used, instances do not normally have an attribute dictionary—Python uses the class descriptors feature covered in Chapter 37 to allocate\nspace for slot attributes in the instance instead. Only names in the slots list can be\nassigned to instances, but slot-based attributes can still be fetched and set by name\nusing generic tools. In Python 3.0 (and in 2.6 for classes derived from object):\n>>> class C:\n...\n__slots__ = ['a', 'b']\n# __slots__ means no __dict__ by default\n...\n>>> X = C()\n>>> X.a = 1\n>>> X.a\n1\n>>> X.__dict__\nAttributeError: 'C' object has no attribute '__dict__'\n>>> getattr(X, 'a')\n1\n>>> setattr(X, 'b', 2)\n# But getattr() and setattr() still work\n>>> X.b\n2\n>>> 'a' in dir(X)\n# And dir() finds slot attributes too\nTrue\n>>> 'b' in dir(X)\nTrue",
    "Without an attribute namespaces dictionary, it’s not possible to assign new names to\ninstances that are not names in the slots list:\n>>> class D:\n...\n__slots__ = ['a', 'b']\n...\ndef __init__(self): self.d = 4\n# Cannot add new names if no __dict__\n...\n>>> X = D()\nAttributeError: 'D' object has no attribute 'd'\n\nHowever, extra attributes can still be accommodated by including __dict__ in\n__slots__, in order to allow for an attribute namespace dictionary. In this case, both\nstorage mechanisms are used, but generic tools such as getattr allow us to treat them\nas a single set of attributes:\n>>> class D:\n...\n__slots__ = ['a', 'b', '__dict__']\n# List __dict__ to include one too\n...\nc = 3\n# Class attrs work normally\n...\ndef __init__(self): self.d = 4\n# d put in __dict__, a in __slots__\n...\n>>> X = D()\n>>> X.d\n4\n>>> X.__dict__\n# Some objects have both __dict__ and __slots__\n{'d': 4}\n# getattr() can fetch either type of attr\n\nNew-Style Class Extensions | 789",
    "New-Style Class Extensions | 789\n\n\f>>> X.__slots__\n['a', 'b', '__dict__']\n>>> X.c\n3\n>>> X.a\n# All instance attrs undefined until assigned\nAttributeError: a\n>>> X.a = 1\n>>> getattr(X, 'a',), getattr(X, 'c'), getattr(X, 'd')\n(1, 3, 4)\n\nCode that wishes to list all instance attributes generically, though, may still need to\nallow for both storage forms, since dir also returns inherited attributes (this relies on\ndictionary iterators to collect keys):\n>>> for attr in list(X.__dict__) + X.__slots__:\n...\nprint(attr, '=>', getattr(X, attr))\nd => 4\na => 1\nb => 2\n__dict__ => {'d': 4}\n\nSince either can be omitted, this is more correctly coded as follows (getattr allows for\ndefaults):\n>>> for attr in list(getattr(X, '__dict__', [])) + getattr(X, '__slots__', []):\n...\nprint(attr, '=>', getattr(X, attr))\nd => 4\na => 1\nb => 2\n__dict__ => {'d': 4}",
    "Multiple __slot__ lists in superclasses\nNote, however, that this code addresses only slot names in the lowest __slots__ attribute inherited by an instance. If multiple classes in a class tree have their own\n__slots__ attributes, generic programs must develop other policies for listing attributes\n(e.g., classifying slot names as attributes of classes, not instances).\nSlot declarations can appear in multiple classes in a class tree, but they are subject to a\nnumber of constraints that are somewhat difficult to rationalize unless you understand\nthe implementation of slots as class-level descriptors (a tool we’ll study in detail in the\nlast part of this book):\n• If a subclass inherits from a superclass without a __slots__, the __dict__ attribute\nof the superclass will always be accessible, making a __slots__ in the subclass\nmeaningless.\n• If a class defines the same slot name as a superclass, the version of the name defined",
    "the implementation of slots as class-level descriptors (a tool we’ll study in detail in the\nlast part of this book):\n• If a subclass inherits from a superclass without a __slots__, the __dict__ attribute\nof the superclass will always be accessible, making a __slots__ in the subclass\nmeaningless.\n• If a class defines the same slot name as a superclass, the version of the name defined\nby the superclass slot will be accessible only by fetching its descriptor directly from\nthe superclass.",
    "790 | Chapter 31: Advanced Class Topics\n\n\f• Because the meaning of a __slots__ declaration is limited to the class in which it\nappears, subclasses will have a __dict__ unless they also define a __slots__.\nIn terms of listing instance attributes generically, slots in multiple classes might require\nmanual class tree climbs, dir usage, or a policy that treats slot names as a different\ncategory of names altogether:\n>>> class E:\n...\n__slots__ = ['c', 'd']\n...\n>>> class D(E):\n...\n__slots__ = ['a', '__dict__']\n...\n>>> X = D()\n>>> X.a = 1; X.b = 2; X.c = 3\n>>> X.a, X.c\n(1, 3)\n>>> E.__slots__\n['c', 'd']\n>>> D.__slots__\n['a', '__dict__']\n>>> X.__slots__\n['a', '__dict__']\n>>> X.__dict__\n{'b': 2}\n\n# Superclass has slots\n# So does its subclass\n# The instance is the union\n\n# But slots are not concatenated\n\n# Instance inherits *lowest* __slots__\n# And has its own an attr dict",
    "# Superclass has slots\n# So does its subclass\n# The instance is the union\n\n# But slots are not concatenated\n\n# Instance inherits *lowest* __slots__\n# And has its own an attr dict\n\n>>> for attr in list(getattr(X, '__dict__', [])) + getattr(X, '__slots__', []):\n...\nprint(attr, '=>', getattr(X, attr))\n...\nb => 2\n# Superclass slots missed!\na => 1\n__dict__ => {'b': 2}\n>>> dir(X)\n# dir() includes all slot names\n[...many names omitted... 'a', 'b', 'c', 'd']",
    "When such generality is possible, slots are probably best treated as class attributes,\nrather than trying to mold them to appear the same as normal instance attributes. For\nmore on slots in general, see the Python standard manual set. Also watch for an example\nthat allows for attributes based on both __slots__ and __dict__ storage in the\nPrivate decorator discussion of Chapter 38.\nFor a prime example of why generic programs may need to care about slots, see the\nlister.py display mix-in classes example in the multiple inheritance section of the prior\nchapter; a note there describes the example’s slot concerns. In such a tool that attempts\nto list attributes generically, slot usage requires either extra code or the implementation\nof policies regarding the handling of slot-based attributes in general.\n\nNew-Style Class Extensions | 791",
    "Class Properties\nA mechanism known as properties provides another way for new-style classes to define\nautomatically called methods for access or assignment to instance attributes. At least\nfor specific attributes, this feature is an alternative to many current uses of the\n__getattr__ and __setattr__ overloading methods we studied in Chapter 29. Properties have a similar effect to these two methods, but they incur an extra method call for\nany accesses to names that require dynamic computation. Properties (and slots) are\nbased on a new notion of attribute descriptors, which is too advanced for us to cover\nhere.\nIn short, a property is a type of object assigned to a class attribute name. A property is\ngenerated by calling the property built-in with three methods (handlers for get, set, and\ndelete operations), as well as a docstring; if any argument is passed as None or omitted,\nthat operation is not supported. Properties are typically assigned at the top level of a",
    "here.\nIn short, a property is a type of object assigned to a class attribute name. A property is\ngenerated by calling the property built-in with three methods (handlers for get, set, and\ndelete operations), as well as a docstring; if any argument is passed as None or omitted,\nthat operation is not supported. Properties are typically assigned at the top level of a\nclass statement [e.g., name = property(...)]. When thus assigned, accesses to the class\nattribute itself (e.g., obj.name) are automatically routed to one of the accessor methods\npassed into the property. For example, the __getattr__ method allows classes to intercept undefined attribute references:\n>>> class classic:\n...\ndef __getattr__(self, name):\n...\nif name == 'age':\n...\nreturn 40\n...\nelse:\n...\nraise AttributeError\n...\n>>> x = classic()\n>>> x.age\n40\n>>> x.name\nAttributeError",
    "# Runs __getattr__\n# Runs __getattr__\n\nHere is the same example, coded with properties instead (note that properties are\navailable for all classes but require the new-style object derivation in 2.6 to work properly for intercepting attribute assignments):\n>>> class newprops(object):\n...\ndef getage(self):\n...\nreturn 40\n...\nage = property(getage, None, None, None) # get, set, del, docs\n...\n>>> x = newprops()\n>>> x.age\n# Runs getage\n40\n>>> x.name\n# Normal fetch\nAttributeError: newprops instance has no attribute 'name'\n\n792 | Chapter 31: Advanced Class Topics",
    "792 | Chapter 31: Advanced Class Topics\n\n\fFor some coding tasks, properties can be less complex and quicker to run than the\ntraditional techniques. For example, when we add attribute assignment support,\nproperties become more attractive—there’s less code to type, and no extra method calls\nare incurred for assignments to attributes we don’t wish to compute dynamically:\n>>> class newprops(object):\n...\ndef getage(self):\n...\nreturn 40\n...\ndef setage(self, value):\n...\nprint('set age:', value)\n...\nself._age = value\n...\nage = property(getage, setage, None, None)\n...\n>>> x = newprops()\n>>> x.age\n# Runs getage\n40\n>>> x.age = 42\n# Runs setage\nset age: 42\n>>> x._age\n# Normal fetch; no getage call\n42\n>>> x.job = 'trainer'\n# Normal assign; no setage call\n>>> x.job\n# Normal fetch; no getage call\n'trainer'",
    "The equivalent classic class incurs extra method calls for assignments to attributes not\nbeing managed and needs to route attribute assignments through the attribute dictionary (or, for new-style classes, to the object superclass’s __setattr__) to avoid loops:\n>>> class classic:\n...\ndef __getattr__(self, name):\n...\nif name == 'age':\n...\nreturn 40\n...\nelse:\n...\nraise AttributeError\n...\ndef __setattr__(self, name, value):\n...\nprint('set:', name, value)\n...\nif name == 'age':\n...\nself.__dict__['_age'] = value\n...\nelse:\n...\nself.__dict__[name] = value\n...\n>>> x = classic()\n>>> x.age\n40\n>>> x.age = 41\nset: age 41\n>>> x._age\n41\n>>> x.job = 'trainer'\n>>> x.job\n\n# On undefined reference\n\n# On all assignments\n\n# Runs __getattr__\n# Runs __setattr__\n# Defined: no __getattr__ call\n# Runs __setattr__ again\n# Defined: no __getattr__ call\n\nNew-Style Class Extensions | 793",
    "New-Style Class Extensions | 793\n\n\fProperties seem like a win for this simple example. However, some applications of\n__getattr__ and __setattr__ may still require more dynamic or generic interfaces than\nproperties directly provide. For example, in many cases, the set of attributes to be\nsupported cannot be determined when the class is coded, and may not even exist in\nany tangible form (e.g., when delegating arbitrary method references to a wrapped/\nembedded object generically). In such cases, a generic __getattr__ or a __setattr__\nattribute handler with a passed-in attribute name may be preferable. Because such generic handlers can also handle simpler cases, properties are often an optional extension.\nFor more details on both options, stay tuned for Chapter 37 in the final part of this\nbook. As we’ll see there, it’s also possible to code properties using function decorator\nsyntax, a topic introduced later in this chapter.",
    "__getattribute__ and Descriptors\nThe __getattribute__ method, available for new-style classes only, allows a class to\nintercept all attribute references, not just undefined references, like __getattr__. It is\nalso somewhat trickier to use than __getattr__: it is prone to loops, much like\n__setattr__, but in different ways.\nIn addition to properties and operator overloading methods, Python supports the notion of attribute descriptors—classes with __get__ and __set__ methods, assigned to\nclass attributes and inherited by instances, that intercept read and write accesses to\nspecific attributes. Descriptors are in a sense a more general form of properties; in fact,\nproperties are a simplified way to define a specific type of descriptor, one that runs\nfunctions on access. Descriptors are also used to implement the slots feature we met\nearlier.\nBecause properties, __getattribute__, and descriptors are somewhat advanced topics,",
    "specific attributes. Descriptors are in a sense a more general form of properties; in fact,\nproperties are a simplified way to define a specific type of descriptor, one that runs\nfunctions on access. Descriptors are also used to implement the slots feature we met\nearlier.\nBecause properties, __getattribute__, and descriptors are somewhat advanced topics,\nwe’ll defer the rest of their coverage, as well as more on properties, to Chapter 37 in\nthe final part of this book.",
    "Metaclasses\nMost of the changes and feature additions of new-style classes integrate with the notion\nof subclassable types mentioned earlier in this chapter, because subclassable types and\nnew-style classes were introduced in conjunction with a merging of the type/class dichotomy in Python 2.2 and beyond. As we’ve seen, in 3.0, this merging is complete:\nclasses are now types, and types are classes.\nAlong with these changes, Python also grew a more coherent protocol for coding\nmetaclasses, which are classes that subclass the type object and intercept class creation\ncalls. As such, they provide a well-defined hook for management and augmentation of\nclass objects. They are also an advanced topic that is optional for most Python programmers, so we’ll postpone further details here. We’ll meet metaclasses briefly later\n\n794 | Chapter 31: Advanced Class Topics",
    "794 | Chapter 31: Advanced Class Topics\n\n\fin this chapter in conjunction with class decorators, and we’ll explore them in full detail\nin Chapter 39, in the final part of this book.\n\nStatic and Class Methods\nAs of Python 2.2, it is possible to define two kinds of methods within a class that can\nbe called without an instance: static methods work roughly like simple instance-less\nfunctions inside a class, and class methods are passed a class instead of an instance.\nAlthough this feature was added in conjunction with the new-style classes discussed in\nthe prior sections, static and class methods work for classic classes too.\nTo enable these method modes, special built-in functions called staticmethod and\nclassmethod must be called within the class, or invoked with the decoration syntax we’ll\nmeet later in this chapter. In Python 3.0, instance-less methods called only through a\nclass name do not require a staticmethod declaration, but such methods called through\ninstances do.",
    "Why the Special Methods?\nAs we’ve learned, a class method is normally passed an instance object in its first argument, to serve as the implied subject of the method call. Today, though, there are\ntwo ways to modify this model. Before I explain what they are, I should explain why\nthis might matter to you.\nSometimes, programs need to process data associated with classes instead of instances.\nConsider keeping track of the number of instances created from a class, or maintaining\na list of all of a class’s instances that are currently in memory. This type of information\nand its processing are associated with the class rather than its instances. That is, the\ninformation is usually stored on the class itself and processed in the absence of any\ninstance.\nFor such tasks, simple functions coded outside a class can often suffice—because they\ncan access class attributes through the class name, they have access to class data and",
    "and its processing are associated with the class rather than its instances. That is, the\ninformation is usually stored on the class itself and processed in the absence of any\ninstance.\nFor such tasks, simple functions coded outside a class can often suffice—because they\ncan access class attributes through the class name, they have access to class data and\nnever require access to an instance. However, to better associate such code with a class,\nand to allow such processing to be customized with inheritance as usual, it would be\nbetter to code these types of functions inside the class itself. To make this work, we\nneed methods in a class that are not passed, and do not expect, a self instance\nargument.\nPython supports such goals with the notion of static methods—simple functions with\nno self argument that are nested in a class and are designed to work on class attributes\ninstead of instance attributes. Static methods never receive an automatic self argument,",
    "need methods in a class that are not passed, and do not expect, a self instance\nargument.\nPython supports such goals with the notion of static methods—simple functions with\nno self argument that are nested in a class and are designed to work on class attributes\ninstead of instance attributes. Static methods never receive an automatic self argument,\nwhether called through a class or an instance. They usually keep track of information\nthat spans all instances, rather than providing behavior for instances.",
    "Static and Class Methods | 795\n\n\fAlthough less commonly used, Python also supports the notion of class methods—\nmethods of a class that are passed a class object in their first argument instead of an\ninstance, regardless of whether they are called through an instance or a class. Such\nmethods can access class data through their self class argument even if called through\nan instance. Normal methods (now known in formal circles as instance methods) still\nreceive a subject instance when called; static and class methods do not.",
    "Static Methods in 2.6 and 3.0\nThe concept of static methods is the same in both Python 2.6 and 3.0, but its implementation requirements have evolved somewhat in Python 3.0. Since this book covers\nboth versions, I need to explain the differences in the two underlying models before we\nget to the code.\nReally, we already began this story in the preceding chapter, when we explored the\nnotion of unbound methods. Recall that both Python 2.6 and 3.0 always pass an instance to a method that is called through an instance. However, Python 3.0 treats\nmethods fetched directly from a class differently than 2.6:\n• In Python 2.6, fetching a method from a class produces an unbound method, which\ncannot be called without manually passing an instance.\n• In Python 3.0, fetching a method from a class produces a simple function, which\ncan be called normally with no instance present.\nIn other words, Python 2.6 class methods always require an instance to be passed in,",
    "• In Python 2.6, fetching a method from a class produces an unbound method, which\ncannot be called without manually passing an instance.\n• In Python 3.0, fetching a method from a class produces a simple function, which\ncan be called normally with no instance present.\nIn other words, Python 2.6 class methods always require an instance to be passed in,\nwhether they are called through an instance or a class. By contrast, in Python 3.0 we\nare required to pass an instance to a method only if the method expects one—methods\nwithout a self instance argument can be called through the class without passing an\ninstance. That is, 3.0 allows simple functions in a class, as long as they do not expect\nand are not passed an instance argument. The net effect is that:\n• In Python 2.6, we must always declare a method as static in order to call it without\nan instance, whether it is called through a class or an instance.\n• In Python 3.0, we need not declare such methods as static if they will be called",
    "instance. That is, 3.0 allows simple functions in a class, as long as they do not expect\nand are not passed an instance argument. The net effect is that:\n• In Python 2.6, we must always declare a method as static in order to call it without\nan instance, whether it is called through a class or an instance.\n• In Python 3.0, we need not declare such methods as static if they will be called\nthrough a class only, but we must do so in order to call them through an instance.\nTo illustrate, suppose we want to use class attributes to count how many instances are\ngenerated from a class. The following file, spam.py, makes a first attempt—its class has\na counter stored as a class attribute, a constructor that bumps up the counter by one\neach time a new instance is created, and a method that displays the counter’s value.\nRemember, class attributes are shared by all instances. Therefore, storing the counter\nin the class object itself ensures that it effectively spans all instances:\nclass Spam:",
    "a counter stored as a class attribute, a constructor that bumps up the counter by one\neach time a new instance is created, and a method that displays the counter’s value.\nRemember, class attributes are shared by all instances. Therefore, storing the counter\nin the class object itself ensures that it effectively spans all instances:\nclass Spam:\nnumInstances = 0\ndef __init__(self):\nSpam.numInstances = Spam.numInstances + 1",
    "796 | Chapter 31: Advanced Class Topics\n\n\fdef printNumInstances():\nprint(\"Number of instances created: \", Spam.numInstances)\n\nThe printNumInstances method is designed to process class data, not instance data—\nit’s about all the instances, not any one in particular. Because of that, we want to be\nable to call it without having to pass an instance. Indeed, we don’t want to make an\ninstance to fetch the number of instances, because this would change the number of\ninstances we’re trying to fetch! In other words, we want a self-less “static” method.\nWhether this code works or not, though, depends on which Python you use, and which\nway you call the method—through the class or through an instance. In 2.6 (and 2.X in\ngeneral), calls to a self-less method function through both the class and instances fail\n(I’ve omitted some error text here for space):\nC:\\misc> c:\\python26\\python\n>>> from spam import Spam\n>>> a = Spam()\n>>> b = Spam()\n>>> c = Spam()",
    "# Cannot call unbound class methods in 2.6\n# Methods expect a self object by default\n\n>>> Spam.printNumInstances()\nTypeError: unbound method printNumInstances() must be called with Spam instance\nas first argument (got nothing instead)\n>>> a.printNumInstances()\nTypeError: printNumInstances() takes no arguments (1 given)\n\nThe problem here is that unbound instance methods aren’t exactly the same as simple\nfunctions in 2.6. Even though there are no arguments in the def header, the method\nstill expects an instance to be passed in when it’s called, because the function is associated with a class. In Python 3.0 (and later 3.X releases), calls to self-less methods made\nthrough classes work, but calls from instances fail:\nC:\\misc> c:\\python30\\python\n>>> from spam import Spam\n>>> a = Spam()\n>>> b = Spam()\n>>> c = Spam()\n\n# Can call functions in class in 3.0\n# Calls through instances still pass a self",
    "# Can call functions in class in 3.0\n# Calls through instances still pass a self\n\n>>> Spam.printNumInstances()\n# Differs in 3.0\nNumber of instances created: 3\n>>> a.printNumInstances()\nTypeError: printNumInstances() takes no arguments (1 given)\n\nThat is, calls to instance-less methods like printNumInstances made through the class\nfail in Python 2.6 but work in Python 3.0. On the other hand, calls made through an\ninstance fail in both Pythons, because an instance is automatically passed to a method\nthat does not have an argument to receive it:\nSpam.printNumInstances()\ninstance.printNumInstances()\n\n# Fails in 2.6, works in 3.0\n# Fails in both 2.6 and 3.0\n\nIf you’re able to use 3.0 and stick with calling self-less methods through classes only,\nyou already have a static method feature. However, to allow self-less methods to be\n\nStatic and Class Methods | 797",
    "# Fails in 2.6, works in 3.0\n# Fails in both 2.6 and 3.0\n\nIf you’re able to use 3.0 and stick with calling self-less methods through classes only,\nyou already have a static method feature. However, to allow self-less methods to be\n\nStatic and Class Methods | 797\n\n\fcalled through classes in 2.6 and through instances in both 2.6 and 3.0, you need to\neither adopt other designs or be able to somehow mark such methods as special. Let’s\nlook at both options in turn.",
    "Static Method Alternatives\nShort of marking a self-less method as special, there are a few different coding structures\nthat can be tried. If you want to call functions that access class members without an\ninstance, perhaps the simplest idea is to just make them simple functions outside the\nclass, not class methods. This way, an instance isn’t expected in the call. For example,\nthe following mutation of spam.py works the same in Python 3.0 and 2.6 (albeit displaying extra parentheses in 2.6 for its print statement):\ndef printNumInstances():\nprint(\"Number of instances created: \", Spam.numInstances)\nclass Spam:\nnumInstances = 0\ndef __init__(self):\nSpam.numInstances = Spam.numInstances + 1\n>>> import spam\n>>> a = spam.Spam()\n>>> b = spam.Spam()\n>>> c = spam.Spam()\n>>> spam.printNumInstances()\nNumber of instances created:\n>>> spam.Spam.numInstances\n3\n\n3\n\n# But function may be too far removed\n# And cannot be changed via inheritance",
    "Because the class name is accessible to the simple function as a global variable, this\nworks fine. Also, note that the name of the function becomes global, but only to this\nsingle module; it will not clash with names in other files of the program.\nPrior to static methods in Python, this structure was the general prescription. Because\nPython already provides modules as a namespace-partitioning tool, one could argue\nthat there’s not typically any need to package functions in classes unless they implement\nobject behavior. Simple functions within modules like the one here do much of what\ninstance-less class methods could, and are already associated with the class because\nthey live in the same module.\nUnfortunately, this approach is still less than ideal. For one thing, it adds to this file’s\nscope an extra name that is used only for processing a single class. For another, the\nfunction is much less directly associated with the class; in fact, its definition could be",
    "instance-less class methods could, and are already associated with the class because\nthey live in the same module.\nUnfortunately, this approach is still less than ideal. For one thing, it adds to this file’s\nscope an extra name that is used only for processing a single class. For another, the\nfunction is much less directly associated with the class; in fact, its definition could be\nhundreds of lines away. Perhaps worse, simple functions like this cannot be customized\nby inheritance, since they live outside a class’s namespace: subclasses cannot directly\nreplace or extend such a function by redefining it.",
    "798 | Chapter 31: Advanced Class Topics\n\n\fWe might try to make this example work in a version-neutral way by using a normal\nmethod and always calling it through (or with) an instance, as usual:\nclass Spam:\nnumInstances = 0\ndef __init__(self):\nSpam.numInstances = Spam.numInstances + 1\ndef printNumInstances(self):\nprint(\"Number of instances created: \", Spam.numInstances)\n>>> from spam import Spam\n>>> a, b, c = Spam(), Spam(), Spam()\n>>> a.printNumInstances()\nNumber of instances created: 3\n>>> Spam.printNumInstances(a)\nNumber of instances created: 3\n>>> Spam().printNumInstances()\nNumber of instances created: 4\n\n# But fetching counter changes counter!\n\nUnfortunately, as mentioned earlier, such an approach is completely unworkable if we\ndon’t have an instance available, and making an instance changes the class data, as\nillustrated in the last line here. A better solution would be to somehow mark a method\ninside a class as never requiring an instance. The next section shows how.",
    "Unfortunately, as mentioned earlier, such an approach is completely unworkable if we\ndon’t have an instance available, and making an instance changes the class data, as\nillustrated in the last line here. A better solution would be to somehow mark a method\ninside a class as never requiring an instance. The next section shows how.\n\nUsing Static and Class Methods\nToday, there is another option for coding simple functions associated with a class that\nmay be called through either the class or its instances. As of Python 2.2, we can code\nclasses with static and class methods, neither of which requires an instance argument\nto be passed in when invoked. To designate such methods, classes call the built-in\nfunctions staticmethod and classmethod, as hinted in the earlier discussion of new-style\nclasses. Both mark a function object as special—i.e., as requiring no instance if static\nand requiring a class argument if a class method. For example:\nclass Methods:\ndef imeth(self, x):\nprint(self, x)",
    "# Normal instance method: passed a self\n\ndef smeth(x):\nprint(x)\n\n# Static: no instance passed\n\ndef cmeth(cls, x):\nprint(cls, x)\n\n# Class: gets class, not instance\n\nsmeth = staticmethod(smeth)\ncmeth = classmethod(cmeth)\n\n# Make smeth a static method\n# Make cmeth a class method\n\nNotice how the last two assignments in this code simply reassign the method names\nsmeth and cmeth. Attributes are created and changed by any assignment in a class\nstatement, so these final assignments simply overwrite the assignments made earlier by\nthe defs.\n\nStatic and Class Methods | 799",
    "Static and Class Methods | 799\n\n\fTechnically, Python now supports three kinds of class-related methods: instance,\nstatic, and class. Moreover, Python 3.0 extends this model by also allowing simple\nfunctions in a class to serve the role of static methods without extra protocol, when\ncalled through a class.\nInstance methods are the normal (and default) case that we’ve seen in this book. An\ninstance method must always be called with an instance object. When you call it\nthrough an instance, Python passes the instance to the first (leftmost) argument automatically; when you call it through a class, you must pass along the instance manually\n(for simplicity, I’ve omitted some class imports in interactive sessions like this one):\n>>> obj = Methods()\n\n# Make an instance\n\n>>> obj.imeth(1)\n<__main__.Methods object...> 1\n\n# Normal method, call through instance\n# Becomes imeth(obj, 1)\n\n>>> Methods.imeth(obj, 2)\n<__main__.Methods object...> 2",
    "# Make an instance\n\n>>> obj.imeth(1)\n<__main__.Methods object...> 1\n\n# Normal method, call through instance\n# Becomes imeth(obj, 1)\n\n>>> Methods.imeth(obj, 2)\n<__main__.Methods object...> 2\n\n# Normal method, call through class\n# Instance passed explicitly\n\nBy contrast, static methods are called without an instance argument. Unlike simple\nfunctions outside a class, their names are local to the scopes of the classes in which they\nare defined, and they may be looked up by inheritance. Instance-less functions can be\ncalled through a class normally in Python 3.0, but never by default in 2.6. Using the\nstaticmethod built-in allows such methods to also be called through an instance in 3.0\nand through both a class and an instance in Python 2.6 (the first of these works in 3.0\nwithout staticmethod, but the second does not):\n>>> Methods.smeth(3)\n3\n\n# Static method, call through class\n# No instance passed or expected\n\n>>> obj.smeth(4)\n4",
    "# Static method, call through class\n# No instance passed or expected\n\n>>> obj.smeth(4)\n4\n\n# Static method, call through instance\n# Instance not passed\n\nClass methods are similar, but Python automatically passes the class (not an instance)\nin to a class method’s first (leftmost) argument, whether it is called through a class or\nan instance:\n>>> Methods.cmeth(5)\n<class '__main__.Methods'> 5\n\n# Class method, call through class\n# Becomes cmeth(Methods, 5)\n\n>>> obj.cmeth(6)\n<class '__main__.Methods'> 6\n\n# Class method, call through instance\n# Becomes cmeth(Methods, 6)\n\nCounting Instances with Static Methods\nNow, given these built-ins, here is the static method equivalent of this section’s\ninstance-counting example—it marks the method as special, so it will never be passed\nan instance automatically:\n\n800 | Chapter 31: Advanced Class Topics",
    ">>> obj.cmeth(6)\n<class '__main__.Methods'> 6\n\n# Class method, call through instance\n# Becomes cmeth(Methods, 6)\n\nCounting Instances with Static Methods\nNow, given these built-ins, here is the static method equivalent of this section’s\ninstance-counting example—it marks the method as special, so it will never be passed\nan instance automatically:\n\n800 | Chapter 31: Advanced Class Topics\n\n\fclass Spam:\nnumInstances = 0\n# Use static method for class data\ndef __init__(self):\nSpam.numInstances += 1\ndef printNumInstances():\nprint(\"Number of instances:\", Spam.numInstances)\nprintNumInstances = staticmethod(printNumInstances)\n\nUsing the static method built-in, our code now allows the self-less method to be called\nthrough the class or any instance of it, in both Python 2.6 and 3.0:\n>>> a = Spam()\n>>> b = Spam()\n>>> c = Spam()\n>>> Spam.printNumInstances()\nNumber of instances: 3\n>>> a.printNumInstances()\nNumber of instances: 3\n\n# Call as simple function\n# Instance argument not passed",
    "Compared to simply moving printNumInstances outside the class, as prescribed earlier,\nthis version requires an extra staticmethod call; however, it localizes the function name\nin the class scope (so it won’t clash with other names in the module), moves the function\ncode closer to where it is used (inside the class statement), and allows subclasses to\ncustomize the static method with inheritance—a more convenient approach than importing functions from the files in which superclasses are coded. The following subclass\nand new testing session illustrate:\nclass Sub(Spam):\ndef printNumInstances():\n# Override a static method\nprint(\"Extra stuff...\")\n# But call back to original\nSpam.printNumInstances()\nprintNumInstances = staticmethod(printNumInstances)\n>>> a = Sub()\n>>> b = Sub()\n>>> a.printNumInstances()\nExtra stuff...\nNumber of instances: 2\n>>> Sub.printNumInstances()\nExtra stuff...\nNumber of instances: 2\n>>> Spam.printNumInstances()\nNumber of instances: 2",
    "# Call from subclass instance\n# Call from subclass itself\n\nMoreover, classes can inherit the static method without redefining it—it is run without\nan instance, regardless of where it is defined in a class tree:\n>>> class Other(Spam): pass\n\n# Inherit static method verbatim\n\n>>> c = Other()\n>>> c.printNumInstances()\nNumber of instances: 3\n\nStatic and Class Methods | 801\n\n\fCounting Instances with Class Methods\nInterestingly, a class method can do similar work here—the following has the same\nbehavior as the static method version listed earlier, but it uses a class method that\nreceives the instance’s class in its first argument. Rather than hardcoding the class\nname, the class method uses the automatically passed class object generically:\nclass Spam:\nnumInstances = 0\n# Use class method instead of static\ndef __init__(self):\nSpam.numInstances += 1\ndef printNumInstances(cls):\nprint(\"Number of instances:\", cls.numInstances)\nprintNumInstances = classmethod(printNumInstances)",
    "This class is used in the same way as the prior versions, but its printNumInstances\nmethod receives the class, not the instance, when called from both the class and an\ninstance:\n>>> a, b = Spam(), Spam()\n>>> a.printNumInstances()\nNumber of instances: 2\n>>> Spam.printNumInstances()\nNumber of instances: 2\n\n# Passes class to first argument\n# Also passes class to first argument",
    "# Passes class to first argument\n# Also passes class to first argument\n\nWhen using class methods, though, keep in mind that they receive the most specific\n(i.e., lowest) class of the call’s subject. This has some subtle implications when trying\nto update class data through the passed-in class. For example, if in module test.py we\nsubclass to customize as before, augment Spam.printNumInstances to also display its\ncls argument, and start a new testing session:\nclass Spam:\nnumInstances = 0\n# Trace class passed in\ndef __init__(self):\nSpam.numInstances += 1\ndef printNumInstances(cls):\nprint(\"Number of instances:\", cls.numInstances, cls)\nprintNumInstances = classmethod(printNumInstances)\nclass Sub(Spam):\ndef printNumInstances(cls):\n# Override a class method\nprint(\"Extra stuff...\", cls)\n# But call back to original\nSpam.printNumInstances()\nprintNumInstances = classmethod(printNumInstances)\nclass Other(Spam): pass\n\n# Inherit class method verbatim",
    "# Inherit class method verbatim\n\nthe lowest class is passed in whenever a class method is run, even for subclasses that\nhave no class methods of their own:\n>>> x, y = Sub(), Spam()\n>>> x.printNumInstances()\nExtra stuff... <class 'test.Sub'>\nNumber of instances: 2 <class 'test.Spam'>\n\n802 | Chapter 31: Advanced Class Topics\n\n# Call from subclass instance\n\n\f>>> Sub.printNumInstances()\nExtra stuff... <class 'test.Sub'>\nNumber of instances: 2 <class 'test.Spam'>\n>>> y.printNumInstances()\nNumber of instances: 2 <class 'test.Spam'>\n\n# Call from subclass itself",
    "802 | Chapter 31: Advanced Class Topics\n\n# Call from subclass instance\n\n\f>>> Sub.printNumInstances()\nExtra stuff... <class 'test.Sub'>\nNumber of instances: 2 <class 'test.Spam'>\n>>> y.printNumInstances()\nNumber of instances: 2 <class 'test.Spam'>\n\n# Call from subclass itself\n\nIn the first call here, a class method call is made through an instance of the Sub subclass,\nand Python passes the lowest class, Sub, to the class method. All is well in this case—\nsince Sub’s redefinition of the method calls the Spam superclass’s version explicitly, the\nsuperclass method in Spam receives itself in its first argument. But watch what happens\nfor an object that simply inherits the class method:\n>>> z = Other()\n>>> z.printNumInstances()\nNumber of instances: 3 <class 'test.Other'>",
    "This last call here passes Other to Spam’s class method. This works in this example\nbecause fetching the counter finds it in Spam by inheritance. If this method tried to\nassign to the passed class’s data, though, it would update Object, not Spam! In this\nspecific case, Spam is probably better off hardcoding its own class name to update its\ndata, rather than relying on the passed-in class argument.",
    "Counting instances per class with class methods\nIn fact, because class methods always receive the lowest class in an instance’s tree:\n• Static methods and explicit class names may be a better solution for processing\ndata local to a class.\n• Class methods may be better suited to processing data that may differ for each class\nin a hierarchy.\nCode that needs to manage per-class instance counters, for example, might be best off\nleveraging class methods. In the following, the top-level superclass uses a class method\nto manage state information that varies for and is stored on each class in the tree—\nsimilar in spirit to the way instance methods manage state information in class\ninstances:\nclass Spam:\nnumInstances = 0\ndef count(cls):\ncls.numInstances += 1\ndef __init__(self):\nself.count()\ncount = classmethod(count)\nclass Sub(Spam):\nnumInstances = 0\ndef __init__(self):\nSpam.__init__(self)\nclass Other(Spam):\nnumInstances = 0",
    "# Per-class instance counters\n# cls is lowest class above instance\n# Passes self.__class__ to count\n\n# Redefines __init__\n# Inherits __init__\n\nStatic and Class Methods | 803\n\n\f>>> x = Spam()\n>>> y1, y2 = Sub(), Sub()\n>>> z1, z2, z3 = Other(), Other(), Other()\n>>> x.numInstances, y1.numInstances, z1.numInstances\n(1, 2, 3)\n>>> Spam.numInstances, Sub.numInstances, Other.numInstances\n(1, 2, 3)\n\nStatic and class methods have additional advanced roles, which we will finesse here;\nsee other resources for more use cases. In recent Python versions, though, the static\nand class method designations have become even simpler with the advent of function\ndecoration syntax—a way to apply one function to another that has roles well beyond\nthe static method use case that was its motivation. This syntax also allows us to augment\nclasses in Python 2.6 and 3.0—to initialize data like the numInstances counter in the\nlast example, for instance. The next section explains how.",
    "Decorators and Metaclasses: Part 1\nBecause the staticmethod call technique described in the prior section initially seemed\nobscure to some users, a feature was eventually added to make the operation simpler.\nFunction decorators provide a way to specify special operation modes for functions, by\nwrapping them in an extra layer of logic implemented as another function.\nFunction decorators turn out to be general tools: they are useful for adding many types\nof logic to functions besides the static method use case. For instance, they may be used\nto augment functions with code that logs calls made to them, checks the types of passed\narguments during debugging, and so on. In some ways, function decorators are similar\nto the delegation design pattern we explored in Chapter 30, but they are designed to\naugment a specific function or method call, not an entire object interface.\nPython provides some built-in function decorators for operations such as marking static",
    "arguments during debugging, and so on. In some ways, function decorators are similar\nto the delegation design pattern we explored in Chapter 30, but they are designed to\naugment a specific function or method call, not an entire object interface.\nPython provides some built-in function decorators for operations such as marking static\nmethods, but programmers can also code arbitrary decorators of their own. Although\nthey are not strictly tied to classes, user-defined function decorators often are coded as\nclasses to save the original functions, along with other data, as state information.\nThere’s also a more recent related extension available in Python 2.6 and 3.0: class decorators are directly tied to the class model, and their roles overlap with metaclasses.",
    "Function Decorator Basics\nSyntactically, a function decorator is a sort of runtime declaration about the function\nthat follows. A function decorator is coded on a line by itself just before the def statement that defines a function or method. It consists of the @ symbol, followed by what\nwe call a metafunction—a function (or other callable object) that manages another\nfunction. Static methods today, for example, may be coded with decorator syntax like\nthis:\n\n804 | Chapter 31: Advanced Class Topics\n\n\fclass C:\n@staticmethod\ndef meth():\n...\n\n# Decoration syntax\n\nInternally, this syntax has the same effect as the following (passing the function through\nthe decorator and assigning the result back to the original name):\nclass C:\ndef meth():\n...\nmeth = staticmethod(meth)\n\n# Rebind name",
    "# Rebind name\n\nDecoration rebinds the method name to the decorator’s result. The net effect is that\ncalling the method function’s name later actually triggers the result of its\nstaticmethod decorator first. Because a decorator can return any sort of object, this\nallows the decorator to insert a layer of logic to be run on every call. The decorator\nfunction is free to return either the original function itself, or a new object that saves\nthe original function passed to the decorator to be invoked indirectly after the extra\nlogic layer runs.\nWith this addition, here’s a better way to code our static method example from the\nprior section in either Python 2.6 or 3.0 (the classmethod decorator is used the same\nway):\nclass Spam:\nnumInstances = 0\ndef __init__(self):\nSpam.numInstances = Spam.numInstances + 1\n@staticmethod\ndef printNumInstances():\nprint(\"Number of instances created: \", Spam.numInstances)\na = Spam()\nb = Spam()\nc = Spam()\nSpam.printNumInstances()\na.printNumInstances()",
    "# Calls from both classes and instances work now!\n# Both print \"Number of instances created: 3\"\n\nKeep in mind that staticmethod is still a built-in function; it may be used in decoration\nsyntax, just because it takes a function as argument and returns a callable. In fact, any\nsuch function can be used in this way—even user-defined functions we code ourselves,\nas the next section explains.\n\nA First Function Decorator Example\nAlthough Python provides a handful of built-in functions that can be used as decorators,\nwe can also write custom decorators of our own. Because of their wide utility, we’re\ngoing to devote an entire chapter to coding decorators in the next part of this book. As\na quick example, though, let’s look at a simple user-defined decorator at work.\n\nDecorators and Metaclasses: Part 1 | 805",
    "Decorators and Metaclasses: Part 1 | 805\n\n\fRecall from Chapter 29 that the __call__ operator overloading method implements a\nfunction-call interface for class instances. The following code uses this to define a class\nthat saves the decorated function in the instance and catches calls to the original name.\nBecause this is a class, it also has state information (a counter of calls made):\nclass tracer:\ndef __init__(self, func):\nself.calls = 0\nself.func = func\ndef __call__(self, *args):\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))\nself.func(*args)\n@tracer\ndef spam(a, b, c):\nprint(a, b, c)\n\n# Same as spam = tracer(spam)\n# Wrap spam in a decorator object\n\nspam(1, 2, 3)\nspam('a', 'b', 'c')\nspam(4, 5, 6)\n\n# Really calls the tracer wrapper object\n# Invokes __call__ in class\n# __call__ adds logic and runs original object",
    "# Same as spam = tracer(spam)\n# Wrap spam in a decorator object\n\nspam(1, 2, 3)\nspam('a', 'b', 'c')\nspam(4, 5, 6)\n\n# Really calls the tracer wrapper object\n# Invokes __call__ in class\n# __call__ adds logic and runs original object\n\nBecause the spam function is run through the tracer decorator, when the original\nspam name is called it actually triggers the __call__ method in the class. This method\ncounts and logs the call, and then dispatches it to the original wrapped function. Note\nhow the *name argument syntax is used to pack and unpack the passed-in arguments;\nbecause of this, this decorator can be used to wrap any function with any number of\npositional arguments.\nThe net effect, again, is to add a layer of logic to the original spam function. Here is the\nscript’s output—the first line comes from the tracer class, and the second comes from\nthe spam function:\ncall 1 to spam\n1 2 3\ncall 2 to spam\na b c\ncall 3 to spam\n4 5 6",
    "Trace through this example’s code for more insight. As it is, this decorator works for\nany function that takes positional arguments, but it does not return the decorated\nfunction’s result, doesn’t handle keyword arguments, and cannot decorate class\nmethod functions (in short, for methods its __call__ would be passed a tracer instance\nonly). As we’ll see in Part VIII, there are a variety of ways to code function decorators,\nincluding nested def statements; some of the alternatives are better suited to methods\nthan the version shown here.\n\n806 | Chapter 31: Advanced Class Topics",
    "806 | Chapter 31: Advanced Class Topics\n\n\fClass Decorators and Metaclasses\nFunction decorators turned out to be so useful that Python 2.6 and 3.0 expanded the\nmodel, allowing decorators to be applied to classes as well as functions. In short, class\ndecorators are similar to function decorators, but they are run at the end of a class\nstatement to rebind a class name to a callable. As such, they can be used to either\nmanage classes just after they are created, or insert a layer of wrapper logic to manage\ninstances when they are later created. Symbolically, the code structure:\ndef decorator(aClass): ...\n@decorator\nclass C: ...\n\nis mapped to the following equivalent:\ndef decorator(aClass): ...\nclass C: ...\nC = decorator(C)",
    "is mapped to the following equivalent:\ndef decorator(aClass): ...\nclass C: ...\nC = decorator(C)\n\nThe class decorator is free to augment the class itself, or return an object that intercepts\nlater instance construction calls. For instance, in the example in the section “Counting\ninstances per class with class methods” on page 803, we could use this hook to automatically augment the classes with instance counters and any other data required:\ndef count(aClass):\naClass.numInstances = 0\nreturn aClass\n\n# Return class itself, instead of a wrapper\n\n@count\nclass Spam: ...\n\n# Same as Spam = count(Spam)\n\n@count\nclass Sub(Spam): ...\n\n# numInstances = 0 not needed here\n\n@count\nclass Other(Spam): ...",
    "# Return class itself, instead of a wrapper\n\n@count\nclass Spam: ...\n\n# Same as Spam = count(Spam)\n\n@count\nclass Sub(Spam): ...\n\n# numInstances = 0 not needed here\n\n@count\nclass Other(Spam): ...\n\nMetaclasses are a similarly advanced class-based tool whose roles often intersect with\nthose of class decorators. They provide an alternate model, which routes the creation\nof a class object to a subclass of the top-level type class, at the conclusion of a class\nstatement:\nclass Meta(type):\ndef __new__(meta, classname, supers, classdict): ...\nclass C(metaclass=Meta): ...\n\nDecorators and Metaclasses: Part 1 | 807\n\n\fIn Python 2.6, the effect is the same, but the coding differs—use a class attribute instead\nof a keyword argument in the class header:\nclass C:\n__metaclass__ = Meta\n...",
    "Decorators and Metaclasses: Part 1 | 807\n\n\fIn Python 2.6, the effect is the same, but the coding differs—use a class attribute instead\nof a keyword argument in the class header:\nclass C:\n__metaclass__ = Meta\n...\n\nThe metaclass generally redefines the __new__ or __init__ method of the type class, in\norder to assume control of the creation or initialization of a new class object. The net\neffect, as with class decorators, is to define code to be run automatically at class creation\ntime. Both schemes are free to augment a class or return an arbitrary object to replace\nit—a protocol with almost limitless class-based possibilities.",
    "For More Details\nNaturally, there’s much more to the decorator and metaclass stories than I’ve shown\nhere. Although they are a general mechanism, decorators and metaclasses are advanced\nfeatures of interest primarily to tool writers, not application programmers, so we’ll defer\nadditional coverage until the final part of this book:\n• Chapter 37 shows how to code properties using function decorator syntax.\n• Chapter 38 has much more on decorators, including more comprehensive\nexamples.\n• Chapter 39 covers metaclasses, and more on the class and instance management\nstory.\nAlthough these chapters cover advanced topics, they’ll also provide us with a chance\nto see Python at work in more substantial examples than much of the rest of the book\nwas able to provide.",
    "Class Gotchas\nMost class issues can be boiled down to namespace issues (which makes sense, given\nthat classes are just namespaces with a few extra tricks). Some of the topics we’ll cover\nin this section are more like case studies of advanced class usage than real problems,\nand one or two of these gotchas have been eased by recent Python releases.\n\nChanging Class Attributes Can Have Side Effects\nTheoretically speaking, classes (and class instances) are mutable objects. Like built-in\nlists and dictionaries, they can be changed in-place by assigning to their attributes—\nand as with lists and dictionaries, this means that changing a class or instance object\nmay impact multiple references to it.\n\n808 | Chapter 31: Advanced Class Topics",
    "808 | Chapter 31: Advanced Class Topics\n\n\fThat’s usually what we want (and is how objects change their state in general), but\nawareness of this issue becomes especially critical when changing class attributes. Because all instances generated from a class share the class’s namespace, any changes at\nthe class level are reflected in all instances, unless they have their own versions of the\nchanged class attributes.\nBecause classes, modules, and instances are all just objects with attribute namespaces,\nyou can normally change their attributes at runtime by assignments. Consider the following class. Inside the class body, the assignment to the name a generates an attribute\nX.a, which lives in the class object at runtime and will be inherited by all of X’s instances:\n>>> class X:\n...\na = 1\n...\n>>> I = X()\n>>> I.a\n1\n>>> X.a\n1\n\n# Class attribute\n# Inherited by instance",
    "# Class attribute\n# Inherited by instance\n\nSo far, so good—this is the normal case. But notice what happens when we change the\nclass attribute dynamically outside the class statement: it also changes the attribute in\nevery object that inherits from the class. Moreover, new instances created from the class\nduring this session or program run also get the dynamically set value, regardless of what\nthe class’s source code says:\n>>> X.a = 2\n>>> I.a\n2\n>>> J = X()\n>>> J.a\n2\n\n# May change more than X\n# I changes too\n# J inherits from X's runtime values\n# (but assigning to J.a changes a in J, not X or I)\n\nIs this a useful feature or a dangerous trap? You be the judge. As we learned in Chapter 26, you can actually get work done by changing class attributes without ever making\na single instance; this technique can simulate the use of “records” or “structs” in other\nlanguages. As a refresher, consider the following unusual but legal Python program:\nclass X: pass\nclass Y: pass",
    "Is this a useful feature or a dangerous trap? You be the judge. As we learned in Chapter 26, you can actually get work done by changing class attributes without ever making\na single instance; this technique can simulate the use of “records” or “structs” in other\nlanguages. As a refresher, consider the following unusual but legal Python program:\nclass X: pass\nclass Y: pass\n\n# Make a few attribute namespaces\n\nX.a = 1\nX.b = 2\nX.c = 3\nY.a = X.a + X.b + X.c\n\n# Use class attributes as variables\n# No instances anywhere to be found\n\nfor X.i in range(Y.a): print(X.i)\n\n# Prints 0..5\n\nHere, the classes X and Y work like “fileless” modules—namespaces for storing variables\nwe don’t want to clash. This is a perfectly legal Python programming trick, but it’s less\nappropriate when applied to classes written by others; you can’t always be sure that\nclass attributes you change aren’t critical to the class’s internal behavior. If you’re out\n\nClass Gotchas | 809",
    "# Prints 0..5\n\nHere, the classes X and Y work like “fileless” modules—namespaces for storing variables\nwe don’t want to clash. This is a perfectly legal Python programming trick, but it’s less\nappropriate when applied to classes written by others; you can’t always be sure that\nclass attributes you change aren’t critical to the class’s internal behavior. If you’re out\n\nClass Gotchas | 809\n\n\fto simulate a C struct, you may be better off changing instances than classes, as that\nway only one object is affected:\nclass Record: pass\nX = Record()\nX.name = 'bob'\nX.job = 'Pizza maker'",
    "Class Gotchas | 809\n\n\fto simulate a C struct, you may be better off changing instances than classes, as that\nway only one object is affected:\nclass Record: pass\nX = Record()\nX.name = 'bob'\nX.job = 'Pizza maker'\n\nChanging Mutable Class Attributes Can Have Side Effects, Too\nThis gotcha is really an extension of the prior. Because class attributes are shared by all\ninstances, if a class attribute references a mutable object, changing that object in-place\nfrom any instance impacts all instances at once:\n>>> class C:\n...\nshared = []\n...\ndef __init__(self):\n...\nself.perobj = []\n...\n>>> x = C()\n>>> y = C()\n>>> y.shared, y.perobj\n([], [])\n\n# Class attribute\n# Instance attribute\n# Two instances\n# Implicitly share class attrs\n\n>>> x.shared.append('spam')\n>>> x.perobj.append('spam')\n>>> x.shared, x.perobj\n(['spam'], ['spam'])\n\n# Impacts y's view too!\n# Impacts x's data only\n\n>>> y.shared, y.perobj\n(['spam'], [])\n>>> C.shared\n['spam']\n\n# y sees change made through x\n# Stored on class and shared",
    ">>> x.shared.append('spam')\n>>> x.perobj.append('spam')\n>>> x.shared, x.perobj\n(['spam'], ['spam'])\n\n# Impacts y's view too!\n# Impacts x's data only\n\n>>> y.shared, y.perobj\n(['spam'], [])\n>>> C.shared\n['spam']\n\n# y sees change made through x\n# Stored on class and shared\n\nThis effect is no different than many we’ve seen in this book already: mutable objects\nare shared by simple variables, globals are shared by functions, module-level objects\nare shared by multiple importers, and mutable function arguments are shared by the\ncaller and the callee. All of these are cases of general behavior—multiple references to\na mutable object—and all are impacted if the shared object is changed in-place from\nany reference. Here, this occurs in class attributes shared by all instances via inheritance, but it’s the same phenomenon at work. It may be made more subtle by the\ndifferent behavior of assignments to instance attributes themselves:\nx.shared.append('spam')\nx.shared = 'spam'",
    "# Changes shared object attached to class in-place\n# Changed or creates instance attribute attached to x\n\nbut again, this is not a problem, it’s just something to be aware of; shared mutable class\nattributes can have many valid uses in Python programs.\n\n810 | Chapter 31: Advanced Class Topics\n\n\fMultiple Inheritance: Order Matters\nThis may be obvious by now, but it’s worth underscoring: if you use multiple inheritance, the order in which superclasses are listed in the class statement header can be\ncritical. Python always searches superclasses from left to right, according to their order\nin the header line.\nFor instance, in the multiple inheritance example we studied in Chapter 30, suppose\nthat the Super class implemented a __str__ method, too:\nclass ListTree:\ndef __str__(self): ...\nclass Super:\ndef __str__(self): ...\nclass Sub(ListTree, Super):\n\n# Get ListTree's __str__ by listing it first\n\nx = Sub()\n\n# Inheritance searches ListTree before Super",
    "x = Sub()\n\n# Inheritance searches ListTree before Super\n\nWhich class would we inherit it from—ListTree or Super? As inheritance searches proceed from left to right, we would get the method from whichever class is listed first\n(leftmost) in Sub’s class header. Presumably, we would list ListTree first because its\nwhole purpose is its custom __str__ (indeed, we had to do this in Chapter 30 when\nmixing this class with a tkinter.Button that had a __str__ of its own).\nBut now suppose Super and ListTree have their own versions of other same-named\nattributes, too. If we want one name from Super and another from ListTree, the order\nin which we list them in the class header won’t help—we will have to override inheritance by manually assigning to the attribute name in the Sub class:\nclass ListTree:\ndef __str__(self): ...\ndef other(self): ...\nclass Super:\ndef __str__(self): ...\ndef other(self): ...\nclass Sub(ListTree, Super):\nother = Super.other\ndef __init__(self):\n...",
    "# Get ListTree's __str__ by listing it first\n# But explicitly pick Super's version of other\n\nx = Sub()\n\n# Inheritance searches Sub before ListTree/Super\n\nHere, the assignment to other within the Sub class creates Sub.other—a reference back\nto the Super.other object. Because it is lower in the tree, Sub.other effectively hides\nListTree.other, the attribute that the inheritance search would normally find. Similarly, if we listed Super first in the class header to pick up its other, we would need to\nselect ListTree’s method explicitly:\n\nClass Gotchas | 811\n\n\f# Get Super's other by order\n# Explicitly pick Lister.__str__\n\nclass Sub(Super, ListTree):\n__str__ = Lister.__str__",
    "Multiple inheritance is an advanced tool. Even if you understood the last paragraph,\nit’s still a good idea to use it sparingly and carefully. Otherwise, the meaning of a name\nmay come to depend on the order in which classes are mixed in an arbitrarily\nfar-removed subclass. (For another example of the technique shown here in action, see\nthe discussion of explicit conflict resolution in “The “New-Style” Class\nModel” on page 777.)\nAs a rule of thumb, multiple inheritance works best when your mix-in classes are as\nself-contained as possible—because they may be used in a variety of contexts, they\nshould not make assumptions about names related to other classes in a tree. The\npseudoprivate __X attributes feature we studied in Chapter 30 can help by localizing\nnames that a class relies on owning and limiting the names that your mix-in classes add\nto the mix. In this example, for instance, if ListTree only means to export its custom",
    "should not make assumptions about names related to other classes in a tree. The\npseudoprivate __X attributes feature we studied in Chapter 30 can help by localizing\nnames that a class relies on owning and limiting the names that your mix-in classes add\nto the mix. In this example, for instance, if ListTree only means to export its custom\n__str__, it can name its other method __other to avoid clashing with like-named classes\nin the tree.",
    "Methods, Classes, and Nested Scopes\nThis gotcha went away in Python 2.2 with the introduction of nested function scopes,\nbut I’ve retained it here for historical perspective, for readers working with older Python\nreleases, and because it demonstrates what happens to the new nested function scope\nrules when one layer of the nesting is a class.\nClasses introduce local scopes, just as functions do, so the same sorts of scope behavior\ncan happen in a class statement body. Moreover, methods are further nested functions,\nso the same issues apply. Confusion seems to be especially common when classes are\nnested.\nIn the following example (the file nester.py), the generate function returns an instance\nof the nested Spam class. Within its code, the class name Spam is assigned in the\ngenerate function’s local scope. However, in versions of Python prior to 2.2, within the\nclass’s method function the class name Spam is not visible—method has access only to its",
    "nested.\nIn the following example (the file nester.py), the generate function returns an instance\nof the nested Spam class. Within its code, the class name Spam is assigned in the\ngenerate function’s local scope. However, in versions of Python prior to 2.2, within the\nclass’s method function the class name Spam is not visible—method has access only to its\nown local scope, the module surrounding generate, and built-in names:\ndef generate():\nclass Spam:\ncount = 1\ndef method(self):\nprint(Spam.count)\nreturn Spam()",
    "# Fails prior to Python 2.2, works later\n# Name Spam not visible:\n# not local (def), global (module), built-in\n\ngenerate().method()\nC:\\python\\examples> python nester.py\n...error text omitted...\n\n812 | Chapter 31: Advanced Class Topics\n\n\fPrint(Spam.count)\nNameError: Spam\n\n# Not local (def), global (module), built-in",
    "This example works in Python 2.2 and later because the local scopes of all enclosing\nfunction defs are automatically visible to nested defs (including nested method defs,\nas in this example). However, it doesn’t work before 2.2 (we’ll look at some possible\nsolutions momentarily).\nNote that even in 2.2 and later, method defs cannot see the local scope of the enclosing\nclass; they can only see the local scopes of enclosing defs. That’s why methods must\ngo through the self instance or the class name to reference methods and other attributes\ndefined in the enclosing class statement. For example, code in the method must use\nself.count or Spam.count, not just count.\nIf you’re using a release prior to 2.2, there are a variety of ways to get the preceding\nexample to work. One of the simplest is to move the name Spam out to the enclosing\nmodule’s scope with a global declaration. Because method sees global names in the\nenclosing module, references to Spam will work:\ndef generate():\nglobal Spam",
    "self.count or Spam.count, not just count.\nIf you’re using a release prior to 2.2, there are a variety of ways to get the preceding\nexample to work. One of the simplest is to move the name Spam out to the enclosing\nmodule’s scope with a global declaration. Because method sees global names in the\nenclosing module, references to Spam will work:\ndef generate():\nglobal Spam\nclass Spam:\ncount = 1\ndef method(self):\nprint(Spam.count)\nreturn Spam()\ngenerate().method()",
    "# Force Spam to module scope\n\n# Works: in global (enclosing module)\n# Prints 1\n\nA better alternative would be to restructure the code such that the class Spam is defined\nat the top level of the module by virtue of its nesting level, rather than using global\ndeclarations. The nested method function and the top-level generate will then find\nSpam in their global scopes:\ndef generate():\nreturn Spam()\nclass Spam:\ncount = 1\ndef method(self):\nprint(Spam.count)\n\n# Define at top level of module\n# Works: in global (enclosing module)\n\ngenerate().method()\n\nIn fact, this approach is recommended for all Python releases—code tends to be simpler\nin general if you avoid nesting classes and functions.\nIf you want to get complicated and tricky, you can also get rid of the Spam reference in\nmethod altogether by using the special __class__ attribute, which returns an instance’s\nclass object:\ndef generate():\nclass Spam:\n\nClass Gotchas | 813",
    "In fact, this approach is recommended for all Python releases—code tends to be simpler\nin general if you avoid nesting classes and functions.\nIf you want to get complicated and tricky, you can also get rid of the Spam reference in\nmethod altogether by using the special __class__ attribute, which returns an instance’s\nclass object:\ndef generate():\nclass Spam:\n\nClass Gotchas | 813\n\n\fcount = 1\ndef method(self):\nprint(self.__class__.count)\nreturn Spam()\n\n# Works: qualify to get class\n\ngenerate().method()",
    "generate().method()\n\nDelegation-Based Classes in 3.0: __getattr__ and built-ins\nWe met this issue briefly in our class tutorial in Chapter 27 and our delegation coverage\nin Chapter 30: classes that use the __getattr__ operator overloading method to delegate\nattribute fetches to wrapped objects will fail in Python 3.0 unless operator overloading\nmethods are redefined in the wrapper class. In Python 3.0 (and 2.6, when new-style\nclasses are used), the names of operator overloading methods implicitly fetched by\nbuilt-in operations are not routed through generic attribute-interception methods. The\n__str__ method used by printing, for example, never invokes __getattr__. Instead,\nPython 3.0 looks up such names in classes and skips the normal runtime instance\nlookup mechanism entirely. To work around this, such methods must be redefined in\nwrapper classes, either by hand, with tools, or by definition in superclasses. We’ll revisit\nthis gotcha in Chapters 37 and 38.",
    "“Overwrapping-itis”\nWhen used well, the code reuse features of OOP make it excel at cutting development\ntime. Sometimes, though, OOP’s abstraction potential can be abused to the point of\nmaking code difficult to understand. If classes are layered too deeply, code can become\nobscure; you may have to search through many classes to discover what an operation\ndoes.\nFor example, I once worked in a C++ shop with thousands of classes (some machinegenerated), and up to 15 levels of inheritance. Deciphering method calls in such a\ncomplex system was often a monumental task: multiple classes had to be consulted for\neven the most basic of operations. In fact, the logic of the system was so deeply wrapped\nthat understanding a piece of code in some cases required days of wading through\nrelated files.\nThe most general rule of thumb of Python programming applies here, too: don’t make\nthings complicated unless they truly must be. Wrapping your code in multiple layers",
    "even the most basic of operations. In fact, the logic of the system was so deeply wrapped\nthat understanding a piece of code in some cases required days of wading through\nrelated files.\nThe most general rule of thumb of Python programming applies here, too: don’t make\nthings complicated unless they truly must be. Wrapping your code in multiple layers\nof classes to the point of incomprehensibility is always a bad idea. Abstraction is the\nbasis of polymorphism and encapsulation, and it can be a very effective tool when used\nwell. However, you’ll simplify debugging and aid maintainability if you make your class\ninterfaces intuitive, avoid making your code overly abstract, and keep your class hierarchies short and flat unless there is a good reason to do otherwise.",
    "814 | Chapter 31: Advanced Class Topics",
    "Chapter Summary\nThis chapter presented a handful of advanced class-related topics, including subclassing built-in types, new-style classes, static methods, and decorators. Most of these are\noptional extensions to the OOP model in Python, but they may become more useful\nas you start writing larger object-oriented programs. As mentioned earlier, our discussion of some of the more advanced class tools continues in the final part of this book;\nbe sure to look ahead if you need more details on properties, descriptors, decorators,\nand metaclasses.\nThis is the end of the class part of this book, so you’ll find the usual lab exercises at the\nend of the chapter—be sure to work through them to get some practice coding real\nclasses. In the next chapter, we’ll begin our look at our last core language topic, exceptions. Exceptions are Python’s mechanism for communicating errors and other\nconditions to your code. This is a relatively lightweight topic, but I’ve saved it for last",
    "end of the chapter—be sure to work through them to get some practice coding real\nclasses. In the next chapter, we’ll begin our look at our last core language topic, exceptions. Exceptions are Python’s mechanism for communicating errors and other\nconditions to your code. This is a relatively lightweight topic, but I’ve saved it for last\nbecause exceptions are supposed to be coded as classes today. Before we tackle that\nfinal core subject, though, take a look at this chapter’s quiz and the lab exercises.",
    "Test Your Knowledge: Quiz\n1. Name two ways to extend a built-in object type.\n2. What are function decorators used for?\n3. How do you code a new-style class?\n4. How are new-style and classic classes different?\n5. How are normal and static methods different?\n6. How long should you wait before lobbing a “Holy Hand Grenade”?\n\nTest Your Knowledge: Answers\n1. You can embed a built-in object in a wrapper class, or subclass the built-in type\ndirectly. The latter approach tends to be simpler, as most original behavior is automatically inherited.\n2. Function decorators are generally used to add to an existing function a layer of\nlogic that is run each time the function is called. They can be used to log or count\ncalls to a function, check its argument types, and so on. They are also used to\n“declare” static methods—simple functions in a class that are not passed an instance when called.\n\nTest Your Knowledge: Answers | 815",
    "3. New-style classes are coded by inheriting from the object built-in class (or any\nother built-in type). In Python 3.0, all classes are new-style automatically, so this\nderivation is not required; in 2.6, classes with this derivation are new-style and\nthose without it are “classic.”\n4. New-style classes search the diamond pattern of multiple inheritance trees differently—they essentially search breadth-first (across), instead of depth-first (up).\nNew-style classes also change the result of the type built-in for instances and\nclasses, do not run generic attribute fetch methods such as __getattr__ for builtin operation methods, and support a set of advanced extra tools including properties, descriptors, and __slots__ instance attribute lists.\n5. Normal (instance) methods receive a self argument (the implied instance), but\nstatic methods do not. Static methods are simple functions nested in class objects.",
    "classes, do not run generic attribute fetch methods such as __getattr__ for builtin operation methods, and support a set of advanced extra tools including properties, descriptors, and __slots__ instance attribute lists.\n5. Normal (instance) methods receive a self argument (the implied instance), but\nstatic methods do not. Static methods are simple functions nested in class objects.\nTo make a method static, it must either be run through a special built-in function\nor be decorated with decorator syntax. Python 3.0 allows simple functions in a\nclass to be called through the class without this step, but calls through instances\nstill require static method declaration.\n6. Three seconds. (Or, more accurately: “And the Lord spake, saying, ‘First shalt thou\ntake out the Holy Pin. Then, shalt thou count to three, no more, no less. Three\nshalt be the number thou shalt count, and the number of the counting shall be\nthree. Four shalt thou not count, nor either count thou two, excepting that thou",
    "still require static method declaration.\n6. Three seconds. (Or, more accurately: “And the Lord spake, saying, ‘First shalt thou\ntake out the Holy Pin. Then, shalt thou count to three, no more, no less. Three\nshalt be the number thou shalt count, and the number of the counting shall be\nthree. Four shalt thou not count, nor either count thou two, excepting that thou\nthen proceed to three. Five is right out. Once the number three, being the third\nnumber, be reached, then lobbest thou thy Holy Hand Grenade of Antioch towards\nthy foe, who, being naughty in my sight, shall snuff it.’”)*",
    "Test Your Knowledge: Part VI Exercises\nThese exercises ask you to write a few classes and experiment with some existing code.\nOf course, the problem with existing code is that it must be existing. To work with the\nset class in exercise 5, either pull the class source code off this book’s website (see the\nPreface for a pointer) or type it up by hand (it’s fairly brief). These programs are starting\nto get more sophisticated, so be sure to check the solutions at the end of the book for\npointers. You’ll find them in Appendix B, under “Part VI, Classes and\nOOP” on page 1122.\n1. Inheritance. Write a class called Adder that exports a method add(self, x, y) that\nprints a “Not Implemented” message. Then, define two subclasses of Adder that\nimplement the add method:\nListAdder\n\nWith an add method that returns the concatenation of its two list arguments\n\n* This quote is from Monty Python and the Holy Grail.\n\n816 | Chapter 31: Advanced Class Topics\n\n\fDictAdder",
    "With an add method that returns a new dictionary containing the items in both\nits two dictionary arguments (any definition of addition will do)\nExperiment by making instances of all three of your classes interactively and calling\ntheir add methods.\nNow, extend your Adder superclass to save an object in the instance with a constructor (e.g., assign self.data a list or a dictionary), and overload the + operator\nwith an __add__ method to automatically dispatch to your add methods (e.g., X +\nY triggers X.add(X.data,Y)). Where is the best place to put the constructors and\noperator overloading methods (i.e., in which classes)? What sorts of objects can\nyou add to your class instances?\nIn practice, you might find it easier to code your add methods to accept just one\nreal argument (e.g., add(self,y)), and add that one argument to the instance’s\ncurrent data (e.g., self.data + y). Does this make more sense than passing two",
    "operator overloading methods (i.e., in which classes)? What sorts of objects can\nyou add to your class instances?\nIn practice, you might find it easier to code your add methods to accept just one\nreal argument (e.g., add(self,y)), and add that one argument to the instance’s\ncurrent data (e.g., self.data + y). Does this make more sense than passing two\narguments to add? Would you say this makes your classes more “object-oriented”?\n2. Operator overloading. Write a class called Mylist that shadows (“wraps”) a Python\nlist: it should overload most list operators and operations, including +, indexing,\niteration, slicing, and list methods such as append and sort. See the Python reference\nmanual for a list of all possible methods to support. Also, provide a constructor\nfor your class that takes an existing list (or a Mylist instance) and copies its components into an instance member. Experiment with your class interactively. Things\nto explore:",
    "iteration, slicing, and list methods such as append and sort. See the Python reference\nmanual for a list of all possible methods to support. Also, provide a constructor\nfor your class that takes an existing list (or a Mylist instance) and copies its components into an instance member. Experiment with your class interactively. Things\nto explore:\na. Why is copying the initial value important here?\nb. Can you use an empty slice (e.g., start[:]) to copy the initial value if it’s a\nMylist instance?\nc. Is there a general way to route list method calls to the wrapped list?\nd. Can you add a Mylist and a regular list? How about a list and a Mylist instance?\ne. What type of object should operations like + and slicing return? What about\nindexing operations?\nf. If you are working with a more recent Python release (version 2.2 or later), you\nmay implement this sort of wrapper class by embedding a real list in a standalone class, or by extending the built-in list type with a subclass. Which is",
    "e. What type of object should operations like + and slicing return? What about\nindexing operations?\nf. If you are working with a more recent Python release (version 2.2 or later), you\nmay implement this sort of wrapper class by embedding a real list in a standalone class, or by extending the built-in list type with a subclass. Which is\neasier, and why?\n3. Subclassing. Make a subclass of Mylist from exercise 2 called MylistSub, which\nextends Mylist to print a message to stdout before each overloaded operation is\ncalled and counts the number of calls. MylistSub should inherit basic method behavior from Mylist. Adding a sequence to a MylistSub should print a message,\nincrement the counter for + calls, and perform the superclass’s method. Also, introduce a new method that prints the operation counters to stdout, and experiment\nwith your class interactively. Do your counters count calls per instance, or per class\n(for all instances of the class)? How would you program the other option)?",
    "increment the counter for + calls, and perform the superclass’s method. Also, introduce a new method that prints the operation counters to stdout, and experiment\nwith your class interactively. Do your counters count calls per instance, or per class\n(for all instances of the class)? How would you program the other option)?\nTest Your Knowledge: Part VI Exercises | 817",
    "(Hint: it depends on which object the count members are assigned to: class members are shared by instances, but self members are per-instance data.)\n4. Metaclass methods. Write a class called Meta with methods that intercept every\nattribute qualification (both fetches and assignments), and print messages listing\ntheir arguments to stdout. Create a Meta instance, and experiment with qualifying\nit interactively. What happens when you try to use the instance in expressions? Try\nadding, indexing, and slicing the instance of your class. (Note: a fully generic approach based upon __getattr__ will work in 2.6 but not 3.0, for reasons noted in\nChapter 30 and restated in the solution to this exercise.)\n5. Set objects. Experiment with the set class described in “Extending Types by Embedding” on page 774. Run commands to do the following sorts of operations:\na. Create two sets of integers, and compute their intersection and union by using\n& and | operator expressions.",
    "Chapter 30 and restated in the solution to this exercise.)\n5. Set objects. Experiment with the set class described in “Extending Types by Embedding” on page 774. Run commands to do the following sorts of operations:\na. Create two sets of integers, and compute their intersection and union by using\n& and | operator expressions.\nb. Create a set from a string, and experiment with indexing your set. Which\nmethods in the class are called?\nc. Try iterating through the items in your string set using a for loop. Which\nmethods run this time?\nd. Try computing the intersection and union of your string set and a simple Python string. Does it work?\ne. Now, extend your set by subclassing to handle arbitrarily many operands using\nthe *args argument form. (Hint: see the function versions of these algorithms\nin Chapter 18.) Compute intersections and unions of multiple operands with\nyour set subclass. How can you intersect three or more sets, given that & has\nonly two sides?",
    "e. Now, extend your set by subclassing to handle arbitrarily many operands using\nthe *args argument form. (Hint: see the function versions of these algorithms\nin Chapter 18.) Compute intersections and unions of multiple operands with\nyour set subclass. How can you intersect three or more sets, given that & has\nonly two sides?\nf. How would you go about emulating other list operations in the set class? (Hint:\n__add__ can catch concatenation, and __getattr__ can pass most list method\ncalls to the wrapped list.)\n6. Class tree links. In “Namespaces: The Whole Story” on page 693 in Chapter 28\nand in “Multiple Inheritance: “Mix-in” Classes” on page 756 in Chapter 30, I\nmentioned that classes have a __bases__ attribute that returns a tuple of their superclass objects (the ones listed in parentheses in the class header). Use\n__bases__ to extend the lister.py mix-in classes we wrote in Chapter 30 so that they\nprint the names of the immediate superclasses of the instance’s class. When you’re",
    "mentioned that classes have a __bases__ attribute that returns a tuple of their superclass objects (the ones listed in parentheses in the class header). Use\n__bases__ to extend the lister.py mix-in classes we wrote in Chapter 30 so that they\nprint the names of the immediate superclasses of the instance’s class. When you’re\ndone, the first line of the string representation should look like this (your address\nmay vary):\n<Instance of Sub(Super, Lister), address 7841200:",
    "7. Composition. Simulate a fast-food ordering scenario by defining four classes:\nLunch\n\nA container and controller class\n\n818 | Chapter 31: Advanced Class Topics\n\n\fCustomer\n\nThe actor who buys food\nEmployee\n\nThe actor from whom a customer orders\nFood\n\nWhat the customer buys\nTo get you started, here are the classes and methods you’ll be defining:\nclass Lunch:\ndef __init__(self)\ndef order(self, foodName)\ndef result(self)\n\n# Make/embed Customer and Employee\n# Start a Customer order simulation\n# Ask the Customer what Food it has\n\nclass Customer:\ndef __init__(self)\n# Initialize my food to None\ndef placeOrder(self, foodName, employee) # Place order with an Employee\ndef printFood(self)\n# Print the name of my food\nclass Employee:\ndef takeOrder(self, foodName)\n\n# Return a Food, with requested name\n\nclass Food:\ndef __init__(self, name)\n\n# Store food name",
    "The order simulation should work as follows:\na. The Lunch class’s constructor should make and embed an instance of\nCustomer and an instance of Employee, and it should export a method called\norder. When called, this order method should ask the Customer to place an\norder by calling its placeOrder method. The Customer’s placeOrder method\nshould in turn ask the Employee object for a new Food object by calling\nEmployee’s takeOrder method.\nb. Food objects should store a food name string (e.g., “burritos”), passed down\nfrom Lunch.order, to Customer.placeOrder, to Employee.takeOrder, and finally\nto Food’s constructor. The top-level Lunch class should also export a method\ncalled result, which asks the customer to print the name of the food it received\nfrom the Employee via the order (this can be used to test your simulation).\nNote that Lunch needs to pass either the Employee or itself to the Customer to allow\nthe Customer to call Employee methods.",
    "to Food’s constructor. The top-level Lunch class should also export a method\ncalled result, which asks the customer to print the name of the food it received\nfrom the Employee via the order (this can be used to test your simulation).\nNote that Lunch needs to pass either the Employee or itself to the Customer to allow\nthe Customer to call Employee methods.\nExperiment with your classes interactively by importing the Lunch class, calling its\norder method to run an interaction, and then calling its result method to verify\nthat the Customer got what he or she ordered. If you prefer, you can also simply\ncode test cases as self-test code in the file where your classes are defined, using the\nmodule __name__ trick of Chapter 24. In this simulation, the Customer is the active\nagent; how would your classes change if Employee were the object that initiated\ncustomer/employee interaction instead?",
    "Test Your Knowledge: Part VI Exercises | 819\n\n\fFigure 31-1. A zoo hierarchy composed of classes linked into a tree to be searched by attribute\ninheritance. Animal has a common “reply” method, but each class may have its own custom “speak”\nmethod called by “reply”.",
    "Figure 31-1. A zoo hierarchy composed of classes linked into a tree to be searched by attribute\ninheritance. Animal has a common “reply” method, but each class may have its own custom “speak”\nmethod called by “reply”.\n\n3. Zoo animal hierarchy. Consider the class tree shown in Figure 31-1.\nCode a set of six class statements to model this taxonomy with Python inheritance.\nThen, add a speak method to each of your classes that prints a unique message,\nand a reply method in your top-level Animal superclass that simply calls\nself.speak to invoke the category-specific message printer in a subclass below (this\nwill kick off an independent inheritance search from self). Finally, remove the\nspeak method from your Hacker class so that it picks up the default above it. When\nyou’re finished, your classes should work this way:\n% python\n>>> from zoo import Cat, Hacker\n>>> spot = Cat()\n>>> spot.reply()\nmeow\n>>> data = Hacker()\n>>> data.reply()\nHello world!",
    "# Animal.reply; calls Cat.speak\n# Animal.reply; calls Primate.speak\n\n4. The Dead Parrot Sketch. Consider the object embedding structure captured in\nFigure 31-2.\nCode a set of Python classes to implement this structure with composition. Code\nyour Scene object to define an action method, and embed instances of the Customer,\nClerk, and Parrot classes (each of which should define a line method that prints\na unique message). The embedded objects may either inherit from a common superclass that defines line and simply provide message text, or define line themselves. In the end, your classes should operate like this:\n% python\n>>> import parrot\n>>> parrot.Scene().action()\ncustomer: \"that's one ex-bird!\"\n\n820 | Chapter 31: Advanced Class Topics\n\n# Activate nested objects\n\n\fclerk: \"no it isn't...\"\nparrot: None",
    "820 | Chapter 31: Advanced Class Topics\n\n# Activate nested objects\n\n\fclerk: \"no it isn't...\"\nparrot: None\n\nFigure 31-2. A scene composite with a controller class (Scene) that embeds and directs instances of\nthree other classes (Customer, Clerk, Parrot). The embedded instance’s classes may also participate\nin an inheritance hierarchy; composition and inheritance are often equally useful ways to structure\nclasses for code reuse.",
    "Why You Will Care: OOP by the Masters\nWhen I teach Python classes, I invariably find that about halfway through the class,\npeople who have used OOP in the past are following along intensely, while people who\nhave not are beginning to glaze over (or nod off completely). The point behind the\ntechnology just isn’t apparent.\nIn a book like this, I have the luxury of including material like the new Big Picture\noverview in Chapter 25, and the gradual tutorial of Chapter 27—in fact, you should\nprobably review that section if you’re starting to feel like OOP is just some computer\nscience mumbo-jumbo.\nIn real classes, however, to help get the newcomers on board (and keep them awake),\nI have been known to stop and ask the experts in the audience why they use OOP. The\nanswers they’ve given might help shed some light on the purpose of OOP, if you’re new\nto the subject.\nHere, then, with only a few embellishments, are the most common reasons to use OOP,\nas cited by my students over the years:",
    "In real classes, however, to help get the newcomers on board (and keep them awake),\nI have been known to stop and ask the experts in the audience why they use OOP. The\nanswers they’ve given might help shed some light on the purpose of OOP, if you’re new\nto the subject.\nHere, then, with only a few embellishments, are the most common reasons to use OOP,\nas cited by my students over the years:\nCode reuse\nThis one’s easy (and is the main reason for using OOP). By supporting inheritance,\nclasses allow you to program by customization instead of starting each project from\nscratch.\nEncapsulation\nWrapping up implementation details behind object interfaces insulates users of a\nclass from code changes.\nStructure\nClasses provide new local scopes, which minimizes name clashes. They also provide a natural place to write and look for implementation code, and to manage\nobject state.\nTest Your Knowledge: Part VI Exercises | 821",
    "Maintenance\nClasses naturally promote code factoring, which allows us to minimize redundancy. Thanks both to the structure and code reuse support of classes, usually only\none copy of the code needs to be changed.\nConsistency\nClasses and inheritance allow you to implement common interfaces, and hence\ncreate a common look and feel in your code; this eases debugging, comprehension,\nand maintenance.\nPolymorphism\nThis is more a property of OOP than a reason for using it, but by supporting code\ngenerality, polymorphism makes code more flexible and widely applicable, and\nhence more reusable.\nOther\nAnd, of course, the number one reason students gave for using OOP: it looks good\non a résumé! (OK, I threw this one in as a joke, but it is important to be familiar\nwith OOP if you plan to work in the software field today.)\nFinally, keep in mind what I said at the beginning of this part of the book: you won’t",
    "hence more reusable.\nOther\nAnd, of course, the number one reason students gave for using OOP: it looks good\non a résumé! (OK, I threw this one in as a joke, but it is important to be familiar\nwith OOP if you plan to work in the software field today.)\nFinally, keep in mind what I said at the beginning of this part of the book: you won’t\nfully appreciate OOP until you’ve used it for awhile. Pick a project, study larger examples, work through the exercises—do whatever it takes to get your feet wet with OO\ncode; it’s worth the effort.",
    "822 | Chapter 31: Advanced Class Topics\n\n\fPART VII\n\nExceptions and Tools\n\n\f\fCHAPTER 32\n\nException Basics\n\nThis part of the book deals with exceptions, which are events that can modify the flow\nof control through a program. In Python, exceptions are triggered automatically on\nerrors, and they can be triggered and intercepted by your code. They are processed by\nfour statements we’ll study in this part, the first of which has two variations (listed\nseparately here) and the last of which was an optional extension until Python 2.6 and\n3.0:\ntry/except\n\nCatch and recover from exceptions raised by Python, or by you.\ntry/finally\n\nPerform cleanup actions, whether exceptions occur or not.\nraise\n\nTrigger an exception manually in your code.\nassert",
    "Catch and recover from exceptions raised by Python, or by you.\ntry/finally\n\nPerform cleanup actions, whether exceptions occur or not.\nraise\n\nTrigger an exception manually in your code.\nassert\n\nConditionally trigger an exception in your code.\nwith/as\nImplement context managers in Python 2.6 and 3.0 (optional in 2.5).\nThis topic was saved until nearly the end of the book because you need to know about\nclasses to code exceptions of your own. With a few exceptions (pun intended), though,\nyou’ll find that exception handling is simple in Python because it’s integrated into the\nlanguage itself as another high-level tool.\n\nWhy Use Exceptions?\nIn a nutshell, exceptions let us jump out of arbitrarily large chunks of a program. Consider the hypothetical pizza-making robot we discussed earlier in the book. Suppose\nwe took the idea seriously and actually built such a machine. To make a pizza, our\nculinary automaton would need to execute a plan, which we would implement as a\n\n825",
    "Python program: it would take an order, prepare the dough, add toppings, bake the\npie, and so on.\nNow, suppose that something goes very wrong during the “bake the pie” step. Perhaps\nthe oven is broken, or perhaps our robot miscalculates its reach and spontaneously\ncombusts. Clearly, we want to be able to jump to code that handles such states quickly.\nAs we have no hope of finishing the pizza task in such unusual cases, we might as well\nabandon the entire plan.\nThat’s exactly what exceptions let you do: you can jump to an exception handler in a\nsingle step, abandoning all function calls begun since the exception handler was entered. Code in the exception handler can then respond to the raised exception as appropriate (by calling the fire department, for instance!).\nOne way to think of an exception is as a sort of structured “super go to.” An exception\nhandler ( try statement) leaves a marker and executes some code. Somewhere further",
    "single step, abandoning all function calls begun since the exception handler was entered. Code in the exception handler can then respond to the raised exception as appropriate (by calling the fire department, for instance!).\nOne way to think of an exception is as a sort of structured “super go to.” An exception\nhandler ( try statement) leaves a marker and executes some code. Somewhere further\nahead in the program, an exception is raised that makes Python jump back to that\nmarker, abandoning any active functions that were called after the marker was left.\nThis protocol provides a coherent way to respond to unusual events. Moreover, because\nPython jumps to the handler statement immediately, your code is simpler—there is\nusually no need to check status codes after every call to a function that could possibly\nfail.",
    "Exception Roles\nIn Python programs, exceptions are typically used for a variety of purposes. Here are\nsome of their most common roles:\nError handling\nPython raises exceptions whenever it detects errors in programs at runtime. You\ncan catch and respond to the errors in your code, or ignore the exceptions that are\nraised. If an error is ignored, Python’s default exception-handling behavior kicks\nin: it stops the program and prints an error message. If you don’t want this default\nbehavior, code a try statement to catch and recover from the exception—Python\nwill jump to your try handler when the error is detected, and your program will\nresume execution after the try.\nEvent notification\nExceptions can also be used to signal valid conditions without you having to pass\nresult flags around a program or test them explicitly. For instance, a search routine\nmight raise an exception on failure, rather than returning an integer result code\n(and hoping that the code will never be a valid result).",
    "resume execution after the try.\nEvent notification\nExceptions can also be used to signal valid conditions without you having to pass\nresult flags around a program or test them explicitly. For instance, a search routine\nmight raise an exception on failure, rather than returning an integer result code\n(and hoping that the code will never be a valid result).\nSpecial-case handling\nSometimes a condition may occur so rarely that it’s hard to justify convoluting your\ncode to handle it. You can often eliminate special-case code by handling unusual\ncases in exception handlers in higher levels of your program.",
    "826 | Chapter 32: Exception Basics\n\n\fTermination actions\nAs you’ll see, the try/finally statement allows you to guarantee that required\nclosing-time operations will be performed, regardless of the presence or absence\nof exceptions in your programs.\nUnusual control flows\nFinally, because exceptions are a sort of high-level “go to,” you can use them as\nthe basis for implementing exotic control flows. For instance, although the language does not explicitly support backtracking, it can be implemented in Python\nby using exceptions and a bit of support logic to unwind assignments.* There is no\n“go to” statement in Python (thankfully!), but exceptions can sometimes serve\nsimilar roles.\nWe’ll see such typical use cases in action later in this part of the book. For now, let’s\nget started with a look at Python’s exception-processing tools.",
    "Exceptions: The Short Story\nCompared to some other core language topics we’ve met in this book, exceptions are\na fairly lightweight tool in Python. Because they are so simple, let’s jump right into\nsome code.\n\nDefault Exception Handler\nSuppose we write the following function:\n>>> def fetcher(obj, index):\n...\nreturn obj[index]\n...\n\nThere’s not much to this function—it simply indexes an object on a passed-in index.\nIn normal operation, it returns the result of a legal index:\n>>> x = 'spam'\n>>> fetcher(x, 3)\n'm'\n\n# Like x[3]\n\nHowever, if we ask this function to index off the end of the string, an exception will be\ntriggered when the function tries to run obj[index]. Python detects out-of-bounds indexing for sequences and reports it by raising (triggering) the built-in IndexError\nexception:",
    "# Like x[3]\n\nHowever, if we ask this function to index off the end of the string, an exception will be\ntriggered when the function tries to run obj[index]. Python detects out-of-bounds indexing for sequences and reports it by raising (triggering) the built-in IndexError\nexception:\n\n* True backtracking is an advanced topic that is not part of the Python language, so I won’t say much more\nabout it here (even the generator functions and expressions we met in Chapter 20 are not true backtracking—\nthey simply respond to next(G) requests). Roughly, backtracking undoes all computations before it jumps;\nPython exceptions do not (i.e., variables assigned between the time a try statement is entered and the time\nan exception is raised are not reset to their prior values). See a book on artificial intelligence or the Prolog or\nIcon programming languages if you’re curious.\n\nExceptions: The Short Story | 827",
    "Exceptions: The Short Story | 827\n\n\f>>> fetcher(x, 4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 2, in fetcher\nIndexError: string index out of range\n\n# Default handler - shell interface",
    "Because our code does not explicitly catch this exception, it filters back up to the top\nlevel of the program and invokes the default exception handler, which simply prints the\nstandard error message. By this point in the book, you’ve probably seen your share of\nstandard error messages. They include the exception that was raised, along with a stack\ntrace—a list of all the lines and functions that were active when the exception occurred.\nThe error message text here was printed by Python 3.0; it can vary slightly per release,\nand even per interactive shell. When coding interactively in the basic shell interface,\nthe filename is just “<stdin>,” meaning the standard input stream. When working in\nthe IDLE GUI’s interactive shell, the filename is “<pyshell>”, and source lines are displayed, too. Either way, file line numbers are not very meaningful when there is no file\n(we’ll see more interesting error messages later in this part of the book):\n>>> fetcher(x, 4)",
    "the filename is just “<stdin>,” meaning the standard input stream. When working in\nthe IDLE GUI’s interactive shell, the filename is “<pyshell>”, and source lines are displayed, too. Either way, file line numbers are not very meaningful when there is no file\n(we’ll see more interesting error messages later in this part of the book):\n>>> fetcher(x, 4)\n# Default handler - IDLE GUI interface\nTraceback (most recent call last):\nFile \"<pyshell#6>\", line 1, in <module>\nfetcher(x, 4)\nFile \"<pyshell#3>\", line 2, in fetcher\nreturn obj[index]\nIndexError: string index out of range",
    "In a more realistic program launched outside the interactive prompt, after printing an\nerror message the default handler at the top also terminates the program immediately.\nThat course of action makes sense for simple scripts; errors often should be fatal, and\nthe best you can do when they occur is inspect the standard error message.\n\nCatching Exceptions\nSometimes, this isn’t what you want, though. Server programs, for instance, typically\nneed to remain active even after internal errors. If you don’t want the default exception\nbehavior, wrap the call in a try statement to catch exceptions yourself:\n>>> try:\n...\nfetcher(x, 4)\n... except IndexError:\n...\nprint('got exception')\n...\ngot exception\n>>>\n\n# Catch and recover",
    "Catching Exceptions\nSometimes, this isn’t what you want, though. Server programs, for instance, typically\nneed to remain active even after internal errors. If you don’t want the default exception\nbehavior, wrap the call in a try statement to catch exceptions yourself:\n>>> try:\n...\nfetcher(x, 4)\n... except IndexError:\n...\nprint('got exception')\n...\ngot exception\n>>>\n\n# Catch and recover\n\nNow, Python jumps to your handler (the block under the except clause that names the\nexception raised) automatically when an exception is triggered while the try block is\nrunning. When working interactively like this, after the except clause runs, we wind\nup back at the Python prompt. In a more realistic program, try statements not only\ncatch exceptions, but also recover from them:\n828 | Chapter 32: Exception Basics\n\n\f>>> def catcher():\n...\ntry:\n...\nfetcher(x, 4)\n...\nexcept IndexError:\n...\nprint('got exception')\n...\nprint('continuing')\n...\n>>> catcher()\ngot exception\ncontinuing\n>>>",
    ">>> def catcher():\n...\ntry:\n...\nfetcher(x, 4)\n...\nexcept IndexError:\n...\nprint('got exception')\n...\nprint('continuing')\n...\n>>> catcher()\ngot exception\ncontinuing\n>>>\n\nThis time, after the exception is caught and handled, the program resumes execution\nafter the entire try statement that caught it—which is why we get the “continuing”\nmessage here. We don’t see the standard error message, and the program continues on\nits way normally.",
    "This time, after the exception is caught and handled, the program resumes execution\nafter the entire try statement that caught it—which is why we get the “continuing”\nmessage here. We don’t see the standard error message, and the program continues on\nits way normally.\n\nRaising Exceptions\nSo far, we’ve been letting Python raise exceptions for us by making mistakes (on purpose this time!), but our scripts can raise exceptions too—that is, exceptions can be\nraised by Python or by your program, and can be caught or not. To trigger an exception\nmanually, simply run a raise statement. User-triggered exceptions are caught the same\nway as those Python raises. The following may not be the most useful Python code ever\npenned, but it makes the point:\n>>> try:\n...\nraise IndexError\n... except IndexError:\n...\nprint('got exception')\n...\ngot exception\n\n# Trigger exception manually",
    "# Trigger exception manually\n\nAs usual, if they’re not caught, user-triggered exceptions are propagated up to the toplevel default exception handler and terminate the program with a standard error\nmessage:\n>>> raise IndexError\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError\n\nAs we’ll see in the next chapter, the assert statement can be used to trigger exceptions,\ntoo—it’s a conditional raise, used mostly for debugging purposes during development:\n>>> assert False, 'Nobody expects the Spanish Inquisition!'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nAssertionError: Nobody expects the Spanish Inquisition!\n\nExceptions: The Short Story | 829",
    "Exceptions: The Short Story | 829\n\n\fUser-Defined Exceptions\nThe raise statement introduced in the prior section raises a built-in exception defined\nin Python’s built-in scope. As you’ll learn later in this part of the book, you can also\ndefine new exceptions of your own that are specific to your programs. User-defined\nexceptions are coded with classes, which inherit from a built-in exception class: usually\nthe class named Exception. Class-based exceptions allow scripts to build exception\ncategories, inherit behavior, and have attached state information:\n>>> class Bad(Exception):\n...\npass\n...\n>>> def doomed():\n...\nraise Bad()\n...\n>>> try:\n...\ndoomed()\n... except Bad:\n...\nprint('got Bad')\n...\ngot Bad\n>>>\n\n# User-defined exception\n\n# Raise an instance\n\n# Catch class name",
    "# User-defined exception\n\n# Raise an instance\n\n# Catch class name\n\nTermination Actions\nFinally, try statements can say “finally”—that is, they may include finally blocks.\nThese look like except handlers for exceptions, but the try/finally combination specifies termination actions that always execute “on the way out,” regardless of whether\nan exception occurs in the try block:\n>>> try:\n...\nfetcher(x, 3)\n... finally:\n...\nprint('after fetch')\n...\n'm'\nafter fetch\n>>>\n\n# Termination actions\n\nHere, if the try block finishes without an exception, the finally block will run, and\nthe program will resume after the entire try. In this case, this statement seems a bit\nsilly—we might as well have simply typed the print right after a call to the function,\nand skipped the try altogether:\nfetcher(x, 3)\nprint('after fetch')",
    "# Termination actions\n\nHere, if the try block finishes without an exception, the finally block will run, and\nthe program will resume after the entire try. In this case, this statement seems a bit\nsilly—we might as well have simply typed the print right after a call to the function,\nand skipped the try altogether:\nfetcher(x, 3)\nprint('after fetch')\n\nThere is a problem with coding this way, though: if the function call raises an exception,\nthe print will never be reached. The try/finally combination avoids this pitfall—when\nan exception does occur in a try block, finally blocks are executed while the program\nis being unwound:\n\n830 | Chapter 32: Exception Basics\n\n\f>>> def after():\n...\ntry:\n...\nfetcher(x, 4)\n...\nfinally:\n...\nprint('after fetch')\n...\nprint('after try?')\n...\n>>> after()\nafter fetch\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in after\nFile \"<stdin>\", line 2, in fetcher\nIndexError: string index out of range\n>>>",
    "830 | Chapter 32: Exception Basics\n\n\f>>> def after():\n...\ntry:\n...\nfetcher(x, 4)\n...\nfinally:\n...\nprint('after fetch')\n...\nprint('after try?')\n...\n>>> after()\nafter fetch\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in after\nFile \"<stdin>\", line 2, in fetcher\nIndexError: string index out of range\n>>>\n\nHere, we don’t get the “after try?” message because control does not resume after the\ntry/finally block when an exception occurs. Instead, Python jumps back to run the\nfinally action, and then propagates the exception up to a prior handler (in this case,\nto the default handler at the top). If we change the call inside this function so as not to\ntrigger an exception, the finally code still runs, but the program continues after the try:\n>>> def after():\n...\ntry:\n...\nfetcher(x, 3)\n...\nfinally:\n...\nprint('after fetch')\n...\nprint('after try?')\n...\n>>> after()\nafter fetch\nafter try?\n>>>",
    "In practice, try/except combinations are useful for catching and recovering from exceptions, and try/finally combinations come in handy to guarantee that termination\nactions will fire regardless of any exceptions that may occur in the try block’s code.\nFor instance, you might use try/except to catch errors raised by code that you import\nfrom a third-party library, and try/finally to ensure that calls to close files or terminate\nserver connections are always run. We’ll see some such practical examples later in this\npart of the book.\nAlthough they serve conceptually distinct purposes, as of Python 2.5, we can now mix\nexcept and finally clauses in the same try statement—the finally is run on the way\nout regardless of whether an exception was raised, and regardless of whether the exception was caught by an except clause.\nAs we’ll learn in the next chapter, Python 2.6 and 3.0 provide an alternative to try/",
    "part of the book.\nAlthough they serve conceptually distinct purposes, as of Python 2.5, we can now mix\nexcept and finally clauses in the same try statement—the finally is run on the way\nout regardless of whether an exception was raised, and regardless of whether the exception was caught by an except clause.\nAs we’ll learn in the next chapter, Python 2.6 and 3.0 provide an alternative to try/\nfinally when using some types of objects. The with/as statement runs an object’s context management logic to guarantee that termination actions occur:",
    "Exceptions: The Short Story | 831\n\n\f>>> with open('lumberjack.txt', 'w') as file:\n...\nfile.write('The larch!\\n')\n\n# Always close file on exit\n\nAlthough this option requires fewer lines of code, it’s only applicable when processing\ncertain object types, so try/finally is a more general termination structure. On the\nother hand, with/as may also run startup actions and supports user-defined context\nmanagement code.",
    "# Always close file on exit\n\nAlthough this option requires fewer lines of code, it’s only applicable when processing\ncertain object types, so try/finally is a more general termination structure. On the\nother hand, with/as may also run startup actions and supports user-defined context\nmanagement code.\n\nWhy You Will Care: Error Checks\nOne way to see how exceptions are useful is to compare coding styles in Python and\nlanguages without exceptions. For instance, if you want to write robust programs in\nthe C language, you generally have to test return values or status codes after every\noperation that could possibly go astray, and propagate the results of the tests as your\nprograms run:\ndoStuff()\n{\n# C program\nif (doFirstThing() == ERROR) # Detect errors everywhere\nreturn ERROR;\n# even if not handled here\nif (doNextThing() == ERROR)\nreturn ERROR;\n...\nreturn doLastThing();\n}\nmain()\n{\nif (doStuff() == ERROR)\nbadEnding();\nelse\ngoodEnding();\n}",
    "In fact, realistic C programs often have as much code devoted to error detection as to\ndoing actual work. But in Python, you don’t have to be so methodical (and neurotic!).\nYou can instead wrap arbitrarily vast pieces of a program in exception handlers and\nsimply write the parts that do the actual work, assuming all is well:\ndef doStuff():\ndoFirstThing()\ndoNextThing()\n...\ndoLastThing()\n\n# Python code\n# We don't care about exceptions here,\n# so we don't need to detect them\n\nif __name__ == '__main__':\ntry:\ndoStuff()\n# This is where we care about results,\nexcept:\n# so it's the only place we must check\nbadEnding()\nelse:\ngoodEnding()\n\n832 | Chapter 32: Exception Basics",
    "# Python code\n# We don't care about exceptions here,\n# so we don't need to detect them\n\nif __name__ == '__main__':\ntry:\ndoStuff()\n# This is where we care about results,\nexcept:\n# so it's the only place we must check\nbadEnding()\nelse:\ngoodEnding()\n\n832 | Chapter 32: Exception Basics\n\n\fBecause control jumps immediately to a handler when an exception occurs, there’s no\nneed to instrument all your code to guard for errors. Moreover, because Python detects\nerrors automatically, your code usually doesn’t need to check for errors in the first\nplace. The upshot is that exceptions let you largely ignore the unusual cases and avoid\nerror-checking code.",
    "Chapter Summary\nAnd that is the majority of the exception story; exceptions really are a simple tool.\nTo summarize, Python exceptions are a high-level control flow device. They may be\nraised by Python, or by your own programs. In both cases, they may be ignored (to\ntrigger the default error message), or caught by try statements (to be processed by your\ncode). The try statement comes in two logical formats that, as of Python 2.5, can be\ncombined—one that handles exceptions, and one that executes finalization code regardless of whether exceptions occur or not. Python’s raise and assert statements\ntrigger exceptions on demand (both built-ins and new exceptions we define with\nclasses); the with/as statement is an alternative way to ensure that termination actions\nare carried out for objects that support it.\nIn the rest of this part of the book, we’ll fill in some of the details about the statements\ninvolved, examine the other sorts of clauses that can appear under a try, and discuss",
    "trigger exceptions on demand (both built-ins and new exceptions we define with\nclasses); the with/as statement is an alternative way to ensure that termination actions\nare carried out for objects that support it.\nIn the rest of this part of the book, we’ll fill in some of the details about the statements\ninvolved, examine the other sorts of clauses that can appear under a try, and discuss\nclass-based exception objects. The next chapter begins our tour by taking a closer look\nat the statements we introduced here. Before you turn the page, though, here are a few\nquiz questions to review.",
    "Test Your Knowledge: Quiz\n1. Name three things that exception processing is good for.\n2. What happens to an exception if you don’t do anything special to handle it?\n3. How can your script recover from an exception?\n4. Name two ways to trigger exceptions in your script.\n5. Name two ways to specify actions to be run at termination time, whether an exception occurs or not.\n\nTest Your Knowledge: Answers\n1. Exception processing is useful for error handling, termination actions, and event\nnotification. It can also simplify the handling of special cases and can be used to\nimplement alternative control flows. In general, exception processing also cuts\n\nTest Your Knowledge: Answers | 833",
    "down on the amount of error-checking code your program may require—because\nall errors filter up to handlers, you may not need to test the outcome of every\noperation.\n2. Any uncaught exception eventually filters up to the default exception handler Python provides at the top of your program. This handler prints the familiar error\nmessage and shuts down your program.\n3. If you don’t want the default message and shutdown, you can code try/except\nstatements to catch and recover from exceptions that are raised. Once an exception\nis caught, the exception is terminated and your program continues.\n4. The raise and assert statements can be used to trigger an exception, exactly as if\nit had been raised by Python itself. In principle, you can also raise an exception by\nmaking a programming mistake, but that’s not usually an explicit goal!\n5. The try/finally statement can be used to ensure actions are run after a block of",
    "is caught, the exception is terminated and your program continues.\n4. The raise and assert statements can be used to trigger an exception, exactly as if\nit had been raised by Python itself. In principle, you can also raise an exception by\nmaking a programming mistake, but that’s not usually an explicit goal!\n5. The try/finally statement can be used to ensure actions are run after a block of\ncode exits, regardless of whether it raises an exception or not. The with/as statement can also be used to ensure termination actions are run, but only when processing object types that support it.",
    "834 | Chapter 32: Exception Basics\n\n\fCHAPTER 33\n\nException Coding Details",
    "In the prior chapter we took a quick look at exception-related statements in action.\nHere, we’re going to dig a bit deeper—this chapter provides a more formal introduction\nto exception processing syntax in Python. Specifically, we’ll explore the details behind\nthe try, raise, assert, and with statements. As we’ll see, although these statements are\nmostly straightforward, they offer powerful tools for dealing with exceptions in Python\ncode.\nOne procedural note up front: The exception story has changed in major\nways in recent years. As of Python 2.5, the finally clause can appear in\nthe same try statement as except and else clauses (previously, they\ncould not be combined). Also, as of Python 3.0 and 2.6, the new with\ncontext manager statement has become official, and user-defined exceptions must now be coded as class instances, which should inherit",
    "ways in recent years. As of Python 2.5, the finally clause can appear in\nthe same try statement as except and else clauses (previously, they\ncould not be combined). Also, as of Python 3.0 and 2.6, the new with\ncontext manager statement has become official, and user-defined exceptions must now be coded as class instances, which should inherit\nfrom a built-in exception superclass. Moreover, 3.0 sports slightly modified syntax for the raise statement and except clauses. I will focus on\nthe state of exceptions in Python 2.6 and 3.0 in this edition, but because\nyou are still very likely to see the original techniques in code for some\ntime to come, along the way I’ll point out how things have evolved in\nthis domain.",
    "The try/except/else Statement\nNow that we’ve seen the basics, it’s time for the details. In the following discussion,\nI’ll first present try/except/else and try/finally as separate statements, because in\nversions of Python prior to 2.5 they serve distinct roles and cannot be combined. As\nmentioned in the preceding note, in Python 2.5 and later except and finally can be\nmixed in a single try statement; I’ll explain the implications of this change after we’ve\nexplored the two original forms in isolation.\nThe try is a compound statement; its most complete form is sketched below. It starts\nwith a try header line, followed by a block of (usually) indented statements, then one\n\n835\n\n\for more except clauses that identify exceptions to be caught, and an optional else clause\nat the end. The words try, except, and else are associated by indenting them to the\nsame level (i.e., lining them up vertically). For reference, here’s the general format in\nPython 3.0:\ntry:",
    "835\n\n\for more except clauses that identify exceptions to be caught, and an optional else clause\nat the end. The words try, except, and else are associated by indenting them to the\nsame level (i.e., lining them up vertically). For reference, here’s the general format in\nPython 3.0:\ntry:\n\n<statements>\nexcept <name1>:\n<statements>\nexcept (name2, name3):\n<statements>\nexcept <name4> as <data>:\n<statements>\nexcept:\n<statements>\nelse:\n<statements>\n\n# Run this main action first\n# Run if name1 is raised during try block\n# Run if any of these exceptions occur\n# Run if name4 is raised, and get instance raised\n# Run for all (other) exceptions raised\n# Run if no exception was raised during try block",
    "In this statement, the block under the try header represents the main action of the\nstatement—the code you’re trying to run. The except clauses define handlers for exceptions raised during the try block, and the else clause (if coded) provides a handler\nto be run if no exceptions occur. The <data> entry here has to do with a feature of\nraise statements and exception classes, which we will discuss later in this chapter.\nHere’s how try statements work. When a try statement is entered, Python marks the\ncurrent program context so it can return to it if an exception occurs. The statements\nnested under the try header are run first. What happens next depends on whether\nexceptions are raised while the try block’s statements are running:\n• If an exception does occur while the try block’s statements are running, Python\njumps back to the try and runs the statements under the first except clause that\nmatches the raised exception. Control resumes below the entire try statement after",
    "nested under the try header are run first. What happens next depends on whether\nexceptions are raised while the try block’s statements are running:\n• If an exception does occur while the try block’s statements are running, Python\njumps back to the try and runs the statements under the first except clause that\nmatches the raised exception. Control resumes below the entire try statement after\nthe except block runs (unless the except block raises another exception).\n• If an exception happens in the try block and no except clause matches, the exception is propagated up to the last matching try statement that was entered in the\nprogram or, if it’s the first such statement, to the top level of the process (in which\ncase Python kills the program and prints a default error message).\n• If no exception occurs while the statements under the try header run, Python runs\nthe statements under the else line (if present), and control then resumes below the\nentire try statement.",
    "program or, if it’s the first such statement, to the top level of the process (in which\ncase Python kills the program and prints a default error message).\n• If no exception occurs while the statements under the try header run, Python runs\nthe statements under the else line (if present), and control then resumes below the\nentire try statement.\nIn other words, except clauses catch any exceptions that happen while the try block is\nrunning, and the else clause runs only if no exceptions happen while the try block runs.\nexcept clauses are focused exception handlers—they catch exceptions that occur only\nwithin the statements in the associated try block. However, as the try block’s state-",
    "ments can call functions coded elsewhere in a program, the source of an exception may\nbe outside the try statement itself. I’ll have more to say about this when we explore\ntry nesting in Chapter 35.\n836 | Chapter 33: Exception Coding Details",
    "try Statement Clauses\nWhen you write a try statement, a variety of clauses can appear after the try header.\nTable 33-1 summarizes all the possible forms—you must use at least one. We’ve already\nmet some of these: as you know, except clauses catch exceptions, finally clauses run\non the way out, and else clauses run if no exceptions are encountered.\nSyntactically, there may be any number of except clauses, but you can code else only\nif there is at least one except, and there can be only one else and one finally. Through\nPython 2.4, the finally clause must appear alone (without else or except); the try/\nfinally is really a different statement. As of Python 2.5, however, a finally can appear\nin the same statement as except and else (more on the ordering rules later in this chapter\nwhen we meet the unified try statement).\nTable 33-1. try statement clause forms\nClause form\n\nInterpretation\n\nexcept:\n\nCatch all (or all other) exception types.\n\nexcept name:\n\nCatch a specific exception only.",
    "Interpretation\n\nexcept:\n\nCatch all (or all other) exception types.\n\nexcept name:\n\nCatch a specific exception only.\n\nexcept name as value:\n\nCatch the listed exception and its instance.\n\nexcept (name1, name2):\n\nCatch any of the listed exceptions.\n\nexcept (name1, name2) as value:\n\nCatch any listed exception and its instance.\n\nelse:\n\nRun if no exceptions are raised.\n\nfinally:\n\nAlways perform this block.",
    "except (name1, name2) as value:\n\nCatch any listed exception and its instance.\n\nelse:\n\nRun if no exceptions are raised.\n\nfinally:\n\nAlways perform this block.\n\nWe’ll explore the entries with the extra as value part when we meet the raise statement.\nThey provide access to the objects that are raised as exceptions.\nThe first and fourth entries in Table 33-1 are new here:\n• except clauses that list no exception name (except:) catch all exceptions not previously listed in the try statement.\n• except clauses that list a set of exceptions in parentheses (except (e1, e2, e3):)\ncatch any of the listed exceptions.\nBecause Python looks for a match within a given try by inspecting the except clauses\nfrom top to bottom, the parenthesized version has the same effect as listing each exception in its own except clause, but you have to code the statement body only once.\nHere’s an example of multiple except clauses at work, which demonstrates just how\nspecific your handlers can be:\ntry:",
    "action()\nexcept NameError:\n...\nexcept IndexError:\n...\n\nThe try/except/else Statement | 837\n\n\fexcept KeyError:\n...\nexcept (AttributeError, TypeError, SyntaxError):\n...\nelse:\n...\n\nIn this example, if an exception is raised while the call to the action function is running,\nPython returns to the try and searches for the first except that names the exception\nraised. It inspects the except clauses from top to bottom and left to right, and runs the\nstatements under the first one that matches. If none match, the exception is propagated\npast this try. Note that the else runs only when no exception occurs in action—it does\nnot run when an exception without a matching except is raised.\nIf you really want a general “catch-all” clause, an empty except does the trick:\ntry:\n\naction()\nexcept NameError:\n...\nexcept IndexError:\n...\nexcept:\n...\nelse:\n...\n\n# Handle NameError\n# Handle IndexError\n# Handle all other exceptions\n# Handle the no-exception case",
    "action()\nexcept NameError:\n...\nexcept IndexError:\n...\nexcept:\n...\nelse:\n...\n\n# Handle NameError\n# Handle IndexError\n# Handle all other exceptions\n# Handle the no-exception case\n\nThe empty except clause is a sort of wildcard feature—because it catches everything, it\nallows your handlers to be as general or specific as you like. In some scenarios, this\nform may be more convenient than listing all possible exceptions in a try. For example,\nthe following catches everything without listing anything:\ntry:\n\naction()\nexcept:\n...\n\n# Catch all possible exceptions",
    "action()\nexcept:\n...\n\n# Catch all possible exceptions\n\nEmpty excepts also raise some design issues, though. Although convenient, they may\ncatch unexpected system exceptions unrelated to your code, and they may inadvertently intercept exceptions meant for another handler. For example, even system exit\ncalls in Python trigger exceptions, and you usually want these to pass. That said, this\nstructure may also catch genuine programming mistakes for you which you probably\nwant to see an error message. We’ll revisit this as a gotcha at the end of this part of the\nbook. For now, I’ll just say “use with care.”\nPython 3.0 introduced an alternative that solves one of these problems—catching an\nexception named Exception has almost the same effect as an empty except, but ignores\nexceptions related to system exits:\ntry:\n\naction()\nexcept Exception:\n...\n\n# Catch all possible exceptions, except exits\n\n838 | Chapter 33: Exception Coding Details",
    "This has most of the same convenience of the empty except, but also most of the same\ndangers. We’ll explore how this form works its voodoo in the next chapter, when we\nstudy exception classes.\nVersion skew note: Python 3.0 requires the except E as V: handler clause\nform listed in Table 33-1 and used in this book, rather than the older\nexcept E, V: form. The latter form is still available (but not\nrecommended) in Python 2.6: if used, it’s converted to the former. The\nchange was made to eliminate errors that occur when confusing the\nolder form with two alternate exceptions, properly coded in 2.6 as\nexcept (E1, E2):. Because 3.0 supports the as form only, commas in a\nhandler clause are always taken to mean a tuple, regardless of whether\nparentheses are used or not, and the values are interpreted as alternative\nexceptions to be caught. This change also modifies the scoping rules:\nwith the new as syntax, the variable V is deleted at the end of the\nexcept block.",
    "The try else Clause\nThe purpose of the else clause is not always immediately obvious to Python newcomers. Without it, though, there is no way to tell (without setting and checking Boolean\nflags) whether the flow of control has proceeded past a try statement because no exception was raised, or because an exception occurred and was handled:\ntry:\n\n...run code...\nexcept IndexError:\n...handle exception...\n# Did we get here because the try failed or not?\n\nMuch like the way else clauses in loops make the exit cause more apparent, the else\nclause provides syntax in a try that makes what has happened obvious and\nunambiguous:\ntry:\n\n...run code...\nexcept IndexError:\n...handle exception...\nelse:\n...no exception occurred...\n\nYou can almost emulate an else clause by moving its code into the try block:\ntry:\n\n...run code...\n...no exception occurred...\nexcept IndexError:\n...handle exception...",
    "...run code...\nexcept IndexError:\n...handle exception...\nelse:\n...no exception occurred...\n\nYou can almost emulate an else clause by moving its code into the try block:\ntry:\n\n...run code...\n...no exception occurred...\nexcept IndexError:\n...handle exception...\n\nThis can lead to incorrect exception classifications, though. If the “no exception occurred” action triggers an IndexError, it will register as a failure of the try block and\nThe try/except/else Statement | 839\n\n\ferroneously trigger the exception handler below the try (subtle, but true!). By using an\nexplicit else clause instead, you make the logic more obvious and guarantee that\nexcept handlers will run only for real failures in the code you’re wrapping in a try, not\nfor failures in the else case’s action.",
    "erroneously trigger the exception handler below the try (subtle, but true!). By using an\nexplicit else clause instead, you make the logic more obvious and guarantee that\nexcept handlers will run only for real failures in the code you’re wrapping in a try, not\nfor failures in the else case’s action.\n\nExample: Default Behavior\nBecause the control flow through a program is easier to capture in Python than in\nEnglish, let’s run some examples that further illustrate exception basics. I’ve mentioned\nthat exceptions not caught by try statements percolate up to the top level of the Python\nprocess and run Python’s default exception-handling logic (i.e., Python terminates the\nrunning program and prints a standard error message). Let’s look at an example. Running the following module file, bad.py, generates a divide-by-zero exception:\ndef gobad(x, y):\nreturn x / y\ndef gosouth(x):\nprint(gobad(x, 0))\ngosouth(1)",
    "Because the program ignores the exception it triggers, Python kills the program and\nprints a message:\n% python bad.py\nTraceback (most recent call last):\nFile \"bad.py\", line 7, in <module>\ngosouth(1)\nFile \"bad.py\", line 5, in gosouth\nprint(gobad(x, 0))\nFile \"bad.py\", line 2, in gobad\nreturn x / y\nZeroDivisionError: int division or modulo by zero",
    "I ran this in a shell widow with Python 3.0. The message consists of a stack trace\n(“Traceback”) and the name of and details about the exception that was raised. The\nstack trace lists all lines active when the exception occurred, from oldest to newest.\nNote that because we’re not working at the interactive prompt, in this case the file and\nline number information is more useful. For example, here we can see that the bad\ndivide happens at the last entry in the trace—line 2 of the file bad.py, a return\nstatement.*\nBecause Python detects and reports all errors at runtime by raising exceptions, exceptions are intimately bound up with the ideas of error handling and debugging in general.\n* As mentioned in the prior chapter, the text of error messages and stack traces tends to vary slightly over time\nand shells. Don’t be alarmed if your error messages don’t exactly match mine. When I ran this example in",
    "Because Python detects and reports all errors at runtime by raising exceptions, exceptions are intimately bound up with the ideas of error handling and debugging in general.\n* As mentioned in the prior chapter, the text of error messages and stack traces tends to vary slightly over time\nand shells. Don’t be alarmed if your error messages don’t exactly match mine. When I ran this example in\nPython 3.0’s IDLE GUI, for instance, its error message text showed filenames with full absolute directory\npaths.",
    "840 | Chapter 33: Exception Coding Details\n\n\fIf you’ve worked through this book’s examples, you’ve undoubtedly seen an exception\nor two along the way—even typos usually generate a SyntaxError or other exception\nwhen a file is imported or executed (that’s when the compiler is run). By default, you\nget a useful error display like the one just shown, which helps you track down the\nproblem.\nOften, this standard error message is all you need to resolve problems in your code.\nFor more heavy-duty debugging jobs, you can catch exceptions with try statements,\nor use one of the debugging tools that I introduced in Chapter 3 and will summarize\nagain in Chapter 35 (such as the pdb standard library module).",
    "Example: Catching Built-in Exceptions\nPython’s default exception handling is often exactly what you want—especially for\ncode in a top-level script file, an error generally should terminate your program immediately. For many programs, there is no need to be more specific about errors in your\ncode.\nSometimes, though, you’ll want to catch errors and recover from them instead. If you\ndon’t want your program terminated when Python raises an exception, simply catch it\nby wrapping the program logic in a try. This is an important capability for programs\nsuch as network servers, which must keep running persistently. For example, the following code catches and recovers from the TypeError Python raises immediately when\nyou try to concatenate a list and a string (the + operator expects the same sequence type\non both sides):\ndef kaboom(x, y):\nprint(x + y)\n\n# Trigger TypeError\n\ntry:\n\nkaboom([0,1,2], \"spam\")\nexcept TypeError:\nprint('Hello world!')\nprint('resuming here')",
    "# Trigger TypeError\n\ntry:\n\nkaboom([0,1,2], \"spam\")\nexcept TypeError:\nprint('Hello world!')\nprint('resuming here')\n\n# Catch and recover here\n# Continue here if exception or not\n\nWhen the exception occurs in the function kaboom, control jumps to the try statement’s\nexcept clause, which prints a message. Since an exception is “dead” after it’s been\ncaught like this, the program continues executing below the try rather than being terminated by Python. In effect, the code processes and clears the error, and your script\nrecovers:\n% python kaboom.py\nHello world!\nresuming here\n\nNotice that once you’ve caught an error, control resumes at the place where you caught\nit (i.e., after the try); there is no direct way to go back to the place where the exception\noccurred (here, in the function kaboom). In a sense, this makes exceptions more like\n\nThe try/except/else Statement | 841\n\n\fsimple jumps than function calls—there is no way to return to the code that triggered\nthe error.",
    "The try/except/else Statement | 841\n\n\fsimple jumps than function calls—there is no way to return to the code that triggered\nthe error.\n\nThe try/finally Statement\nThe other flavor of the try statement is a specialization that has to do with finalization\nactions. If a finally clause is included in a try, Python will always run its block of\nstatements “on the way out” of the try statement, whether an exception occurred while\nthe try block was running or not. Its general form is:\ntry:\n\n<statements>\nfinally:\n<statements>\n\n# Run this action first\n# Always run this code on the way out",
    "With this variant, Python begins by running the statement block associated with the\ntry header line. What happens next depends on whether an exception occurs during\nthe try block:\n• If no exception occurs while the try block is running, Python jumps back to run\nthe finally block and then continues execution past below the try statement.\n• If an exception does occur during the try block’s run, Python still comes back and\nruns the finally block, but it then propagates the exception up to a higher try or\nthe top-level default handler; the program does not resume execution below the\ntry statement. That is, the finally block is run even if an exception is raised, but\nunlike an except, the finally does not terminate the exception—it continues being\nraised after the finally block runs.\nThe try/finally form is useful when you want to be completely sure that an action will\nhappen after some code runs, regardless of the exception behavior of the program. In",
    "try statement. That is, the finally block is run even if an exception is raised, but\nunlike an except, the finally does not terminate the exception—it continues being\nraised after the finally block runs.\nThe try/finally form is useful when you want to be completely sure that an action will\nhappen after some code runs, regardless of the exception behavior of the program. In\npractice, it allows you to specify cleanup actions that always must occur, such as file\ncloses and server disconnects.\nNote that the finally clause cannot be used in the same try statement as except and\nelse in Python 2.4 and earlier, so the try/finally is best thought of as a distinct statement form if you are using an older release. In Python 2.5, and later, however,\nfinally can appear in the same statement as except and else, so today there is really a\nsingle try statement with many optional clauses (more about this shortly). Whichever",
    "else in Python 2.4 and earlier, so the try/finally is best thought of as a distinct statement form if you are using an older release. In Python 2.5, and later, however,\nfinally can appear in the same statement as except and else, so today there is really a\nsingle try statement with many optional clauses (more about this shortly). Whichever\nversion you use, though, the finally clause still serves the same purpose—to specify\n“cleanup” actions that must always be run, regardless of any exceptions.\nAs we’ll also see later in this chapter, in Python 2.6 and 3.0, the new\nwith statement and its context managers provide an object-based way\nto do similar work for exit actions. Unlike finally, this new statement\nalso supports entry actions, but it is limited in scope to objects that\nimplement the context manager protocol.",
    "842 | Chapter 33: Exception Coding Details\n\n\fExample: Coding Termination Actions with try/finally\nWe saw some simple try/finally examples in the prior chapter. Here’s a more realistic\nexample that illustrates a typical role for this statement:\nclass MyError(Exception): pass\ndef stuff(file):\nraise MyError()\nfile = open('data', 'w')\ntry:\nstuff(file)\nfinally:\nfile.close()\nprint('not reached')\n\n# Open an output file\n# Raises exception\n# Always close file to flush output buffers\n# Continue here only if no exception",
    "In this code, we’ve wrapped a call to a file-processing function in a try with a\nfinally clause to make sure that the file is always closed, and thus finalized, whether\nthe function triggers an exception or not. This way, later code can be sure that the file’s\noutput buffer’s content has been flushed from memory to disk. A similar code structure\ncan guarantee that server connections are closed, and so on.\nAs we learned in Chapter 9, file objects are automatically closed on garbage collection;\nthis is especially useful for temporary files that we don’t assign to variables. However,\nit’s not always easy to predict when garbage collection will occur, especially in larger\nprograms. The try statement makes file closes more explicit and predictable and pertains to a specific block of code. It ensures that the file will be closed on block exit,\nregardless of whether an exception occurs or not.\nThis particular example’s function isn’t all that useful (it just raises an exception), but",
    "programs. The try statement makes file closes more explicit and predictable and pertains to a specific block of code. It ensures that the file will be closed on block exit,\nregardless of whether an exception occurs or not.\nThis particular example’s function isn’t all that useful (it just raises an exception), but\nwrapping calls in try/finally statements is a good way to ensure that your closing-time\n(i.e., termination) activities always run. Again, Python always runs the code in your\nfinally blocks, regardless of whether an exception happens in the try block.†\nWhen the function here raises its exception, the control flow jumps back and runs the\nfinally block to close the file. The exception is then propagated on to either another\ntry or the default top-level handler, which prints the standard error message and shuts\ndown the program; the statement after this try is never reached. If the function here",
    "When the function here raises its exception, the control flow jumps back and runs the\nfinally block to close the file. The exception is then propagated on to either another\ntry or the default top-level handler, which prints the standard error message and shuts\ndown the program; the statement after this try is never reached. If the function here\ndid not raise an exception, the program would still execute the finally block to close\nthe file, but it would then continue below the entire try statement.\nNotice that the user-defined exception here is again defined with a class—as we’ll see\nin the next chapter, exceptions today must all be class instances in both 2.6 and 3.0.",
    "† Unless Python crashes completely, of course. It does a good job of avoiding this, though, by checking all\npossible errors as a program runs. When a program does crash hard, it is usually due to a bug in linked-in C\nextension code, outside of Python’s scope.\n\nThe try/finally Statement | 843",
    "The try/finally Statement | 843\n\n\fUnified try/except/finally\nIn all versions of Python prior to Release 2.5 (for its first 15 years of life, more or less),\nthe try statement came in two flavors and was really two separate statements—we\ncould either use a finally to ensure that cleanup code was always run, or write\nexcept blocks to catch and recover from specific exceptions and optionally specify an\nelse clause to be run if no exceptions occurred.\nThat is, the finally clause could not be mixed with except and else. This was partly\nbecause of implementation issues, and partly because the meaning of mixing the two\nseemed obscure—catching and recovering from exceptions seemed a disjoint concept\nfrom performing cleanup actions.\nIn Python 2.5 and later, though (including 2.6 and 3.0, the versions used in this book),\nthe two statements have merged. Today, we can mix finally, except, and else clauses\nin the same statement. That is, we can now write a statement of this form:\ntry:",
    "# Merged form\n\nmain-action\nexcept Exception1:\nhandler1\nexcept Exception2:\nhandler2\n...\nelse:\nelse-block\nfinally:\nfinally-block",
    "The code in this statement’s main-action block is executed first, as usual. If that code\nraises an exception, all the except blocks are tested, one after another, looking for a\nmatch to the exception raised. If the exception raised is Exception1, the handler1 block\nis executed; if it’s Exception2, handler2 is run, and so on. If no exception is raised, the\nelse-block is executed.\nNo matter what’s happened previously, the finally-block is executed once the main\naction block is complete and any raised exceptions have been handled. In fact, the code\nin the finally-block will be run even if there is an error in an exception handler or the\nelse-block and a new exception is raised.\nAs always, the finally clause does not end the exception—if an exception is active\nwhen the finally-block is executed, it continues to be propagated after the finallyblock runs, and control jumps somewhere else in the program (to another try, or to",
    "in the finally-block will be run even if there is an error in an exception handler or the\nelse-block and a new exception is raised.\nAs always, the finally clause does not end the exception—if an exception is active\nwhen the finally-block is executed, it continues to be propagated after the finallyblock runs, and control jumps somewhere else in the program (to another try, or to\nthe default top-level handler). If no exception is active when the finally is run, control\nresumes after the entire try statement.\nThe net effect is that the finally is always run, regardless of whether:\n• An exception occurred in the main action and was handled.\n• An exception occurred in the main action and was not handled.\n844 | Chapter 33: Exception Coding Details",
    "• No exceptions occurred in the main action.\n• A new exception was triggered in one of the handlers.\nAgain, the finally serves to specify cleanup actions that must always occur on the way\nout of the try, regardless of what exceptions have been raised or handled.\n\nUnified try Statement Syntax\nWhen combined like this, the try statement must have either an except or a finally,\nand the order of its parts must be like this:\ntry -> except -> else -> finally\n\nwhere the else and finally are optional, and there may be zero or more except, but\nthere must be at least one except if an else appears. Really, the try statement consists\nof two parts: excepts with an optional else, and/or the finally.\nIn fact, it’s more accurate to describe the merged statement’s syntactic form this way\n(square brackets mean optional and star means zero-or-more here):\ntry:\n\nstatements\nexcept [type [as value]]:\nstatements\n[except [type [as value]]:\nstatements]*\n[else:\nstatements]\n[finally:\nstatements]\ntry:",
    "statements\nexcept [type [as value]]:\nstatements\n[except [type [as value]]:\nstatements]*\n[else:\nstatements]\n[finally:\nstatements]\ntry:\n\n# Format 1\n# [type [, value]] in Python 2\n\n# Format 2\n\nstatements\nfinally:\nstatements\n\nBecause of these rules, the else can appear only if there is at least one except, and it’s\nalways possible to mix except and finally, regardless of whether an else appears or\nnot. It’s also possible to mix finally and else, but only if an except appears too (though\nthe except can omit an exception name to catch everything and run a raise statement,\ndescribed later, to reraise the current exception). If you violate any of these ordering\nrules, Python will raise a syntax error exception before your code runs.",
    "Combining finally and except by Nesting\nPrior to Python 2.5, it is actually possible to combine finally and except clauses in a\ntry by syntactically nesting a try/except in the try block of a try/finally statement\n(we’ll explore this technique more fully in Chapter 35). In fact, the following has the\nsame effect as the new merged form shown at the start of this section:\n\nUnified try/except/finally | 845\n\n\f# Nested equivalent to merged form\n\ntry:\n\ntry:\n\nmain-action\nexcept Exception1:\nhandler1\nexcept Exception2:\nhandler2\n...\nelse:\nno-error\nfinally:\ncleanup",
    "Unified try/except/finally | 845\n\n\f# Nested equivalent to merged form\n\ntry:\n\ntry:\n\nmain-action\nexcept Exception1:\nhandler1\nexcept Exception2:\nhandler2\n...\nelse:\nno-error\nfinally:\ncleanup\n\nAgain, the finally block is always run on the way out, regardless of what happened in\nthe main action and regardless of any exception handlers run in the nested try (trace\nthrough the four cases listed previously to see how this works the same). Since an\nelse always requires an except, this nested form even sports the same mixing constraints of the unified statement form outlined in the preceding section.\nHowever, this nested equivalent is more obscure and requires more code than the new\nmerged form (one four-character line, at least). Mixing finally into the same statement\nmakes your code easier to write and read, so this is the generally preferred technique\ntoday.",
    "Unified try Example\nHere’s a demonstration of the merged try statement form at work. The following file,\nmergedexc.py, codes four common scenarios, with print statements that describe the\nmeaning of each:\nsep = '-' * 32 + '\\n'\nprint(sep + 'EXCEPTION RAISED AND CAUGHT')\ntry:\nx = 'spam'[99]\nexcept IndexError:\nprint('except run')\nfinally:\nprint('finally run')\nprint('after run')\nprint(sep + 'NO EXCEPTION RAISED')\ntry:\nx = 'spam'[3]\nexcept IndexError:\nprint('except run')\nfinally:\nprint('finally run')\nprint('after run')\nprint(sep + 'NO EXCEPTION RAISED, WITH ELSE')\ntry:\n\n846 | Chapter 33: Exception Coding Details\n\n\fx = 'spam'[3]\nexcept IndexError:\nprint('except run')\nelse:\nprint('else run')\nfinally:\nprint('finally run')\nprint('after run')\nprint(sep + 'EXCEPTION RAISED BUT NOT CAUGHT')\ntry:\nx = 1 / 0\nexcept IndexError:\nprint('except run')\nfinally:\nprint('finally run')\nprint('after run')",
    "When this code is run, the following output is produced in Python 3.0 (actually, its\nbehavior and output are the same in 2.6, because the print calls each print a single\nitem). Trace through the code to see how exception handling produces the output of\neach of the four tests here:\nc:\\misc> C:\\Python30\\python mergedexc.py\n-------------------------------EXCEPTION RAISED AND CAUGHT\nexcept run\nfinally run\nafter run\n-------------------------------NO EXCEPTION RAISED\nfinally run\nafter run\n-------------------------------NO EXCEPTION RAISED, WITH ELSE\nelse run\nfinally run\nafter run\n-------------------------------EXCEPTION RAISED BUT NOT CAUGHT\nfinally run\nTraceback (most recent call last):\nFile \"mergedexc.py\", line 36, in <module>\nx = 1 / 0\nZeroDivisionError: int division or modulo by zero",
    "This example uses built-in operations in the main action to trigger exceptions (or not),\nand it relies on the fact that Python always checks for errors as code is running. The\nnext section shows how to raise exceptions manually instead.\n\nUnified try/except/finally | 847\n\n\fThe raise Statement\nTo trigger exceptions explicitly, you can code raise statements. Their general form is\nsimple—a raise statement consists of the word raise, optionally followed by the class\nto be raised or an instance of it:\nraise <instance>\nraise <class>\nraise\n\n# Raise instance of class\n# Make and raise instance of class\n# Reraise the most recent exception",
    "# Raise instance of class\n# Make and raise instance of class\n# Reraise the most recent exception\n\nAs mentioned earlier, exceptions are always instances of classes in Python 2.6 and 3.0.\nHence, the first raise form here is the most common—we provide an instance directly,\neither created before the raise or within the raise statement itself. If we pass a class\ninstead, Python calls the class with no constructor arguments, to create an instance to\nbe raised; this form is equivalent to adding parentheses after the class reference. The\nlast form reraises the most recently raised exception; it’s commonly used in exception\nhandlers to propagate exceptions that have been caught.\nTo make this clearer, let’s look at some examples. With built-in exceptions, the following two forms are equivalent—both raise an instance of the exception class named,\nbut the first creates the instance implicitly:\nraise IndexError\nraise IndexError()\n\n# Class (instance created)\n# Instance (created in statement)",
    "# Class (instance created)\n# Instance (created in statement)\n\nWe can also create the instance ahead of time—because the raise statement accepts\nany kind of object reference, the following two examples raise IndexError just like the\nprior two:\nexc = IndexError()\nraise exc\n\n# Create instance ahead of time\n\nexcs = [IndexError, TypeError]\nraise excs[0]\n\nWhen an exception is raised, Python sends the raised instance along with the exception.\nIf a try includes an except name as X: clause, the variable X will be assigned the instance\nprovided in the raise:\ntry:\n\n...\nexcept IndexError as X:\n...\n\n# X assigned the raised instance object",
    "# Create instance ahead of time\n\nexcs = [IndexError, TypeError]\nraise excs[0]\n\nWhen an exception is raised, Python sends the raised instance along with the exception.\nIf a try includes an except name as X: clause, the variable X will be assigned the instance\nprovided in the raise:\ntry:\n\n...\nexcept IndexError as X:\n...\n\n# X assigned the raised instance object\n\nThe as is optional in a try handler (if it’s omitted, the instance is simply not assigned\nto a name), but including it allows the handler to access both data in the instance and\nmethods in the exception class.\nThis model works the same for user-defined exceptions we code with classes—the\nfollowing, for example, passes to the exception class constructor arguments that become available in the handler through the assigned instance:\n\n848 | Chapter 33: Exception Coding Details",
    "848 | Chapter 33: Exception Coding Details\n\n\fclass MyExc(Exception): pass\n...\nraise MyExc('spam')\n# Exception class with constructor args\n...\ntry:\n...\nexcept MyExc as X:\n# Instance attributes available in handler\nprint(X.args)\n\nBecause this encroaches on the next chapter’s topic, though, I’ll defer further details\nuntil then.\nRegardless of how you name them, exceptions are always identified by instance objects,\nand at most one is active at any given time. Once caught by an except clause anywhere\nin the program, an exception dies (i.e., won’t propagate to another try), unless it’s\nreraised by another raise statement or error.",
    "Propagating Exceptions with raise\nA raise statement that does not include an exception name or extra data value simply\nreraises the current exception. This form is typically used if you need to catch and\nhandle an exception but don’t want the exception to die in your code:\n>>> try:\n...\nraise IndexError('spam')\n... except IndexError:\n...\nprint('propagating')\n...\nraise\n...\npropagating\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nIndexError: spam\n\n# Exceptions remember arguments\n# Reraise most recent exception\n\nRunning a raise this way reraises the exception and propagates it to a higher handler\n(or the default handler at the top, which stops the program with a standard error message). Notice how the argument we passed to the exception class shows up in the error\nmessages; you’ll learn why this happens in the next chapter.",
    "# Exceptions remember arguments\n# Reraise most recent exception\n\nRunning a raise this way reraises the exception and propagates it to a higher handler\n(or the default handler at the top, which stops the program with a standard error message). Notice how the argument we passed to the exception class shows up in the error\nmessages; you’ll learn why this happens in the next chapter.\n\nPython 3.0 Exception Chaining: raise from\nPython 3.0 (but not 2.6) also allows raise statements to have an optional from clause:\nraise exception from otherexception\n\nWhen the from is used, the second expression specifies another exception class or instance to attach to the raised exception’s __cause__ attribute. If the raised exception is\nnot caught, Python prints both exceptions as part of the standard error message:\n>>> try:\n...\n1 / 0\n... except Exception as E:\n\nThe raise Statement | 849",
    "When the from is used, the second expression specifies another exception class or instance to attach to the raised exception’s __cause__ attribute. If the raised exception is\nnot caught, Python prints both exceptions as part of the standard error message:\n>>> try:\n...\n1 / 0\n... except Exception as E:\n\nThe raise Statement | 849\n\n\f...\nraise TypeError('Bad!') from E\n...\nTraceback (most recent call last):\nFile \"<stdin>\", line 2, in <module>\nZeroDivisionError: int division or modulo by zero\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\nFile \"<stdin>\", line 4, in <module>\nTypeError: Bad!",
    "When an exception is raised inside an exception handler, a similar procedure is followed implicitly: the previous exception is attached to the new exception’s\n__context__ attribute and is again displayed in the standard error message if the exception goes uncaught. This is an advanced and still somewhat obscure extension, so\nsee Python’s manuals for more details.\nVersion skew note: Python 3.0 no longer supports the raise Exc, Args\nform that is still available in Python 2.6. In 3.0, use the raise\nExc(Args) instance-creation call form described in this book instead.\nThe equivalent comma form in 2.6 is legacy syntax provided for compatibility with the now defunct string-based exceptions model, and it’s\ndeprecated in 3.0. If used, it is converted to the 3.0 call form. As in earlier\nreleases, a raise Exc form is also allowed—it is converted to raise\nExc() in both versions, calling the class constructor with no arguments.",
    "The assert Statement\nAs a somewhat special case for debugging purposes, Python includes the assert statement. It is mostly just syntactic shorthand for a common raise usage pattern, and an\nassert can be thought of as a conditional raise statement. A statement of the form:\nassert <test>, <data>\n\n# The <data> part is optional\n\nworks like the following code:\nif __debug__:\nif not <test>:\nraise AssertionError(<data>)",
    "# The <data> part is optional\n\nworks like the following code:\nif __debug__:\nif not <test>:\nraise AssertionError(<data>)\n\nIn other words, if the test evaluates to false, Python raises an exception: the data item\n(if it’s provided) is used as the exception’s constructor argument. Like all exceptions,\nthe AssertionError exception will kill your program if it’s not caught with a try, in\nwhich case the data item shows up as part of the error message.\nAs an added feature, assert statements may be removed from a compiled program’s\nbyte code if the -O Python command-line flag is used, thereby optimizing the program.\nAssertionError is a built-in exception, and the __debug__ flag is a built-in name that is\n\n850 | Chapter 33: Exception Coding Details\n\n\fautomatically set to True unless the -O flag is used. Use a command line like python –O\nmain.py to run in optimized mode and disable asserts.",
    "850 | Chapter 33: Exception Coding Details\n\n\fautomatically set to True unless the -O flag is used. Use a command line like python –O\nmain.py to run in optimized mode and disable asserts.\n\nExample: Trapping Constraints (but Not Errors!)\nAssertions are typically used to verify program conditions during development. When\ndisplayed, their error message text automatically includes source code line information\nand the value listed in the assert statement. Consider the file asserter.py:\ndef f(x):\nassert x < 0, 'x must be negative'\nreturn x ** 2\n% python\n>>> import asserter\n>>> asserter.f(1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"asserter.py\", line 2, in f\nassert x < 0, 'x must be negative'\nAssertionError: x must be negative",
    "It’s important to keep in mind that assert is mostly intended for trapping user-defined\nconstraints, not for catching genuine programming errors. Because Python traps programming errors itself, there is usually no need to code asserts to catch things like outof-bounds indexes, type mismatches, and zero divides:\ndef reciprocal(x):\nassert x != 0\nreturn 1 / x\n\n# A useless assert!\n# Python checks for zero automatically\n\nSuch asserts are generally superfluous—because Python raises exceptions on errors\nautomatically, you might as well let it do the job for you.‡ For another example of\ncommon assert usage, see the abstract superclass example in Chapter 28; there, we\nused assert to make calls to undefined methods fail with a message.",
    "# A useless assert!\n# Python checks for zero automatically\n\nSuch asserts are generally superfluous—because Python raises exceptions on errors\nautomatically, you might as well let it do the job for you.‡ For another example of\ncommon assert usage, see the abstract superclass example in Chapter 28; there, we\nused assert to make calls to undefined methods fail with a message.\n\nwith/as Context Managers\nPython 2.6 and 3.0 introduced a new exception-related statement—the with, and its\noptional as clause. This statement is designed to work with context manager objects,\nwhich support a new method-based protocol. This feature is also available as an option\nin 2.5, enabled with an import of this form:\nfrom __future__ import with_statement",
    "with/as Context Managers\nPython 2.6 and 3.0 introduced a new exception-related statement—the with, and its\noptional as clause. This statement is designed to work with context manager objects,\nwhich support a new method-based protocol. This feature is also available as an option\nin 2.5, enabled with an import of this form:\nfrom __future__ import with_statement\n\n‡ In most cases, at least. As suggested earlier in the book, if a function has to perform long-running or\nunrecoverable actions before it reaches the place where an exception will be triggered, you still might want\nto test for errors. Even in this case, though, be careful not to make your tests overly specific or restrictive, or\nyou will limit your code’s utility.\n\nwith/as Context Managers | 851",
    "with/as Context Managers | 851\n\n\fIn short, the with/as statement is designed to be an alternative to a common try/\nfinally usage idiom; like that statement, it is intended for specifying termination-time\nor “cleanup” activities that must run regardless of whether an exception occurs in a\nprocessing step. Unlike try/finally, though, the with statement supports a richer\nobject-based protocol for specifying both entry and exit actions around a block of code.\nPython enhances some built-in tools with context managers, such as files that automatically close themselves and thread locks that automatically lock and unlock, but\nprogrammers can code context managers of their own with classes, too.\n\nBasic Usage\nThe basic format of the with statement looks like this:\nwith expression [as variable]:\nwith-block",
    "The expression here is assumed to return an object that supports the context management protocol (more on this protocol in a moment). This object may also return a value\nthat will be assigned to the name variable if the optional as clause is present.\nNote that the variable is not necessarily assigned the result of the expression; the result\nof the expression is the object that supports the context protocol, and the variable may\nbe assigned something else intended to be used inside the statement. The object returned by the expression may then run startup code before the with-block is started,\nas well as termination code after the block is done, regardless of whether the block\nraised an exception or not.\nSome built-in Python objects have been augmented to support the context management\nprotocol, and so can be used with the with statement. For example, file objects (covered\nin Chapter 9) have a context manager that automatically closes the file after the with",
    "as well as termination code after the block is done, regardless of whether the block\nraised an exception or not.\nSome built-in Python objects have been augmented to support the context management\nprotocol, and so can be used with the with statement. For example, file objects (covered\nin Chapter 9) have a context manager that automatically closes the file after the with\nblock regardless of whether an exception is raised:\nwith open(r'C:\\misc\\data') as myfile:\nfor line in myfile:\nprint(line)\n...more code here...",
    "Here, the call to open returns a simple file object that is assigned to the name myfile.\nWe can use myfile with the usual file tools—in this case, the file iterator reads line by\nline in the for loop.\nHowever, this object also supports the context management protocol used by the\nwith statement. After this with statement has run, the context management machinery\nguarantees that the file object referenced by myfile is automatically closed, even if the\nfor loop raised an exception while processing the file.\nAlthough file objects are automatically closed on garbage collection, it’s not always\nstraightforward to know when that will occur. The with statement in this role is an\nalternative that allows us to be sure that the close will occur after execution of a specific\n852 | Chapter 33: Exception Coding Details",
    "block of code. As we saw earlier, we can achieve a similar effect with the more general\nand explicit try/finally statement, but it requires four lines of administrative code\ninstead of one in this case:\nmyfile = open(r'C:\\misc\\data')\ntry:\nfor line in myfile:\nprint(line)\n...more code here...\nfinally:\nmyfile.close()\n\nWe won’t cover Python’s multithreading modules in this book (for more on that topic,\nsee follow-up application-level texts such as Programming Python), but the lock and\ncondition synchronization objects they define may also be used with the with statement,\nbecause they support the context management protocol:\nlock = threading.Lock()\nwith lock:\n# critical section of code\n...access shared resources...",
    "Here, the context management machinery guarantees that the lock is automatically\nacquired before the block is executed and released once the block is complete, regardless of exception outcomes.\nAs introduced in Chapter 5, the decimal module also uses context managers to simplify\nsaving and restoring the current decimal context, which specifies the precision and\nrounding characteristics for calculations:\nwith decimal.localcontext() as ctx:\nctx.prec = 2\nx = decimal.Decimal('1.00') / decimal.Decimal('3.00')\n\nAfter this statement runs, the current thread’s context manager state is automatically\nrestored to what it was before the statement began. To do the same with a try/\nfinally, we would need to save the context before and restore it manually.",
    "After this statement runs, the current thread’s context manager state is automatically\nrestored to what it was before the statement began. To do the same with a try/\nfinally, we would need to save the context before and restore it manually.\n\nThe Context Management Protocol\nAlthough some built-in types come with context managers, we can also write new ones\nof our own. To implement context managers, classes use special methods that fall into\nthe operator overloading category to tap into the with statement. The interface expected\nof objects used in with statements is somewhat complex, and most programmers only\nneed to know how to use existing context managers. For tool builders who might want\nto write new application-specific context managers, though, let’s take a quick look at\nwhat’s involved.\nHere’s how the with statement actually works:\n\nwith/as Context Managers | 853",
    "1. The expression is evaluated, resulting in an object known as a context manager that\nmust have __enter__ and __exit__ methods.\n2. The context manager’s __enter__ method is called. The value it returns is assigned\nto the variable in the as clause if present, or simply discarded otherwise.\n3. The code in the nested with block is executed.\n4. If the with block raises an exception, the __exit__(type, value, traceback) method\nis called with the exception details. Note that these are the same values returned\nby sys.exc_info, described in the Python manuals and later in this part of the book.\nIf this method returns a false value, the exception is reraised; otherwise, the exception is terminated. The exception should normally be reraised so that it is\npropagated outside the with statement.\n5. If the with block does not raise an exception, the __exit__ method is still called,\nbut its type, value, and traceback arguments are all passed in as None.",
    "If this method returns a false value, the exception is reraised; otherwise, the exception is terminated. The exception should normally be reraised so that it is\npropagated outside the with statement.\n5. If the with block does not raise an exception, the __exit__ method is still called,\nbut its type, value, and traceback arguments are all passed in as None.\nLet’s look at a quick demo of the protocol in action. The following defines a context\nmanager object that traces the entry and exit of the with block in any with statement it\nis used for:\nclass TraceBlock:\ndef message(self, arg):\nprint('running', arg)\ndef __enter__(self):\nprint('starting with block')\nreturn self\ndef __exit__(self, exc_type, exc_value, exc_tb):\nif exc_type is None:\nprint('exited normally\\n')\nelse:\nprint('raise an exception!', exc_type)\nreturn False",
    "# Propagate\n\nwith TraceBlock() as action:\naction.message('test 1')\nprint('reached')\nwith TraceBlock() as action:\naction.message('test 2')\nraise TypeError\nprint('not reached')\n\nNotice that this class’s __exit__ method returns False to propagate the exception;\ndeleting the return statement would have the same effect, as the default None return\nvalue of functions is False by definition. Also notice that the __enter__ method returns\nself as the object to assign to the as variable; in other use cases, this might return a\ncompletely different object instead.\nWhen run, the context manager traces the entry and exit of the with statement block\nwith its __enter__ and __exit__ methods. Here’s the script in action being run under\nPython 3.0 (it runs in 2.6, too, but prints some extra tuple parentheses):\n\n854 | Chapter 33: Exception Coding Details",
    "854 | Chapter 33: Exception Coding Details\n\n\f% python withas.py\nstarting with block\nrunning test 1\nreached\nexited normally\nstarting with block\nrunning test 2\nraise an exception! <class 'TypeError'>\nTraceback (most recent call last):\nFile \"withas.py\", line 20, in <module>\nraise TypeError\nTypeError",
    "Context managers are somewhat advanced devices for tool builders, so we’ll skip additional details here (see Python’s standard manuals for the full story—for example,\nthere’s a new contextlib standard module that provides additional tools for coding\ncontext managers). For simpler purposes, the try/finally statement provides sufficient\nsupport for termination-time activities.\nIn the upcoming Python 3.1 release, the with statement may also specify\nmultiple (sometimes referred to as “nested”) context managers with new\ncomma syntax. In the following, for example, both files’ exit actions are\nautomatically run when the statement block exits, regardless of exception outcomes:\nwith open('data') as fin, open('res', 'w') as fout:\nfor line in fin:\nif 'some key' in line:\nfout.write(line)\n\nAny number of context manager items may be listed, and multiple items\nwork the same as nested with statements. In general, the 3.1 (and later)\ncode:\nwith A() as a, B() as b:\n...statements...",
    "Any number of context manager items may be listed, and multiple items\nwork the same as nested with statements. In general, the 3.1 (and later)\ncode:\nwith A() as a, B() as b:\n...statements...\n\nis equivalent to the following, which works in 3.1, 3.0, and 2.6:\nwith A() as a:\nwith B() as b:\n...statements...\n\nSee Python 3.1 release notes for additional details.\n\nChapter Summary\nIn this chapter, we took a more detailed look at exception processing by exploring the\nstatements related to exceptions in Python: try to catch them, raise to trigger them,\nassert to raise them conditionally, and with to wrap code blocks in context managers\nthat specify entry and exit actions.\n\nChapter Summary | 855",
    "See Python 3.1 release notes for additional details.\n\nChapter Summary\nIn this chapter, we took a more detailed look at exception processing by exploring the\nstatements related to exceptions in Python: try to catch them, raise to trigger them,\nassert to raise them conditionally, and with to wrap code blocks in context managers\nthat specify entry and exit actions.\n\nChapter Summary | 855\n\n\fSo far, exceptions probably seem like a fairly lightweight tool, and in fact, they are; the\nonly substantially complex thing about them is how they are identified. The next chapter continues our exploration by describing how to implement exception objects of\nyour own; as you’ll see, classes allow you to code new exceptions specific to your\nprograms. Before we move ahead, though, let’s work though the following short quiz\non the basics covered here.",
    "Test Your Knowledge: Quiz\n1. What is the try statement for?\n2. What are the two common variations of the try statement?\n3. What is the raise statement for?\n4. What is the assert statement designed to do, and what other statement is it like?\n5. What is the with/as statement designed to do, and what other statement is it like?",
    "Test Your Knowledge: Answers\n1. The try statement catches and recovers from exceptions—it specifies a block of\ncode to run, and one or more handlers for exceptions that may be raised during\nthe block’s execution.\n2. The two common variations on the try statement are try/except/else (for catching\nexceptions) and try/finally (for specifying cleanup actions that must occur\nwhether an exception is raised or not). In Python 2.4, these were separate statements that could be combined by syntactic nesting; in 2.5 and later, except and\nfinally blocks may be mixed in the same statement, so the two statement forms\nare merged. In the merged form, the finally is still run on the way out of the try,\nregardless of what exceptions may have been raised or handled.\n3. The raise statement raises (triggers) an exception. Python raises built-in exceptions on errors internally, but your scripts can trigger built-in or user-defined exceptions with raise, too.",
    "are merged. In the merged form, the finally is still run on the way out of the try,\nregardless of what exceptions may have been raised or handled.\n3. The raise statement raises (triggers) an exception. Python raises built-in exceptions on errors internally, but your scripts can trigger built-in or user-defined exceptions with raise, too.\n4. The assert statement raises an AssertionError exception if a condition is false. It\nworks like a conditional raise statement wrapped up in an if statement.\n5. The with/as statement is designed to automate startup and termination activities\nthat must occur around a block of code. It is roughly like a try/finally statement\nin that its exit actions run whether an exception occurred or not, but it allows a\nricher object-based protocol for specifying entry and exit actions.",
    "856 | Chapter 33: Exception Coding Details\n\n\fCHAPTER 34\n\nException Objects",
    "So far, I’ve been deliberately vague about what an exception actually is. As suggested\nin the prior chapter, in Python 2.6 and 3.0 both built-in and user-defined exceptions\nare identified by class instance objects. Although this means you must use objectoriented programming to define new exceptions in your programs, classes and OOP\nin general offer a number of benefits.\nHere are some of the advantages of class-based exceptions:\n• They can be organized into categories. Exception classes support future changes\nby providing categories—adding new exceptions in the future won’t generally require changes in try statements.\n• They have attached state information. Exception classes provide a natural place\nfor us to store context information for use in the try handler—they may have both\nattached state information and callable methods, accessible through instances.\n• They support inheritance. Class-based exceptions can participate in inheritance",
    "• They have attached state information. Exception classes provide a natural place\nfor us to store context information for use in the try handler—they may have both\nattached state information and callable methods, accessible through instances.\n• They support inheritance. Class-based exceptions can participate in inheritance\nhierarchies to obtain and customize common behavior—inherited display methods, for example, can provide a common look and feel for error messages.\nBecause of these advantages, class-based exceptions support program evolution and\nlarger systems well. In fact, all built-in exceptions are identified by classes and are\norganized into an inheritance tree, for the reasons just listed. You can do the same with\nuser-defined exceptions of your own.\nIn Python 3.0, user-defined exceptions inherit from built-in exception superclasses. As\nwe’ll see here, because these superclasses provide useful defaults for printing and state",
    "larger systems well. In fact, all built-in exceptions are identified by classes and are\norganized into an inheritance tree, for the reasons just listed. You can do the same with\nuser-defined exceptions of your own.\nIn Python 3.0, user-defined exceptions inherit from built-in exception superclasses. As\nwe’ll see here, because these superclasses provide useful defaults for printing and state\nretention, the task of coding user-defined exceptions also involves understanding the\nroles of these built-ins.",
    "857\n\n\fVersion skew note: Python 2.6 and 3.0 both require exceptions to be\ndefined by classes. In addition, 3.0 requires exception classes to be derived from the BaseException built-in exception superclass, either directly or indirectly. As we’ll see, most programs inherit from this class’s\nException subclass, to support catchall handlers for normal exception\ntypes—naming it in a handler will catch everything most programs\nshould. Python 2.6 allows standalone classic classes to serve as exceptions, too, but it requires new-style classes to be derived from built-in\nexception classes, the same as 3.0.",
    "Exceptions: Back to the Future\nOnce upon a time (well, prior to Python 2.6 and 3.0), it was possible to define exceptions in two different ways. This complicated try statements, raise statements, and\nPython in general. Today, there is only one way to do it. This is a good thing: it removes\nfrom the language substantial cruft accumulated for the sake of backward compatibility. Because the old way helps explain why exceptions are as they are today, though,\nand because it’s not really possible to completely erase the history of something that\nhas been used by a million people over the course of nearly two decades, let’s begin our\nexploration of the present with a brief look at the past.",
    "String Exceptions Are Right Out!\nPrior to Python 2.6 and 3.0, it was possible to define exceptions with both class instances and string objects. String-based exceptions began issuing deprecation warnings\nin 2.5 and were removed in 2.6 and 3.0, so today you should use class-based exceptions,\nas shown in this book. If you work with legacy code, though, you might still come\nacross string exceptions. They might also appear in tutorials and web resources written\na few years ago (which qualifies as an eternity in Python years!).\nString exceptions were straightforward to use—any string would do, and they matched\nby object identity, not value (that is, using is, not ==):\nC:\\misc> C:\\Python25\\python\n>>> myexc = \"My exception string\"\n>>> try:\n...\nraise myexc\n... except myexc:\n...\nprint('caught')\n...\ncaught\n\n# Were we ever this young?",
    "# Were we ever this young?\n\nThis form of exception was removed because it was not as good as classes for larger\nprograms and code maintenance. Although you can’t use string exceptions today, they\nactually provide a natural vehicle for introducing the class-based exceptions model.\n\n858 | Chapter 34: Exception Objects",
    "Class-Based Exceptions\nStrings were a simple way to define exceptions. As described earlier, however, classes\nhave some added advantages that merit a quick look. Most prominently, they allow us\nto identify exception categories that are more flexible to use and maintain than simple\nstrings. Moreover, classes naturally allow for attached exception details and support\ninheritance. Because they are the better approach, they are now required.\nCoding details aside, the chief difference between string and class exceptions has to do\nwith the way that exceptions raised are matched against except clauses in try\nstatements:\n• String exceptions were matched by simple object identity: the raised exception was\nmatched to except clauses by Python’s is test.\n• Class exceptions are matched by superclass relationships: the raised exception\nmatches an except clause if that except clause names the exception’s class or any\nsuperclass of it.",
    "statements:\n• String exceptions were matched by simple object identity: the raised exception was\nmatched to except clauses by Python’s is test.\n• Class exceptions are matched by superclass relationships: the raised exception\nmatches an except clause if that except clause names the exception’s class or any\nsuperclass of it.\nThat is, when a try statement’s except clause lists a superclass, it catches instances of\nthat superclass, as well as instances of all its subclasses lower in the class tree. The net\neffect is that class exceptions support the construction of exception hierarchies: superclasses become category names, and subclasses become specific kinds of exceptions\nwithin a category. By naming a general exception superclass, an except clause can catch\nan entire category of exceptions—any more specific subclass will match.\nString exceptions had no such concept: because they were matched by simple object",
    "within a category. By naming a general exception superclass, an except clause can catch\nan entire category of exceptions—any more specific subclass will match.\nString exceptions had no such concept: because they were matched by simple object\nidentity, there was no direct way to organize exceptions into more flexible categories\nor groups. The net result was that exception handlers were coupled with exception sets\nin a way that made changes difficult.\nIn addition to this category idea, class-based exceptions better support exception state\ninformation (attached to instances) and allow exceptions to participate in inheritance\nhierarchies (to obtain common behaviors). Because they offer all the benefits of classes\nand OOP in general, they provide a more powerful alternative to the now defunct stringbased exceptions model in exchange for a small amount of additional code.",
    "Coding Exceptions Classes\nLet’s look at an example to see how class exceptions translate to code. In the following\nfile, classexc.py, we define a superclass called General and two subclasses called\nSpecific1 and Specific2. This example illustrates the notion of exception categories—\nGeneral is a category name, and its two subclasses are specific types of exceptions within\nthe category. Handlers that catch General will also catch any subclasses of it, including\nSpecific1 and Specific2:\nclass General(Exception): pass\nclass Specific1(General): pass\n\nExceptions: Back to the Future | 859\n\n\fclass Specific2(General): pass\ndef raiser0():\nX = General()\nraise X\n\n# Raise superclass instance\n\ndef raiser1():\nX = Specific1()\nraise X\n\n# Raise subclass instance\n\ndef raiser2():\nX = Specific2()\nraise X\n\n# Raise different subclass instance",
    "Exceptions: Back to the Future | 859\n\n\fclass Specific2(General): pass\ndef raiser0():\nX = General()\nraise X\n\n# Raise superclass instance\n\ndef raiser1():\nX = Specific1()\nraise X\n\n# Raise subclass instance\n\ndef raiser2():\nX = Specific2()\nraise X\n\n# Raise different subclass instance\n\nfor func in (raiser0, raiser1, raiser2):\ntry:\nfunc()\nexcept General:\n# Match General or any subclass of it\nimport sys\nprint('caught:', sys.exc_info()[0])\nC:\\python30> python classexc.py\ncaught: <class '__main__.General'>\ncaught: <class '__main__.Specific1'>\ncaught: <class '__main__.Specific2'>",
    "This code is mostly straightforward, but here are a few implementation notes:\nException superclass\nClasses used to build exception category trees have very few requirements—in fact,\nin this example they are mostly empty, with bodies that do nothing but pass. Notice, though, how the top-level class here inherits from the built-in Exception class.\nThis is required in Python 3.0; Python 2.6 allows standalone classic classes to serve\nas exceptions too, but it requires new-style classes to be derived from built-in exception classes just like in 3.0. Although we don’t employ it here, because\nException provides some useful behavior we’ll meet later, it’s a good idea to inherit\nfrom it in either Python.\nRaising instances\nIn this code, we call classes to make instances for the raise statements. In the class\nexception model, we always raise and catch a class instance object. If we list a class\nname without parentheses in a raise, Python calls the class with no constructor",
    "Exception provides some useful behavior we’ll meet later, it’s a good idea to inherit\nfrom it in either Python.\nRaising instances\nIn this code, we call classes to make instances for the raise statements. In the class\nexception model, we always raise and catch a class instance object. If we list a class\nname without parentheses in a raise, Python calls the class with no constructor\nargument to make an instance for us. Exception instances can be created before\nthe raise, as done here, or within the raise statement itself.\nCatching categories\nThis code includes functions that raise instances of all three of our classes as exceptions, as well as a top-level try that calls the functions and catches General\nexceptions. The same try also catches the two specific exceptions, because they\nare subclasses of General.",
    "860 | Chapter 34: Exception Objects",
    "Exception details\nThe exception handler here uses the sys.exc_info call—as we’ll see in more detail\nin the next chapter, it’s how we can grab hold of the most recently raised exception\nin a generic fashion. Briefly, the first item in its result is the class of the exception\nraised, and the second is the actual instance raised. In a general except clause like\nthe one here that catches all classes in a category, sys.exc_info is one way to determine exactly what’s occurred. In this particular case, it’s equivalent to fetching\nthe instance’s __class__ attribute. As we’ll see in the next chapter, the\nsys.exc_info scheme is also commonly used with empty except clauses that catch\neverything.\nThe last point merits further explanation. When an exception is caught, we can be sure\nthat the instance raised is an instance of the class listed in the except, or one of its more\nspecific subclasses. Because of this, the __class__ attribute of the instance also gives",
    "sys.exc_info scheme is also commonly used with empty except clauses that catch\neverything.\nThe last point merits further explanation. When an exception is caught, we can be sure\nthat the instance raised is an instance of the class listed in the except, or one of its more\nspecific subclasses. Because of this, the __class__ attribute of the instance also gives\nthe exception type. The following variant, for example, works the same as the prior\nexample:\nclass General(Exception): pass\nclass Specific1(General): pass\nclass Specific2(General): pass\ndef raiser0(): raise General()\ndef raiser1(): raise Specific1()\ndef raiser2(): raise Specific2()\nfor func in (raiser0, raiser1, raiser2):\ntry:\nfunc()\nexcept General as X:\nprint('caught:', X.__class__)",
    "# X is the raised instance\n# Same as sys.exc_info()[0]\n\nBecause __class__ can be used like this to determine the specific type of exception\nraised, sys.exc_info is more useful for empty except clauses that do not otherwise have\na way to access the instance or its class. Furthermore, more realistic programs usually\nshould not have to care about which specific exception was raised at all—by calling\nmethods of the instance generically, we automatically dispatch to behavior tailored for\nthe exception raised. More on this and sys.exc_info in the next chapter; also see\nChapter 28 and Part VI at large if you’ve forgotten what __class__ means in an instance.\n\nWhy Exception Hierarchies?\nBecause there are only three possible exceptions in the prior section’s example, it\ndoesn’t really do justice to the utility of class exceptions. In fact, we could achieve the\nsame effects by coding a list of exception names in parentheses within the except clause:\ntry:",
    "Why Exception Hierarchies?\nBecause there are only three possible exceptions in the prior section’s example, it\ndoesn’t really do justice to the utility of class exceptions. In fact, we could achieve the\nsame effects by coding a list of exception names in parentheses within the except clause:\ntry:\n\nfunc()\nexcept (General, Specific1, Specific2):\n...\n\n# Catch any of these\n\nWhy Exception Hierarchies? | 861",
    "func()\nexcept (General, Specific1, Specific2):\n...\n\n# Catch any of these\n\nWhy Exception Hierarchies? | 861\n\n\fThis approach worked for the defunct string exception model too. For large or high\nexception hierarchies, however, it may be easier to catch categories using class-based\ncategories than to list every member of a category in a single except clause. Perhaps\nmore importantly, you can extend exception hierarchies by adding new subclasses\nwithout breaking existing code.\nSuppose, for example, you code a numeric programming library in Python, to be used\nby a large number of people. While you are writing your library, you identify two things\nthat can go wrong with numbers in your code—division by zero, and numeric overflow.\nYou document these as the two exceptions that your library may raise:\n# mathlib.py\nclass Divzero(Exception): pass\nclass Oflow(Exception): pass\ndef func():\n...\nraise Divzero()",
    "Now, when people use your library, they typically wrap calls to your functions or classes\nin try statements that catch your two exceptions (if they do not catch your exceptions,\nexceptions from the library will kill their code):\n# client.py\nimport mathlib\ntry:\n\nmathlib.func(...)\nexcept (mathlib.Divzero, mathlib.Oflow):\n...handle and recover...\n\nThis works fine, and lots of people start using your library. Six months down the road,\nthough, you revise it (as programmers are prone to do). Along the way, you identify a\nnew thing that can go wrong—underflow—and add that as a new exception:\n# mathlib.py\nclass Divzero(Exception): pass\nclass Oflow(Exception): pass\nclass Uflow(Exception): pass\n\nUnfortunately, when you re-release your code, you create a maintenance problem for\nyour users. If they’ve listed your exceptions explicitly, they now have to go back and\nchange every place they call your library to include the newly added exception name:\n# client.py\ntry:",
    "Unfortunately, when you re-release your code, you create a maintenance problem for\nyour users. If they’ve listed your exceptions explicitly, they now have to go back and\nchange every place they call your library to include the newly added exception name:\n# client.py\ntry:\n\nmathlib.func(...)\nexcept (mathlib.Divzero, mathlib.Oflow, mathlib.Uflow):\n...handle and recover...\n\n862 | Chapter 34: Exception Objects\n\n\fThis may not be the end of the world. If your library is used only in-house, you can\nmake the changes yourself. You might also ship a Python script that tries to fix such\ncode automatically (it would probably be only a few dozen lines, and it would guess\nright at least some of the time). If many people have to change all their try statements\neach time you alter your exception set, though, this is not exactly the most polite of\nupgrade policies.\nYour users might try to avoid this pitfall by coding empty except clauses to catch all\npossible exceptions:\n# client.py\ntry:",
    "mathlib.func(...)\nexcept:\n...handle and recover...\n\n# Catch everything here",
    "But this workaround might catch more than they bargained for—things like running\nout of memory, keyboard interrupts (Ctrl-C), system exits, and even typos in their own\ntry block’s code will all trigger exceptions, and such things should pass, not be caught\nand erroneously classified as library errors.\nAnd really, in this scenario users want to catch and recover from only the specific exceptions the library is defined and documented to raise; if any other exception occurs\nduring a library call, it’s likely a genuine bug in the library (and probably time to contact\nthe vendor!). As a rule of thumb, it’s usually better to be specific than general in exception handlers—an idea we’ll revisit as a “gotcha” in the next chapter.*\nSo what to do, then? Class exception hierarchies fix this dilemma completely. Rather\nthan defining your library’s exceptions as a set of autonomous classes, arrange them\ninto a class tree with a common superclass to encompass the entire category:\n# mathlib.py",
    "So what to do, then? Class exception hierarchies fix this dilemma completely. Rather\nthan defining your library’s exceptions as a set of autonomous classes, arrange them\ninto a class tree with a common superclass to encompass the entire category:\n# mathlib.py\nclass NumErr(Exception): pass\nclass Divzero(NumErr): pass\nclass Oflow(NumErr): pass\n...\ndef func():\n...\nraise DivZero()",
    "This way, users of your library simply need to list the common superclass (i.e., category)\nto catch all of your library’s exceptions, both now and in the future:\n* As a clever student of mine suggested, the library module could also provide a tuple object that contains all\nthe exceptions the library can possibly raise—the client could then import the tuple and name it in an\nexcept clause to catch all the library’s exceptions (recall that including a tuple in an except means catch\nany of its exceptions). When new exceptions are added later, the library can just expand the exported tuple.\nThis would work, but you’d still need to keep the tuple up-to-date with raised exceptions inside the library\nmodule. Also, class hierarchies offer more benefits than just categories—they also support inherited state\nand methods and a customization model that individual exceptions do not.\n\nWhy Exception Hierarchies? | 863",
    "Why Exception Hierarchies? | 863\n\n\f# client.py\nimport mathlib\n...\ntry:\nmathlib.func(...)\nexcept mathlib.NumErr:\n...report and recover...\n\nWhen you go back and hack your code again, you can add new exceptions as new\nsubclasses of the common superclass:\n# mathlib.py\n...\nclass Uflow(NumErr): pass\n\nThe end result is that user code that catches your library’s exceptions will keep working,\nunchanged. In fact, you are free to add, delete, and change exceptions arbitrarily in the\nfuture—as long as clients name the superclass, they are insulated from changes in your\nexceptions set. In other words, class exceptions provide a better answer to maintenance\nissues than strings do.\nClass-based exception hierarchies also support state retention and inheritance in ways\nthat make them ideal in larger programs. To understand these roles, though, we first\nneed to see how user-defined exception classes relate to the built-in exceptions from\nwhich they inherit.",
    "Built-in Exception Classes\nI didn’t really pull the prior section’s examples out of thin air. All built-in exceptions\nthat Python itself may raise are predefined class objects. Moreover, they are organized\ninto a shallow hierarchy with general superclass categories and specific subclass types,\nmuch like the exceptions class tree we developed earlier.\nIn Python 3.0, all the familiar exceptions you’ve seen (e.g., SyntaxError) are really just\npredefined classes, available as built-in names in the module named builtins (in Python\n2.6, they instead live in __builtin__ and are also attributes of the standard library\nmodule exceptions). In addition, Python organizes the built-in exceptions into a hierarchy, to support a variety of catching modes. For example:\nBaseException",
    "The top-level root superclass of exceptions. This class is not supposed to be directly\ninherited by user-defined classes (use Exception instead). It provides default printing and state retention behavior inherited by subclasses. If the str built-in is called\non an instance of this class (e.g., by print), the class returns the display strings of\nthe constructor arguments passed when the instance was created (or an empty\nstring if there were no arguments). In addition, unless subclasses replace this class’s\n\n864 | Chapter 34: Exception Objects\n\n\fconstructor, all of the arguments passed to this class at instance construction time\nare stored in its args attribute as a tuple.\nException",
    "864 | Chapter 34: Exception Objects\n\n\fconstructor, all of the arguments passed to this class at instance construction time\nare stored in its args attribute as a tuple.\nException\n\nThe top-level root superclass of application-related exceptions. This is an immediate subclass of BaseException and is superclass to every other built-in exception,\nexcept the system exit event classes (SystemExit, KeyboardInterrupt, and\nGeneratorExit). Almost all user-defined classes should inherit from this class, not\nBaseException. When this convention is followed, naming Exception in a try statement’s handler ensures that your program will catch everything but system exit\nevents, which should normally be allowed to pass. In effect, Exception becomes a\ncatchall in try statements and is more accurate than an empty except.\nArithmeticError\n\nThe superclass of all numeric errors (and a subclass of Exception).\nOverflowError",
    "The superclass of all numeric errors (and a subclass of Exception).\nOverflowError\n\nA subclass of ArithmeticError that identifies a specific numeric error.\nAnd so on—you can read further about this structure in reference texts such as Python\nPocket Reference or the Python library manual. Note that the exceptions class tree differs slightly between Python 3.0 and 2.6. Also note that you can see the class tree in the\nhelp text of the exceptions module in Python 2.6 only (this module is removed in 3.0).\nSee Chapters 4 and 15 for help on help:\n>>> import exceptions\n>>> help(exceptions)\n...lots of text omitted...",
    "Built-in Exception Categories\nThe built-in class tree allows you to choose how specific or general your handlers will\nbe. For example, the built-in exception ArithmeticError is a superclass for more specific\nexceptions such as OverflowError and ZeroDivisionError. By listing ArithmeticError\nin a try, you will catch any kind of numeric error raised; by listing just\nOverflowError, you will intercept just that specific type of error, and no others.\nSimilarly, because Exception is the superclass of all application-level exceptions in Python 3.0, you can generally use it as a catchall—the effect is much like an empty\nexcept, but it allows system exit exceptions to pass as they usually should:\ntry:\n\naction()\nexcept Exception:\n...handle all application exceptions...\nelse:\n...handle no-exception case...\n\nBuilt-in Exception Classes | 865",
    "Built-in Exception Classes | 865\n\n\fThis doesn’t quite work universally in Python 2.6, however, because standalone userdefined exceptions coded as classic classes are not required to be subclasses of the\nException root class. This technique is more reliable in Python 3.0, since it requires all\nclasses to derive from built-in exceptions. Even in Python 3.0, though, this scheme\nsuffers most of the same potential pitfalls as the empty except, as described in the prior\nchapter—it might intercept exceptions intended for elsewhere, and it might mask genuine programming errors. Since this is such a common issue, we’ll revisit it as a “gotcha”\nin the next chapter.\nWhether or not you will leverage the categories in the built-in class tree, it serves as a\ngood example; by using similar techniques for class exceptions in your own code, you\ncan provide exception sets that are flexible and easily modified.",
    "Default Printing and State\nBuilt-in exceptions also provide default print displays and state retention, which is often\nas much logic as user-defined classes require. Unless you redefine the constructors your\nclasses inherit from them, any constructor arguments you pass to these classes are saved\nin the instance’s args tuple attribute and are automatically displayed when the instance\nis printed (an empty tuple and display string are used if no constructor arguments are\npassed).\nThis explains why arguments passed to built-in exception classes show up in error\nmessages—any constructor arguments are attached to the instance and displayed when\nthe instance is printed:\n>>> raise IndexError\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError\n\n# Same as IndexError(): no arguments\n\n>>> raise IndexError('spam')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError: spam\n\n# Constructor argument attached, printed",
    "# Same as IndexError(): no arguments\n\n>>> raise IndexError('spam')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nIndexError: spam\n\n# Constructor argument attached, printed\n\n>>> I = IndexError('spam')\n>>> I.args\n('spam',)\n\n# Available in object attribute\n\nThe same holds true for user-defined exceptions, because they inherit the constructor\nand display methods present in their built-in superclasses:\n>>> class E(Exception): pass\n...\n>>> try:\n...\nraise E('spam')\n... except E as X:\n...\nprint(X, X.args)\n...\nspam ('spam',)\n\n866 | Chapter 34: Exception Objects\n\n# Displays and saves constructor arguments\n\n\f>>> try:\n...\nraise E('spam', 'eggs', 'ham')\n... except E as X:\n...\nprint(X, X.args)\n...\n('spam', 'eggs', 'ham') ('spam', 'eggs', 'ham')",
    "866 | Chapter 34: Exception Objects\n\n# Displays and saves constructor arguments\n\n\f>>> try:\n...\nraise E('spam', 'eggs', 'ham')\n... except E as X:\n...\nprint(X, X.args)\n...\n('spam', 'eggs', 'ham') ('spam', 'eggs', 'ham')\n\nNote that exception instance objects are not strings themselves, but use the __str__\noperator overloading protocol we studied in Chapter 29 to provide display strings when\nprinted; to concatenate with real strings, perform manual conversions: str(X) +\n\"string\".\nAlthough this automatic state and display support is useful by itself, for more specific\ndisplay and state retention needs you can always redefine inherited methods such as\n__str__ and __init__ in Exception subclasses—the next section shows how.",
    "Custom Print Displays\nAs we saw in the preceding section, by default, instances of class-based exceptions\ndisplay whatever you passed to the class constructor when they are caught and printed:\n>>> class MyBad(Exception): pass\n...\n>>> try:\n...\nraise MyBad('Sorry--my mistake!')\n... except MyBad as X:\n...\nprint(X)\n...\nSorry--my mistake!\n\nThis inherited default display model is also used if the exception is displayed as part of\nan error message when the exception is not caught:\n>>> raise MyBad('Sorry--my mistake!')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n__main__.MyBad: Sorry--my mistake!",
    "This inherited default display model is also used if the exception is displayed as part of\nan error message when the exception is not caught:\n>>> raise MyBad('Sorry--my mistake!')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n__main__.MyBad: Sorry--my mistake!\n\nFor many roles, this is sufficient. To provide a more custom display, though, you can\ndefine one of two string-representation overloading methods in your class (__repr__ or\n__str__) to return the string you want to display for your exception. The string the\nmethod returns will be displayed if the exception either is caught and printed or reaches\nthe default handler:\n>>> class MyBad(Exception):\n...\ndef __str__(self):\n...\nreturn 'Always look on the bright side of life...'\n...\n>>> try:\n...\nraise MyBad()\n... except MyBad as X:\n...\nprint(X)\n\nCustom Print Displays | 867",
    "Custom Print Displays | 867\n\n\f...\nAlways look on the bright side of life...\n>>> raise MyBad()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\n__main__.MyBad: Always look on the bright side of life...\n\nA subtle point to note here is that you generally must redefine __str__ for this purpose,\nbecause the built-in superclasses already have a __str__ method, and __str__ is preferred to __repr__ in most contexts (including printing). If you define a __repr__, printing will happily call the superclass’s __str__ instead! See Chapter 29 for more details\non these special methods.\nWhatever your method returns is included in error messages for uncaught exceptions\nand used when exceptions are printed explicitly. The method returns a hardcoded\nstring here to illustrate, but it can also perform arbitrary text processing, possibly using\nstate information attached to the instance object. The next section looks at state information options.",
    "Custom Data and Behavior\nBesides supporting flexible hierarchies, exception classes also provide storage for extra\nstate information as instance attributes. As we saw earlier, built-in exception superclasses provide a default constructor that automatically saves constructor arguments\nin an instance tuple attribute named args. Although the default constructor is adequate\nfor many cases, for more custom needs we can provide a constructor of our own. In\naddition, classes may define methods for use in handlers that provide precoded exception processing logic.",
    "Providing Exception Details\nWhen an exception is raised, it may cross arbitrary file boundaries—the raise statement that triggers an exception and the try statement that catches it may be in completely different module files. It is not generally feasible to store extra details in global\nvariables because the try statement might not know which file the globals reside in.\nPassing extra state information along in the exception itself allows the try statement\nto access it more reliably.\nWith classes, this is nearly automatic. As we’ve seen, when an exception is raised,\nPython passes the class instance object along with the exception. Code in try statements\ncan access the raised instance by listing an extra variable after the as keyword in an\nexcept handler. This provides a natural hook for supplying data and behavior to the\nhandler.\n\n868 | Chapter 34: Exception Objects",
    "868 | Chapter 34: Exception Objects\n\n\fFor example, a program that parses data files might signal a formatting error by raising\nan exception instance that is filled out with extra details about the error:\n>>> class FormatError(Exception):\n...\ndef __init__(self, line, file):\n...\nself.line = line\n...\nself.file = file\n...\n>>> def parser():\n...\nraise FormatError(42, file='spam.txt')\n...\n>>> try:\n...\nparser()\n... except FormatError as X:\n...\nprint('Error at', X.file, X.line)\n...\nError at spam.txt 42\n\n# When error found",
    "# When error found\n\nIn the except clause here, the variable X is assigned a reference to the instance that was\ngenerated when the exception was raised.† This gives access to the attributes attached\nto the instance by the custom constructor. Although we could rely on the default state\nretention of built-in superclasses, it’s less relevant to our application:\n>>> class FormatError(Exception): pass\n...\n>>> def parser():\n...\nraise FormatError(42, 'spam.txt')\n...\n>>> try:\n...\nparser()\n... except FormatError as X:\n...\nprint('Error at:', X.args[0], X.args[1])\n...\nError at: 42 spam.txt\n\n# Inherited constructor\n# No keywords allowed!\n\n# Not specific to this app",
    "# Inherited constructor\n# No keywords allowed!\n\n# Not specific to this app\n\nProviding Exception Methods\nBesides enabling application-specific state information, custom constructors also better\nsupport extra behavior for exception objects. That is, the exception class can also define\nmethods to be called in the handler. The following, for example, adds a method that\nuses exception state information to log errors to a file:\nclass FormatError(Exception):\nlogfile = 'formaterror.txt'\ndef __init__(self, line, file):\nself.line = line\nself.file = file",
    "† As suggested earlier, the raised instance object is also available generically as the second item in the result\ntuple of the sys.exc_info() call—a tool that returns information about the most recently raised exception.\nThis interface must be used if you do not list an exception name in an except clause but still need access to\nthe exception that occurred, or to any of its attached state information or methods. More on sys.exc_info\nin the next chapter.\n\nCustom Data and Behavior | 869\n\n\fdef logerror(self):\nlog = open(self.logfile, 'a')\nprint('Error at', self.file, self.line, file=log)\ndef parser():\nraise FormatError(40, 'spam.txt')\ntry:\n\nparser()\nexcept FormatError as exc:\nexc.logerror()\n\nWhen run, this script writes its error message to a file in response to method calls in\nthe exception handler:\nC:\\misc> C:\\Python30\\python parse.py\nC:\\misc> type formaterror.txt\nError at spam.txt 40",
    "parser()\nexcept FormatError as exc:\nexc.logerror()\n\nWhen run, this script writes its error message to a file in response to method calls in\nthe exception handler:\nC:\\misc> C:\\Python30\\python parse.py\nC:\\misc> type formaterror.txt\nError at spam.txt 40\n\nIn such a class, methods (like logerror) may also be inherited from superclasses, and\ninstance attributes (like line and file) provide a place to save state information that\nprovides extra context for use in later method calls. Moreover, exception classes are\nfree to customize and extend inherited behavior. In other words, because they are defined with classes, all the benefits of OOP that we studied in Part VI are available for\nuse with exceptions in Python.",
    "Chapter Summary\nIn this chapter, we explored coding user-defined exceptions. As we learned, exceptions\nare implemented as class instance objects in Python 2.6 and 3.0 (an earlier string-based\nexception model alternative was available in earlier releases but has now been deprecated). Exception classes support the concept of exception hierarchies that ease maintenance, allow data and behavior to be attached to exceptions as instance attributes\nand methods, and allow exceptions to inherit data and behavior from superclasses.\nWe saw that in a try statement, catching a superclass catches that class as well as all\nsubclasses below it in the class tree—superclasses become exception category names,\nand subclasses become more specific exception types within those categories. We also\nsaw that the built-in exception superclasses we must inherit from provide usable defaults for printing and state retention, which we can override if desired.",
    "subclasses below it in the class tree—superclasses become exception category names,\nand subclasses become more specific exception types within those categories. We also\nsaw that the built-in exception superclasses we must inherit from provide usable defaults for printing and state retention, which we can override if desired.\nThe next chapter wraps up this part of the book by exploring some common use cases\nfor exceptions and surveying tools commonly used by Python programmers. Before we\nget there, though, here’s this chapter’s quiz.",
    "870 | Chapter 34: Exception Objects\n\n\fTest Your Knowledge: Quiz\n1. What are the two new constraints on user-defined exceptions in Python 3.0?\n2. How are raised class-based exceptions matched to handlers?\n3. Name two ways that you can attach context information to exception objects.\n4. Name two ways that you can specify the error message text for exception objects.\n5. Why should you not use string-based exceptions anymore today?",
    "Test Your Knowledge: Answers\n1. In 3.0, exceptions must be defined by classes (that is, a class instance object is raised\nand caught). In addition, exception classes must be derived from the built-in class\nBaseException (most programs inherit from its Exception subclass, to support\ncatchall handlers for normal kinds of exceptions).\n2. Class-based exceptions match by superclass relationships: naming a superclass in\nan exception handler will catch instances of that class, as well as instances of any\nof its subclasses lower in the class tree. Because of this, you can think of superclasses\nas general exception categories and subclasses as more specific types of exceptions\nwithin those categories.\n3. You can attach context information to class-based exceptions by filling out instance\nattributes in the instance object raised, usually in a custom class constructor. For\nsimpler needs, built-in exception superclasses provide a constructor that stores its",
    "as general exception categories and subclasses as more specific types of exceptions\nwithin those categories.\n3. You can attach context information to class-based exceptions by filling out instance\nattributes in the instance object raised, usually in a custom class constructor. For\nsimpler needs, built-in exception superclasses provide a constructor that stores its\narguments on the instance automatically (in the attribute args). In exception handlers, you list a variable to be assigned to the raised instance, then go through this\nname to access attached state information and call any methods defined in the class.\n4. The error message text in class-based exceptions can be specified with a custom\n__str__ operator overloading method. For simpler needs, built-in exception superclasses automatically display anything you pass to the class constructor. Operations like print and str automatically fetch the display string of an exception",
    "4. The error message text in class-based exceptions can be specified with a custom\n__str__ operator overloading method. For simpler needs, built-in exception superclasses automatically display anything you pass to the class constructor. Operations like print and str automatically fetch the display string of an exception\nobject when is it printed either explicitly or as part of an error message.\n5. Because Guido said so—they have been removed in both Python 2.6 and 3.0.\nReally, there are good reasons for this: string-based exceptions did not support\ncategories, state information, or behavior inheritance in the way class-based exceptions do. In practice, this made string-based exceptions easier to use at first,\nwhen programs were small, but more complex to use as programs grew larger.",
    "Test Your Knowledge: Answers | 871\n\n\f\fCHAPTER 35\n\nDesigning with Exceptions\n\nThis chapter rounds out this part of the book with a collection of exception design\ntopics and common use case examples, followed by this part’s gotchas and exercises.\nBecause this chapter also closes out the fundamentals portion of the book at large, it\nincludes a brief overview of development tools as well to help you as you make the\nmigration from Python beginner to Python application developer.",
    "Nesting Exception Handlers\nOur examples so far have used only a single try to catch exceptions, but what happens\nif one try is physically nested inside another? For that matter, what does it mean if a\ntry calls a function that runs another try? Technically, try statements can nest, in terms\nof syntax and the runtime control flow through your code.\nBoth of these cases can be understood if you realize that Python stacks try statements\nat runtime. When an exception is raised, Python returns to the most recently entered\ntry statement with a matching except clause. Because each try statement leaves a\nmarker, Python can jump back to earlier trys by inspecting the stacked markers. This\nnesting of active handlers is what we mean when we talk about propagating exceptions\nup to “higher” handlers—such handlers are simply try statements entered earlier in\nthe program’s execution flow.\nFigure 35-1 illustrates what occurs when try statements with except clauses nest at",
    "marker, Python can jump back to earlier trys by inspecting the stacked markers. This\nnesting of active handlers is what we mean when we talk about propagating exceptions\nup to “higher” handlers—such handlers are simply try statements entered earlier in\nthe program’s execution flow.\nFigure 35-1 illustrates what occurs when try statements with except clauses nest at\nruntime. The amount of code that goes into a try block can be substantial, and it may\ncontain function calls that invoke other code watching for the same exceptions. When\nan exception is eventually raised, Python jumps back to the most recently entered\ntry statement that names that exception, runs that statement’s except clause, and then\nresumes execution after that try.\nOnce the exception is caught, its life is over—control does not jump back to all matching trys that name the exception; only the first one is given the opportunity to handle",
    "an exception is eventually raised, Python jumps back to the most recently entered\ntry statement that names that exception, runs that statement’s except clause, and then\nresumes execution after that try.\nOnce the exception is caught, its life is over—control does not jump back to all matching trys that name the exception; only the first one is given the opportunity to handle\nit. In Figure 35-1, for instance, the raise statement in the function func2 sends control\nback to the handler in func1, and then the program continues within func1.\n873",
    "Figure 35-1. Nested try/except statements: when an exception is raised (by you or by Python), control\njumps back to the most recently entered try statement with a matching except clause, and the program\nresumes after that try statement. except clauses intercept and stop the exception—they are where you\nprocess and recover from exceptions.\n\nBy contrast, when try statements that contain only finally clauses are nested, each\nfinally block is run in turn when an exception occurs—Python continues propagating\nthe exception up to other trys, and eventually perhaps to the top-level default handler\n(the standard error message printer). As Figure 35-2 illustrates, the finally clauses do\nnot kill the exception—they just specify code to be run on the way out of each try\nduring the exception propagation process. If there are many try/finally clauses active\nwhen an exception occurs, they will all be run, unless a try/except catches the exception\nsomewhere along the way.",
    "Figure 35-2. Nested try/finally statements: when an exception is raised here, control returns to the\nmost recently entered try to run its finally statement, but then the exception keeps propagating to all\nfinallys in all active try statements and eventually reaches the default top-level handler, where an\nerror message is printed. finally clauses intercept (but do not stop) an exception—they are for actions\nto be performed “on the way out.”\n\nIn other words, where the program goes when an exception is raised depends entirely\nupon where it has been—it’s a function of the runtime flow of control through the script,\nnot just its syntax. The propagation of an exception essentially proceeds backward\nthrough time to try statements that have been entered but not yet exited. This propagation stops as soon as control is unwound to a matching except clause, but not as it\npasses through finally clauses on the way.\n\n874 | Chapter 35: Designing with Exceptions",
    "874 | Chapter 35: Designing with Exceptions\n\n\fExample: Control-Flow Nesting\nLet’s turn to an example to make this nesting concept more concrete. The following\nmodule file, nestexc.py, defines two functions. action2 is coded to trigger an exception\n(you can’t add numbers and sequences), and action1 wraps a call to action2 in a try\nhandler, to catch the exception:\ndef action2():\nprint(1 + [])\ndef action1():\ntry:\naction2()\nexcept TypeError:\nprint('inner try')\n\n# Generate TypeError\n\n# Most recent matching try\n\ntry:\n\naction1()\nexcept TypeError:\nprint('outer try')\n\n# Here, only if action1 re-raises\n\n% python nestexc.py\ninner try",
    "# Generate TypeError\n\n# Most recent matching try\n\ntry:\n\naction1()\nexcept TypeError:\nprint('outer try')\n\n# Here, only if action1 re-raises\n\n% python nestexc.py\ninner try\n\nNotice, though, that the top-level module code at the bottom of the file wraps a call to\naction1 in a try handler, too. When action2 triggers the TypeError exception, there will\nbe two active try statements—the one in action1, and the one at the top level of the\nmodule file. Python picks and runs just the most recent try with a matching except,\nwhich in this case is the try inside action1.\nAs I’ve mentioned, the place where an exception winds up jumping to depends on the\ncontrol flow through the program at runtime. Because of this, to know where you will\ngo, you need to know where you’ve been. In this case, where exceptions are handled\nis more a function of control flow than of statement syntax. However, we can also nest\nexception handlers syntactically—an equivalent case we’ll look at next.",
    "Example: Syntactic Nesting\nAs I mentioned when we looked at the new unified try/except/finally statement in\nChapter 33, it is possible to nest try statements syntactically by their position in your\nsource code:\ntry:\n\ntry:\n\naction2()\nexcept TypeError:\nprint('inner try')\nexcept TypeError:\nprint('outer try')\n\n# Most recent matching try\n# Here, only if nested handler re-raises\n\nNesting Exception Handlers | 875",
    "try:\n\naction2()\nexcept TypeError:\nprint('inner try')\nexcept TypeError:\nprint('outer try')\n\n# Most recent matching try\n# Here, only if nested handler re-raises\n\nNesting Exception Handlers | 875\n\n\fReally, this code just sets up the same handler-nesting structure as (and behaves identically to) the prior example. In fact, syntactic nesting works just like the cases sketched\nin Figures 35-1 and 35-2; the only difference is that the nested handlers are physically\nembedded in a try block, not coded in functions called elsewhere. For example, nested\nfinally handlers all fire on an exception, whether they are nested syntactically or by\nmeans of the runtime flow through physically separated parts of your code:\n>>> try:\n...\ntry:\n...\nraise IndexError\n...\nfinally:\n...\nprint('spam')\n... finally:\n...\nprint('SPAM')\n...\nspam\nSPAM\nTraceback (most recent call last):\nFile \"<stdin>\", line 3, in <module>\nIndexError",
    "See Figure 35-2 for a graphic illustration of this code’s operation; the effect is the same,\nbut the function logic has been inlined as nested statements here. For a more useful\nexample of syntactic nesting at work, consider the following file, except-finally.py:\ndef raise1(): raise IndexError\ndef noraise(): return\ndef raise2(): raise SyntaxError\nfor func in (raise1, noraise, raise2):\nprint('\\n', func, sep='')\ntry:\ntry:\nfunc()\nexcept IndexError:\nprint('caught IndexError')\nfinally:\nprint('finally run')\n\nThis code catches an exception if one is raised and performs a finally terminationtime action regardless of whether an exception occurs. This may take a few moments\nto digest, but the effect is much like combining an except and a finally clause in a\nsingle try statement in Python 2.5 and later:\n% python except-finally.py\n<function raise1 at 0x026ECA98>\ncaught IndexError\nfinally run\n<function noraise at 0x026ECA50>\nfinally run\n<function raise2 at 0x026ECBB8>\nfinally run",
    "876 | Chapter 35: Designing with Exceptions\n\n\fTraceback (most recent call last):\nFile \"except-finally.py\", line 9, in <module>\nfunc()\nFile \"except-finally.py\", line 3, in raise2\ndef raise2(): raise SyntaxError\nSyntaxError: None\n\nAs we saw in Chapter 33, as of Python 2.5, except and finally clauses can be mixed\nin the same try statement. This makes some of the syntactic nesting described in this\nsection unnecessary, though it still works, may appear in code written prior to Python\n2.5 that you may encounter, and can be used as a technique for implementing alternative exception-handling behaviors.\n\nException Idioms\nWe’ve seen the mechanics behind exceptions. Now let’s take a look at some of the other\nways they are typically used.",
    "Exceptions Aren’t Always Errors\nIn Python, all errors are exceptions, but not all exceptions are errors. For instance, we\nsaw in Chapter 9 that file object read methods return an empty string at the end of a\nfile. In contrast, the built-in input function (which we first met in Chapter 3 and deployed in an interactive loop in Chapter 10) reads a line of text from the standard input\nstream, sys.stdin, at each call and raises the built-in EOFError at end-of-file. (This\nfunction is known as raw_input in Python 2.6.)\nUnlike file methods, this function does not return an empty string—an empty string\nfrom input means an empty line. Despite its name, the EOFError exception is just a\nsignal in this context, not an error. Because of this behavior, unless the end-of-file\nshould terminate a script, input often appears wrapped in a try handler and nested in\na loop, as in the following code:\nwhile True:\ntry:\nline = input()\n# Read line from stdin\nexcept EOFError:\nbreak\n# Exit loop at end-of-file",
    "from input means an empty line. Despite its name, the EOFError exception is just a\nsignal in this context, not an error. Because of this behavior, unless the end-of-file\nshould terminate a script, input often appears wrapped in a try handler and nested in\na loop, as in the following code:\nwhile True:\ntry:\nline = input()\n# Read line from stdin\nexcept EOFError:\nbreak\n# Exit loop at end-of-file\nelse:\n...process next line here...",
    "Several other built-in exceptions are similarly signals, not errors—calling sys.exit()\nand pressing Ctrl-C on your keyboard, respectively, raise SystemExit and Key\nboardInterrupt, for example. Python also has a set of built-in exceptions that represent\nwarnings rather than errors; some of these are used to signal use of deprecated (phased\nout) language features. See the standard library manual’s description of built-in exceptions for more information, and consult the warnings module’s documentation for more\non warnings.\n\nException Idioms | 877",
    "Exception Idioms | 877\n\n\fFunctions Can Signal Conditions with raise\nUser-defined exceptions can also signal nonerror conditions. For instance, a search\nroutine can be coded to raise an exception when a match is found instead of returning\na status flag for the caller to interpret. In the following, the try/except/else exception\nhandler does the work of an if/else return-value tester:\nclass Found(Exception): pass\ndef searcher():\nif ...success...:\nraise Found()\nelse:\nreturn\ntry:\n\nsearcher()\nexcept Found:\n...success...\nelse:\n...failure...\n\n# Exception if item was found\n# else returned: not found",
    "searcher()\nexcept Found:\n...success...\nelse:\n...failure...\n\n# Exception if item was found\n# else returned: not found\n\nMore generally, such a coding structure may also be useful for any function that cannot\nreturn a sentinel value to designate success or failure. For instance, if all objects are\npotentially valid return values, it’s impossible for any return value to signal unusual\nconditions. Exceptions provide a way to signal results without a return value:\nclass Failure(Exception): pass\ndef searcher():\nif ...success...:\nreturn ...founditem...\nelse:\nraise Failure()\ntry:\n\nitem = searcher()\nexcept Failure:\n...report...\nelse:\n...use item here...\n\nBecause Python is dynamically typed and polymorphic to the core, exceptions, rather\nthan sentinel return values, are the generally preferred way to signal such conditions.",
    "item = searcher()\nexcept Failure:\n...report...\nelse:\n...use item here...\n\nBecause Python is dynamically typed and polymorphic to the core, exceptions, rather\nthan sentinel return values, are the generally preferred way to signal such conditions.\n\nClosing Files and Server Connections\nWe encountered examples in this category in Chapter 33. As a summary, though, exception processing tools are also commonly used to ensure that system resources are\nfinalized, regardless of whether an error occurs during processing or not.\n\n878 | Chapter 35: Designing with Exceptions",
    "Closing Files and Server Connections\nWe encountered examples in this category in Chapter 33. As a summary, though, exception processing tools are also commonly used to ensure that system resources are\nfinalized, regardless of whether an error occurs during processing or not.\n\n878 | Chapter 35: Designing with Exceptions\n\n\fFor example, some servers require connections to be closed in order to terminate a\nsession. Similarly, output files may require close calls to flush their buffers to disk, and\ninput files may consume file descriptors if not closed; although file objects are automatically closed when garbage collected if still open, it’s sometimes difficult to be sure\nwhen that will occur.\nThe most general and explicit way to guarantee termination actions for a specific block\nof code is the try/finally statement:\nmyfile = open(r'C:\\misc\\script', 'w')\ntry:\n...process myfile...\nfinally:\nmyfile.close()",
    "As we saw in Chapter 33, some objects make this easier in Python 2.6 and 3.0 by\nproviding context managers run by the with/as statement that terminate or close the\nobjects for us automatically:\nwith open(r'C:\\misc\\script', 'w') as myfile:\n...process myfile...",
    "So which option is better here? As usual, it depends on your programs. Compared to\nthe try/finally, context managers are more implicit, which runs contrary to Python’s\ngeneral design philosophy. Context managers are also arguably less general—they are\navailable only for select objects, and writing user-defined context managers to handle\ngeneral termination requirements is more complex than coding a try/finally.\nOn the other hand, using existing context managers requires less code than using try/\nfinally, as shown by the preceding examples. Moreover, the context manager protocol\nsupports entry actions in addition to exit actions. Although the try/finally is perhaps\nthe more widely applicable technique, context managers may be more appropriate\nwhere they are already available, or where their extra complexity is warranted.",
    "Debugging with Outer try Statements\nYou can also make use of exception handlers to replace Python’s default top-level\nexception-handling behavior. By wrapping an entire program (or a call to it) in an outer\ntry in your top-level code, you can catch any exception that may occur while your\nprogram runs, thereby subverting the default program termination.\nIn the following, the empty except clause catches any uncaught exception raised while\nthe program runs. To get hold of the actual exception that occurred, fetch the\nsys.exc_info function call result from the built-in sys module; it returns a tuple whose\nfirst two items contain the current exception’s class and the instance object raised (more\non sys.exc_info in a moment):\n\nException Idioms | 879\n\n\ftry:\n\n...run program...\nexcept:\n# All uncaught exceptions come here\nimport sys\nprint('uncaught!', sys.exc_info()[0], sys.exc_info()[1])",
    "Exception Idioms | 879\n\n\ftry:\n\n...run program...\nexcept:\n# All uncaught exceptions come here\nimport sys\nprint('uncaught!', sys.exc_info()[0], sys.exc_info()[1])\n\nThis structure is commonly used during development, to keep programs active even\nafter errors occur—it allows you to run additional tests without having to restart. It’s\nalso used when testing other program code, as described in the next section.\n\nRunning In-Process Tests\nYou might combine some of the coding patterns we’ve just looked at in a test-driver\napplication that tests other code within the same process:\nimport sys\nlog = open('testlog', 'a')\nfrom testapi import moreTests, runNextTest, testName\ndef testdriver():\nwhile moreTests():\ntry:\nrunNextTest()\nexcept:\nprint('FAILED', testName(), sys.exc_info()[:2], file=log)\nelse:\nprint('PASSED', testName(), file=log)\ntestdriver()",
    "The testdriver function here cycles through a series of test calls (the module testapi\nis left abstract in this example). Because an uncaught exception in a test case would\nnormally kill this test driver, you need to wrap test case calls in a try if you want to\ncontinue the testing process after a test fails. The empty except catches any uncaught\nexception generated by a test case as usual, and it uses sys.exc_info to log the exception\nto a file. The else clause is run when no exception occurs—the test success case.\nSuch boilerplate code is typical of systems that test functions, modules, and classes by\nrunning them in the same process as the test driver. In practice, however, testing can\nbe much more sophisticated than this. For instance, to test external programs, you\ncould instead check status codes or outputs generated by program-launching tools such\nas os.system and os.popen, covered in the standard library manual (such tools do not",
    "running them in the same process as the test driver. In practice, however, testing can\nbe much more sophisticated than this. For instance, to test external programs, you\ncould instead check status codes or outputs generated by program-launching tools such\nas os.system and os.popen, covered in the standard library manual (such tools do not\ngenerally raise exceptions for errors in the external programs—in fact, the test cases\nmay run in parallel with the test driver).\nAt the end of this chapter, we’ll also meet some more complete testing frameworks\nprovided by Python, such as doctest and PyUnit, which provide tools for comparing\nexpected outputs with actual results.",
    "880 | Chapter 35: Designing with Exceptions\n\n\fMore on sys.exc_info\nThe sys.exc_info result used in the last two sections allows an exception handler to\ngain access to the most recently raised exception generically. This is especially useful\nwhen using the empty except clause to catch everything blindly, to determine what was\nraised:\ntry:\n\n...\nexcept:\n# sys.exc_info()[0:2] are the exception class and instance",
    "...\nexcept:\n# sys.exc_info()[0:2] are the exception class and instance\n\nIf no exception is being handled, this call it returns a tuple containing three None values.\nOtherwise, the values returned are (type, value, traceback), where:\n• type is the exception class of the exception being handled.\n• value is the exception class instance that was raised.\n• traceback is a traceback object that represents the call stack at the point where the\nexception originally occurred (see the traceback module’s documentation for tools\nthat may be used in conjunction with this object to generate error messages\nmanually).\nAs we saw in the prior chapter, sys.exc_info can also sometimes be useful to determine\nthe specific exception type when catching exception category superclasses. As we saw,\nthough, because in this case you can also get the exception type by fetching the\n__class__ attribute of the instance obtained with the as clause, sys.exc_info is mostly\nused by the empty except today:\ntry:",
    "...\nexcept General as instance:\n# instance.__class__ is the exception class\n\nThat said, using the instance object’s interfaces and polymorphism is often a better\napproach than testing exception types—exception methods can be defined per class\nand run generically:\ntry:\n\n...\nexcept General as instance:\n# instance.method() does the right thing for this instance\n\nAs usual, being too specific in Python can limit your code’s flexibility. A polymorphic\napproach like the last example here generally supports future evolution better.\n\nException Idioms | 881",
    "...\nexcept General as instance:\n# instance.method() does the right thing for this instance\n\nAs usual, being too specific in Python can limit your code’s flexibility. A polymorphic\napproach like the last example here generally supports future evolution better.\n\nException Idioms | 881\n\n\fVersion skew note: In Python 2.6, the older tools sys.exc_type and\nsys.exc_value still work to fetch the most recent exception type and\nvalue, but they can manage only a single, global exception for the entire\nprocess. These two names have been removed in Python 3.0. The newer\nand preferred sys.exc_info() call available in both 2.6 and 3.0 instead\nkeeps track of each thread’s exception information, and so is threadspecific. Of course, this distinction matters only when using multiple\nthreads in Python programs (a subject beyond this book’s scope), but\n3.0 forces the issue. See other resources for more details.",
    "Exception Design Tips and Gotchas\nI’m lumping design tips and gotchas together in this chapter, because it turns out that\nthe most common gotchas largely stem from design issues. By and large, exceptions\nare easy to use in Python. The real art behind them is in deciding how specific or general\nyour except clauses should be and how much code to wrap up in try statements. Let’s\naddress the second of these concerns first.",
    "What Should Be Wrapped\nIn principle, you could wrap every statement in your script in its own try, but that\nwould just be silly (the try statements would then need to be wrapped in try statements!). What to wrap is really a design issue that goes beyond the language itself, and\nit will become more apparent with use. But for now, here are a few rules of thumb:\n• Operations that commonly fail should generally be wrapped in try statements. For\nexample, operations that interface with system state (file opens, socket calls, and\nthe like) are prime candidates for trys.\n• However, there are exceptions to the prior rule—in a simple script, you may\nwant failures of such operations to kill your program instead of being caught and\nignored. This is especially true if the failure is a showstopper. Failures in Python\ntypically result in useful error messages (not hard crashes), and this is often the\nbest outcome you could hope for.",
    "• However, there are exceptions to the prior rule—in a simple script, you may\nwant failures of such operations to kill your program instead of being caught and\nignored. This is especially true if the failure is a showstopper. Failures in Python\ntypically result in useful error messages (not hard crashes), and this is often the\nbest outcome you could hope for.\n• You should implement termination actions in try/finally statements to guarantee\ntheir execution, unless a context manager is available as a with/as option. The try/\nfinally statement form allows you to run code whether exceptions occur or not\nin arbitrary scenarios.\n• It is sometimes more convenient to wrap the call to a large function in a single\ntry statement, rather than littering the function itself with many try statements.\nThat way, all exceptions in the function percolate up to the try around the call,\nand you reduce the amount of code within the function.",
    "in arbitrary scenarios.\n• It is sometimes more convenient to wrap the call to a large function in a single\ntry statement, rather than littering the function itself with many try statements.\nThat way, all exceptions in the function percolate up to the try around the call,\nand you reduce the amount of code within the function.\nThe types of programs you write will probably influence the amount of exception handling you code as well. Servers, for instance, must generally keep running persistently\n882 | Chapter 35: Designing with Exceptions",
    "and so will likely require try statements to catch and recover from exceptions. Inprocess testing programs of the kind we saw in this chapter will probably handle exceptions as well. Simpler one-shot scripts, though, will often ignore exception handling\ncompletely because failure at any step requires script shutdown.",
    "Catching Too Much: Avoid Empty except and Exception\nOn to the issue of handler generality. Python lets you pick and choose which exceptions\nto catch, but you sometimes have to be careful to not be too inclusive. For example,\nyou’ve seen that an empty except clause catches every exception that might be raised\nwhile the code in the try block runs.\nThat’s easy to code, and sometimes desirable, but you may also wind up intercepting\nan error that’s expected by a try handler higher up in the exception nesting structure.\nFor example, an exception handler such as the following catches and stops every exception that reaches it, regardless of whether another handler is waiting for it:\ndef func():\ntry:\n...\nexcept:\n...\ntry:\nfunc()\nexcept IndexError:\n...\n\n# IndexError is raised in here\n# But everything comes here and dies!\n# Exception should be processed here",
    "# IndexError is raised in here\n# But everything comes here and dies!\n# Exception should be processed here\n\nPerhaps worse, such code might also catch unrelated system exceptions. Even things\nlike memory errors, genuine programming mistakes, iteration stops, keyboard interrupts, and system exits raise exceptions in Python. Such exceptions should not usually\nbe intercepted.\nFor example, scripts normally exit when control falls off the end of the top-level file.\nHowever, Python also provides a built-in sys.exit(statuscode) call to allow early terminations. This actually works by raising a built-in SystemExit exception to end the\nprogram, so that try/finally handlers run on the way out and special types of programs\ncan intercept the event.* Because of this, a try with an empty except might unknowingly\nprevent a crucial exit, as in the following file (exiter.py):\nimport sys\ndef bye():\nsys.exit(40)\ntry:\nbye()\nexcept:\nprint('got it')\n\n# Crucial error: abort now!\n\n# Oops--we ignored the exit",
    "# Crucial error: abort now!\n\n# Oops--we ignored the exit\n\n* A related call, os._exit, also ends a program, but via an immediate termination—it skips cleanup actions\nand cannot be intercepted with try/except or try/finally blocks. It is usually only used in spawned child\nprocesses, a topic beyond this book’s scope. See the library manual or follow-up texts for details.\n\nException Design Tips and Gotchas | 883\n\n\fprint('continuing...')\n% python exiter.py\ngot it\ncontinuing...\n\nYou simply might not expect all the kinds of exceptions that could occur during an\noperation. Using the built-in exception classes of the prior chapter can help in this\nparticular case, because the Exception superclass is not a superclass of SystemExit:\ntry:\n\nbye()\nexcept Exception:\n...\n\n# Won't catch exits, but _will_ catch many others",
    "bye()\nexcept Exception:\n...\n\n# Won't catch exits, but _will_ catch many others\n\nIn other cases, though, this scheme is no better than an empty except clause—because\nException is a superclass above all built-in exceptions except system-exit events, it still\nhas the potential to catch exceptions meant for elsewhere in the program.\nProbably worst of all, both an empty except and catching the Exception class will also\ncatch genuine programming errors, which should be allowed to pass most of the time.\nIn fact, these two techniques can effectively turn off Python’s error-reporting machinery, making it difficult to notice mistakes in your code. Consider this code, for\nexample:\nmydictionary = {...}\n...\ntry:\nx = myditctionary['spam']\nexcept:\nx = None\n...continue here with x...\n\n# Oops: misspelled\n# Assume we got KeyError",
    "The coder here assumes that the only sort of error that can happen when indexing a\ndictionary is a missing key error. But because the name myditctionary is misspelled (it\nshould say mydictionary), Python raises a NameError instead for the undefined name\nreference, which the handler will silently catch and ignore. The event handler will incorrectly fill in a default for the dictionary access, masking the program error. Moreover,\ncatching Exception here would have the exact same effect as an empty except. If this\nhappens in code that is far removed from the place where the fetched values are used,\nit might make for a very interesting debugging task!\nAs a rule of thumb, be as specific in your handlers as you can be—empty except clauses\nand Exception catchers are handy, but potentially error-prone. In the last example, for\ninstance, you would be better off saying except KeyError: to make your intentions",
    "happens in code that is far removed from the place where the fetched values are used,\nit might make for a very interesting debugging task!\nAs a rule of thumb, be as specific in your handlers as you can be—empty except clauses\nand Exception catchers are handy, but potentially error-prone. In the last example, for\ninstance, you would be better off saying except KeyError: to make your intentions\nexplicit and avoid intercepting unrelated events. In simpler scripts, the potential for\nproblems might not be significant enough to outweigh the convenience of a catchall,\nbut in general, general handlers are generally trouble.",
    "884 | Chapter 35: Designing with Exceptions\n\n\fCatching Too Little: Use Class-Based Categories\nOn the other hand, neither should handlers be too specific. When you list specific\nexceptions in a try, you catch only what you actually list. This isn’t necessarily a bad\nthing, but if a system evolves to raise other exceptions in the future, you may need to\ngo back and add them to exception lists elsewhere in your code.\nWe saw this phenomenon at work in the prior chapter. For instance, the following\nhandler is written to treat MyExcept1 and MyExcept2 as normal cases and everything else\nas an error. Therefore, if you add a MyExcept3 in the future, it will be processed as an\nerror unless you update the exception list:\ntry:\n\n...\nexcept (MyExcept1, MyExcept2):\n...\nelse:\n...\n\n# Breaks if you add a MyExcept3\n# Non-errors\n# Assumed to be an error",
    "...\nexcept (MyExcept1, MyExcept2):\n...\nelse:\n...\n\n# Breaks if you add a MyExcept3\n# Non-errors\n# Assumed to be an error\n\nLuckily, careful use of the class-based exceptions we discussed in Chapter 33 can make\nthis trap go away completely. As we saw, if you catch a general superclass, you can add\nand raise more specific subclasses in the future without having to extend except clause\nlists manually—the superclass becomes an extendible exceptions category:\ntry:\n\n...\nexcept SuccessCategoryName:\n...\nelse:\n...\n\n# OK if I add a myerror3 subclass\n# Non-errors\n# Assumed to be an error\n\nIn other words, a little design goes a long way. The moral of the story is to be careful\nto be neither too general nor too specific in exception handlers, and to pick the granularity of your try statement wrappings wisely. Especially in larger systems, exception\npolicies should be a part of the overall design.",
    "In other words, a little design goes a long way. The moral of the story is to be careful\nto be neither too general nor too specific in exception handlers, and to pick the granularity of your try statement wrappings wisely. Especially in larger systems, exception\npolicies should be a part of the overall design.\n\nCore Language Summary\nCongratulations! This concludes your look at the core Python programming language.\nIf you’ve gotten this far, you may consider yourself an Official Python Programmer (and\nshould feel free to add Python to your résumé the next time you dig it out). You’ve\nalready seen just about everything there is to see in the language itself, and all in much\nmore depth than many practicing Python programmers initially do. You’ve studied\nbuilt-in types, statements, and exceptions, as well as tools used to build up larger program units (functions, modules, and classes); you’ve even explored important design\nissues, OOP, program architecture, and more.",
    "Core Language Summary | 885",
    "The Python Toolset\nFrom this point forward, your future Python career will largely consist of becoming\nproficient with the toolset available for application-level Python programming. You’ll\nfind this to be an ongoing task. The standard library, for example, contains hundreds\nof modules, and the public domain offers still more tools. It’s possible to spend a decade\nor more seeking proficiency with all these tools, especially as new ones are constantly\nappearing (trust me on this!).\nSpeaking generally, Python provides a hierarchy of toolsets:\nBuilt-ins\nBuilt-in types like strings, lists, and dictionaries make it easy to write simple programs fast.\nPython extensions\nFor more demanding tasks, you can extend Python by writing your own functions,\nmodules, and classes.\nCompiled extensions\nAlthough we don’t cover this topic in this book, Python can also be extended with\nmodules written in an external language like C or C++.",
    "Built-ins\nBuilt-in types like strings, lists, and dictionaries make it easy to write simple programs fast.\nPython extensions\nFor more demanding tasks, you can extend Python by writing your own functions,\nmodules, and classes.\nCompiled extensions\nAlthough we don’t cover this topic in this book, Python can also be extended with\nmodules written in an external language like C or C++.\nBecause Python layers its toolsets, you can decide how deeply your programs need to\ndelve into this hierarchy for any given task—you can use built-ins for simple scripts,\nadd Python-coded extensions for larger systems, and code compiled extensions for\nadvanced work. We’ve only covered the first two of these categories in this book, and\nthat’s plenty to get you started doing substantial programming in Python.\nTable 35-1 summarizes some of the sources of built-in or existing functionality available\nto Python programmers, and some topics you’ll probably be busy exploring for the",
    "advanced work. We’ve only covered the first two of these categories in this book, and\nthat’s plenty to get you started doing substantial programming in Python.\nTable 35-1 summarizes some of the sources of built-in or existing functionality available\nto Python programmers, and some topics you’ll probably be busy exploring for the\nremainder of your Python career. Up until now, most of our examples have been very\nsmall and self-contained. They were written that way on purpose, to help you master\nthe basics. But now that you know all about the core language, it’s time to start learning\nhow to use Python’s built-in interfaces to do real work. You’ll find that with a simple\nlanguage like Python, common tasks are often much easier than you might expect.\nTable 35-1. Python’s toolbox categories\nCategory",
    "Examples\n\nObject types\n\nLists, dictionaries, files, strings\n\nFunctions\n\nlen, range, open\n\nExceptions\n\nIndexError, KeyError\n\nModules\n\nos, tkinter, pickle, re\n\nAttributes\n\n__dict__, __name__, __class__\n\nPeripheral tools\n\nNumPy, SWIG, Jython, IronPython, Django, etc.\n\n886 | Chapter 35: Designing with Exceptions",
    "Development Tools for Larger Projects\nOnce you’ve mastered the basics, you’ll find your Python programs becoming substantially larger than the examples you’ve experimented with so far. For developing\nlarger systems, a set of development tools is available in Python and the public domain.\nYou’ve seen some of these in action, and I’ve mentioned a few others. To help you on\nyour way, here is a summary of some of the most commonly used tools in this domain:\nPyDoc and docstrings\nPyDoc’s help function and HTML interfaces were introduced in Chapter 15. PyDoc\nprovides a documentation system for your modules and objects and integrates with\nPython’s docstrings feature. It is a standard part of the Python system—see the\nlibrary manual for more details. Be sure to also refer back to the documentation\nsource hints listed in Chapter 4 for information on other Python information\nresources.\nPyChecker and PyLint\nBecause Python is such a dynamic language, some programming errors are not",
    "Python’s docstrings feature. It is a standard part of the Python system—see the\nlibrary manual for more details. Be sure to also refer back to the documentation\nsource hints listed in Chapter 4 for information on other Python information\nresources.\nPyChecker and PyLint\nBecause Python is such a dynamic language, some programming errors are not\nreported until your program runs (e.g., syntax errors are caught when a file is run\nor imported). This isn’t a big drawback—as with most languages, it just means\nthat you have to test your Python code before shipping it. At worst, with Python\nyou essentially trade a compile phase for an initial testing phase. Furthermore,\nPython’s dynamic nature, automatic error messages, and exception model make it\neasier and quicker to find and fix errors in Python than it is in some other languages\n(unlike C, for example, Python does not crash on errors).\nThe PyChecker and PyLint systems provide support for catching a large set of",
    "you essentially trade a compile phase for an initial testing phase. Furthermore,\nPython’s dynamic nature, automatic error messages, and exception model make it\neasier and quicker to find and fix errors in Python than it is in some other languages\n(unlike C, for example, Python does not crash on errors).\nThe PyChecker and PyLint systems provide support for catching a large set of\ncommon errors ahead of time, before your script runs. They serve similar roles to\nthe lint program in C development. Some Python groups run their code through\nPyChecker prior to testing or delivery, to catch any lurking potential problems. In\nfact, the Python standard library is regularly run through PyChecker before release.\nPyChecker and PyLint are third-party open source packages; you can find them at\nhttp://www.python.org or the PyPI website, or via your friendly neighborhood web\nsearch engine.\nPyUnit (a.k.a. unittest)\nIn Chapter 24, we learned how to add self-test code to a Python file by using the",
    "fact, the Python standard library is regularly run through PyChecker before release.\nPyChecker and PyLint are third-party open source packages; you can find them at\nhttp://www.python.org or the PyPI website, or via your friendly neighborhood web\nsearch engine.\nPyUnit (a.k.a. unittest)\nIn Chapter 24, we learned how to add self-test code to a Python file by using the\n__name__ == '__main__' trick at the bottom of the file. For more advanced testing\npurposes, Python comes with two testing support tools. The first, PyUnit (called\nunittest in the library manual), provides an object-oriented class framework for\nspecifying and customizing test cases and expected results. It mimics the JUnit\nframework for Java. This is a sophisticated class-based unit testing system; see the\nPython library manual for details.\ndoctest",
    "The doctest standard library module provides a second and simpler approach to\nregression testing, based upon Python’s docstrings feature. Roughly, to use\n\nCore Language Summary | 887\n\n\fdoctest, you cut and paste a log of an interactive testing session into the docstrings\nof your source files. doctest then extracts your docstrings, parses out the test cases\nand results, and reruns the tests to verify the expected results. doctest’s operation",
    "can be tailored in a variety of ways; see the library manual for more details.\nIDEs\nWe discussed IDEs for Python in Chapter 3. IDEs such as IDLE provide a graphical\nenvironment for editing, running, debugging, and browsing your Python\nprograms. Some advanced IDEs (such as Eclipse, Komodo, NetBeans, and Wing\nIDE) may support additional development tasks, including source control integration, code refactoring, project management tools, and more. See Chapter 3, the\ntext editors page at http://www.python.org, and your favorite web search engine for\nmore on available IDEs and GUI builders for Python.\nProfilers\nBecause Python is so high-level and dynamic, intuitions about performance\ngleaned from experience with other languages usually don’t apply to Python code.\nTo truly isolate performance bottlenecks in your code, you need to add timing logic\nwith clock tools in the time or timeit modules, or run your code under the",
    "more on available IDEs and GUI builders for Python.\nProfilers\nBecause Python is so high-level and dynamic, intuitions about performance\ngleaned from experience with other languages usually don’t apply to Python code.\nTo truly isolate performance bottlenecks in your code, you need to add timing logic\nwith clock tools in the time or timeit modules, or run your code under the\nprofile module. We saw an example of the timing modules at work when comparing iteration tools’ speeds in Chapter 20. Profiling is usually your first optimization step—profile to isolate bottlenecks, then time alternative codings of them.\nprofile is a standard library module that implements a source code profiler for\nPython; it runs a string of code you provide (e.g., a script file import, or a call to a\nfunction) and then, by default, prints a report to the standard output stream that\ngives performance statistics—number of calls to each function, time spent in each\nfunction, and more.",
    "profile is a standard library module that implements a source code profiler for\nPython; it runs a string of code you provide (e.g., a script file import, or a call to a\nfunction) and then, by default, prints a report to the standard output stream that\ngives performance statistics—number of calls to each function, time spent in each\nfunction, and more.\nThe profile module can be run as a script or imported, and it may be customized\nin various ways; for example, it can save run statistics to a file to be analyzed later\nwith the pstats module. To profile interactively, import the profile module and\ncall profile.run('code'), passing in the code you wish to profile as a string (e.g.,\na call to a function, or an import of an entire file). To profile from a system shell\ncommand line, use a command of the form python -m profile main.py args...",
    "with the pstats module. To profile interactively, import the profile module and\ncall profile.run('code'), passing in the code you wish to profile as a string (e.g.,\na call to a function, or an import of an entire file). To profile from a system shell\ncommand line, use a command of the form python -m profile main.py args...\n(see Appendix A for more on this format). Also see Python’s standard library manuals for other profiling options; the cProfile module, for example, has identical\ninterfaces to profile but runs with less overhead, so it may be better suited to\nprofiling long-running programs.\nDebuggers\nWe also discussed debugging options in Chapter 3 (see its sidebar “Debugging\nPython Code” on page 67). As a review, most development IDEs for Python support\nGUI-based debugging, and the Python standard library also includes a source code\ndebugger module called pdb. This module provides a command-line interface and\nworks much like common C language debuggers (e.g., dbx, gdb).",
    "888 | Chapter 35: Designing with Exceptions",
    "Much like the profiler, the pdb debugger can be run either interactively or from a\ncommand line and can be imported and called from a Python program. To use it\ninteractively, import the module, start running code by calling a pdb function (e.g.,\npdb.run(\"main()\")), and then type debugging commands from pdb’s interactive\nprompt. To launch pdb from a system shell command line, use a command of the\nform python -m pdb main.py args... (see Appendix A for more on this format).\npdb also includes a useful postmortem analysis call, pdb.pm(), which starts the\ndebugger after an exception has been encountered.\nBecause IDEs such as IDLE also include point-and-click debugging interfaces,\npdb isn’t a critical a tool today, except when a GUI isn’t available or when more\ncontrol is desired. See Chapter 3 for tips on using IDLE’s debugging GUI interfaces.",
    "pdb also includes a useful postmortem analysis call, pdb.pm(), which starts the\ndebugger after an exception has been encountered.\nBecause IDEs such as IDLE also include point-and-click debugging interfaces,\npdb isn’t a critical a tool today, except when a GUI isn’t available or when more\ncontrol is desired. See Chapter 3 for tips on using IDLE’s debugging GUI interfaces.\nReally, neither pdb nor IDEs seem to be used much in practice—as noted in Chapter 3, most programmers either insert print statements or simply read Python’s\nerror messages (not the most high-tech of approaches, but the practical tends to\nwin the day in the Python world!).\nShipping options\nIn Chapter 2, we introduced common tools for packaging Python programs.\npy2exe, PyInstaller, and freeze can package byte code and the Python Virtual Machine into “frozen binary” standalone executables, which don’t require that Python\nbe installed on the target machine and fully hide your system’s code. In addition,",
    "win the day in the Python world!).\nShipping options\nIn Chapter 2, we introduced common tools for packaging Python programs.\npy2exe, PyInstaller, and freeze can package byte code and the Python Virtual Machine into “frozen binary” standalone executables, which don’t require that Python\nbe installed on the target machine and fully hide your system’s code. In addition,\nwe learned in Chapter 2 that Python programs may be shipped in their source\n(.py) or byte code (.pyc) forms, and that import hooks support special packaging\ntechniques such as automatic extraction of .zip files and byte code encryption.\nWe also briefly met the standard library’s distutils modules, which provide packaging options for Python modules and packages, and C-coded extensions; see the\nPython manuals for more details. The emerging Python “eggs” third-party packaging system provides another alternative that also accounts for dependencies;\nsearch the Web for more details.\nOptimization options",
    "We also briefly met the standard library’s distutils modules, which provide packaging options for Python modules and packages, and C-coded extensions; see the\nPython manuals for more details. The emerging Python “eggs” third-party packaging system provides another alternative that also accounts for dependencies;\nsearch the Web for more details.\nOptimization options\nThere are a couple of options for optimizing your programs. The Psyco system\ndescribed in Chapter 2 provides a just-in-time compiler for translating Python byte\ncode to binary machine code, and Shedskin offers a Python-to-C++ translator. You\nmay also occasionally see .pyo optimized byte code files, generated and run with\nthe -O Python command-line flag (discussed in Chapters 21 and 33); because this\nprovides a very modest performance boost, however, it is not commonly used.\nAs a last resort, you can also move parts of your program to a compiled language",
    "code to binary machine code, and Shedskin offers a Python-to-C++ translator. You\nmay also occasionally see .pyo optimized byte code files, generated and run with\nthe -O Python command-line flag (discussed in Chapters 21 and 33); because this\nprovides a very modest performance boost, however, it is not commonly used.\nAs a last resort, you can also move parts of your program to a compiled language\nsuch as C to boost performance; see the book Programming Python and the Python\nstandard manuals for more on C extensions. In general, Python’s speed also improves over time, so be sure to upgrade to the faster releases when possible.",
    "Core Language Summary | 889\n\n\fOther hints for larger projects\nWe’ve met a variety of language features in this text that will tend to become more\nuseful once you start coding larger projects. These include module packages\n(Chapter 23), class-based exceptions (Chapter 33), class pseudoprivate attributes\n(Chapter 30), documentation strings (Chapter 15), module path configuration files\n(Chapter 21), hiding names from from * with __all__ lists and _X-style names\n(Chapter 24), adding self-test code with the __name__ == '__main__' trick (Chapter 24), using common design rules for functions and modules (Chapters 17, 19,\nand 24), using object-oriented design patterns (Chapter 30 and others), and so on.\nTo learn about other large-scale Python development tools available in the public domain, be sure to browse the pages at the PyPI website at http://www.python.org, and\nthe Web at large.",
    "Chapter Summary\nThis chapter wrapped up the exceptions part of the book with a survey of related statements, a look at common exception use cases, and a brief summary of commonly used\ndevelopment tools.\nThis chapter also wrapped up the core material of this book. At this point, you’ve been\nexposed to the full subset of Python that most programmers use. In fact, if you have\nread this far, you should feel free to consider yourself an official Python programmer.\nBe sure to pick up a t-shirt the next time you’re online.\nThe next and final part of this book is a collection of chapters dealing with topics that\nare advanced, but still in the core language category. These chapters are all optional\nreading, because not every Python programmer must delve into their subjects; indeed,",
    "Be sure to pick up a t-shirt the next time you’re online.\nThe next and final part of this book is a collection of chapters dealing with topics that\nare advanced, but still in the core language category. These chapters are all optional\nreading, because not every Python programmer must delve into their subjects; indeed,\nmost of you can stop here and begin exploring Python’s roles in your application domains. Frankly, application libraries tend to be more important in practice than advanced (and to some, esoteric) language features.\nOn the other hand, if you do need to care about things like Unicode or binary data,\nhave to deal with API-building tools such as descriptors, decorators, and metaclasses,\nor just want to dig a bit further in general, the next part of the book will help you get\nstarted. The larger examples in the final part will also give you a chance to see the\nconcepts you’ve already learned being applied in more realistic ways.",
    "have to deal with API-building tools such as descriptors, decorators, and metaclasses,\nor just want to dig a bit further in general, the next part of the book will help you get\nstarted. The larger examples in the final part will also give you a chance to see the\nconcepts you’ve already learned being applied in more realistic ways.\nAs this is the end of the core material of this book, you get a break on the chapter quiz—\njust one question this time. As always, though, be sure to work through this part’s\nclosing exercises to cement what you’ve learned in the past few chapters; because the\nnext part is optional reading, this is the final end-of-part exercises session. If you want\nto see some examples of how what you’ve learned comes together in real scripts drawn\nfrom common applications, check out the “solution” to exercise 4 in Appendix B.",
    "890 | Chapter 35: Designing with Exceptions\n\n\fTest Your Knowledge: Quiz\n1. (This question is a repeat from the first quiz in Chapter 1—see, I told you it would\nbe easy! :-) Why does “spam” show up in so many Python examples in books and\non the Web?\n\nTest Your Knowledge: Answers\n1. Because Python is named after the British comedy group Monty Python (based on\nsurveys I’ve conducted in classes, this is a much-too-well-kept secret in the Python\nworld!). The spam reference comes from a Monty Python skit, where a couple who\nare trying to order food in a cafeteria keep getting drowned out by a chorus of\nVikings singing a song about spam. No, really. And if I could insert an audio clip\nof that song here, I would....",
    "Test Your Knowledge: Part VII Exercises\nAs we’ve reached the end of this part of the book, it’s time for a few exception exercises\nto give you a chance to practice the basics. Exceptions really are simple tools; if you get\nthese, you’ve probably mastered exceptions.\nSee “Part VII, Exceptions and Tools” on page 1130 in Appendix B for the solutions.\n1. try/except. Write a function called oops that explicitly raises an IndexError exception when called. Then write another function that calls oops inside a try/except\nstatement to catch the error. What happens if you change oops to raise a\nKeyError instead of an IndexError? Where do the names KeyError and IndexError\ncome from? (Hint: recall that all unqualified names come from one of four scopes.)\n2. Exception objects and lists. Change the oops function you just wrote to raise an\nexception you define yourself, called MyError. Identify your exception with a class.",
    "KeyError instead of an IndexError? Where do the names KeyError and IndexError\ncome from? (Hint: recall that all unqualified names come from one of four scopes.)\n2. Exception objects and lists. Change the oops function you just wrote to raise an\nexception you define yourself, called MyError. Identify your exception with a class.\nThen, extend the try statement in the catcher function to catch this exception and\nits instance in addition to IndexError, and print the instance you catch.\n3. Error handling. Write a function called safe(func, *args) that runs any function\nwith any number of arguments by using the *name arbitrary arguments call syntax,\ncatches any exception raised while the function runs, and prints the exception using\nthe exc_info call in the sys module. Then use your safe function to run your\noops function from exercise 1 or 2. Put safe in a module file called tools.py, and\npass it the oops function interactively. What kind of error messages do you get?",
    "catches any exception raised while the function runs, and prints the exception using\nthe exc_info call in the sys module. Then use your safe function to run your\noops function from exercise 1 or 2. Put safe in a module file called tools.py, and\npass it the oops function interactively. What kind of error messages do you get?\nFinally, expand safe to also print a Python stack trace when an error occurs by\ncalling the built-in print_exc function in the standard traceback module (see the\nPython library reference manual for details).\nTest Your Knowledge: Part VII Exercises | 891",
    "4. Self-study examples. At the end of Appendix B, I’ve included a handful of example\nscripts developed as group exercises in live Python classes for you to study and run\non your own in conjunction with Python’s standard manual set. These are not\ndescribed, and they use tools in the Python standard library that you’ll have to\nresearch on your own. Still, for many readers, it helps to see how the concepts\nwe’ve discussed in this book come together in real programs. If these whet your\nappetite for more, you can find a wealth of larger and more realistic\napplication-level Python program examples in follow-up books like Programming\nPython and on the Web.\n\n892 | Chapter 35: Designing with Exceptions\n\n\fPART VIII\n\nAdvanced Topics\n\n\f\fCHAPTER 36\n\nUnicode and Byte Strings",
    "In the strings chapter in the core types part of this book (Chapter 7), I deliberately\nlimited the scope to the subset of string topics that most Python programmers need to\nknow about. Because the vast majority of programmers deal with simple forms of text\nlike ASCII, they can happily work with Python’s basic str string type and its associated\noperations and don’t need to come to grips with more advanced string concepts. In\nfact, such programmers can largely ignore the string changes in Python 3.0 and continue\nto use strings as they may have in the past.\nOn the other hand, some programmers deal with more specialized types of data: nonASCII character sets, image file contents, and so on. For those programmers (and others\nwho may join them some day), in this chapter we’re going to fill in the rest of the Python\nstring story and look at some more advanced concepts in Python’s string model.\nSpecifically, we’ll explore the basics of Python’s support for Unicode text—",
    "who may join them some day), in this chapter we’re going to fill in the rest of the Python\nstring story and look at some more advanced concepts in Python’s string model.\nSpecifically, we’ll explore the basics of Python’s support for Unicode text—\nwide-character strings used in internationalized applications—as well as binary data—\nstrings that represent absolute byte values. As we’ll see, the advanced string\nrepresentation story has diverged in recent versions of Python:\n• Python 3.0 provides an alternative string type for binary data and supports Unicode\ntext in its normal string type (ASCII is treated as a simple type of Unicode).\n• Python 2.6 provides an alternative string type for non-ASCII Unicode text and\nsupports both simple text and binary data in its normal string type.\nIn addition, because Python’s string model has a direct impact on how you process",
    "• Python 3.0 provides an alternative string type for binary data and supports Unicode\ntext in its normal string type (ASCII is treated as a simple type of Unicode).\n• Python 2.6 provides an alternative string type for non-ASCII Unicode text and\nsupports both simple text and binary data in its normal string type.\nIn addition, because Python’s string model has a direct impact on how you process\nnon-ASCII files, we’ll explore the fundamentals of that related topic here as well. Finally, we’ll take a brief look at some advanced string and binary tools, such as pattern\nmatching, object pickling, binary data packing, and XML parsing, and the ways in\nwhich they are impacted by 3.0’s string changes.\nThis is officially an advanced topics chapter, because not all programmers will need to\ndelve into the worlds of Unicode encodings or binary data. If you ever need to care\nabout processing either of these, though, you’ll find that Python’s string models provide\nthe support you need.\n895",
    "String Changes in 3.0\nOne of the most noticeable changes in 3.0 is the mutation of string object types. In a\nnutshell, 2.X’s str and unicode types have morphed into 3.0’s str and bytes types, and\na new mutable bytearray type has been added. The bytearray type is technically available in Python 2.6 too (though not earlier), but it’s a back-port from 3.0 and does not\nas clearly distinguish between text and binary content in 2.6.\nEspecially if you process data that is either Unicode or binary in nature, these changes\ncan have substantial impacts on your code. In fact, as a general rule of thumb, how\nmuch you need to care about this topic depends in large part upon which of the following categories you fall into:\n• If you deal with non-ASCII Unicode text—for instance, in the context of internationalized applications and the results of some XML parsers—you will find support\nfor text encodings to be different in 3.0, but also probably more direct, accessible,\nand seamless than in 2.6.",
    "much you need to care about this topic depends in large part upon which of the following categories you fall into:\n• If you deal with non-ASCII Unicode text—for instance, in the context of internationalized applications and the results of some XML parsers—you will find support\nfor text encodings to be different in 3.0, but also probably more direct, accessible,\nand seamless than in 2.6.\n• If you deal with binary data—for example, in the form of image or audio files or\npacked data processed with the struct module—you will need to understand 3.0’s\nnew bytes object and 3.0’s different and sharper distinction between text and binary data and files.\n• If you fall into neither of the prior two categories, you can generally use strings in\n3.0 much as you would in 2.6: with the general str string type, text files, and all\nthe familiar string operations we studied earlier. Your strings will be encoded and",
    "new bytes object and 3.0’s different and sharper distinction between text and binary data and files.\n• If you fall into neither of the prior two categories, you can generally use strings in\n3.0 much as you would in 2.6: with the general str string type, text files, and all\nthe familiar string operations we studied earlier. Your strings will be encoded and\ndecoded using your platform’s default encoding (e.g., ASCII, or UTF-8 on Windows in the U.S.—sys.getdefaultencoding() gives your default if you care to\ncheck), but you probably won’t notice.\nIn other words, if your text is always ASCII, you can get by with normal string objects\nand text files and can avoid most of the following story. As we’ll see in a moment, ASCII\nis a simple kind of Unicode and a subset of other encodings, so string operations and\nfiles “just work” if your programs process ASCII text.\nEven if you fall into the last of the three categories just mentioned, though, a basic",
    "and text files and can avoid most of the following story. As we’ll see in a moment, ASCII\nis a simple kind of Unicode and a subset of other encodings, so string operations and\nfiles “just work” if your programs process ASCII text.\nEven if you fall into the last of the three categories just mentioned, though, a basic\nunderstanding of 3.0’s string model can help both to demystify some of the underlying\nbehavior now, and to make mastering Unicode or binary data issues easier if they impact\nyou in the future.\nPython 3.0’s support for Unicode and binary data is also available in 2.6, albeit in\ndifferent forms. Although our main focus in this chapter is on string types in 3.0, we’ll\nexplore some 2.6 differences along the way too. Regardless of which version you use,\nthe tools we’ll explore here can become important in many types of programs.",
    "896 | Chapter 36: Unicode and Byte Strings\n\n\fString Basics\nBefore we look at any code, let’s begin with a general overview of Python’s string model.\nTo understand why 3.0 changed the way it did on this front, we have to start with a\nbrief look at how characters are actually represented in computers.",
    "Character Encoding Schemes\nMost programmers think of strings as series of characters used to represent textual data.\nThe way characters are stored in a computer’s memory can vary, though, depending\non what sort of character set must be recorded.\nThe ASCII standard was created in the U.S., and it defines many U.S. programmers’\nnotion of text strings. ASCII defines character codes from 0 through 127 and allows\neach character to be stored in one 8-bit byte (only 7 bits of which are actually used).\nFor example, the ASCII standard maps the character 'a' to the integer value 97 (0x61\nin hex), which is stored in a single byte in memory and files. If you wish to see how this\nworks, Python’s ord built-in function gives the binary value for a character, and chr\nreturns the character for a given integer code value:\n>>> ord('a')\n97\n>>> hex(97)\n'0x61'\n>>> chr(97)\n'a'\n\n# 'a' is a byte with binary value 97 in ASCII\n\n# Binary value 97 stands for character 'a'",
    "# 'a' is a byte with binary value 97 in ASCII\n\n# Binary value 97 stands for character 'a'\n\nSometimes one byte per character isn’t enough, though. Various symbols and accented\ncharacters, for instance, do not fit into the range of possible characters defined by\nASCII. To accommodate special characters, some standards allow all possible values\nin an 8-bit byte, 0 through 255, to represent characters, and assign the values 128\nthrough 255 (outside ASCII’s range) to special characters. One such standard, known\nas Latin-1, is widely used in Western Europe. In Latin-1, character codes above 127\nare assigned to accented and otherwise special characters. The character assigned to\nbyte value 196, for example, is a specially marked non-ASCII character:\n>>> 0xC4\n196\n>>> chr(196)\n'Ä'",
    "This standard allows for a wide array of extra special characters. Still, some alphabets\ndefine so many characters that it is impossible to represent each of them as one byte.\nUnicode allows more flexibility. Unicode text is commonly referred to as\n“wide-character” strings, because each character may be represented with multiple\nbytes. Unicode is typically used in internationalized programs, to represent European\nand Asian character sets that have more characters than 8-bit bytes can represent.\n\nString Basics | 897",
    "To store such rich text in computer memory, we say that characters are translated to\nand from raw bytes using an encoding—the rules for translating a string of Unicode\ncharacters into a sequence of bytes, and extracting a string from a sequence of bytes.\nMore procedurally, this translation back and forth between bytes and strings is defined\nby two terms:\n• Encoding is the process of translating a string of characters into its raw bytes form,\naccording to a desired encoding name.\n• Decoding is the process of translating a raw string of bytes into is character string\nform, according to its encoding name.\nThat is, we encode from string to raw bytes, and decode from raw bytes to string. For\nsome encodings, the translation process is trivial—ASCII and Latin-1, for instance,\nmap each character to a single byte, so no translation work is required. For other encodings, the mapping can be more complex and yield multiple bytes per character.",
    "form, according to its encoding name.\nThat is, we encode from string to raw bytes, and decode from raw bytes to string. For\nsome encodings, the translation process is trivial—ASCII and Latin-1, for instance,\nmap each character to a single byte, so no translation work is required. For other encodings, the mapping can be more complex and yield multiple bytes per character.\nThe widely used UTF-8 encoding, for example, allows a wide range of characters to be\nrepresented by employing a variable number of bytes scheme. Character codes less than\n128 are represented as a single byte; codes between 128 and 0x7ff (2047) are turned\ninto two bytes, where each byte has a value between 128 and 255; and codes above\n0x7ff are turned into three- or four-byte sequences having values between 128 and 255.\nThis keeps simple ASCII strings compact, sidesteps byte ordering issues, and avoids\nnull (zero) bytes that can cause problems for C libraries and networking.",
    "into two bytes, where each byte has a value between 128 and 255; and codes above\n0x7ff are turned into three- or four-byte sequences having values between 128 and 255.\nThis keeps simple ASCII strings compact, sidesteps byte ordering issues, and avoids\nnull (zero) bytes that can cause problems for C libraries and networking.\nBecause encodings’ character maps assign characters to the same codes for compatibility, ASCII is a subset of both Latin-1 and UTF-8; that is, a valid ASCII character string\nis also a valid Latin-1- and UTF-8-encoded string. This is also true when the data is\nstored in files: every ASCII file is a valid UTF-8 file, because ASCII is a 7-bit subset of\nUTF-8.\nConversely, the UTF-8 encoding is binary compatible with ASCII for all character codes\nless than 128. Latin-1 and UTF-8 simply allow for additional characters: Latin-1 for\ncharacters mapped to values 128 through 255 within a byte, and UTF-8 for characters",
    "stored in files: every ASCII file is a valid UTF-8 file, because ASCII is a 7-bit subset of\nUTF-8.\nConversely, the UTF-8 encoding is binary compatible with ASCII for all character codes\nless than 128. Latin-1 and UTF-8 simply allow for additional characters: Latin-1 for\ncharacters mapped to values 128 through 255 within a byte, and UTF-8 for characters\nthat may be represented with multiple bytes. Other encodings allow wider character\nsets in similar ways, but all of these—ASCII, Latin-1, UTF-8, and many others—are\nconsidered to be Unicode.\nTo Python programmers, encodings are specified as strings containing the encoding’s\nname. Python comes with roughly 100 different encodings; see the Python library\nreference for a complete list. Importing the module encodings and running\nhelp(encodings) shows you many encoding names as well; some are implemented in\nPython, and some in C. Some encodings have multiple names, too; for example, latin-1,",
    "name. Python comes with roughly 100 different encodings; see the Python library\nreference for a complete list. Importing the module encodings and running\nhelp(encodings) shows you many encoding names as well; some are implemented in\nPython, and some in C. Some encodings have multiple names, too; for example, latin-1,\niso_8859_1, and 8859 are all synonyms for the same encoding, Latin-1. We’ll revisit\nencodings later in this chapter, when we study techniques for writing Unicode strings\nin a script.",
    "898 | Chapter 36: Unicode and Byte Strings\n\n\fFor more on the Unicode story, see the Python standard manual set. It includes a\n“Unicode HOWTO” in its “Python HOWTOs” section, which provides additional\nbackground that we will skip here in the interest of space.",
    "Python’s String Types\nAt a more concrete level, the Python language provides string data types to represent\ncharacter text in your scripts. The string types you will use in your scripts depend upon\nthe version of Python you’re using. Python 2.X has a general string type for representing\nbinary data and simple 8-bit text like ASCII, along with a specific type for representing\nmultibyte Unicode text:\n• str for representing 8-bit text and binary data\n• unicode for representing wide-character Unicode text\nPython 2.X’s two string types are different (unicode allows for the extra size of characters\nand has extra support for encoding and decoding), but their operation sets largely\noverlap. The str string type in 2.X is used for text that can be represented with 8-bit\nbytes, as well as binary data that represents absolute byte values.\nBy contrast, Python 3.X comes with three string object types—one for textual data and\ntwo for binary data:",
    "and has extra support for encoding and decoding), but their operation sets largely\noverlap. The str string type in 2.X is used for text that can be represented with 8-bit\nbytes, as well as binary data that represents absolute byte values.\nBy contrast, Python 3.X comes with three string object types—one for textual data and\ntwo for binary data:\n• str for representing Unicode text (both 8-bit and wider)\n• bytes for representing binary data\n• bytearray, a mutable flavor of the bytes type\nAs mentioned earlier, bytearray is also available in Python 2.6, but it’s simply a backport from 3.0 with less content-specific behavior and is generally considered a 3.0 type.\nAll three string types in 3.0 support similar operation sets, but they have different roles.\nThe main goal behind this change in 3.X was to merge the normal and Unicode string\ntypes of 2.X into a single string type that supports both normal and Unicode text:",
    "All three string types in 3.0 support similar operation sets, but they have different roles.\nThe main goal behind this change in 3.X was to merge the normal and Unicode string\ntypes of 2.X into a single string type that supports both normal and Unicode text:\ndevelopers wanted to remove the 2.X string dichotomy and make Unicode processing\nmore natural. Given that ASCII and other 8-bit text is really a simple kind of Unicode,\nthis convergence seems logically sound.\nTo achieve this, the 3.0 str type is defined as an immutable sequence of characters (not\nnecessarily bytes), which may be either normal text such as ASCII with one byte per\ncharacter, or richer character set text such as UTF-8 Unicode that may include multibyte characters. Strings processed by your script with this type are encoded per the\nplatform default, but explicit encoding names may be provided to translate str objects\nto and from different schemes, both in memory and when transferring to and from files.",
    "character, or richer character set text such as UTF-8 Unicode that may include multibyte characters. Strings processed by your script with this type are encoded per the\nplatform default, but explicit encoding names may be provided to translate str objects\nto and from different schemes, both in memory and when transferring to and from files.\nWhile 3.0’s new str type does achieve the desired string/unicode merging, many programs still need to process raw binary data that is not encoded per any text format.\nImage and audio files, as well as packed data used to interface with devices or C",
    "String Basics | 899",
    "programs you might process with Python’s struct module, fall into this category. To\nsupport processing of truly binary data, therefore, a new type, bytes, also was\nintroduced.\nIn 2.X, the general str type filled this binary data role, because strings were just sequences of bytes (the separate unicode type handles wide-character strings). In 3.0, the\nbytes type is defined as an immutable sequence of 8-bit integers representing absolute\nbyte values. Moreover, the 3.0 bytes type supports almost all the same operations that\nthe str type does; this includes string methods, sequence operations, and even re module pattern matching, but not string formatting.\nA 3.0 bytes object really is a sequence of small integers, each of which is in the range\n0 through 255; indexing a bytes returns an int, slicing one returns another bytes, and",
    "byte values. Moreover, the 3.0 bytes type supports almost all the same operations that\nthe str type does; this includes string methods, sequence operations, and even re module pattern matching, but not string formatting.\nA 3.0 bytes object really is a sequence of small integers, each of which is in the range\n0 through 255; indexing a bytes returns an int, slicing one returns another bytes, and\nrunning the list built-in on one returns a list of integers, not characters. When processed with operations that assume characters, though, the contents of bytes objects\nare assumed to be ASCII-encoded bytes (e.g., the isalpha method assumes each byte\nis an ASCII character code). Further, bytes objects are printed as character strings instead of integers for convenience.\nWhile they were at it, Python developers also added a bytearray type in 3.0.\nbytearray is a variant of bytes that is mutable and so supports in-place changes. It",
    "are assumed to be ASCII-encoded bytes (e.g., the isalpha method assumes each byte\nis an ASCII character code). Further, bytes objects are printed as character strings instead of integers for convenience.\nWhile they were at it, Python developers also added a bytearray type in 3.0.\nbytearray is a variant of bytes that is mutable and so supports in-place changes. It\nsupports the usual string operations that str and bytes do, as well as many of the same\nin-place change operations as lists (e.g., the append and extend methods, and assignment\nto indexes). Assuming your strings can be treated as raw bytes, bytearray finally adds\ndirect in-place mutability for string data—something not possible without conversion\nto a mutable type in Python 2, and not supported by Python 3.0’s str or bytes.\nAlthough Python 2.6 and 3.0 offer much the same functionality, they package it differently. In fact, the mapping from 2.6 to 3.0 string types is not direct—2.6’s str equates",
    "direct in-place mutability for string data—something not possible without conversion\nto a mutable type in Python 2, and not supported by Python 3.0’s str or bytes.\nAlthough Python 2.6 and 3.0 offer much the same functionality, they package it differently. In fact, the mapping from 2.6 to 3.0 string types is not direct—2.6’s str equates\nto both str and bytes in 3.0, and 3.0’s str equates to both str and unicode in 2.6.\nMoreover, the mutability of 3.0’s bytearray is unique.\nIn practice, though, this asymmetry is not as daunting as it might sound. It boils down\nto the following: in 2.6, you will use str for simple text and binary data and unicode\nfor more advanced forms of text; in 3.0, you’ll use str for any kind of text (simple and\nUnicode) and bytes or bytearray for binary data. In practice, the choice is often made\nfor you by the tools you use—especially in the case of file processing tools, the topic\nof the next section.",
    "Text and Binary Files\nFile I/O (input and output) has also been revamped in 3.0 to reflect the str/bytes\ndistinction and automatically support encoding Unicode text. Python now makes a\nsharp platform-independent distinction between text files and binary files:\n\n900 | Chapter 36: Unicode and Byte Strings",
    "Text files\nWhen a file is opened in text mode, reading its data automatically decodes its content (per a platform default or a provided encoding name) and returns it as a str;\nwriting takes a str and automatically encodes it before transferring it to the file.\nText-mode files also support universal end-of-line translation and additional encoding specification arguments. Depending on the encoding name, text files may\nalso automatically process the byte order mark sequence at the start of a file (more\non this momentarily).\nBinary files\nWhen a file is opened in binary mode by adding a b (lowercase only) to the mode\nstring argument in the built-in open call, reading its data does not decode it in any\nway but simply returns its content raw and unchanged, as a bytes object; writing\nsimilarly takes a bytes object and transfers it to the file unchanged. Binary-mode\nfiles also accept a bytearray object for the content to be written to the file.",
    "string argument in the built-in open call, reading its data does not decode it in any\nway but simply returns its content raw and unchanged, as a bytes object; writing\nsimilarly takes a bytes object and transfers it to the file unchanged. Binary-mode\nfiles also accept a bytearray object for the content to be written to the file.\nBecause the language sharply differentiates between str and bytes, you must decide\nwhether your data is text or binary in nature and use either str or bytes objects to\nrepresent its content in your script, as appropriate. Ultimately, the mode in which you\nopen a file will dictate which type of object your script will use to represent its content:\n• If you are processing image files, packed data created by other programs whose\ncontent you must extract, or some device data streams, chances are good that you\nwill want to deal with it using bytes and binary-mode files. You might also opt for",
    "open a file will dictate which type of object your script will use to represent its content:\n• If you are processing image files, packed data created by other programs whose\ncontent you must extract, or some device data streams, chances are good that you\nwill want to deal with it using bytes and binary-mode files. You might also opt for\nbytearray if you wish to update the data without making copies of it in memory.\n• If instead you are processing something that is textual in nature, such as program\noutput, HTML, internationalized text, or CSV or XML files, you’ll probably want\nto use str and text-mode files.\nNotice that the mode string argument to built-in function open (its second argument)\nbecomes fairly crucial in Python 3.0—its content not only specifies a file processing\nmode, but also implies a Python object type. By adding a b to the mode string, you specify\nbinary mode and will receive, or must provide, a bytes object to represent the file’s",
    "to use str and text-mode files.\nNotice that the mode string argument to built-in function open (its second argument)\nbecomes fairly crucial in Python 3.0—its content not only specifies a file processing\nmode, but also implies a Python object type. By adding a b to the mode string, you specify\nbinary mode and will receive, or must provide, a bytes object to represent the file’s\ncontent when reading or writing. Without the b, your file is processed in text mode,\nand you’ll use str objects to represent its content in your script. For example, the modes\nrb, wb, and rb+ imply bytes; r, w+, and rt (the default) imply str.\nText-mode files also handle the byte order marker (BOM) sequence that may appear at\nthe start of files under certain encoding schemes. In the UTF-16 and UTF-32 encodings,\nfor example, the BOM specifies big- or little-endian format (essentially, which end of\na bitstring is most significant). A UTF-8 text file may also include a BOM to declare",
    "Text-mode files also handle the byte order marker (BOM) sequence that may appear at\nthe start of files under certain encoding schemes. In the UTF-16 and UTF-32 encodings,\nfor example, the BOM specifies big- or little-endian format (essentially, which end of\na bitstring is most significant). A UTF-8 text file may also include a BOM to declare\nthat it is UTF-8 in general, but this isn’t guaranteed. When reading and writing data\nusing these encoding schemes, Python automatically skips or writes the BOM if it is\nimplied by a general encoding name or if you provide a more specific encoding name\nto force the issue. For example, the BOM is always processed for “utf-16,” the more\nspecific encoding name “utf-16-le” species little-endian UTF-16 format, and the more\nString Basics | 901",
    "specific encoding name “utf-8-sig” forces Python to both skip and write a BOM on\ninput and output, respectively, for UTF-8 text (the general name “utf-8” does not).\nWe’ll learn more about BOMs and files in general in the section “Handling the BOM\nin 3.0” on page 926. First, let’s explore the implications of Python’s new Unicode\nstring model.",
    "Python 3.0 Strings in Action\nLet’s step through a few examples that demonstrate how the 3.0 string types are used.\nOne note up front: the code in this section was run with and applies to 3.0 only. Still,\nbasic string operations are generally portable across Python versions. Simple ASCII\nstrings represented with the str type work the same in 2.6 and 3.0 (and exactly as we\nsaw in Chapter 7 of this book). Moreover, although there is no bytes type in Python\n2.6 (it has just the general str), it can usually run code that thinks there is—in 2.6, the\ncall bytes(X) is present as a synonym for str(X), and the new literal form b'...' is taken\nto be the same as the normal string literal '...'. You may still run into version skew in\nsome isolated cases, though; the 2.6 bytes call, for instance, does not allow the second\nargument (encoding name) required by 3.0’s bytes.",
    "Literals and Basic Properties\nPython 3.0 string objects originate when you call a built-in function such as str or\nbytes, process a file created by calling open (described in the next section), or code literal\nsyntax in your script. For the latter, a new literal form, b'xxx' (and equivalently,\nB'xxx') is used to create bytes objects in 3.0, and bytearray objects may be created by\ncalling the bytearray function, with a variety of possible arguments.\nMore formally, in 3.0 all the current string literal forms—'xxx', \"xxx\", and triple-quoted blocks—generate a str; adding a b or B just before any of them creates a bytes\ninstead. This new b'...' bytes literal is similar in form to the r'...' raw string used to\nsuppresses backslash escapes. Consider the following, run in 3.0:\nC:\\misc> c:\\python30\\python\n>>> B = b'spam'\n>>> S = 'eggs'\n\n# Make a bytes object (8-bit bytes)\n# Make a str object (Unicode characters, 8-bit or wider)",
    "# Make a bytes object (8-bit bytes)\n# Make a str object (Unicode characters, 8-bit or wider)\n\n>>> type(B), type(S)\n(<class 'bytes'>, <class 'str'>)\n>>> B\nb'spam'\n>>> S\n'eggs'\n\n# Prints as a character string, really sequence of ints\n\n902 | Chapter 36: Unicode and Byte Strings\n\n\fThe bytes object is actually a sequence of short integers, though it prints its content as\ncharacters whenever possible:\n>>> B[0], S[0]\n(115, 'e')\n\n# Indexing returns an int for bytes, str for str\n\n>>> B[1:], S[1:]\n(b'pam', 'ggs')\n\n# Slicing makes another bytes or str object\n\n>>> list(B), list(S)\n([115, 112, 97, 109], ['e', 'g', 'g', 's'])\n\n# bytes is really ints",
    "The bytes object is actually a sequence of short integers, though it prints its content as\ncharacters whenever possible:\n>>> B[0], S[0]\n(115, 'e')\n\n# Indexing returns an int for bytes, str for str\n\n>>> B[1:], S[1:]\n(b'pam', 'ggs')\n\n# Slicing makes another bytes or str object\n\n>>> list(B), list(S)\n([115, 112, 97, 109], ['e', 'g', 'g', 's'])\n\n# bytes is really ints\n\nThe bytes object is immutable, just like str (though bytearray, described later, is not);\nyou cannot assign a str, bytes, or integer to an offset of a bytes object. The bytes prefix\nalso works for any string literal form:\n>>> B[0] = 'x'\n# Both are immutable\nTypeError: 'bytes' object does not support item assignment\n>>> S[0] = 'x'\nTypeError: 'str' object does not support item assignment\n>>> B = B\"\"\"\n... xxxx\n... yyyy\n... \"\"\"\n>>> B\nb'\\nxxxx\\nyyyy\\n'\n\n# bytes prefix works on single, double, triple quotes",
    "# bytes prefix works on single, double, triple quotes\n\nAs mentioned earlier, in Python 2.6 the b'xxx' literal is present for compatibility but is\nthe same as 'xxx' and makes a str, and bytes is just a synonym for str; as you’ve seen,\nin 3.0 both of these address the distinct bytes type. Also note that the u'xxx' and\nU'xxx' Unicode string literal forms in 2.6 are gone in 3.0; use 'xxx' instead, since all\nstrings are Unicode, even if they contain all ASCII characters (more on writing nonASCII Unicode text in the section “Coding Non-ASCII Text” on page 905).",
    "Conversions\nAlthough Python 2.X allowed str and unicode type objects to be mixed freely (if the\nstrings contained only 7-bit ASCII text), 3.0 draws a much sharper distinction—str\nand bytes type objects never mix automatically in expressions and never are converted\nto one another automatically when passed to functions. A function that expects an\nargument to be a str object won’t generally accept a bytes, and vice versa.\nBecause of this, Python 3.0 basically requires that you commit to one type or the other,\nor perform manual, explicit conversions:\n• str.encode() and bytes(S, encoding) translate a string to its raw bytes form and\ncreate a bytes from a str in the process.\n• bytes.decode() and str(B, encoding) translate raw bytes into its string form and\ncreate a str from a bytes in the process.\nPython 3.0 Strings in Action | 903",
    "These encode and decode methods (as well as file objects, described in the next section)\nuse either a default encoding for your platform or an explicitly passed-in encoding\nname. For example, in 3.0:\n>>> S = 'eggs'\n>>> S.encode()\nb'eggs'\n>>> bytes(S, encoding='ascii')\nb'eggs'\n>>> B = b'spam'\n>>> B.decode()\n'spam'\n>>> str(B, encoding='ascii')\n'spam'\n\n# str to bytes: encode text into raw bytes\n# str to bytes, alternative\n\n# bytes to str: decode raw bytes into text\n# bytes to str, alternative",
    "# str to bytes: encode text into raw bytes\n# str to bytes, alternative\n\n# bytes to str: decode raw bytes into text\n# bytes to str, alternative\n\nTwo cautions here. First of all, your platform’s default encoding is available in the\nsys module, but the encoding argument to bytes is not optional, even though it is in\nstr.encode (and bytes.decode).\nSecond, although calls to str do not require the encoding argument like bytes does,\nleaving it off in str calls does not mean it defaults—instead, a str call without an\nencoding returns the bytes object’s print string, not its str converted form (this is\nusually not what you’ll want!). Assuming B and S are still as in the prior listing:\n>>> import sys\n>>> sys.platform\n'win32'\n>>> sys.getdefaultencoding()\n'utf-8'\n\n# Underlying platform\n# Default encoding for str here\n\n>>> bytes(S)\nTypeError: string argument without an encoding\n>>> str(B)\n\"b'spam'\"\n>>> len(str(B))\n7\n>>> len(str(B, encoding='ascii'))\n4",
    "# Underlying platform\n# Default encoding for str here\n\n>>> bytes(S)\nTypeError: string argument without an encoding\n>>> str(B)\n\"b'spam'\"\n>>> len(str(B))\n7\n>>> len(str(B, encoding='ascii'))\n4\n\n# str without encoding\n# A print string, not conversion!\n# Use encoding to convert to str\n\nCoding Unicode Strings\nEncoding and decoding become more meaningful when you start dealing with actual\nnon-ASCII Unicode text. To code arbitrary Unicode characters in your strings, some\nof which you might not even be able to type on your keyboard, Python string literals\nsupport both \"\\xNN\" hex byte value escapes and \"\\uNNNN\" and \"\\UNNNNNNNN\" Unicode\nescapes in string literals. In Unicode escapes, the first form gives four hex digits to\n\n904 | Chapter 36: Unicode and Byte Strings\n\n\fencode a 2-byte (16-bit) character code, and the second gives eight hex digits for a\n4-byte (32-bit) code.",
    "904 | Chapter 36: Unicode and Byte Strings\n\n\fencode a 2-byte (16-bit) character code, and the second gives eight hex digits for a\n4-byte (32-bit) code.\n\nCoding ASCII Text\nLet’s step through some examples that demonstrate text coding basics. As we’ve seen,\nASCII text is a simple type of Unicode, stored as a sequence of byte values that represent\ncharacters:\nC:\\misc> c:\\python30\\python\n>>> ord('X')\n88\n>>> chr(88)\n'X'\n\n# 'X' has binary value 88 in the default encoding\n\n>>> S = 'XYZ'\n>>> S\n'XYZ'\n>>> len(S)\n3\n>>> [ord(c) for c in S]\n[88, 89, 90]\n\n# A Unicode string of ASCII text\n\n# 88 stands for character 'X'\n\n# 3 characters long\n# 3 bytes with integer ordinal values\n\nNormal 7-bit ASCII text like this is represented with one character per byte under each\nof the Unicode encoding schemes described earlier in this chapter:\n>>> S.encode('ascii')\nb'XYZ'\n>>> S.encode('latin-1')\nb'XYZ'\n>>> S.encode('utf-8')\nb'XYZ'",
    "# A Unicode string of ASCII text\n\n# 88 stands for character 'X'\n\n# 3 characters long\n# 3 bytes with integer ordinal values\n\nNormal 7-bit ASCII text like this is represented with one character per byte under each\nof the Unicode encoding schemes described earlier in this chapter:\n>>> S.encode('ascii')\nb'XYZ'\n>>> S.encode('latin-1')\nb'XYZ'\n>>> S.encode('utf-8')\nb'XYZ'\n\n# Values 0..127 in 1 byte (7 bits) each\n# Values 0..255 in 1 byte (8 bits) each\n# Values 0..127 in 1 byte, 128..2047 in 2, others 3 or 4\n\nIn fact, the bytes objects returned by encoding ASCII text this way is really a sequence\nof short integers, which just happen to print as ASCII characters when possible:\n>>> S.encode('latin-1')[0]\n88\n>>> list(S.encode('latin-1'))\n[88, 89, 90]",
    "# Values 0..127 in 1 byte (7 bits) each\n# Values 0..255 in 1 byte (8 bits) each\n# Values 0..127 in 1 byte, 128..2047 in 2, others 3 or 4\n\nIn fact, the bytes objects returned by encoding ASCII text this way is really a sequence\nof short integers, which just happen to print as ASCII characters when possible:\n>>> S.encode('latin-1')[0]\n88\n>>> list(S.encode('latin-1'))\n[88, 89, 90]\n\nCoding Non-ASCII Text\nTo code non-ASCII characters, you may use hex or Unicode escapes in your strings;\nhex escapes are limited to a single byte’s value, but Unicode escapes can name characters with values two and four bytes wide. The hex values 0xCD and 0xE8, for instance,\nare codes for two special accented characters outside the 7-bit range of ASCII, but we\ncan embed them in 3.0 str objects because str supports Unicode today:\n\nCoding Unicode Strings | 905\n\n\f>>> chr(0xc4)\n'Ä'\n>>> chr(0xe8)\n'è'\n\n# 0xC4, 0xE8: characters outside ASCII's range\n\n>>> S = '\\xc4\\xe8'\n>>> S\n'Äè'\n\n# Single byte 8-bit hex escapes",
    "Coding Unicode Strings | 905\n\n\f>>> chr(0xc4)\n'Ä'\n>>> chr(0xe8)\n'è'\n\n# 0xC4, 0xE8: characters outside ASCII's range\n\n>>> S = '\\xc4\\xe8'\n>>> S\n'Äè'\n\n# Single byte 8-bit hex escapes\n\n>>> S = '\\u00c4\\u00e8'\n>>> S\n'Äè'\n>>> len(S)\n2\n\n# 16-bit Unicode escapes\n# 2 characters long (not number of bytes!)\n\nEncoding and Decoding Non-ASCII text\nNow, if we try to encode a non-ASCII string into raw bytes using as ASCII, we’ll get an\nerror. Encoding as Latin-1 works, though, and allocates one byte per character; encoding as UTF-8 allocates 2 bytes per character instead. If you write this string to a file,\nthe raw bytes shown here is what is actually stored on the file for the encoding types\ngiven:\n>>> S = '\\u00c4\\u00e8'\n>>> S\n'Äè'\n>>> len(S)\n2\n>>> S.encode('ascii')\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1:\nordinal not in range(128)\n>>> S.encode('latin-1')\nb'\\xc4\\xe8'\n\n# One byte per character\n\n>>> S.encode('utf-8')\nb'\\xc3\\x84\\xc3\\xa8'\n\n# Two bytes per character",
    "# One byte per character\n\n>>> S.encode('utf-8')\nb'\\xc3\\x84\\xc3\\xa8'\n\n# Two bytes per character\n\n>>> len(S.encode('latin-1'))\n2\n>>> len(S.encode('utf-8'))\n4\n\n# 2 bytes in latin-1, 4 in utf-8\n\nNote that you can also go the other way, reading raw bytes from a file and decoding\nthem back to a Unicode string. However, as we’ll see later, the encoding mode you give\nto the open call causes this decoding to be done for you automatically on input (and\navoids issues that may arise from reading partial character sequences when reading by\nblocks of bytes):\n>>> B = b'\\xc4\\xe8'\n>>> B\nb'\\xc4\\xe8'\n\n906 | Chapter 36: Unicode and Byte Strings\n\n\f>>> len(B)\n2\n>>> B.decode('latin-1')\n'Äè'\n>>> B = b'\\xc3\\x84\\xc3\\xa8'\n>>> len(B)\n4\n>>> B.decode('utf-8')\n'Äè'\n>>> len(B.decode('utf-8'))\n2\n\n# 2 raw bytes, 2 characters\n# Decode to latin-1 text\n\n# 4 raw bytes\n\n# 2 Unicode characters",
    "906 | Chapter 36: Unicode and Byte Strings\n\n\f>>> len(B)\n2\n>>> B.decode('latin-1')\n'Äè'\n>>> B = b'\\xc3\\x84\\xc3\\xa8'\n>>> len(B)\n4\n>>> B.decode('utf-8')\n'Äè'\n>>> len(B.decode('utf-8'))\n2\n\n# 2 raw bytes, 2 characters\n# Decode to latin-1 text\n\n# 4 raw bytes\n\n# 2 Unicode characters\n\nOther Unicode Coding Techniques\nSome encodings use even larger byte sequences to represent characters. When needed,\nyou can specify both 16- and 32-bit Unicode values for characters in your strings—use\n\"\\u...\" with four hex digits for the former, and \"\\U....\" with eight hex digits for the\nlatter:\n>>> S = 'A\\u00c4B\\U000000e8C'\n>>> S\n'AÄBèC'\n>>> len(S)\n5\n>>> S.encode('latin-1')\nb'A\\xc4B\\xe8C'\n>>> len(S.encode('latin-1'))\n5\n>>> S.encode('utf-8')\nb'A\\xc3\\x84B\\xc3\\xa8C'\n>>> len(S.encode('utf-8'))\n7\n\n# A, B, C, and 2 non-ASCII characters\n# 5 characters long\n\n# 5 bytes in latin-1\n\n# 7 bytes in utf-8",
    "# A, B, C, and 2 non-ASCII characters\n# 5 characters long\n\n# 5 bytes in latin-1\n\n# 7 bytes in utf-8\n\nInterestingly, some other encodings may use very different byte formats. The cp500\nEBCDIC encoding, for example, doesn’t even encode ASCII the same way as the encodings we’ve been using so far (since Python encodes and decodes for us, we only\ngenerally need to care about this when providing encoding names):\n>>> S\n'AÄBèC'\n>>> S.encode('cp500')\nb'\\xc1c\\xc2T\\xc3'\n>>> S.encode('cp850')\nb'A\\x8eB\\x8aC'\n>>> S = 'spam'\n>>> S.encode('latin-1')\nb'spam'\n>>> S.encode('utf-8')\nb'spam'\n>>> S.encode('cp500')\n\n# Two other Western European encodings\n# 5 bytes each\n# ASCII text is the same in most\n\n# But not in cp500: IBM EBCDIC!\n\nCoding Unicode Strings | 907\n\n\fb'\\xa2\\x97\\x81\\x94'\n>>> S.encode('cp850')\nb'spam'",
    "# Two other Western European encodings\n# 5 bytes each\n# ASCII text is the same in most\n\n# But not in cp500: IBM EBCDIC!\n\nCoding Unicode Strings | 907\n\n\fb'\\xa2\\x97\\x81\\x94'\n>>> S.encode('cp850')\nb'spam'\n\nTechnically speaking, you can also build Unicode strings piecemeal using chr instead\nof Unicode or hex escapes, but this might become tedious for large strings:\n>>> S = 'A' + chr(0xC4) + 'B' + chr(0xE8) + 'C'\n>>> S\n'AÄBèC'\n\nTwo cautions here. First, Python 3.0 allows special characters to be coded with both\nhex and Unicode escapes in str strings, but only with hex escapes in bytes strings—\nUnicode escape sequences are silently taken verbatim in bytes literals, not as escapes.\nIn fact, bytes must be decoded to str strings to print their non-ASCII characters\nproperly:\n>>> S = 'A\\xC4B\\xE8C'\n>>> S\n'AÄBèC'\n\n# str recognizes hex and Unicode escapes\n\n>>> S = 'A\\u00C4B\\U000000E8C'\n>>> S\n'AÄBèC'\n>>> B = b'A\\xC4B\\xE8C'\n>>> B\nb'A\\xc4B\\xe8C'\n\n# bytes recognizes hex but not Unicode",
    "# str recognizes hex and Unicode escapes\n\n>>> S = 'A\\u00C4B\\U000000E8C'\n>>> S\n'AÄBèC'\n>>> B = b'A\\xC4B\\xE8C'\n>>> B\nb'A\\xc4B\\xe8C'\n\n# bytes recognizes hex but not Unicode\n\n>>> B = b'A\\u00C4B\\U000000E8C'\n>>> B\nb'A\\\\u00C4B\\\\U000000E8C'\n\n# Escape sequences taken literally!\n\n>>> B = b'A\\xC4B\\xE8C'\n>>> B\nb'A\\xc4B\\xe8C'\n>>> print(B)\nb'A\\xc4B\\xe8C'\n>>> B.decode('latin-1')\n'AÄBèC'\n\n# Use hex escapes for bytes\n# Prints non-ASCII as hex\n\n# Decode as latin-1 to interpret as text\n\nSecond, bytes literals require characters either to be either ASCII characters or, if their\nvalues are greater than 127, to be escaped; str stings, on the other hand, allow literals\ncontaining any character in the source character set (which, as discussed later, defaults\nto UTF-8 unless an encoding declaration is given in the source file):\n>>> S = 'AÄBèC'\n>>> S\n'AÄBèC'\n\n# Chars from UTF-8 if no encoding declaration",
    "# Chars from UTF-8 if no encoding declaration\n\n>>> B = b'AÄBèC'\nSyntaxError: bytes can only contain ASCII literal characters.\n>>> B = b'A\\xC4B\\xE8C'\n>>> B\n\n908 | Chapter 36: Unicode and Byte Strings\n\n# Chars must be ASCII, or escapes\n\n\fb'A\\xc4B\\xe8C'\n>>> B.decode('latin-1')\n'AÄBèC'\n>>> S.encode()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n>>> S.encode('utf-8')\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Source code encoded per UTF-8 by default\n# Uses system default to encode, unless passed\n\n>>> B.decode()\n# Raw bytes do not correspond to utf-8\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: ...\n\nConverting Encodings\nSo far, we’ve been encoding and decoding strings to inspect their structure. More generally, we can always convert a string to a different encoding than the source character\nset default, but we must provide an explicit encoding name to encode to and decode\nfrom:\n>>> S = 'AÄBèC'\n>>> S\n'AÄBèC'\n>>> S.encode()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Default utf-8 encoding",
    "Converting Encodings\nSo far, we’ve been encoding and decoding strings to inspect their structure. More generally, we can always convert a string to a different encoding than the source character\nset default, but we must provide an explicit encoding name to encode to and decode\nfrom:\n>>> S = 'AÄBèC'\n>>> S\n'AÄBèC'\n>>> S.encode()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Default utf-8 encoding\n\n>>> T = S.encode('cp500')\n>>> T\nb'\\xc1c\\xc2T\\xc3'\n\n# Convert to EBCDIC\n\n>>> U = T.decode('cp500')\n>>> U\n'AÄBèC'\n\n# Convert back to Unicode\n\n>>> U.encode()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Default utf-8 encoding again",
    ">>> U = T.decode('cp500')\n>>> U\n'AÄBèC'\n\n# Convert back to Unicode\n\n>>> U.encode()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Default utf-8 encoding again\n\nKeep in mind that the special Unicode and hex character escapes are only necessary\nwhen you code non-ASCII Unicode strings manually. In practice, you’ll often load such\ntext from files instead. As we’ll see later in this chapter, 3.0’s file object (created with\nthe open built-in function) automatically decodes text strings as they are read and\nencodes them when they are written; because of this, your script can often deal with\nstrings generically, without having to code special characters directly.\nLater in this chapter we’ll also see that it’s possible to convert between encodings when\ntransferring strings to and from files, using a technique very similar to that in the last\nexample; although you’ll still need to provide explicit encoding names when opening\na file, the file interface does most of the conversion work for you automatically.",
    "Coding Unicode Strings | 909\n\n\fCoding Unicode Strings in Python 2.6\nNow that I’ve shown you the basics of Unicode strings in 3.0, I need to explain that\nyou can do much the same in 2.6, though the tools differ. unicode is available in Python\n2.6, but it is a distinct data type from str, and it allows free mixing of normal and\nUnicode strings when they are compatible. In fact, you can essentially pretend 2.6’s\nstr is 3.0’s bytes when it comes to decoding raw bytes into a Unicode string, as long\nas it’s in the proper form. Here is 2.6 in action (all other sections in this chapter are run\nunder 3.0):\nC:\\misc> c:\\python26\\python\n>>> import sys\n>>> sys.version\n'2.6 (r26:66721, Oct 2 2008, 11:35:03) [MSC v.1500 32 bit (Intel)]'\n>>> S = 'A\\xC4B\\xE8C'\n>>> print S\nAÄBèC\n\n# String of 8-bit bytes\n# Some are non-ASCII\n\n>>> S.decode('latin-1')\nu'A\\xc4B\\xe8C'\n\n# Decode byte to latin-1 Unicode",
    "# String of 8-bit bytes\n# Some are non-ASCII\n\n>>> S.decode('latin-1')\nu'A\\xc4B\\xe8C'\n\n# Decode byte to latin-1 Unicode\n\n>>> S.decode('utf-8')\n# Not formatted as utf-8\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: invalid data\n>>> S.decode('ascii')\n# Outside ASCII range\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 1: ordinal\nnot in range(128)\n\nTo store arbitrarily encoded Unicode text, make a unicode object with the u'xxx' literal\nform (this literal is no longer available in 3.0, since all strings support Unicode in 3.0):\n>>> U = u'A\\xC4B\\xE8C'\n>>> U\nu'A\\xc4B\\xe8C'\n>>> print U\nAÄBèC\n\n# Make Unicode string, hex escapes\n\nOnce you’ve created it, you can convert Unicode text to different raw byte encodings,\nsimilar to encoding str objects into bytes objects in 3.0:\n>>> U.encode('latin-1')\n'A\\xc4B\\xe8C'\n>>> U.encode('utf-8')\n'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Encode per latin-1: 8-bit bytes\n# Encode per utf-8: multibyte",
    "# Make Unicode string, hex escapes\n\nOnce you’ve created it, you can convert Unicode text to different raw byte encodings,\nsimilar to encoding str objects into bytes objects in 3.0:\n>>> U.encode('latin-1')\n'A\\xc4B\\xe8C'\n>>> U.encode('utf-8')\n'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Encode per latin-1: 8-bit bytes\n# Encode per utf-8: multibyte\n\nNon-ASCII characters can be coded with hex or Unicode escapes in string literals in\n2.6, just as in 3.0. However, as with bytes in 3.0, the \"\\u...\" and \"\\U...\" escapes are\nrecognized only for unicode strings in 2.6, not 8-bit str strings:\nC:\\misc> c:\\python26\\python\n>>> U = u'A\\xC4B\\xE8C'\n>>> U\nu'A\\xc4B\\xe8C'\n\n910 | Chapter 36: Unicode and Byte Strings\n\n# Hex escapes for non-ASCII\n\n\f>>> print U\nAÄBèC\n>>> U = u'A\\u00C4B\\U000000E8C'\n>>> U\nu'A\\xc4B\\xe8C'\n>>> print U\nAÄBèC\n\n# Unicode escapes for non-ASCII\n# u'' = 16 bits, U'' = 32 bits\n\n>>> S = 'A\\xC4B\\xE8C'\n>>> S\n'A\\xc4B\\xe8C'\n>>> print S\nA-BFC\n>>> print S.decode('latin-1')\nAÄBèC\n\n# Hex escapes work",
    "910 | Chapter 36: Unicode and Byte Strings\n\n# Hex escapes for non-ASCII\n\n\f>>> print U\nAÄBèC\n>>> U = u'A\\u00C4B\\U000000E8C'\n>>> U\nu'A\\xc4B\\xe8C'\n>>> print U\nAÄBèC\n\n# Unicode escapes for non-ASCII\n# u'' = 16 bits, U'' = 32 bits\n\n>>> S = 'A\\xC4B\\xE8C'\n>>> S\n'A\\xc4B\\xe8C'\n>>> print S\nA-BFC\n>>> print S.decode('latin-1')\nAÄBèC\n\n# Hex escapes work\n\n>>> S = 'A\\u00C4B\\U000000E8C'\n>>> S\n'A\\\\u00C4B\\\\U000000E8C'\n>>> print S\nA\\u00C4B\\U000000E8C\n>>> len(S)\n19\n\n# Not Unicode escapes: taken literally!\n\n# But some print oddly, unless decoded",
    "# Unicode escapes for non-ASCII\n# u'' = 16 bits, U'' = 32 bits\n\n>>> S = 'A\\xC4B\\xE8C'\n>>> S\n'A\\xc4B\\xe8C'\n>>> print S\nA-BFC\n>>> print S.decode('latin-1')\nAÄBèC\n\n# Hex escapes work\n\n>>> S = 'A\\u00C4B\\U000000E8C'\n>>> S\n'A\\\\u00C4B\\\\U000000E8C'\n>>> print S\nA\\u00C4B\\U000000E8C\n>>> len(S)\n19\n\n# Not Unicode escapes: taken literally!\n\n# But some print oddly, unless decoded\n\nLike 3.0’s str and bytes, 2.6’s unicode and str share nearly identical operation sets, so\nunless you need to convert to other encodings you can often treat unicode as though it\nwere str. One of the primary differences between 2.6 and 3.0, though, is that\nunicode and non-Unicode str objects can be freely mixed in expressions, and as long\nas the str is compatible with the unicode’s encoding Python will automatically convert\nit up to unicode (in 3.0, str and bytes never mix automatically and require manual\nconversions):\n>>> u'ab' + 'cd'\nu'abcd'\n\n# Can mix if compatible in 2.6\n# 'ab' + b'cd' not allowed in 3.0",
    "# Can mix if compatible in 2.6\n# 'ab' + b'cd' not allowed in 3.0\n\nIn fact, the difference in types is often trivial to your code in 2.6. Like normal strings,\nUnicode strings may be concatenated, indexed, sliced, matched with the re module,\nand so on, and they cannot be changed in-place. If you ever need to convert between\nthe two types explicitly, you can use the built-in str and unicode functions:\n>>> str(u'spam')\n'spam'\n>>> unicode('spam')\nu'spam'\n\n# Unicode to normal\n# Normal to Unicode\n\nHowever, this liberal approach to mixing string types in 2.6 only works if the string is\ncompatible with the unicode object’s encoding type:\n>>> S = 'A\\xC4B\\xE8C'\n# Can't mix if incompatible\n>>> U = u'A\\xC4B\\xE8C'\n>>> S + U\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 1: ordinal\nnot in range(128)\n\nCoding Unicode Strings | 911\n\n\f>>> S.decode('latin-1') + U\nu'A\\xc4B\\xe8CA\\xc4B\\xe8C'\n\n# Manual conversion still required\n\n>>> print S.decode('latin-1') + U\nAÄBèCAÄBèC",
    "Coding Unicode Strings | 911\n\n\f>>> S.decode('latin-1') + U\nu'A\\xc4B\\xe8CA\\xc4B\\xe8C'\n\n# Manual conversion still required\n\n>>> print S.decode('latin-1') + U\nAÄBèCAÄBèC\n\nFinally, as we’ll see in more detail later in this chapter, 2.6’s open call supports only files\nof 8-bit bytes, returning their contents as str strings; it’s up to you to interpret the\ncontents as text or binary data and decode if needed. To read and write Unicode files\nand encode or decode their content automatically, use 2.6’s codecs.open call, documented in the 2.6 library manual. This call provides much the same functionality as\n3.0’s open and uses 2.6 unicode objects to represent file content—reading a file translates\nencoded bytes into decoded Unicode characters, and writing translates strings to the\ndesired encoding specified when the file is opened.",
    "Source File Character Set Encoding Declarations\nUnicode escape codes are fine for the occasional Unicode character in string literals,\nbut they can become tedious if you need to embed non-ASCII text in your strings\nfrequently. For strings you code within your script files, Python uses the UTF-8 encoding by default, but it allows you to change this to support arbitrary character sets\nby including a comment that names your desired encoding. The comment must be of\nthis form and must appear as either the first or second line in your script in either Python\n2.6 or 3.0:\n# -*- coding: latin-1 -*-",
    "When a comment of this form is present, Python will recognize strings represented\nnatively in the given encoding. This means you can edit your script file in a text editor\nthat accepts and displays accented and other non-ASCII characters correctly, and Python will decode them correctly in your string literals. For example, notice how the\ncomment at the top of the following file, text.py, allows Latin-1 characters to be embedded in strings:\n# -*- coding: latin-1 -*# Any of the following string literal forms work in latin-1.\n# Changing the encoding above to either ascii or utf-8 fails,\n# because the 0xc4 and 0xe8 in myStr1 are not valid in either.\nmyStr1 = 'aÄBèC'\nmyStr2 = 'A\\u00c4B\\U000000e8C'\nmyStr3 = 'A' + chr(0xC4) + 'B' + chr(0xE8) + 'C'\nimport sys\nprint('Default encoding:', sys.getdefaultencoding())\nfor aStr in myStr1, myStr2, myStr3:\n\n912 | Chapter 36: Unicode and Byte Strings",
    "912 | Chapter 36: Unicode and Byte Strings\n\n\fprint('{0}, strlen={1}, '.format(aStr, len(aStr)), end='')\nbytes1 = aStr.encode()\nbytes2 = aStr.encode('latin-1')\n#bytes3 = aStr.encode('ascii')\n\n# Per default utf-8: 2 bytes for non-ASCII\n# One byte per char\n# ASCII fails: outside 0..127 range\n\nprint('byteslen1={0}, byteslen2={1}'.format(len(bytes1), len(bytes2)))\n\nWhen run, this script produces the following output:\nC:\\misc> c:\\python30\\python text.py\nDefault encoding: utf-8\naÄBèC, strlen=5, byteslen1=7, byteslen2=5\nAÄBèC, strlen=5, byteslen1=7, byteslen2=5\nAÄBèC, strlen=5, byteslen1=7, byteslen2=5\n\nSince most programmers are likely to fall back on the standard UTF-8 encoding, I’ll\ndefer to Python’s standard manual set for more details on this option and other advanced Unicode support topics, such as properties and character name escapes in\nstrings.",
    "Using 3.0 Bytes Objects\nWe studied a wide variety of operations available for Python 3.0’s general str string\ntype in Chapter 7; the basic string type works identically in 2.6 and 3.0, so we won’t\nrehash this topic. Instead, let’s dig a bit deeper into the operation sets provided by the\nnew bytes type in 3.0.\nAs mentioned previously, the 3.0 bytes object is a sequence of small integers, each of\nwhich is in the range 0 through 255, that happens to print as ASCII characters when\ndisplayed. It supports sequence operations and most of the same methods available on\nstr objects (and present in 2.X’s str type). However, bytes does not support the for\nmat method or the % formatting expression, and you cannot mix and match bytes and\nstr type objects without explicit conversions—you generally will use all str type objects\nand text files for text data, and all bytes type objects and binary files for binary data.",
    "Method Calls\nIf you really want to see what attributes str has that bytes doesn’t, you can always\ncheck their dir built-in function results. The output can also tell you something about\nthe expression operators they support (e.g., __mod__ and __rmod__ implement the %\noperator):\nC:\\misc> c:\\python30\\python\n# Attributes unique to str\n>>> set(dir('abc')) - set(dir(b'abc'))\n{'isprintable', 'format', '__mod__', 'encode', 'isidentifier',\n'_formatter_field_name_split', 'isnumeric', '__rmod__', 'isdecimal',\n\nUsing 3.0 Bytes Objects | 913\n\n\f'_formatter_parser', 'maketrans'}\n# Attributes unique to bytes\n>>> set(dir(b'abc')) - set(dir('abc'))\n{'decode', 'fromhex'}",
    "Using 3.0 Bytes Objects | 913\n\n\f'_formatter_parser', 'maketrans'}\n# Attributes unique to bytes\n>>> set(dir(b'abc')) - set(dir('abc'))\n{'decode', 'fromhex'}\n\nAs you can see, str and bytes have almost identical functionality. Their unique attributes are generally methods that don’t apply to the other; for instance, decode translates a raw bytes into its str representation, and encode translates a string into its raw\nbytes representation. Most of the methods are the same, though bytes methods require\nbytes arguments (again, 3.0 string types don’t mix). Also recall that bytes objects are\nimmutable, just like str objects in both 2.6 and 3.0 (error messages here have been\nshortened for brevity):\n>>> B = b'spam'\n>>> B.find(b'pa')\n1\n\n# b'...' bytes literal\n\n>>> B.replace(b'pa', b'XY')\nb'sXYm'\n\n# bytes methods expect bytes arguments\n\n>>> B.split(b'pa')\n[b's', b'm']\n>>> B\nb'spam'\n>>> B[0] = 'x'\nTypeError: 'bytes' object does not support item assignment",
    "# b'...' bytes literal\n\n>>> B.replace(b'pa', b'XY')\nb'sXYm'\n\n# bytes methods expect bytes arguments\n\n>>> B.split(b'pa')\n[b's', b'm']\n>>> B\nb'spam'\n>>> B[0] = 'x'\nTypeError: 'bytes' object does not support item assignment\n\nOne notable difference is that string formatting works only on str objects in 3.0, not\non bytes objects (see Chapter 7 for more on string formatting expressions and\nmethods):\n>>> b'%s' % 99\nTypeError: unsupported operand type(s) for %: 'bytes' and 'int'\n>>> '%s' % 99\n'99'\n>>> b'{0}'.format(99)\nAttributeError: 'bytes' object has no attribute 'format'\n>>> '{0}'.format(99)\n'99'\n\nSequence Operations\nBesides method calls, all the usual generic sequence operations you know (and possibly\nlove) from Python 2.X strings and lists work as expected on both str and bytes in 3.0;\nthis includes indexing, slicing, concatenation, and so on. Notice in the following that\n\n914 | Chapter 36: Unicode and Byte Strings",
    "Sequence Operations\nBesides method calls, all the usual generic sequence operations you know (and possibly\nlove) from Python 2.X strings and lists work as expected on both str and bytes in 3.0;\nthis includes indexing, slicing, concatenation, and so on. Notice in the following that\n\n914 | Chapter 36: Unicode and Byte Strings\n\n\findexing a bytes object returns an integer giving the byte’s binary value; bytes really is\na sequence of 8-bit integers, but it prints as a string of ASCII-coded characters when\ndisplayed as a whole for convenience. To check a given byte’s value, use the chr builtin to convert it back to its character, as in the following:\n>>> B = b'spam'\n>>> B\nb'spam'\n\n# A sequence of small ints\n# Prints as ASCII characters\n\n>>> B[0]\n115\n>>> B[-1]\n109\n\n# Indexing yields an int\n\n>>> chr(B[0])\n's'\n>>> list(B)\n[115, 112, 97, 109]\n\n# Show character for int\n# Show all the byte's int values",
    "# A sequence of small ints\n# Prints as ASCII characters\n\n>>> B[0]\n115\n>>> B[-1]\n109\n\n# Indexing yields an int\n\n>>> chr(B[0])\n's'\n>>> list(B)\n[115, 112, 97, 109]\n\n# Show character for int\n# Show all the byte's int values\n\n>>> B[1:], B[:-1]\n(b'pam', b'spa')\n>>> len(B)\n4\n>>> B + b'lmn'\nb'spamlmn'\n>>> B * 4\nb'spamspamspamspam'",
    ">>> chr(B[0])\n's'\n>>> list(B)\n[115, 112, 97, 109]\n\n# Show character for int\n# Show all the byte's int values\n\n>>> B[1:], B[:-1]\n(b'pam', b'spa')\n>>> len(B)\n4\n>>> B + b'lmn'\nb'spamlmn'\n>>> B * 4\nb'spamspamspamspam'\n\nOther Ways to Make bytes Objects\nSo far, we’ve been mostly making bytes objects with the b'...' literal syntax; they can\nalso be created by calling the bytes constructor with a str and an encoding name, calling\nthe bytes constructor with an iterable of integers representing byte values, or encoding\na str object per the default (or passed-in) encoding. As we’ve seen, encoding takes a\nstr and returns the raw binary byte values of the string according to the encoding\nspecification; conversely, decoding takes a raw bytes sequence and encodes it to its\nstring representation—a series of possibly wide characters. Both operations create new\nstring objects:\n>>> B = b'abc'\n>>> B\nb'abc'\n>>> B = bytes('abc', 'ascii')\n>>> B\nb'abc'\n>>> ord('a')\n97\n>>> B = bytes([97, 98, 99])",
    "Using 3.0 Bytes Objects | 915\n\n\f>>> B\nb'abc'\n>>> B = 'spam'.encode()\n>>> B\nb'spam'\n>>>\n>>> S = B.decode()\n>>> S\n'spam'\n\n# Or bytes()\n\n# Or str()\n\nFrom a larger perspective, the last two of these operations are really tools for converting between str and bytes, a topic introduced earlier and expanded upon in the next\nsection.",
    "Mixing String Types\nIn the replace call of the section “Method Calls” on page 913, we had to pass in two\nbytes objects—str types won’t work there. Although Python 2.X automatically converts str to and from unicode when possible (i.e., when the str is 7-bit ASCII text),\nPython 3.0 requires specific string types in some contexts and expects manual conversions if needed:\n# Must pass expected types to function and method calls\n>>> B = b'spam'\n>>> B.replace('pa', 'XY')\nTypeError: expected an object with the buffer interface\n>>> B.replace(b'pa', b'XY')\nb'sXYm'\n>>> B = B'spam'\n>>> B.replace(bytes('pa'), bytes('xy'))\nTypeError: string argument without an encoding\n>>> B.replace(bytes('pa', 'ascii'), bytes('xy', 'utf-8'))\nb'sxym'\n# Must convert manually in mixed-type expressions\n>>> b'ab' + 'cd'\nTypeError: can't concat bytes to str\n>>> b'ab'.decode() + 'cd'\n'abcd'\n\n# bytes to str\n\n>>> b'ab' + 'cd'.encode()\nb'abcd'\n\n# str to bytes\n\n916 | Chapter 36: Unicode and Byte Strings",
    "# bytes to str\n\n>>> b'ab' + 'cd'.encode()\nb'abcd'\n\n# str to bytes\n\n916 | Chapter 36: Unicode and Byte Strings\n\n\f>>> b'ab' + bytes('cd', 'ascii')\nb'abcd'\n\n# str to bytes\n\nAlthough you can create bytes objects yourself to represent packed binary data, they\ncan also be made automatically by reading files opened in binary mode, as we’ll see in\nmore detail later in this chapter. First, though, we should introduce bytes’s very close,\nand mutable, cousin.",
    "Using 3.0 (and 2.6) bytearray Objects\nSo far we’ve focused on str and bytes, since they subsume Python 2’s unicode and\nstr. Python 3.0 has a third string type, though—bytearray, a mutable sequence of\nintegers in the range 0 through 255, is essentially a mutable variant of bytes. As such,\nit supports the same string methods and sequence operations as bytes, as well as many\nof the mutable in-place-change operations supported by lists. The bytearray type is\nalso available in Python 2.6 as a back-port from 3.0, but it does not enforce the strict\ntext/binary distinction there that it does in 3.0.\nLet’s take a quick tour. bytearray objects may be created by calling the bytearray builtin. In Python 2.6, any string may be used to initialize:\n# Creation in 2.6: a mutable sequence of small (0..255) ints\n>>> S = 'spam'\n>>> C = bytearray(S)\n>>> C\nbytearray(b'spam')\n\n# A back-port from 3.0 in 2.6\n# b'..' == '..' in 2.6 (str)",
    "# A back-port from 3.0 in 2.6\n# b'..' == '..' in 2.6 (str)\n\nIn Python 3.0, an encoding name or byte string is required, because text and binary\nstrings do not mix, though byte strings may reflect encoded Unicode text:\n# Creation in 3.0: text/binary do not mix\n>>> S = 'spam'\n>>> C = bytearray(S)\nTypeError: string argument without an encoding\n>>> C = bytearray(S, 'latin1')\n>>> C\nbytearray(b'spam')\n\n# A content-specific type in 3.0\n\n>>> B = b'spam'\n>>> C = bytearray(B)\n>>> C\nbytearray(b'spam')\n\n# b'..' != '..' in 3.0 (bytes/str)\n\nOnce created, bytearray objects are sequences of small integers like bytes and are mutable like lists, though they require an integer for index assignments, not a string (all\nof the following is a continuation of this session and is run under Python 3.0 unless\notherwise noted—see comments for 2.6 usage notes):\n\nUsing 3.0 (and 2.6) bytearray Objects | 917\n\n\f# Mutable, but must assign ints, not strings\n>>> C[0]\n115\n>>> C[0] = 'x'\nTypeError: an integer is required",
    "Using 3.0 (and 2.6) bytearray Objects | 917\n\n\f# Mutable, but must assign ints, not strings\n>>> C[0]\n115\n>>> C[0] = 'x'\nTypeError: an integer is required\n\n# This and the next work in 2.6\n\n>>> C[0] = b'x'\nTypeError: an integer is required\n>>> C[0] = ord('x')\n>>> C\nbytearray(b'xpam')\n>>> C[1] = b'Y'[0]\n>>> C\nbytearray(b'xYam')\n\nProcessing bytearray objects borrows from both strings and lists, since they are mutable\nbyte strings. Besides named methods, the __iadd__ and __setitem__ methods in\nbytearray implement += in-place concatenation and index assignment, respectively:\n# Methods overlap with both str and bytes, but also has list's mutable methods\n>>> set(dir(b'abc')) - set(dir(bytearray(b'abc')))\n{'__getnewargs__'}\n>>> set(dir(bytearray(b'abc'))) - set(dir(b'abc'))\n{'insert', '__alloc__', 'reverse', 'extend', '__delitem__', 'pop', '__setitem__'\n, '__iadd__', 'remove', 'append', '__imul__'}",
    "You can change a bytearray in-place with both index assignment, as you’ve just seen,\nand list-like methods like those shown here (to change text in-place in 2.6, you would\nneed to convert to and then from a list, with list(str) and ''.join(list)):\n# Mutable method calls\n>>> C\nbytearray(b'xYam')\n>>> C.append(b'LMN')\nTypeError: an integer is required\n>>> C.append(ord('L'))\n>>> C\nbytearray(b'xYamL')\n>>> C.extend(b'MNO')\n>>> C\nbytearray(b'xYamLMNO')\n\n918 | Chapter 36: Unicode and Byte Strings\n\n# 2.6 requires string of size 1",
    "918 | Chapter 36: Unicode and Byte Strings\n\n# 2.6 requires string of size 1\n\n\fAll the usual sequence operations and string methods work on bytearrays, as you would\nexpect (notice that like bytes objects, their expressions and methods expect bytes arguments, not str arguments):\n# Sequence operations and string methods\n>>> C + b'!#'\nbytearray(b'xYamLMNO!#')\n>>> C[0]\n120\n>>> C[1:]\nbytearray(b'YamLMNO')\n>>> len(C)\n8\n>>> C\nbytearray(b'xYamLMNO')\n>>> C.replace('xY', 'sp')\n# This works in 2.6\nTypeError: Type str doesn't support the buffer API\n>>> C.replace(b'xY', b'sp')\nbytearray(b'spamLMNO')\n>>> C\nbytearray(b'xYamLMNO')\n>>> C * 4\nbytearray(b'xYamLMNOxYamLMNOxYamLMNOxYamLMNO')\n\nFinally, by way of summary, the following examples demonstrate how bytes and\nbytearray objects are sequences of ints, and str objects are sequences of characters:\n# Binary versus text\n>>> B\nb'spam'\n>>> list(B)\n[115, 112, 97, 109]\n\n# B is same as S in 2.6",
    "Finally, by way of summary, the following examples demonstrate how bytes and\nbytearray objects are sequences of ints, and str objects are sequences of characters:\n# Binary versus text\n>>> B\nb'spam'\n>>> list(B)\n[115, 112, 97, 109]\n\n# B is same as S in 2.6\n\n>>> C\nbytearray(b'xYamLMNO')\n>>> list(C)\n[120, 89, 97, 109, 76, 77, 78, 79]\n>>> S\n'spam'\n>>> list(S)\n['s', 'p', 'a', 'm']\n\nUsing 3.0 (and 2.6) bytearray Objects | 919\n\n\fAlthough all three Python 3.0 string types can contain character values and support\nmany of the same operations, again, you should always:\n• Use str for textual data.\n• Use bytes for binary data.\n• Use bytearray for binary data you wish to change in-place.\nRelated tools such as files, the next section’s topic, often make the choice for you.",
    "Using Text and Binary Files\nThis section expands on the impact of Python 3.0’s string model on the file processing\nbasics introduced earlier in the book. As mentioned earlier, the mode in which you\nopen a file is crucial—it determines which object type you will use to represent the file’s\ncontent in your script. Text mode implies str objects, and binary mode implies bytes\nobjects:\n• Text-mode files interpret file contents according to a Unicode encoding—either the\ndefault for your platform, or one whose name you pass in. By passing in an encoding\nname to open, you can force conversions for various types of Unicode files. Textmode files also perform universal line-end translations: by default, all line-end\nforms map to the single '\\n' character in your script, regardless of the platform on\nwhich you run it. As described earlier, text files also handle reading and writing\nthe byte order mark (BOM) stored at the start-of-file in some Unicode encoding\nschemes.",
    "forms map to the single '\\n' character in your script, regardless of the platform on\nwhich you run it. As described earlier, text files also handle reading and writing\nthe byte order mark (BOM) stored at the start-of-file in some Unicode encoding\nschemes.\n• Binary-mode files instead return file content to you raw, as a sequence of integers\nrepresenting byte values, with no encoding or decoding and no line-end\ntranslations.\nThe second argument to open determines whether you want text or binary processing,\njust as it does in 2.X Python—adding a “b” to this string implies binary mode (e.g.,\n\"rb\" to read binary data files). The default mode is \"rt\"; this is the same as \"r\", which\nmeans text input (just as in 2.X).\nIn 3.0, though, this mode argument to open also implies an object type for file content\nrepresentation, regardless of the underlying platform—text files return a str for reads\nand expect one for writes, but binary files return a bytes for reads and expect one (or",
    "\"rb\" to read binary data files). The default mode is \"rt\"; this is the same as \"r\", which\nmeans text input (just as in 2.X).\nIn 3.0, though, this mode argument to open also implies an object type for file content\nrepresentation, regardless of the underlying platform—text files return a str for reads\nand expect one for writes, but binary files return a bytes for reads and expect one (or\na bytearray) for writes.",
    "Text File Basics\nTo demonstrate, let’s begin with basic file I/O. As long as you’re processing basic text\nfiles (e.g., ASCII) and don’t care about circumventing the platform-default encoding of\nstrings, files in 3.0 look and feel much as they do in 2.X (for that matter, so do strings\nin general). The following, for instance, writes one line of text to a file and reads it back\n920 | Chapter 36: Unicode and Byte Strings\n\n\fin 3.0, exactly as it would in 2.6 (note that file is no longer a built-in name in 3.0, so\nit’s perfectly OK to use it as a variable here):\nC:\\misc> c:\\python30\\python\n# Basic text files (and strings) work the same as in 2.X\n>>> file = open('temp', 'w')\n>>> size = file.write('abc\\n')\n>>> file.close()\n\n# Returns number of bytes written\n# Manual close to flush output buffer\n# Default mode is \"r\" (== \"rt\"): text input\n\n>>> file = open('temp')\n>>> text = file.read()\n>>> text\n'abc\\n'\n>>> print(text)\nabc",
    "# Returns number of bytes written\n# Manual close to flush output buffer\n# Default mode is \"r\" (== \"rt\"): text input\n\n>>> file = open('temp')\n>>> text = file.read()\n>>> text\n'abc\\n'\n>>> print(text)\nabc\n\nText and Binary Modes in 3.0\nIn Python 2.6, there is no major distinction between text and binary files—both accept\nand return content as str strings. The only major difference is that text files automatically map \\n end-of-line characters to and from \\r\\n on Windows, while binary files\ndo not (I’m stringing operations together into one-liners here just for brevity):\nC:\\misc> c:\\python26\\python\n>>> open('temp', 'w').write('abd\\n')\n>>> open('temp', 'r').read()\n'abd\\n'\n>>> open('temp', 'rb').read()\n'abd\\r\\n'\n>>> open('temp', 'wb').write('abc\\n')\n>>> open('temp', 'r').read()\n'abc\\n'\n>>> open('temp', 'rb').read()\n'abc\\n'\n\n# Write in text mode: adds \\r\n# Read in text mode: drops \\r\n# Read in binary mode: verbatim\n# Write in binary mode\n# \\n not expanded to \\r\\n",
    "# Write in text mode: adds \\r\n# Read in text mode: drops \\r\n# Read in binary mode: verbatim\n# Write in binary mode\n# \\n not expanded to \\r\\n\n\nIn Python 3.0, things are bit more complex because of the distinction between str for\ntext data and bytes for binary data. To demonstrate, let’s write a text file and read it\nback in both modes in 3.0. Notice that we are required to provide a str for writing, but\nreading gives us a str or a bytes, depending on the open mode:\nC:\\misc> c:\\python30\\python\n# Write and read a text file\n>>> open('temp', 'w').write('abc\\n')\n4\n\n# Text mode output, provide a str\n\n>>> open('temp', 'r').read()\n'abc\\n'\n\n# Text mode input, returns a str\n\nUsing Text and Binary Files | 921\n\n\f>>> open('temp', 'rb').read()\nb'abc\\r\\n'\n\n# Binary mode input, returns a bytes",
    "# Text mode output, provide a str\n\n>>> open('temp', 'r').read()\n'abc\\n'\n\n# Text mode input, returns a str\n\nUsing Text and Binary Files | 921\n\n\f>>> open('temp', 'rb').read()\nb'abc\\r\\n'\n\n# Binary mode input, returns a bytes\n\nNotice how on Windows text-mode files translate the \\n end-of-line character to \\r\\n\non output; on input, text mode translates the \\r\\n back to \\n, but binary mode does\nnot. This is the same in 2.6, and it’s what we want for binary data (no translations\nshould occur), although you can control this behavior with extra open arguments in 3.0\nif desired.\nNow let’s do the same again, but with a binary file. We provide a bytes to write in this\ncase, and we still get back a str or a bytes, depending on the input mode:\n# Write and read a binary file\n>>> open('temp', 'wb').write(b'abc\\n')\n4\n\n# Binary mode output, provide a bytes\n\n>>> open('temp', 'r').read()\n'abc\\n'\n\n# Text mode input, returns a str\n\n>>> open('temp', 'rb').read()\nb'abc\\n'",
    "# Binary mode output, provide a bytes\n\n>>> open('temp', 'r').read()\n'abc\\n'\n\n# Text mode input, returns a str\n\n>>> open('temp', 'rb').read()\nb'abc\\n'\n\n# Binary mode input, returns a bytes\n\nNote that the \\n end-of-line character is not expanded to \\r\\n in binary-mode output—\nagain, a desired result for binary data. Type requirements and file behavior are the same\neven if the data we’re writing to the binary file is truly binary in nature. In the following,\nfor example, the \"\\x00\" is a binary zero byte and not a printable character:\n# Write and read truly binary data\n>>> open('temp', 'wb').write(b'a\\x00c')\n3\n\n# Provide a bytes\n\n>>> open('temp', 'r').read()\n'a\\x00c'\n\n# Receive a str\n\n>>> open('temp', 'rb').read()\nb'a\\x00c'\n\n# Receive a bytes",
    "# Provide a bytes\n\n>>> open('temp', 'r').read()\n'a\\x00c'\n\n# Receive a str\n\n>>> open('temp', 'rb').read()\nb'a\\x00c'\n\n# Receive a bytes\n\nBinary-mode files always return contents as a bytes object, but accept either a bytes or\nbytearray object for writing; this naturally follows, given that bytearray is basically just\na mutable variant of bytes. In fact, most APIs in Python 3.0 that accept a bytes also\nallow a bytearray:\n# bytearrays work too\n>>> BA = bytearray(b'\\x01\\x02\\x03')\n>>> open('temp', 'wb').write(BA)\n3\n>>> open('temp', 'r').read()\n'\\x01\\x02\\x03'\n\n922 | Chapter 36: Unicode and Byte Strings\n\n\f>>> open('temp', 'rb').read()\nb'\\x01\\x02\\x03'",
    "922 | Chapter 36: Unicode and Byte Strings\n\n\f>>> open('temp', 'rb').read()\nb'\\x01\\x02\\x03'\n\nType and Content Mismatches\nNotice that you cannot get away with violating Python’s str/bytes type distinction\nwhen it comes to files. As the following examples illustrate, we get errors (shortened\nhere) if we try to write a bytes to a text file or a str to a binary file:\n# Types are not flexible for file content\n>>> open('temp', 'w').write('abc\\n')\n# Text mode makes and requires str\n4\n>>> open('temp', 'w').write(b'abc\\n')\nTypeError: can't write bytes to text stream\n>>> open('temp', 'wb').write(b'abc\\n')\n# Binary mode makes and requires bytes\n4\n>>> open('temp', 'wb').write('abc\\n')\nTypeError: can't write str to binary stream",
    "This makes sense: text has no meaning in binary terms, before it is encoded. Although\nit is often possible to convert between the types by encoding str and decoding bytes,\nas described earlier in this chapter, you will usually want to stick to either str for text\ndata or bytes for binary data. Because the str and bytes operation sets largely intersect,\nthe choice won’t be much of a dilemma for most programs (see the string tools coverage\nin the final section of this chapter for some prime examples of this).\nIn addition to type constraints, file content can matter in 3.0. Text-mode output files\nrequire a str instead of a bytes for content, so there is no way in 3.0 to write truly binary\ndata to a text-mode file. Depending on the encoding rules, bytes outside the default\ncharacter set can sometimes be embedded in a normal string, and they can always be\nwritten in binary mode. However, because text-mode input files in 3.0 must be able to",
    "require a str instead of a bytes for content, so there is no way in 3.0 to write truly binary\ndata to a text-mode file. Depending on the encoding rules, bytes outside the default\ncharacter set can sometimes be embedded in a normal string, and they can always be\nwritten in binary mode. However, because text-mode input files in 3.0 must be able to\ndecode content per a Unicode encoding, there is no way to read truly binary data in\ntext mode:\n# Can't read truly binary data in text mode\n>>> chr(0xFF)\n# FF is a valid char, FE is not\n'ÿ'\n>>> chr(0xFE)\nUnicodeEncodeError: 'charmap' codec can't encode character '\\xfe' in position 1...\n>>> open('temp', 'w').write(b'\\xFF\\xFE\\xFD')\nTypeError: can't write bytes to text stream",
    "# Can't use arbitrary bytes!\n\n>>> open('temp', 'w').write('\\xFF\\xFE\\xFD')\n3\n>>> open('temp', 'wb').write(b'\\xFF\\xFE\\xFD')\n3\n\n# Can write if embeddable in str\n\n>>> open('temp', 'rb').read()\n\n# Can always read as binary bytes\n\n# Can also write in binary mode\n\nUsing Text and Binary Files | 923\n\n\fb'\\xff\\xfe\\xfd'\n>>> open('temp', 'r').read()\n# Can't read text unless decodable!\nUnicodeEncodeError: 'charmap' codec can't encode characters in position 2-3: ...\n\nThis last error stems from the fact that all text files in 3.0 are really Unicode text files,\nas the next section describes.",
    "# Can always read as binary bytes\n\n# Can also write in binary mode\n\nUsing Text and Binary Files | 923\n\n\fb'\\xff\\xfe\\xfd'\n>>> open('temp', 'r').read()\n# Can't read text unless decodable!\nUnicodeEncodeError: 'charmap' codec can't encode characters in position 2-3: ...\n\nThis last error stems from the fact that all text files in 3.0 are really Unicode text files,\nas the next section describes.\n\nUsing Unicode Files\nSo far, we’ve been reading and writing basic text and binary files, but what about processing Unicode files? It turns out to be easy to read and write Unicode text stored in\nfiles, because the 3.0 open call accepts an encoding for text files, which does the encoding and decoding for us automatically as data is transferred. This allows us to\nprocess Unicode text created with different encodings than the default for the platform,\nand store in different encodings to convert.",
    "Reading and Writing Unicode in 3.0\nIn fact, we can convert a string to different encodings both manually with method calls\nand automatically on file input and output. We’ll use the following Unicode string in\nthis section to demonstrate:\nC:\\misc> c:\\python30\\python\n>>> S = 'A\\xc4B\\xe8C'\n>>> S\n'AÄBèC'\n>>> len(S)\n5\n\n# 5-character string, non-ASCII\n\nManual encoding\nAs we’ve already learned, we can always encode such a string to raw bytes according\nto the target encoding name:\n# Encode manually with methods\n>>> L = S.encode('latin-1')\n>>> L\nb'A\\xc4B\\xe8C'\n>>> len(L)\n5\n\n# 5 bytes when encoded as latin-1\n\n>>> U = S.encode('utf-8')\n>>> U\nb'A\\xc3\\x84B\\xc3\\xa8C'\n>>> len(U)\n7\n\n# 7 bytes when encoded as utf-8\n\n924 | Chapter 36: Unicode and Byte Strings",
    "# 5 bytes when encoded as latin-1\n\n>>> U = S.encode('utf-8')\n>>> U\nb'A\\xc3\\x84B\\xc3\\xa8C'\n>>> len(U)\n7\n\n# 7 bytes when encoded as utf-8\n\n924 | Chapter 36: Unicode and Byte Strings\n\n\fFile output encoding\nNow, to write our string to a text file in a particular encoding, we can simply pass the\ndesired encoding name to open—although we could manually encode first and write in\nbinary mode, there’s no need to:\n# Encoding automatically when written\n>>> open('latindata', 'w', encoding='latin-1').write(S)\n5\n>>> open('utf8data', 'w', encoding='utf-8').write(S)\n5\n\n# Write as latin-1\n\n>>> open('latindata', 'rb').read()\nb'A\\xc4B\\xe8C'\n\n# Read raw bytes\n\n>>> open('utf8data', 'rb').read()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Different in files\n\n# Write as utf-8",
    "# Write as latin-1\n\n>>> open('latindata', 'rb').read()\nb'A\\xc4B\\xe8C'\n\n# Read raw bytes\n\n>>> open('utf8data', 'rb').read()\nb'A\\xc3\\x84B\\xc3\\xa8C'\n\n# Different in files\n\n# Write as utf-8\n\nFile input decoding\nSimilarly, to read arbitrary Unicode data, we simply pass in the file’s encoding type\nname to open, and it decodes from raw bytes to strings automatically; we could read\nraw bytes and decode manually too, but that can be tricky when reading in blocks (we\nmight read an incomplete character), and it isn’t necessary:\n# Decoding automatically when read\n>>> open('latindata', 'r', encoding='latin-1').read()\n'AÄBèC'\n>>> open('utf8data', 'r', encoding='utf-8').read()\n'AÄBèC'\n\n# Decoded on input\n\n>>> X = open('latindata', 'rb').read()\n>>> X.decode('latin-1')\n'AÄBèC'\n>>> X = open('utf8data', 'rb').read()\n>>> X.decode()\n'AÄBèC'\n\n# Manual decoding:\n# Not necessary\n\n# Per encoding type\n\n# UTF-8 is default",
    "# Decoded on input\n\n>>> X = open('latindata', 'rb').read()\n>>> X.decode('latin-1')\n'AÄBèC'\n>>> X = open('utf8data', 'rb').read()\n>>> X.decode()\n'AÄBèC'\n\n# Manual decoding:\n# Not necessary\n\n# Per encoding type\n\n# UTF-8 is default\n\nDecoding mismatches\nFinally, keep in mind that this behavior of files in 3.0 limits the kind of content you can\nload as text. As suggested in the prior section, Python 3.0 really must be able to decode\nthe data in text files into a str string, according to either the default or a passed-in\nUnicode encoding name. Trying to open a truly binary data file in text mode, for example, is unlikely to work in 3.0 even if you use the correct object types:\n>>> file = open('python.exe', 'r')\n>>> text = file.read()\nUnicodeDecodeError: 'charmap' codec can't decode byte 0x90 in position 2: ...\n>>> file = open('python.exe', 'rb')\n\nUsing Unicode Files | 925\n\n\f>>> data = file.read()\n>>> data[:20]\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00'",
    "Using Unicode Files | 925\n\n\f>>> data = file.read()\n>>> data[:20]\nb'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\xb8\\x00\\x00\\x00'\n\nThe first of these examples might not fail in Python 2.X (normal files do not decode\ntext), even though it probably should: reading the file may return corrupted data in the\nstring, due to automatic end-of-line translations in text mode (any embedded \\r\\n bytes\nwill be translated to \\n on Windows when read). To treat file content as Unicode text\nin 2.6, we need to use special tools instead of the general open built-in function, as we’ll\nsee in a moment. First, though, let’s turn to a more explosive topic....",
    "Handling the BOM in 3.0\nAs described earlier in this chapter, some encoding schemes store a special byte order\nmarker (BOM) sequence at the start of files, to specify data endianness or declare the\nencoding type. Python both skips this marker on input and writes it on output if the\nencoding name implies it, but we sometimes must use a specific encoding name to force\nBOM processing explicitly.\nFor example, when you save a text file in Windows Notepad, you can specify its encoding type in a drop-down list—simple ASCII text, UTF-8, or little- or big-endian\nUTF-16. If a one-line text file named spam.txt is saved in Notepad as the encoding type\n“ANSI,” for instance, it’s written as simple ASCII text without a BOM. When this file\nis read in binary mode in Python, we can see the actual bytes stored in the file. When\nit’s read as text, Python performs end-of-line translation by default; we can decode it\nas explicit UTF-8 text since ASCII is a subset of this scheme (and UTF-8 is Python 3.0’s",
    "“ANSI,” for instance, it’s written as simple ASCII text without a BOM. When this file\nis read in binary mode in Python, we can see the actual bytes stored in the file. When\nit’s read as text, Python performs end-of-line translation by default; we can decode it\nas explicit UTF-8 text since ASCII is a subset of this scheme (and UTF-8 is Python 3.0’s\ndefault encoding):\nc:\\misc> C:\\Python30\\python\n# File saved in Notepad\n>>> import sys\n>>> sys.getdefaultencoding()\n'utf-8'\n>>> open('spam.txt', 'rb').read()\n# ASCII (UTF-8) text file\nb'spam\\r\\nSPAM\\r\\n'\n>>> open('spam.txt', 'r').read()\n# Text mode translates line-end\n'spam\\nSPAM\\n'\n>>> open('spam.txt', 'r', encoding='utf-8').read()\n'spam\\nSPAM\\n'",
    "If this file is instead saved as “UTF-8” in Notepad, it is prepended with a three-byte\nUTF-8 BOM sequence, and we need to give a more specific encoding name\n(“utf-8-sig”) to force Python to skip the marker:\n>>> open('spam.txt', 'rb').read()\n# UTF-8 with 3-byte BOM\nb'\\xef\\xbb\\xbfspam\\r\\nSPAM\\r\\n'\n>>> open('spam.txt', 'r').read()\n'ï»¿spam\\nSPAM\\n'\n>>> open('spam.txt', 'r', encoding='utf-8').read()\n'\\ufeffspam\\nSPAM\\n'\n>>> open('spam.txt', 'r', encoding='utf-8-sig').read()\n'spam\\nSPAM\\n'\n\n926 | Chapter 36: Unicode and Byte Strings",
    "926 | Chapter 36: Unicode and Byte Strings\n\n\fIf the file is stored as “Unicode big endian” in Notepad, we get UTF-16-format data in\nthe file, prepended with a two-byte BOM sequence—the encoding name “utf-16” in\nPython skips the BOM because it is implied (since all UTF-16 files have a BOM), and\n“utf-16-be” handles the big-endian format but does not skip the BOM:\n>>> open('spam.txt', 'rb').read()\nb'\\xfe\\xff\\x00s\\x00p\\x00a\\x00m\\x00\\r\\x00\\n\\x00S\\x00P\\x00A\\x00M\\x00\\r\\x00\\n'\n>>> open('spam.txt', 'r').read()\nUnicodeEncodeError: 'charmap' codec can't encode character '\\xfe' in position 1:...\n>>> open('spam.txt', 'r', encoding='utf-16').read()\n'spam\\nSPAM\\n'\n>>> open('spam.txt', 'r', encoding='utf-16-be').read()\n'\\ufeffspam\\nSPAM\\n'",
    "The same is generally true for output. When writing a Unicode file in Python code, we\nneed a more explicit encoding name to force the BOM in UTF-8—“utf-8” does not\nwrite (or skip) the BOM, but “utf-8-sig” does:\n>>> open('temp.txt', 'w', encoding='utf-8').write('spam\\nSPAM\\n')\n10\n>>> open('temp.txt', 'rb').read()\n# No BOM\nb'spam\\r\\nSPAM\\r\\n'\n>>> open('temp.txt', 'w', encoding='utf-8-sig').write('spam\\nSPAM\\n')\n10\n>>> open('temp.txt', 'rb').read()\n# Wrote BOM\nb'\\xef\\xbb\\xbfspam\\r\\nSPAM\\r\\n'\n>>> open('temp.txt', 'r').read()\n'ï»¿spam\\nSPAM\\n'\n>>> open('temp.txt', 'r', encoding='utf-8').read()\n'\\ufeffspam\\nSPAM\\n'\n>>> open('temp.txt', 'r', encoding='utf-8-sig').read()\n'spam\\nSPAM\\n'\n\n# Keeps BOM\n# Skips BOM",
    "# Keeps BOM\n# Skips BOM\n\nNotice that although “utf-8” does not drop the BOM, data without a BOM can be read\nwith both “utf-8” and “utf-8-sig”—use the latter for input if you’re not sure whether a\nBOM is present in a file (and don’t read this paragraph out loud in an airport security\nline!):\n>>> open('temp.txt', 'w').write('spam\\nSPAM\\n')\n10\n>>> open('temp.txt', 'rb').read()\nb'spam\\r\\nSPAM\\r\\n'\n>>> open('temp.txt', 'r').read()\n'spam\\nSPAM\\n'\n>>> open('temp.txt', 'r', encoding='utf-8').read()\n'spam\\nSPAM\\n'\n>>> open('temp.txt', 'r', encoding='utf-8-sig').read()\n'spam\\nSPAM\\n'\n\n# Data without BOM\n# Any utf-8 works\n\nFinally, for the encoding name “utf-16,” the BOM is handled automatically: on output, data is written in the platform’s native endianness, and the BOM is always written;\non input, data is decoded per the BOM, and the BOM is always stripped. More specific\nUsing Unicode Files | 927",
    "UTF-16 encoding names can specify different endianness, though you may have to\nmanually write and skip the BOM yourself in some scenarios if it is required or present:\n>>> sys.byteorder\n'little'\n>>> open('temp.txt', 'w', encoding='utf-16').write('spam\\nSPAM\\n')\n10\n>>> open('temp.txt', 'rb').read()\nb'\\xff\\xfes\\x00p\\x00a\\x00m\\x00\\r\\x00\\n\\x00S\\x00P\\x00A\\x00M\\x00\\r\\x00\\n\\x00'\n>>> open('temp.txt', 'r', encoding='utf-16').read()\n'spam\\nSPAM\\n'\n>>> open('temp.txt', 'w', encoding='utf-16-be').write('\\ufeffspam\\nSPAM\\n')\n11\n>>> open('spam.txt', 'rb').read()\nb'\\xfe\\xff\\x00s\\x00p\\x00a\\x00m\\x00\\r\\x00\\n\\x00S\\x00P\\x00A\\x00M\\x00\\r\\x00\\n'\n>>> open('temp.txt', 'r', encoding='utf-16').read()\n'spam\\nSPAM\\n'\n>>> open('temp.txt', 'r', encoding='utf-16-be').read()\n'\\ufeffspam\\nSPAM\\n'",
    "The more specific UTF-16 encoding names work fine with BOM-less files, though\n“utf-16” requires one on input in order to determine byte order:\n>>> open('temp.txt', 'w', encoding='utf-16-le').write('SPAM')\n4\n>>> open('temp.txt', 'rb').read()\n# OK if BOM not present or expected\nb'S\\x00P\\x00A\\x00M\\x00'\n>>> open('temp.txt', 'r', encoding='utf-16-le').read()\n'SPAM'\n>>> open('temp.txt', 'r', encoding='utf-16').read()\nUnicodeError: UTF-16 stream does not start with BOM\n\nExperiment with these encodings yourself or see Python’s library manuals for more\ndetails on the BOM.",
    "Experiment with these encodings yourself or see Python’s library manuals for more\ndetails on the BOM.\n\nUnicode Files in 2.6\nThe preceding discussion applies to Python 3.0’s string types and files. You can achieve\nsimilar effects for Unicode files in 2.6, but the interface is different. If you replace str\nwith unicode and open with codecs.open, the result is essentially the same in 2.6:\nC:\\misc> c:\\python26\\python\n>>> S = u'A\\xc4B\\xe8C'\n>>> print S\nAÄBèC\n>>> len(S)\n5\n>>> S.encode('latin-1')\n'A\\xc4B\\xe8C'\n>>> S.encode('utf-8')\n'A\\xc3\\x84B\\xc3\\xa8C'\n>>> import codecs\n\n928 | Chapter 36: Unicode and Byte Strings\n\n\f>>> codecs.open('latindata', 'w', encoding='latin-1').write(S)\n>>> codecs.open('utfdata', 'w', encoding='utf-8').write(S)\n>>> open('latindata', 'rb').read()\n'A\\xc4B\\xe8C'\n>>> open('utfdata', 'rb').read()\n'A\\xc3\\x84B\\xc3\\xa8C'\n>>> codecs.open('latindata', 'r', encoding='latin-1').read()\nu'A\\xc4B\\xe8C'\n>>> codecs.open('utfdata', 'r', encoding='utf-8').read()\nu'A\\xc4B\\xe8C'",
    ">>> codecs.open('latindata', 'w', encoding='latin-1').write(S)\n>>> codecs.open('utfdata', 'w', encoding='utf-8').write(S)\n>>> open('latindata', 'rb').read()\n'A\\xc4B\\xe8C'\n>>> open('utfdata', 'rb').read()\n'A\\xc3\\x84B\\xc3\\xa8C'\n>>> codecs.open('latindata', 'r', encoding='latin-1').read()\nu'A\\xc4B\\xe8C'\n>>> codecs.open('utfdata', 'r', encoding='utf-8').read()\nu'A\\xc4B\\xe8C'\n\nOther String Tool Changes in 3.0\nSome of the other popular string-processing tools in Python’s standard library have\nbeen revamped for the new str/bytes type dichotomy too. We won’t cover any of these\napplication-focused tools in much detail in this core language book, but to wrap up\nthis chapter, here’s a quick look at four of the major tools impacted: the re patternmatching module, the struct binary data module, the pickle object serialization module, and the xml package for parsing XML text.",
    "The re Pattern Matching Module\nPython’s re pattern-matching module supports text processing that is more general\nthan that afforded by simple string method calls such as find, split, and replace. With\nre, strings that designate searching and splitting targets can be described by general\npatterns, instead of absolute text. This module has been generalized to work on objects\nof any string type in 3.0—str, bytes, and bytearray—and returns result substrings of\nthe same type as the subject string.\nHere it is at work in 3.0, extracting substrings from a line of text. Within pattern strings,\n(.*) means any character (.), zero or more times (*), saved away as a matched substring\n(()). Parts of the string matched by the parts of a pattern enclosed in parentheses are\navailable after a successful match, via the group or groups method:\nC:\\misc> c:\\python30\\python\n>>> import re\n>>> S = 'Bugger all down here on earth!'\n>>> B = b'Bugger all down here on earth!'\n\n# Line of text\n# Usually from a file",
    "# Line of text\n# Usually from a file\n\n>>> re.match('(.*) down (.*) on (.*)', S).groups()\n('Bugger all', 'here', 'earth!')\n\n# Match line to pattern\n# Matched substrings\n\n>>> re.match(b'(.*) down (.*) on (.*)', B).groups()\n(b'Bugger all', b'here', b'earth!')\n\n# bytes substrings\n\nIn Python 2.6 results are similar, but the unicode type is used for non-ASCII text, and\nstr handles both 8-bit and binary text:\n\nOther String Tool Changes in 3.0 | 929\n\n\fC:\\misc> c:\\python26\\python\n>>> import re\n>>> S = 'Bugger all down here on earth!'\n>>> U = u'Bugger all down here on earth!'\n\n# Simple text and binary\n# Unicode text\n\n>>> re.match('(.*) down (.*) on (.*)', S).groups()\n('Bugger all', 'here', 'earth!')\n>>> re.match('(.*) down (.*) on (.*)', U).groups()\n(u'Bugger all', u'here', u'earth!')",
    "Since bytes and str support essentially the same operation sets, this type distinction is\nlargely transparent. But note that, like in other APIs, you can’t mix str and bytes types\nin its calls’ arguments in 3.0 (although if you don’t plan to do pattern matching on\nbinary data, you probably don’t need to care):\nC:\\misc> c:\\python30\\python\n>>> import re\n>>> S = 'Bugger all down here on earth!'\n>>> B = b'Bugger all down here on earth!'\n>>> re.match('(.*) down (.*) on (.*)', B).groups()\nTypeError: can't use a string pattern on a bytes-like object\n>>> re.match(b'(.*) down (.*) on (.*)', S).groups()\nTypeError: can't use a bytes pattern on a string-like object\n>>> re.match(b'(.*) down (.*) on (.*)', bytearray(B)).groups()\n(bytearray(b'Bugger all'), bytearray(b'here'), bytearray(b'earth!'))\n>>> re.match('(.*) down (.*) on (.*)', bytearray(B)).groups()\nTypeError: can't use a string pattern on a bytes-like object",
    "The struct Binary Data Module\nThe Python struct module, used to create and extract packed binary data from strings,\nalso works the same in 3.0 as it does in 2.X, but packed data is represented as bytes\nand bytearray objects only, not str objects (which makes sense, given that it’s intended\nfor processing binary data, not arbitrarily encoded text).\nHere are both Pythons in action, packing three objects into a string according to a binary\ntype specification (they create a four-byte integer, a four-byte string, and a two-byte\ninteger):\nC:\\misc> c:\\python30\\python\n>>> from struct import pack\n>>> pack('>i4sh', 7, 'spam', 8)\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\nC:\\misc> c:\\python26\\python\n>>> from struct import pack\n>>> pack('>i4sh', 7, 'spam', 8)\n'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n\n930 | Chapter 36: Unicode and Byte Strings\n\n# bytes in 3.0 (8-bit string)\n\n# str in 2.6 (8-bit string)",
    "930 | Chapter 36: Unicode and Byte Strings\n\n# bytes in 3.0 (8-bit string)\n\n# str in 2.6 (8-bit string)\n\n\fSince bytes has an almost identical interface to that of str in 3.0 and 2.6, though, most\nprogrammers probably won’t need to care—the change is irrelevant to most existing\ncode, especially since reading from a binary file creates a bytes automatically. Although\nthe last test in the following example fails on a type mismatch, most scripts will read\nbinary data from a file, not create it as a string:\nC:\\misc> c:\\python30\\python\n>>> import struct\n>>> B = struct.pack('>i4sh', 7, 'spam', 8)\n>>> B\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> vals = struct.unpack('>i4sh', B)\n>>> vals\n(7, b'spam', 8)\n>>> vals = struct.unpack('>i4sh', B.decode())\nTypeError: 'str' does not have the buffer interface",
    "Apart from the new syntax for bytes, creating and reading binary files works almost the\nsame in 3.0 as it does in 2.X. Code like this is one of the main places where programmers\nwill notice the bytes object type:\nC:\\misc> c:\\python30\\python\n# Write values to a packed binary file\n>>> F = open('data.bin', 'wb')\n>>> import struct\n>>> data = struct.pack('>i4sh', 7, 'spam', 8)\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> F.write(data)\n10\n>>> F.close()\n\n# Open binary output file\n# Create packed binary data\n# bytes in 3.0, not str\n# Write to the file\n\n# Read values from a packed binary file\n>>> F = open('data.bin', 'rb')\n>>> data = F.read()\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> values = struct.unpack('>i4sh', data)\n>>> values\n(7, b'spam', 8)\n\n# Open binary input file\n# Read bytes\n# Extract packed binary data\n# Back to Python objects",
    "# Open binary output file\n# Create packed binary data\n# bytes in 3.0, not str\n# Write to the file\n\n# Read values from a packed binary file\n>>> F = open('data.bin', 'rb')\n>>> data = F.read()\n>>> data\nb'\\x00\\x00\\x00\\x07spam\\x00\\x08'\n>>> values = struct.unpack('>i4sh', data)\n>>> values\n(7, b'spam', 8)\n\n# Open binary input file\n# Read bytes\n# Extract packed binary data\n# Back to Python objects\n\nOnce you’ve extracted packed binary data into Python objects like this, you can dig\neven further into the binary world if you have to—strings can be indexed and sliced to\nget individual bytes’ values, individual bits can be extracted from integers with bitwise\noperators, and so on (see earlier in this book for more on the operations applied here):\n>>> values\n(7, b'spam', 8)\n\n# Result of struct.unpack\n\nOther String Tool Changes in 3.0 | 931\n\n\f# Accesssing bits of parsed integers\n# Can get to bits in ints",
    "# Result of struct.unpack\n\nOther String Tool Changes in 3.0 | 931\n\n\f# Accesssing bits of parsed integers\n# Can get to bits in ints\n\n>>> bin(values[0])\n'0b111'\n>>> values[0] & 0x01\n1\n>>> values[0] | 0b1010\n15\n>>> bin(values[0] | 0b1010)\n'0b1111'\n>>> bin(values[0] ^ 0b1010)\n'0b1101'\n>>> bool(values[0] & 0b100)\nTrue\n>>> bool(values[0] & 0b1000)\nFalse\n\n# Test first (lowest) bit in int\n# Bitwise or: turn bits on\n# 15 decimal is 1111 binary\n# Bitwise xor: off if both true\n# Test if bit 3 is on\n# Test if bit 4 is set\n\nSince parsed bytes strings are sequences of small integers, we can do similar processing\nwith their individual bytes:\n# Accessing bytes of parsed strings and bits within them\n>>> values[1]\nb'spam'\n>>> values[1][0]\n115\n>>> values[1][1:]\nb'pam'\n>>> bin(values[1][0])\n'0b1110011'\n>>> bin(values[1][0] | 0b1100)\n'0b1111111'\n>>> values[1][0] | 0b1100\n127\n\n# bytes string: sequence of ints\n# Prints as ASCII characters\n# Can get to bits of bytes in strings\n# Turn bits on",
    "# bytes string: sequence of ints\n# Prints as ASCII characters\n# Can get to bits of bytes in strings\n# Turn bits on\n\nOf course, most Python programmers don’t deal with binary bits; Python has higherlevel object types, like lists and dictionaries, that are generally a better choice for\nrepresenting information in Python scripts. However, if you must use or produce\nlower-level data used by C programs, networking libraries, or other interfaces, Python\nhas tools to assist.\n\nThe pickle Object Serialization Module\nWe met the pickle module briefly in Chapters 9 and 30. In Chapter 27, we also used\nthe shelve module, which uses pickle internally. For completeness here, keep in mind\nthat the Python 3.0 version of the pickle module always creates a bytes object, regardless of the default or passed-in “protocol” (data format level). You can see this by using\nthe module’s dumps call to return an object’s pickle string:\nC:\\misc> C:\\Python30\\python\n>>> import pickle\n\n# dumps() returns pickle string",
    "# dumps() returns pickle string\n\n>>> pickle.dumps([1, 2, 3])\n\n# Python 3.0 default protocol=3=binary\n\n932 | Chapter 36: Unicode and Byte Strings\n\n\fb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'\n>>> pickle.dumps([1, 2, 3], protocol=0)\nb'(lp0\\nL1L\\naL2L\\naL3L\\na.'\n\n# ASCII protocol 0, but still bytes!\n\nThis implies that files used to store pickled objects must always be opened in binary\nmode in Python 3.0, since text files use str strings to represent data, not bytes—the\ndump call simply attempts to write the pickle string to an open output file:\n>>> pickle.dump([1, 2, 3], open('temp', 'w'))\nTypeError: can't write bytes to text stream\n\n# Text files fail on bytes!\n# Despite protocol value\n\n>>> pickle.dump([1, 2, 3], open('temp', 'w'), protocol=0)\nTypeError: can't write bytes to text stream\n>>> pickle.dump([1, 2, 3], open('temp', 'wb'))\n\n# Always use binary in 3.0\n\n>>> open('temp', 'r').read()\nUnicodeEncodeError: 'charmap' codec can't encode character '\\u20ac' in ...",
    "# Text files fail on bytes!\n# Despite protocol value\n\n>>> pickle.dump([1, 2, 3], open('temp', 'w'), protocol=0)\nTypeError: can't write bytes to text stream\n>>> pickle.dump([1, 2, 3], open('temp', 'wb'))\n\n# Always use binary in 3.0\n\n>>> open('temp', 'r').read()\nUnicodeEncodeError: 'charmap' codec can't encode character '\\u20ac' in ...\n\nBecause pickle data is not decodable Unicode text, the same is true on input—correct\nusage in 3.0 requires always writing and reading pickle data in binary modes:\n>>> pickle.dump([1, 2, 3], open('temp', 'wb'))\n>>> pickle.load(open('temp', 'rb'))\n[1, 2, 3]\n>>> open('temp', 'rb').read()\nb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'\n\nIn Python 2.6 (and earlier), we can get by with text-mode files for pickled data, as long\nas the protocol is level 0 (the default in 2.6) and we use text mode consistently to convert\nline-ends:\nC:\\misc> c:\\python26\\python\n>>> import pickle\n>>> pickle.dumps([1, 2, 3])\n'(lp0\\nI1\\naI2\\naI3\\na.'\n\n# Python 2.6 default=0=ASCII",
    "In Python 2.6 (and earlier), we can get by with text-mode files for pickled data, as long\nas the protocol is level 0 (the default in 2.6) and we use text mode consistently to convert\nline-ends:\nC:\\misc> c:\\python26\\python\n>>> import pickle\n>>> pickle.dumps([1, 2, 3])\n'(lp0\\nI1\\naI2\\naI3\\na.'\n\n# Python 2.6 default=0=ASCII\n\n>>> pickle.dumps([1, 2, 3], protocol=1)\n']q\\x00(K\\x01K\\x02K\\x03e.'\n>>> pickle.dump([1, 2, 3], open('temp', 'w'))\n>>> pickle.load(open('temp'))\n[1, 2, 3]\n>>> open('temp').read()\n'(lp0\\nI1\\naI2\\naI3\\na.'\n\n# Text mode works in 2.6\n\nIf you care about version neutrality, though, or don’t want to care about protocols or\ntheir version-specific defaults, always use binary-mode files for pickled data—the following works the same in Python 3.0 and 2.6:\n>>> import pickle\n>>> pickle.dump([1, 2, 3], open('temp', 'wb'))\n>>> pickle.load(open('temp', 'rb'))\n[1, 2, 3]\n\n# Version neutral\n# And required in 3.0\n\nOther String Tool Changes in 3.0 | 933",
    "# Version neutral\n# And required in 3.0\n\nOther String Tool Changes in 3.0 | 933\n\n\fBecause almost all programs let Python pickle and unpickle objects automatically and\ndo not deal with the content of pickled data itself, the requirement to always use binary\nfile modes is the only significant incompatibility in Python 3’s new pickling model. See\nreference books or Python’s manuals for more details on object pickling.",
    "XML Parsing Tools\nXML is a tag-based language for defining structured information, commonly used to\ndefine documents and data shipped over the Web. Although some information can be\nextracted from XML text with basic string methods or the re pattern module, XML’s\nnesting of constructs and arbitrary attribute text tend to make full parsing more\naccurate.\nBecause XML is such a pervasive format, Python itself comes with an entire package of\nXML parsing tools that support the SAX and DOM parsing models, as well as a package\nknown as ElementTree—a Python-specific API for parsing and constructing XML.\nBeyond basic parsing, the open source domain provides support for additional XML\ntools, such as XPath, Xquery, XSLT, and more.\nXML by definition represents text in Unicode form, to support internationalization.\nAlthough most of Python’s XML parsing tools have always returned Unicode strings,\nin Python 3.0 their results have mutated from the 2.X unicode type to the 3.0 general",
    "Beyond basic parsing, the open source domain provides support for additional XML\ntools, such as XPath, Xquery, XSLT, and more.\nXML by definition represents text in Unicode form, to support internationalization.\nAlthough most of Python’s XML parsing tools have always returned Unicode strings,\nin Python 3.0 their results have mutated from the 2.X unicode type to the 3.0 general\nstr string type—which makes sense, given that 3.0’s str string is Unicode, whether the\nencoding is ASCII or other.\nWe can’t go into many details here, but to sample the flavor of this domain, suppose\nwe have a simple XML text file, mybooks.xml:\n<books>\n<date>2009</date>\n<title>Learning Python</title>\n<title>Programming Python</title>\n<title>Python Pocket Reference</title>\n<publisher>O'Reilly Media</publisher>\n</books>",
    "and we want to run a script to extract and display the content of all the nested title\ntags, as follows:\nLearning Python\nProgramming Python\nPython Pocket Reference\n\nThere are at least four basic ways to accomplish this (not counting more advanced tools\nlike XPath). First, we could run basic pattern matching on the file’s text, though this\ntends to be inaccurate if the text is unpredictable. Where applicable, the re module we\nmet earlier does the job—its match method looks for a match at the start of a string,\nsearch scans ahead for a match, and the findall method used here locates all places\nwhere the pattern matches in the string (the result comes back as a list of matched\n\n934 | Chapter 36: Unicode and Byte Strings\n\n\fsubstrings corresponding to parenthesized pattern groups, or tuples of such for multiple groups):\n# File patternparse.py\nimport re\ntext = open('mybooks.xml').read()\nfound = re.findall('<title>(.*)</title>', text)\nfor title in found: print(title)",
    "934 | Chapter 36: Unicode and Byte Strings\n\n\fsubstrings corresponding to parenthesized pattern groups, or tuples of such for multiple groups):\n# File patternparse.py\nimport re\ntext = open('mybooks.xml').read()\nfound = re.findall('<title>(.*)</title>', text)\nfor title in found: print(title)\n\nSecond, to be more robust, we could perform complete XML parsing with the standard\nlibrary’s DOM parsing support. DOM parses XML text into a tree of objects and provides an interface for navigating the tree to extract tag attributes and values; the interface is a formal specification, independent of Python:\n# File domparse.py\nfrom xml.dom.minidom import parse, Node\nxmltree = parse('mybooks.xml')\nfor node1 in xmltree.getElementsByTagName('title'):\nfor node2 in node1.childNodes:\nif node2.nodeType == Node.TEXT_NODE:\nprint(node2.data)",
    "As a third option, Python’s standard library supports SAX parsing for XML. Under the\nSAX model, a class’s methods receive callbacks as a parse progresses and use state\ninformation to keep track of where they are in the document and collect its data:\n# File saxparse.py\nimport xml.sax.handler\nclass BookHandler(xml.sax.handler.ContentHandler):\ndef __init__(self):\nself.inTitle = False\ndef startElement(self, name, attributes):\nif name == 'title':\nself.inTitle = True\ndef characters(self, data):\nif self.inTitle:\nprint(data)\ndef endElement(self, name):\nif name == 'title':\nself.inTitle = False\nimport xml.sax\nparser = xml.sax.make_parser()\nhandler = BookHandler()\nparser.setContentHandler(handler)\nparser.parse('mybooks.xml')",
    "Finally, the ElementTree system available in the etree package of the standard library\ncan often achieve the same effects as XML DOM parsers, but with less code. It’s a\nPython-specific way to both parse and generate XML text; after a parse, its API gives\naccess to components of the document:\n\nOther String Tool Changes in 3.0 | 935\n\n\f# File etreeparse.py\nfrom xml.etree.ElementTree import parse\ntree = parse('mybooks.xml')\nfor E in tree.findall('title'):\nprint(E.text)\n\nWhen run in either 2.6 or 3.0, all four of these scripts display the same printed result:\nC:\\misc> c:\\python26\\python domparse.py\nLearning Python\nProgramming Python\nPython Pocket Reference\nC:\\misc> c:\\python30\\python domparse.py\nLearning Python\nProgramming Python\nPython Pocket Reference",
    "When run in either 2.6 or 3.0, all four of these scripts display the same printed result:\nC:\\misc> c:\\python26\\python domparse.py\nLearning Python\nProgramming Python\nPython Pocket Reference\nC:\\misc> c:\\python30\\python domparse.py\nLearning Python\nProgramming Python\nPython Pocket Reference\n\nTechnically, though, in 2.6 some of these scripts produce unicode string objects, while\nin 3.0 all produce str strings, since that type includes Unicode text (whether ASCII or\nother):\nC:\\misc> c:\\python30\\python\n>>> from xml.dom.minidom import parse, Node\n>>> xmltree = parse('mybooks.xml')\n>>> for node in xmltree.getElementsByTagName('title'):\n...\nfor node2 in node.childNodes:\n...\nif node2.nodeType == Node.TEXT_NODE:\n...\nnode2.data\n...\n'Learning Python'\n'Programming Python'\n'Python Pocket Reference'\nC:\\misc> c:\\python26\\python\n>>> ...same code...\n...\nu'Learning Python'\nu'Programming Python'\nu'Python Pocket Reference'",
    "Programs that must deal with XML parsing results in nontrivial ways will need to account for the different object type in 3.0. Again, though, because all strings have nearly\nidentical interfaces in both 2.6 and 3.0, most scripts won’t be affected by the change;\ntools available on unicode in 2.6 are generally available on str in 3.0.\nRegrettably, going into further XML parsing details is beyond this book’s scope. If you\nare interested in text or XML parsing, it is covered in more detail in the applicationsfocused follow-up book Programming Python. For more details on re, struct, pickle,\nand XML tools in general, consult the Web, the aforementioned book and others, and\nPython’s standard library manual.\n\n936 | Chapter 36: Unicode and Byte Strings",
    "Chapter Summary\nThis chapter explored advanced string types available in Python 3.0 and 2.6 for processing Unicode text and binary data. As we saw, many programmers use ASCII text\nand can get by with the basic string type and its operations. For more advanced applications, Python’s string models fully support both wide-character Unicode text (via the\nnormal string type in 3.0 and a special type in 2.6) and byte-oriented data (represented\nwith a bytes type in 3.0 and normal strings in 2.6).\nIn addition, we learned how Python’s file object has mutated in 3.0 to automatically\nencode and decode Unicode text and deal with byte strings for binary-mode files. Finally, we briefly met some text and binary data tools in Python’s library, and sampled\ntheir behavior in 3.0.\nIn the next chapter, we’ll shift our focus to tool-builder topics, with a look at ways to\nmanage access to object attributes by inserting automatically run code. Before we move",
    "encode and decode Unicode text and deal with byte strings for binary-mode files. Finally, we briefly met some text and binary data tools in Python’s library, and sampled\ntheir behavior in 3.0.\nIn the next chapter, we’ll shift our focus to tool-builder topics, with a look at ways to\nmanage access to object attributes by inserting automatically run code. Before we move\non, though, here’s a set of questions to review what we’ve learned here.",
    "Test Your Knowledge: Quiz\n1. What are the names and roles of string object types in Python 3.0?\n2. What are the names and roles of string object types in Python 2.6?\n3. What is the mapping between 2.6 and 3.0 string types?\n4. How do Python 3.0’s string types differ in terms of operations?\n5. How can you code non-ASCII Unicode characters in a string in 3.0?\n6. What are the main differences between text- and binary-mode files in Python 3.0?\n7. How would you read a Unicode text file that contains text in a different encoding\nthan the default for your platform?\n8. How can you create a Unicode text file in a specific encoding format?\n9. Why is ASCII text considered to be a kind of Unicode text?\n10. How large an impact does Python 3.0’s string types change have on your code?",
    "Test Your Knowledge: Answers\n1. Python 3.0 has three string types: str (for Unicode text, including ASCII), bytes\n(for binary data with absolute byte values), and bytearray (a mutable flavor of\nbytes). The str type usually represents content stored on a text file, and the other\ntwo types generally represent content stored on binary files.\n\nTest Your Knowledge: Answers | 937",
    "2. Python 2.6 has two main string types: str (for 8-bit text and binary data) and\nunicode (for wide-character text). The str type is used for both text and binary file\ncontent; unicode is used for text file content that is generally more complex than\n8 bits. Python 2.6 (but not earlier) also has 3.0’s bytearray type, but it’s mostly a\nback-port and doesn’t exhibit the sharp text/binary distinction that it does in 3.0.\n3. The mapping from 2.6 to 3.0 string types is not direct, because 2.6’s str equates\nto both str and bytes in 3.0, and 3.0’s str equates to both str and unicode in 2.6.\nThe mutability of bytearray in 3.0 is also unique.\n4. Python 3.0’s string types share almost all the same operations: method calls, sequence operations, and even larger tools like pattern matching work the same way.\nOn the other hand, only str supports string formatting operations, and\nbytearray has an additional set of operations that perform in-place changes. The",
    "The mutability of bytearray in 3.0 is also unique.\n4. Python 3.0’s string types share almost all the same operations: method calls, sequence operations, and even larger tools like pattern matching work the same way.\nOn the other hand, only str supports string formatting operations, and\nbytearray has an additional set of operations that perform in-place changes. The\nstr and bytes types also have methods for encoding and decoding text,\nrespectively.\n5. Non-ASCII Unicode characters can be coded in a string with both hex (\\xNN) and\nUnicode (\\uNNNN, \\UNNNNNNNN) escapes. On some keyboards, some non-ASCII characters—certain Latin-1 characters, for example—can also be typed directly.\n6. In 3.0, text-mode files assume their file content is Unicode text (even if it’s ASCII)\nand automatically decode when reading and encode when writing. With binarymode files, bytes are transferred to and from the file unchanged. The contents of",
    "Unicode (\\uNNNN, \\UNNNNNNNN) escapes. On some keyboards, some non-ASCII characters—certain Latin-1 characters, for example—can also be typed directly.\n6. In 3.0, text-mode files assume their file content is Unicode text (even if it’s ASCII)\nand automatically decode when reading and encode when writing. With binarymode files, bytes are transferred to and from the file unchanged. The contents of\ntext-mode files are usually represented as str objects in your script, and the contents of binary files are represented as bytes (or bytearray) objects. Text-mode files\nalso handle the BOM for certain encoding types and automatically translate endof-line sequences to and from the single \\n character on input and output unless\nthis is explicitly disabled; binary-mode files do not perform either of these steps.\n7. To read files encoded in a different encoding than the default for your platform,\nsimply pass the name of the file’s encoding to the open built-in in 3.0",
    "this is explicitly disabled; binary-mode files do not perform either of these steps.\n7. To read files encoded in a different encoding than the default for your platform,\nsimply pass the name of the file’s encoding to the open built-in in 3.0\n(codecs.open() in 2.6); data will be decoded per the specified encoding when it is\nread from the file. You can also read in binary mode and manually decode the bytes\nto a string by giving an encoding name, but this involves extra work and is somewhat error-prone for multibyte characters (you may accidentally read a partial\ncharacter sequence).\n8. To create a Unicode text file in a specific encoding format, pass the desired encoding name to open in 3.0 (codecs.open() in 2.6); strings will be encoded per the\ndesired encoding when they are written to the file. You can also manually encode\na string to bytes and write it in binary mode, but this is usually extra work.\n9. ASCII text is considered to be a kind of Unicode text, because its 7-bit range of",
    "desired encoding when they are written to the file. You can also manually encode\na string to bytes and write it in binary mode, but this is usually extra work.\n9. ASCII text is considered to be a kind of Unicode text, because its 7-bit range of\nvalues is a subset of most Unicode encodings. For example, valid ASCII text is also\nvalid Latin-1 text (Latin-1 simply assigns the remaining possible values in an 8-bit\nbyte to additional characters) and valid UTF-8 text (UTF-8 defines a variable-byte\nscheme for representing more characters, but ASCII characters are still represented\nwith the same codes, in a single byte).\n938 | Chapter 36: Unicode and Byte Strings",
    "10. The impact of Python 3.0’s string types change depends upon the types of strings\nyou use. For scripts that use simple ASCII text, there is probably no impact at all:\nthe str string type works the same in 2.6 and 3.0 in this case. Moreover, although\nstring-related tools in the standard library such as re, struct, pickle, and xml may\ntechnically use different types in 3.0 than in 2.6, the changes are largely irrelevant\nto most programs because 3.0’s str and bytes and 2.6’s str support almost identical interfaces. If you process Unicode data, the toolset you need has simply moved\nfrom 2.6’s unicode and codecs.open() to 3.0’s str and open. If you deal with binary\ndata files, you’ll need to deal with content as bytes objects; since they have a similar\ninterface to 2.6 strings, though, the impact should again be minimal.\n\nTest Your Knowledge: Answers | 939\n\n\f\fCHAPTER 37\n\nManaged Attributes",
    "Test Your Knowledge: Answers | 939\n\n\f\fCHAPTER 37\n\nManaged Attributes\n\nThis chapter expands on the attribute interception techniques introduced earlier, introduces another, and employs them in a handful of larger examples. Like everything\nin this part of the book, this chapter is classified as an advanced topic and optional\nreading, because most applications programmers don’t need to care about the material\ndiscussed here—they can fetch and set attributes on objects without concern for attribute implementations. Especially for tools builders, though, managing attribute access can be an important part of flexible APIs.\n\nWhy Manage Attributes?\nObject attributes are central to most Python programs—they are where we often store\ninformation about the entities our scripts process. Normally, attributes are simply\nnames for objects; a person’s name attribute, for example, might be a simple string,\nfetched and set with basic attribute syntax:\nperson.name\nperson.name = value",
    "Why Manage Attributes?\nObject attributes are central to most Python programs—they are where we often store\ninformation about the entities our scripts process. Normally, attributes are simply\nnames for objects; a person’s name attribute, for example, might be a simple string,\nfetched and set with basic attribute syntax:\nperson.name\nperson.name = value\n\n# Fetch attribute value\n# Change attribute value",
    "# Fetch attribute value\n# Change attribute value\n\nIn most cases, the attribute lives in the object itself, or is inherited from a class from\nwhich it derives. That basic model suffices for most programs you will write in your\nPython career.\nSometimes, though, more flexibility is required. Suppose you’ve written a program to\nuse a name attribute directly, but then your requirements change—for example, you\ndecide that names should be validated with logic when set or mutated in some way\nwhen fetched. It’s straightforward to code methods to manage access to the attribute’s\nvalue (valid and transform are abstract here):\nclass Person:\ndef getName(self):\nif not valid():\nraise TypeError('cannot fetch name')\nelse:\nreturn self.name.transform()\n\n941\n\n\fdef setName(self, value):\nif not valid(value):\nraise TypeError('cannot change name')\nelse:\nself.name = transform(value)\nperson = Person()\nperson.getName()\nperson.setName('value')",
    "941\n\n\fdef setName(self, value):\nif not valid(value):\nraise TypeError('cannot change name')\nelse:\nself.name = transform(value)\nperson = Person()\nperson.getName()\nperson.setName('value')\n\nHowever, this also requires changing all the places where names are used in the entire\nprogram—a possibly nontrivial task. Moreover, this approach requires the program to\nbe aware of how values are exported: as simple names or called methods. If you begin\nwith a method-based interface to data, clients are immune to changes; if you do not,\nthey can become problematic.\nThis issue can crop up more often than you might expect. The value of a cell in a\nspreadsheet-like program, for instance, might begin its life as a simple discrete value,\nbut later mutate into an arbitrary calculation. Since an object’s interface should be\nflexible enough to support such future changes without breaking existing code, switching to methods later is less than ideal.",
    "Inserting Code to Run on Attribute Access\nA better solution would allow you to run code automatically on attribute access, if\nneeded. At various points in this book, we’ve met Python tools that allow our scripts\nto dynamically compute attribute values when fetching them and validate or change\nattribute values when storing them. In this chapter, were going to expand on the tools\nalready introduced, explore other available tools, and study some larger use-case examples in this domain. Specifically, this chapter presents:\n• The __getattr__ and __setattr__ methods, for routing undefined attribute fetches\nand all attribute assignments to generic handler methods.\n• The __getattribute__ method, for routing all attribute fetches to a generic handler\nmethod in new-style classes in 2.6 and all classes in 3.0.\n• The property built-in, for routing specific attribute access to get and set handler\nfunctions, known as properties.",
    "and all attribute assignments to generic handler methods.\n• The __getattribute__ method, for routing all attribute fetches to a generic handler\nmethod in new-style classes in 2.6 and all classes in 3.0.\n• The property built-in, for routing specific attribute access to get and set handler\nfunctions, known as properties.\n• The descriptor protocol, for routing specific attribute accesses to instances of classes\nwith arbitrary get and set handler methods.\nThe first and third of these were briefly introduced in Part VI; the others are new topics\nintroduced and covered here.\nAs we’ll see, all four techniques share goals to some degree, and it’s usually possible to\ncode a given problem using any one of them. They do differ in some important ways,\nthough. For example, the last two techniques listed here apply to specific attributes,\nwhereas the first two are generic enough to be used by delegation-based classes that",
    "942 | Chapter 37: Managed Attributes\n\n\fmust route arbitrary attributes to wrapped objects. As we’ll see, all four schemes also\ndiffer in both complexity and aesthetics, in ways you must see in action to judge for\nyourself.\nBesides studying the specifics behind the four attribute interception techniques listed\nin this section, this chapter also presents an opportunity to explore larger programs\nthan we’ve seen elsewhere in this book. The CardHolder case study at the end, for example, should serve as a self-study example of larger classes in action. We’ll also be\nusing some of the techniques outlined here in the next chapter to code decorators, so\nbe sure you have at least a general understanding of these topics before you move on.",
    "Properties\nThe property protocol allows us to route a specific attribute’s get and set operations to\nfunctions or methods we provide, enabling us to insert code to be run automatically\non attribute access, intercept attribute deletions, and provide documentation for the\nattributes if desired.\nProperties are created with the property built-in and are assigned to class attributes,\njust like method functions. As such, they are inherited by subclasses and instances, like\nany other class attributes. Their access-interception functions are provided with the\nself instance argument, which grants access to state information and class attributes\navailable on the subject instance.\nA property manages a single, specific attribute; although it can’t catch all attribute\naccesses generically, it allows us to control both fetch and assignment accesses and\nenables us to change an attribute from simple data to a computation freely, without",
    "self instance argument, which grants access to state information and class attributes\navailable on the subject instance.\nA property manages a single, specific attribute; although it can’t catch all attribute\naccesses generically, it allows us to control both fetch and assignment accesses and\nenables us to change an attribute from simple data to a computation freely, without\nbreaking existing code. As we’ll see, properties are strongly related to descriptors; they\nare essentially a restricted form of them.",
    "The Basics\nA property is created by assigning the result of a built-in function to a class attribute:\nattribute = property(fget, fset, fdel, doc)\n\nNone of this built-in’s arguments are required, and all default to None if not passed;\nsuch operations are not supported, and attempting them will raise an exception. When\nusing them, we pass fget a function for intercepting attribute fetches, fset a function\nfor assignments, and fdel a function for attribute deletions; the doc argument receives\na documentation string for the attribute, if desired (otherwise the property copies the\ndocstring of fget, if provided, which defaults to None). fget returns the computed attribute value, and fset and fdel return nothing (really, None).\nThis built-in call returns a property object, which we assign to the name of the attribute\nto be managed in the class scope, where it will be inherited by every instance.\n\nProperties | 943",
    "Properties | 943\n\n\fA First Example\nTo demonstrate how this translates to working code, the following class uses a property\nto trace access to an attribute named name; the actual stored data is named _name so it\ndoes not clash with the property:\nclass Person:\n# Use (object) in 2.6\ndef __init__(self, name):\nself._name = name\ndef getName(self):\nprint('fetch...')\nreturn self._name\ndef setName(self, value):\nprint('change...')\nself._name = value\ndef delName(self):\nprint('remove...')\ndel self._name\nname = property(getName, setName, delName, \"name property docs\")\nbob = Person('Bob Smith')\nprint(bob.name)\nbob.name = 'Robert Smith'\nprint(bob.name)\ndel bob.name\nprint('-'*20)\nsue = Person('Sue Jones')\nprint(sue.name)\nprint(Person.name.__doc__)\n\n# bob has a managed attribute\n# Runs getName\n# Runs setName\n# Runs delName\n# sue inherits property too\n# Or help(Person.name)",
    "# bob has a managed attribute\n# Runs getName\n# Runs setName\n# Runs delName\n# sue inherits property too\n# Or help(Person.name)\n\nProperties are available in both 2.6 and 3.0, but they require new-style object derivation\nin 2.6 to work correctly for assignments—add object as a superclass here to run this\nin 2.6 (you can the superclass in 3.0 too, but it’s implied and not required).\nThis particular property doesn’t do much—it simply intercepts and traces an\nattribute—but it serves to demonstrate the protocol. When this code is run, two instances inherit the property, just as they would any other attribute attached to their\nclass. However, their attribute accesses are caught:\nfetch...\nBob Smith\nchange...\nfetch...\nRobert Smith\nremove...\n-------------------fetch...\nSue Jones\nname property docs\n\nLike all class attributes, properties are inherited by both instances and lower subclasses.\nIf we change our example as follows, for example:\n\n944 | Chapter 37: Managed Attributes",
    "Like all class attributes, properties are inherited by both instances and lower subclasses.\nIf we change our example as follows, for example:\n\n944 | Chapter 37: Managed Attributes\n\n\fclass Super:\n...the original Person class code...\nname = property(getName, setName, delName, 'name property docs')\nclass Person(Super):\npass\n\n# Properties are inherited\n\nbob = Person('Bob Smith')\n...rest unchanged...\n\nthe output is the same—the Person subclass inherits the name property from Super, and\nthe bob instance gets it from Person. In terms of inheritance, properties work the same\nas normal methods; because they have access to the self instance argument, they can\naccess instance state information like methods, as the next section demonstrates.",
    "bob = Person('Bob Smith')\n...rest unchanged...\n\nthe output is the same—the Person subclass inherits the name property from Super, and\nthe bob instance gets it from Person. In terms of inheritance, properties work the same\nas normal methods; because they have access to the self instance argument, they can\naccess instance state information like methods, as the next section demonstrates.\n\nComputed Attributes\nThe example in the prior section simply traces attribute accesses. Usually, though,\nproperties do much more—computing the value of an attribute dynamically when\nfetched, for example. The following example illustrates:\nclass PropSquare:\ndef __init__(self, start):\nself.value = start\ndef getX(self):\nreturn self.value ** 2\ndef setX(self, value):\nself.value = value\nX = property(getX, setX)\n\n# On attr fetch\n# On attr assign\n# No delete or docs\n\nP = PropSquare(3)\nQ = PropSquare(32)\n\n# 2 instances of class with property\n# Each has different state information",
    "# On attr fetch\n# On attr assign\n# No delete or docs\n\nP = PropSquare(3)\nQ = PropSquare(32)\n\n# 2 instances of class with property\n# Each has different state information\n\nprint(P.X)\nP.X = 4\nprint(P.X)\nprint(Q.X)\n\n# 3 ** 2\n# 4 ** 2\n# 32 ** 2\n\nThis class defines an attribute X that is accessed as though it were static data, but really\nruns code to compute its value when fetched. The effect is much like an implicit method\ncall. When the code is run, the value is stored in the instance as state information, but\neach time we fetch it via the managed attribute, its value is automatically squared:\n9\n16\n1024\n\nNotice that we’ve made two different instances—because property methods automatically receive a self argument, they have access to the state information stored in instances. In our case, this mean the fetch computes the square of the subject instance’s\ndata.\n\nProperties | 945",
    "Notice that we’ve made two different instances—because property methods automatically receive a self argument, they have access to the state information stored in instances. In our case, this mean the fetch computes the square of the subject instance’s\ndata.\n\nProperties | 945\n\n\fCoding Properties with Decorators\nAlthough we’re saving additional details until the next chapter, we introduced function\ndecorator basics earlier, in Chapter 31. Recall that the function decorator syntax:\n@decorator\ndef func(args): ...\n\nis automatically translated to this equivalent by Python, to rebind the function name\nto the result of the decorator callable:\ndef func(args): ...\nfunc = decorator(func)\n\nBecause of this mapping, it turns out that the property built-in can serve as a decorator,\nto define a function that will run automatically when an attribute is fetched:\nclass Person:\n@property\ndef name(self): ...\n\n# Rebinds: name = property(name)",
    "Because of this mapping, it turns out that the property built-in can serve as a decorator,\nto define a function that will run automatically when an attribute is fetched:\nclass Person:\n@property\ndef name(self): ...\n\n# Rebinds: name = property(name)\n\nWhen run, the decorated method is automatically passed to the first argument of the\nproperty built-in. This is really just alternative syntax for creating a property and rebinding the attribute name manually:\nclass Person:\ndef name(self): ...\nname = property(name)",
    "# Rebinds: name = property(name)\n\nWhen run, the decorated method is automatically passed to the first argument of the\nproperty built-in. This is really just alternative syntax for creating a property and rebinding the attribute name manually:\nclass Person:\ndef name(self): ...\nname = property(name)\n\nAs of Python 2.6, property objects also have getter, setter, and deleter methods that\nassign the corresponding property accessor methods and return a copy of the property\nitself. We can use these to specify components of properties by decorating normal\nmethods too, though the getter component is usually filled in automatically by the act\nof creating the property itself:\nclass Person:\ndef __init__(self, name):\nself._name = name\n@property\ndef name(self):\n\"name property docs\"\nprint('fetch...')\nreturn self._name\n@name.setter\ndef name(self, value):\nprint('change...')\nself._name = value\n@name.deleter\ndef name(self):\nprint('remove...')\ndel self._name\n\n946 | Chapter 37: Managed Attributes",
    "946 | Chapter 37: Managed Attributes\n\n# name = property(name)\n\n# name = name.setter(name)\n\n# name = name.deleter(name)\n\n\fbob = Person('Bob Smith')\nprint(bob.name)\nbob.name = 'Robert Smith'\nprint(bob.name)\ndel bob.name\nprint('-'*20)\nsue = Person('Sue Jones')\nprint(sue.name)\nprint(Person.name.__doc__)\n\n# bob has a managed attribute\n# Runs name getter (name 1)\n# Runs name setter (name 2)\n# Runs name deleter (name 3)\n# sue inherits property too\n# Or help(Person.name)\n\nIn fact, this code is equivalent to the first example in this section—decoration is just\nan alternative way to code properties in this case. When it’s run, the results are the same:\nfetch...\nBob Smith\nchange...\nfetch...\nRobert Smith\nremove...\n-------------------fetch...\nSue Jones\nname property docs",
    "In fact, this code is equivalent to the first example in this section—decoration is just\nan alternative way to code properties in this case. When it’s run, the results are the same:\nfetch...\nBob Smith\nchange...\nfetch...\nRobert Smith\nremove...\n-------------------fetch...\nSue Jones\nname property docs\n\nCompared to manual assignment of property results, in this case using decorators to\ncode properties requires just three extra lines of code (a negligible difference). As is so\noften the case with alternative tools, the choice between the two techniques is largely\nsubjective.",
    "Descriptors\nDescriptors provide an alternative way to intercept attribute access; they are strongly\nrelated to the properties discussed in the prior section. In fact, a property is a kind of\ndescriptor—technically speaking, the property built-in is just a simplified way to create\na specific type of descriptor that runs method functions on attribute accesses.\nFunctionally speaking, the descriptor protocol allows us to route a specific attribute’s\nget and set operations to methods of a separate class object that we provide: they provide a way to insert code to be run automatically on attribute access, and they allow us\nto intercept attribute deletions and provide documentation for the attributes if desired.\nDescriptors are created as independent classes, and they are assigned to class attributes\njust like method functions. Like any other class attribute, they are inherited by subclasses and instances. Their access-interception methods are provided with both a",
    "to intercept attribute deletions and provide documentation for the attributes if desired.\nDescriptors are created as independent classes, and they are assigned to class attributes\njust like method functions. Like any other class attribute, they are inherited by subclasses and instances. Their access-interception methods are provided with both a\nself for the descriptor itself, and the instance of the client class. Because of this, they\ncan retain and use state information of their own, as well as state information of the\nsubject instance. For example, a descriptor may call methods available in the client\nclass, as well as descriptor-specific methods it defines.",
    "Descriptors | 947\n\n\fLike a property, a descriptor manages a single, specific attribute; although it can’t catch\nall attribute accesses generically, it provides control over both fetch and assignment\naccesses and allows us to change an attribute freely from simple data to a computation\nwithout breaking existing code. Properties really are just a convenient way to create a\nspecific kind of descriptor, and as we shall see, they can be coded as descriptors directly.\nWhereas properties are fairly narrow in scope, descriptors provide a more general\nsolution. For instance, because they are coded as normal classes, descriptors have their\nown state, may participate in descriptor inheritance hierarchies, can use composition\nto aggregate objects, and provide a natural structure for coding internal methods and\nattribute documentation strings.",
    "The Basics\nAs mentioned previously, descriptors are coded as separate classes and provide specially named accessor methods for the attribute access operations they wish to\nintercept—get, set, and deletion methods in the descriptor class are automatically run\nwhen the attribute assigned to the descriptor class instance is accessed in the corresponding way:\nclass Descriptor:\n\"docstring goes here\"\ndef __get__(self, instance, owner): ...\ndef __set__(self, instance, value): ...\ndef __delete__(self, instance): ...\n\n# Return attr value\n# Return nothing (None)\n# Return nothing (None)",
    "# Return attr value\n# Return nothing (None)\n# Return nothing (None)\n\nClasses with any of these methods are considered descriptors, and their methods are\nspecial when one of their instances is assigned to another class’s attribute—when the\nattribute is accessed, they are automatically invoked. If any of these methods are absent,\nit generally means that the corresponding type of access is not supported. Unlike with\nproperties, however, omitting a __set__ allows the name to be redefined in an instance,\nthereby hiding the descriptor—to make an attribute read-only, you must define\n__set__ to catch assignments and raise an exception.",
    "Descriptor method arguments\nBefore we code anything realistic, let’s take a brief look at some fundamentals. All three\ndescriptor methods outlined in the prior section are passed both the descriptor class\ninstance (self) and the instance of the client class to which the descriptor instance is\nattached (instance).\nThe __get__ access method additionally receives an owner argument, specifying the class\nto which the descriptor instance is attached. Its instance argument is either the instance\nthrough which the attribute was accessed (for instance.attr), or None when the attribute is accessed through the owner class directly (for class.attr). The former of\nthese generally computes a value for instance access, and the latter usually returns\nself if descriptor object access is supported.\n\n948 | Chapter 37: Managed Attributes",
    "948 | Chapter 37: Managed Attributes\n\n\fFor example, in the following, when X.attr is fetched, Python automatically runs the\n__get__ method of the Descriptor class to which the Subject.attr class attribute is\nassigned (as with properties, in Python 2.6 we must derive from object to use descriptors here; in 3.0 this is implied, but doesn’t hurt):\n>>> class Descriptor(object):\n...\ndef __get__(self, instance, owner):\n...\nprint(self, instance, owner, sep='\\n')\n...\n>>> class Subject:\n...\nattr = Descriptor()\n# Descriptor instance is class attr\n...\n>>> X = Subject()\n>>> X.attr\n<__main__.Descriptor object at 0x0281E690>\n<__main__.Subject object at 0x028289B0>\n<class '__main__.Subject'>\n>>> Subject.attr\n<__main__.Descriptor object at 0x0281E690>\nNone\n<class '__main__.Subject'>",
    "Notice the arguments automatically passed in to the __get__ method in the first attribute fetch—when X.attr is fetched, it’s as though the following translation occurs\n(though the Subject.attr here doesn’t invoke __get__ again):\nX.attr\n\n->\n\nDescriptor.__get__(Subject.attr, X, Subject)\n\nThe descriptor knows it is being accessed directly when its instance argument is None.\n\nRead-only descriptors\nAs mentioned earlier, unlike with properties, with descriptors simply omitting the\n__set__ method isn’t enough to make an attribute read-only, because the descriptor\nname can be assigned to an instance. In the following, the attribute assignment to\nX.a stores a in the instance object X, thereby hiding the descriptor stored in class C:\n>>> class D:\n...\ndef __get__(*args): print('get')\n...\n>>> class C:\n...\na = D()\n...\n>>> X = C()\n>>> X.a\n# Runs inherited descriptor __get__\nget\n>>> C.a\nget\n>>> X.a = 99\n# Stored on X, hiding C.a\n>>> X.a\n99\n>>> list(X.__dict__.keys())\n\nDescriptors | 949",
    "Descriptors | 949\n\n\f['a']\n>>> Y = C()\n>>> Y.a\nget\n>>> C.a\nget\n\n# Y still inherits descriptor\n\nThis is the way all instance attribute assignments work in Python, and it allows classes\nto selectively override class-level defaults in their instances. To make a descriptor-based\nattribute read-only, catch the assignment in the descriptor class and raise an exception\nto prevent attribute assignment—when assigning an attribute that is a descriptor, Python effectively bypasses the normal instance-level assignment behavior and routes the\noperation to the descriptor object:\n>>> class D:\n...\ndef __get__(*args): print('get')\n...\ndef __set__(*args): raise AttributeError('cannot set')\n...\n>>> class C:\n...\na = D()\n...\n>>> X = C()\n>>> X.a\n# Routed to C.a.__get__\nget\n>>> X.a = 99\n# Routed to C.a.__set__\nAttributeError: cannot set",
    "Also be careful not to confuse the descriptor __delete__ method with\nthe general __del__ method. The former is called on attempts to delete\nthe managed attribute name on an instance of the owner class; the latter\nis the general instance destructor method, run when an instance of any\nkind of class is about to be garbage collected. __delete__ is more closely\nrelated to the __delattr__ generic attribute deletion method we’ll meet\nlater in this chapter. See Chapter 29 for more on operator overloading\nmethods.",
    "A First Example\nTo see how this all comes together in more realistic code, let’s get started with the same\nfirst example we wrote for properties. The following defines a descriptor that intercepts\naccess to an attribute named name in its clients. Its methods use their instance argument\nto access state information in the subject instance, where the name string is actually\nstored. Like properties, descriptors work properly only for new-style classes, so be sure\nto derive both classes in the following from object if you’re using 2.6:\nclass Name:\n# Use (object) in 2.6\n\"name descriptor docs\"\ndef __get__(self, instance, owner):\nprint('fetch...')\nreturn instance._name\n\n950 | Chapter 37: Managed Attributes\n\n\fdef __set__(self, instance, value):\nprint('change...')\ninstance._name = value\ndef __delete__(self, instance):\nprint('remove...')\ndel instance._name\nclass Person:\ndef __init__(self, name):\nself._name = name\nname = Name()\n\n# Use (object) in 2.6",
    "950 | Chapter 37: Managed Attributes\n\n\fdef __set__(self, instance, value):\nprint('change...')\ninstance._name = value\ndef __delete__(self, instance):\nprint('remove...')\ndel instance._name\nclass Person:\ndef __init__(self, name):\nself._name = name\nname = Name()\n\n# Use (object) in 2.6\n\nbob = Person('Bob Smith')\nprint(bob.name)\nbob.name = 'Robert Smith'\nprint(bob.name)\ndel bob.name\n\n# bob has a managed attribute\n# Runs Name.__get__\n# Runs Name.__set__\n\nprint('-'*20)\nsue = Person('Sue Jones')\nprint(sue.name)\nprint(Name.__doc__)\n\n# Assign descriptor to attr\n\n# Runs Name.__delete__\n# sue inherits descriptor too\n# Or help(Name)",
    "print('-'*20)\nsue = Person('Sue Jones')\nprint(sue.name)\nprint(Name.__doc__)\n\n# Assign descriptor to attr\n\n# Runs Name.__delete__\n# sue inherits descriptor too\n# Or help(Name)\n\nNotice in this code how we assign an instance of our descriptor class to a class attribute in the client class; because of this, it is inherited by all instances of the class, just\nlike a class’s methods. Really, we must assign the descriptor to a class attribute like\nthis—it won’t work if assigned to a self instance attribute instead. When the descriptor’s __get__ method is run, it is passed three objects to define its context:\n• self is the Name class instance.\n• instance is the Person class instance.\n• owner is the Person class.\nWhen this code is run the descriptor’s methods intercept accesses to the attribute, much\nlike the property version. In fact, the output is the same again:\nfetch...\nBob Smith\nchange...\nfetch...\nRobert Smith\nremove...\n-------------------fetch...\nSue Jones\nname descriptor docs",
    "Also like in the property example, our descriptor class instance is a class attribute and\nthus is inherited by all instances of the client class and any subclasses. If we change the\nPerson class in our example to the following, for instance, the output of our script is\nthe same:\n\nDescriptors | 951\n\n\f...\nclass Super:\ndef __init__(self, name):\nself._name = name\nname = Name()\n# Descriptors are inherited\n\nclass Person(Super):\npass\n...",
    "Descriptors | 951\n\n\f...\nclass Super:\ndef __init__(self, name):\nself._name = name\nname = Name()\n# Descriptors are inherited\n\nclass Person(Super):\npass\n...\n\nAlso note that when a descriptor class is not useful outside the client class, it’s perfectly\nreasonable to embed the descriptor’s definition inside its client syntactically. Here’s\nwhat our example looks like if we use a nested class:\nclass Person:\ndef __init__(self, name):\nself._name = name\nclass Name:\n\"name descriptor docs\"\ndef __get__(self, instance, owner):\nprint('fetch...')\nreturn instance._name\ndef __set__(self, instance, value):\nprint('change...')\ninstance._name = value\ndef __delete__(self, instance):\nprint('remove...')\ndel instance._name\nname = Name()\n\n# Using a nested class",
    "# Using a nested class\n\nWhen coded this way, Name becomes a local variable in the scope of the Person class\nstatement, such that it won’t clash with any names outside the class. This version works\nthe same as the original—we’ve simply moved the descriptor class definition into the\nclient class’s scope—but the last line of the testing code must change to fetch the docstring from its new location:\n...\nprint(Person.Name.__doc__)\n\n# Differs: not Name.__doc__ outside class",
    "# Differs: not Name.__doc__ outside class\n\nComputed Attributes\nAs was the case when using properties, our first descriptor example of the prior section\ndidn’t do much—it simply printed trace messages for attribute accesses. In practice,\ndescriptors can also be used to compute attribute values each time they are fetched.\nThe following illustrates—it’s a rehash of the same example we coded for properties,\nwhich uses a descriptor to automatically square an attribute’s value each time it is\nfetched:\nclass DescSquare:\ndef __init__(self, start):\nself.value = start\ndef __get__(self, instance, owner):\n\n952 | Chapter 37: Managed Attributes\n\n# Each desc has own state\n# On attr fetch\n\n\freturn self.value ** 2\ndef __set__(self, instance, value):\nself.value = value\nclass Client1:\nX = DescSquare(3)\nclass Client2:\nX = DescSquare(32)\n\n# On attr assign\n# No delete or docs\n\n# Assign descriptor instance to class attr\n# Another instance in another client class\n# Could also code 2 instances in same class",
    "952 | Chapter 37: Managed Attributes\n\n# Each desc has own state\n# On attr fetch\n\n\freturn self.value ** 2\ndef __set__(self, instance, value):\nself.value = value\nclass Client1:\nX = DescSquare(3)\nclass Client2:\nX = DescSquare(32)\n\n# On attr assign\n# No delete or docs\n\n# Assign descriptor instance to class attr\n# Another instance in another client class\n# Could also code 2 instances in same class\n\nc1 = Client1()\nc2 = Client2()\nprint(c1.X)\nc1.X = 4\nprint(c1.X)\nprint(c2.X)\n\n# 3 ** 2\n# 4 ** 2\n# 32 ** 2\n\nWhen run, the output of this example is the same as that of the original property-based\nversion, but here a descriptor class object is intercepting the attribute accesses:\n9\n16\n1024",
    "Using State Information in Descriptors\nIf you study the two descriptor examples we’ve written so far, you might notice that\nthey get their information from different places—the first (the name attribute example)\nuses data stored on the client instance, and the second (the attribute squaring example)\nuses data attached to the descriptor object itself. In fact, descriptors can use both instance state and descriptor state, or any combination thereof:\n• Descriptor state is used to manage data internal to the workings of the descriptor.\n• Instance state records information related to and possibly created by the client\nclass.\nDescriptor methods may use either, but descriptor state often makes it unnecessary to\nuse special naming conventions to avoid name collisions for descriptor data stored on\nan instance. For example, the following descriptor attaches information to its own\ninstance, so it doesn’t clash with that on the client class’s instance:\nclass DescState:\ndef __init__(self, value):",
    "class.\nDescriptor methods may use either, but descriptor state often makes it unnecessary to\nuse special naming conventions to avoid name collisions for descriptor data stored on\nan instance. For example, the following descriptor attaches information to its own\ninstance, so it doesn’t clash with that on the client class’s instance:\nclass DescState:\ndef __init__(self, value):\nself.value = value\ndef __get__(self, instance, owner):\nprint('DescState get')\nreturn self.value * 10\ndef __set__(self, instance, value):\nprint('DescState set')\nself.value = value",
    "# Use descriptor state\n# On attr fetch\n# On attr assign\n\n# Client class\n\nDescriptors | 953\n\n\fclass CalcAttrs:\nX = DescState(2)\nY = 3\ndef __init__(self):\nself.Z = 4\nobj = CalcAttrs()\nprint(obj.X, obj.Y, obj.Z)\nobj.X = 5\nobj.Y = 6\nobj.Z = 7\nprint(obj.X, obj.Y, obj.Z)\n\n# Descriptor class attr\n# Class attr\n# Instance attr\n# X is computed, others are not\n# X assignment is intercepted\n\nThis code’s value information lives only in the descriptor, so there won’t be a collision\nif the same name is used in the client’s instance. Notice that only the descriptor attribute\nis managed here—get and set accesses to X are intercepted, but accesses to Y and Z are\nnot (Y is attached to the client class and Z to the instance). When this code is run, X is\ncomputed when fetched:\nDescState get\n20 3 4\nDescState set\nDescState get\n50 6 7",
    "It’s also feasible for a descriptor to store or use an attribute attached to the client class’s\ninstance, instead of itself. The descriptor in the following example assumes the instance\nhas an attribute _Y attached by the client class, and uses it to compute the value of the\nattribute it represents:\nclass InstState:\ndef __get__(self, instance, owner):\nprint('InstState get')\nreturn instance._Y * 100\ndef __set__(self, instance, value):\nprint('InstState set')\ninstance._Y = value\n\n# Using instance state\n# Assume set by client class\n\n# Client class\nclass CalcAttrs:\nX = DescState(2)\nY = InstState()\ndef __init__(self):\nself._Y = 3\nself.Z = 4\nobj = CalcAttrs()\nprint(obj.X, obj.Y, obj.Z)\nobj.X = 5\nobj.Y = 6\nobj.Z = 7\nprint(obj.X, obj.Y, obj.Z)\n\n954 | Chapter 37: Managed Attributes\n\n# Descriptor class attr\n# Descriptor class attr\n# Instance attr\n# Instance attr\n# X and Y are computed, Z is not\n# X and Y assignments intercepted",
    "# Client class\nclass CalcAttrs:\nX = DescState(2)\nY = InstState()\ndef __init__(self):\nself._Y = 3\nself.Z = 4\nobj = CalcAttrs()\nprint(obj.X, obj.Y, obj.Z)\nobj.X = 5\nobj.Y = 6\nobj.Z = 7\nprint(obj.X, obj.Y, obj.Z)\n\n954 | Chapter 37: Managed Attributes\n\n# Descriptor class attr\n# Descriptor class attr\n# Instance attr\n# Instance attr\n# X and Y are computed, Z is not\n# X and Y assignments intercepted\n\n\fThis time, X and Y are both assigned to descriptors and computed when fetched (X is\nassigned the descriptor of the prior example). The new descriptor here has no information itself, but it uses an attribute assumed to exist in the instance—that attribute\nis named _Y, to avoid collisions with the name of the descriptor itself. When this version\nis run the results are similar, but a second attribute is managed, using state that lives\nin the instance instead of the descriptor:\nDescState get\nInstState get\n20 300 4\nDescState set\nInstState set\nDescState get\nInstState get\n50 600 7",
    "Both descriptor and instance state have roles. In fact, this is a general advantage that\ndescriptors have over properties—because they have state of their own, they can easily\nretain data internally, without adding it to the namespace of the client instance object.\n\nHow Properties and Descriptors Relate\nAs mentioned earlier, properties and descriptors are strongly related—the property\nbuilt-in is just a convenient way to create a descriptor. Now that you know how both\nwork, you should also be able to see that it’s possible to simulate the property built-in\nwith a descriptor class like the following:\nclass Property:\ndef __init__(self, fget=None, fset=None, fdel=None, doc=None):\nself.fget = fget\nself.fset = fset\nself.fdel = fdel\n# Save unbound methods\nself.__doc__ = doc\n# or other callables\ndef __get__(self, instance, instancetype=None):\nif instance is None:\nreturn self\nif self.fget is None:\nraise AttributeError(\"can't get attribute\")\nreturn self.fget(instance)",
    "# Pass instance to self\n# in property accessors\n\ndef __set__(self, instance, value):\nif self.fset is None:\nraise AttributeError(\"can't set attribute\")\nself.fset(instance, value)\ndef __delete__(self, instance):\nif self.fdel is None:\nraise AttributeError(\"can't delete attribute\")\nself.fdel(instance)\nclass Person:\n\nDescriptors | 955\n\n\fdef getName(self): ...\ndef setName(self, value): ...\nname = Property(getName, setName)\n\n# Use like property()",
    "This Property class catches attribute accesses with the descriptor protocol and routes\nrequests to functions or methods passed in and saved in descriptor state when the class\nis created. Attribute fetches, for example, are routed from the Person class, to the\nProperty class’s __get__ method, and back to the Person class’s getName. With descriptors, this “just works.”\nNote that this descriptor class equivalent only handles basic property usage, though;\nto use @ decorator syntax to also specify set and delete operations, our Property class\nwould also have to be extended with setter and deleter methods, which would save\nthe decorated accessor function and return the property object (self should suffice).\nSince the property built-in already does this, we’ll omit a formal coding of this extension\nhere.\nAlso note that descriptors are used to implement Python’s __slots__; instance attribute\ndictionaries are avoided by intercepting slot names with descriptors stored at the class",
    "the decorated accessor function and return the property object (self should suffice).\nSince the property built-in already does this, we’ll omit a formal coding of this extension\nhere.\nAlso note that descriptors are used to implement Python’s __slots__; instance attribute\ndictionaries are avoided by intercepting slot names with descriptors stored at the class\nlevel. See Chapter 31 for more on slots.\nIn Chapter 38, we’ll also make use of descriptors to implement function\ndecorators that apply to both functions and methods. As you’ll see there,\nbecause descriptors receive both descriptor and subject class instances\nthey work well in this role, though nested functions are usually a simpler\nsolution.",
    "__getattr__ and __getattribute__\nSo far, we’ve studied properties and descriptors—tools for managing specific attributes.\nThe __getattr__ and __getattribute__ operator overloading methods provide still\nother ways to intercept attribute fetches for class instances. Like properties and descriptors, they allow us to insert code to be run automatically when attributes are accessed; as we’ll see, though, these two methods can be used in more general ways.\nAttribute fetch interception comes in two flavors, coded with two different methods:\n• __getattr__ is run for undefined attributes—that is, attributes not stored on an\ninstance or inherited from one of its classes.\n• __getattribute__ is run for every attribute, so when using it you must be cautious\nto avoid recursive loops by passing attribute accesses to a superclass.\nWe met the former of these in Chapter 29; it’s available for all Python versions. The",
    "• __getattr__ is run for undefined attributes—that is, attributes not stored on an\ninstance or inherited from one of its classes.\n• __getattribute__ is run for every attribute, so when using it you must be cautious\nto avoid recursive loops by passing attribute accesses to a superclass.\nWe met the former of these in Chapter 29; it’s available for all Python versions. The\nlatter of these is available for new-style classes in 2.6, and for all (implicitly new-style)\nclasses in 3.0. These two methods are representatives of a set of attribute interception\nmethods that also includes __setattr__ and __delattr__. Because these methods have\nsimilar roles, we will generally treat them as a single topic here.\n956 | Chapter 37: Managed Attributes",
    "Unlike properties and descriptors, these methods are part of Python’s operator overloading protocol—specially named methods of a class, inherited by subclasses, and run\nautomatically when instances are used in the implied built-in operation. Like all methods of a class, they each receive a first self argument when called, giving access to any\nrequired instance state information or other methods of the class.\nThe __getattr__ and __getattribute__ methods are also more generic than properties\nand descriptors—they can be used to intercept access to any (or even all) instance\nattribute fetches, not just the specific name to which they are assigned. Because of this,\nthese two methods are well suited to general delegation-based coding patterns—they\ncan be used to implement wrapper objects that manage all attribute accesses for an\nembedded object. By contrast, we must define one property or descriptor for every\nattribute we wish to intercept.",
    "attribute fetches, not just the specific name to which they are assigned. Because of this,\nthese two methods are well suited to general delegation-based coding patterns—they\ncan be used to implement wrapper objects that manage all attribute accesses for an\nembedded object. By contrast, we must define one property or descriptor for every\nattribute we wish to intercept.\nFinally, these two methods are more narrowly focused than the alternatives we considered earlier: they intercept attribute fetches only, not assignments. To also catch attribute changes by assignment, we must code a __setattr__ method—an operator\noverloading method run for every attribute fetch, which must take care to avoid recursive loops by routing attribute assignments through the instance namespace dictionary.\nAlthough much less common, we can also code a __delattr__ overloading method",
    "overloading method run for every attribute fetch, which must take care to avoid recursive loops by routing attribute assignments through the instance namespace dictionary.\nAlthough much less common, we can also code a __delattr__ overloading method\n(which must avoid looping in the same way) to intercept attribute deletions. By contrast, properties and descriptors catch get, set, and delete operations by design.\nMost of these operator overloading methods were introduced earlier in the book; here,\nwe’ll expand on their usage and study their roles in larger contexts.",
    "The Basics\n__getattr__ and __setattr__ were introduced in Chapters 29 and 31, and\n__getattribute__ was mentioned briefly in Chapter 31. In short, if a class defines or\n\ninherits the following methods, they will be run automatically when an instance is used\nin the context described by the comments to the right:\ndef __getattr__(self, name):\n# On undefined attribute fetch [obj.name]\ndef __getattribute__(self, name):\n# On all attribute fetch [obj.name]\ndef __setattr__(self, name, value): # On all attribute assignment [obj.name=value]\ndef __delattr__(self, name):\n# On all attribute deletion [del obj.name]",
    "In all of these, self is the subject instance object as usual, name is the string name of\nthe attribute being accessed, and value is the object being assigned to the attribute. The\ntwo get methods normally return an attribute’s value, and the other two return nothing\n(None). For example, to catch every attribute fetch, we can use either of the first two\nmethods above, and to catch every attribute assignment we can use the third:\nclass Catcher:\ndef __getattr__(self, name):\nprint('Get:', name)\ndef __setattr__(self, name, value):\n\n__getattr__ and __getattribute__ | 957\n\n\fprint('Set:', name, value)\nX = Catcher()\nX.job\nX.pay\nX.pay = 99\n\n# Prints \"Get: job\"\n# Prints \"Get: pay\"\n# Prints \"Set: pay 99\"",
    "__getattr__ and __getattribute__ | 957\n\n\fprint('Set:', name, value)\nX = Catcher()\nX.job\nX.pay\nX.pay = 99\n\n# Prints \"Get: job\"\n# Prints \"Get: pay\"\n# Prints \"Set: pay 99\"\n\nSuch a coding structure can be used to implement the delegation design pattern we met\nearlier, in Chapter 30. Because all attribute are routed to our interception methods\ngenerically, we can validate and pass them along to embedded, managed objects. The\nfollowing class (borrowed from Chapter 30), for example, traces every attribute fetch\nmade to another object passed to the wrapper class:\nclass Wrapper:\ndef __init__(self, object):\nself.wrapped = object\ndef __getattr__(self, attrname):\nprint('Trace:', attrname)\nreturn getattr(self.wrapped, attrname)\n\n# Save object\n# Trace fetch\n# Delegate fetch\n\nThere is no such analog for properties and descriptors, short of coding accessors for\nevery possible attribute in every possibly wrapped object.",
    "# Save object\n# Trace fetch\n# Delegate fetch\n\nThere is no such analog for properties and descriptors, short of coding accessors for\nevery possible attribute in every possibly wrapped object.\n\nAvoiding loops in attribute interception methods\nThese methods are generally straightforward to use; their only complex part is the\npotential for looping (a.k.a. recursing). Because __getattr__ is called for undefined\nattributes only, it can freely fetch other attributes within its own code. However, because __getattribute__ and __setattr__ are run for all attributes, their code needs to\nbe careful when accessing other attributes to avoid calling themselves again and triggering a recursive loop.\nFor example, another attribute fetch run inside a __getattribute__ method’s code will\ntrigger __getattribute__ again, and the code will loop until memory is exhausted:\ndef __getattribute__(self, name):\nx = self.other\n\n# LOOPS!",
    "# LOOPS!\n\nTo work around this, route the fetch through a higher superclass instead to skip this\nlevel’s version—the object class is always a superclass, and it serves well in this role:\ndef __getattribute__(self, name):\nx = object.__getattribute__(self, 'other')\n\n# Force higher to avoid me\n\nFor __setattr__, the situation is similar; assigning any attribute inside this method\ntriggers __setattr__ again and creates a similar loop:\ndef __setattr__(self, name, value):\nself.other = value\n\n# LOOPS!\n\nTo work around this problem, assign the attribute as a key in the instance’s __dict__\nnamespace dictionary instead. This avoids direct attribute assignment:\n\n958 | Chapter 37: Managed Attributes\n\n\fdef __setattr__(self, name, value):\nself.__dict__['other'] = value\n\n# Use atttr dict to avoid me",
    "# LOOPS!\n\nTo work around this problem, assign the attribute as a key in the instance’s __dict__\nnamespace dictionary instead. This avoids direct attribute assignment:\n\n958 | Chapter 37: Managed Attributes\n\n\fdef __setattr__(self, name, value):\nself.__dict__['other'] = value\n\n# Use atttr dict to avoid me\n\nAlthough it’s a less common approach, __setattr__ can also pass its own attribute\nassignments to a higher superclass to avoid looping, just like __getattribute__:\ndef __setattr__(self, name, value):\nobject.__setattr__(self, 'other', value)\n\n# Force higher to avoid me\n\nBy contrast, though, we cannot use the __dict__ trick to avoid loops in\n__getattribute__:\ndef __getattribute__(self, name):\nx = self.__dict__['other']\n\n# LOOPS!",
    "# Force higher to avoid me\n\nBy contrast, though, we cannot use the __dict__ trick to avoid loops in\n__getattribute__:\ndef __getattribute__(self, name):\nx = self.__dict__['other']\n\n# LOOPS!\n\nFetching the __dict__ attribute itself triggers __getattribute__ again, causing a recursive loop. Strange but true!\nThe __delattr__ method is rarely used in practice, but when it is, it is called for every\nattribute deletion (just as __setattr__ is called for every attribute assignment). Therefore, you must take care to avoid loops when deleting attributes, by using the same\ntechniques: namespace dictionaries or superclass method calls.",
    "A First Example\nAll this is not nearly as complicated as the prior section may have implied. To see how\nto put these ideas to work, here is the same first example we used for properties and\ndescriptors in action again, this time implemented with attribute operator overloading\nmethods. Because these methods are so generic, we test attribute names here to know\nwhen a managed attribute is being accessed; others are allowed to pass normally:\nclass Person:\ndef __init__(self, name):\nself._name = name\n\n# On [Person()]\n# Triggers __setattr__!\n\ndef __getattr__(self, attr):\nif attr == 'name':\nprint('fetch...')\nreturn self._name\nelse:\nraise AttributeError(attr)\n\n# On [obj.undefined]\n# Intercept name: not stored\n\ndef __setattr__(self, attr, value):\nif attr == 'name':\nprint('change...')\nattr = '_name'\nself.__dict__[attr] = value\n\n# On [obj.any = value]\n\ndef __delattr__(self, attr):\nif attr == 'name':\nprint('remove...')\nattr = '_name'\ndel self.__dict__[attr]\n\n# On [del obj.any]",
    "# On [obj.undefined]\n# Intercept name: not stored\n\ndef __setattr__(self, attr, value):\nif attr == 'name':\nprint('change...')\nattr = '_name'\nself.__dict__[attr] = value\n\n# On [obj.any = value]\n\ndef __delattr__(self, attr):\nif attr == 'name':\nprint('remove...')\nattr = '_name'\ndel self.__dict__[attr]\n\n# On [del obj.any]\n\n# Does not loop: real attr\n# Others are errors\n\n# Set internal name\n# Avoid looping here\n\n# Avoid looping here too\n# but much less common\n\n__getattr__ and __getattribute__ | 959\n\n\fbob = Person('Bob Smith')\nprint(bob.name)\nbob.name = 'Robert Smith'\nprint(bob.name)\ndel bob.name\nprint('-'*20)\nsue = Person('Sue Jones')\nprint(sue.name)\n#print(Person.name.__doc__)\n\n# bob has a managed attribute\n# Runs __getattr__\n# Runs __setattr__\n# Runs __delattr__\n# sue inherits property too\n# No equivalent here",
    "__getattr__ and __getattribute__ | 959\n\n\fbob = Person('Bob Smith')\nprint(bob.name)\nbob.name = 'Robert Smith'\nprint(bob.name)\ndel bob.name\nprint('-'*20)\nsue = Person('Sue Jones')\nprint(sue.name)\n#print(Person.name.__doc__)\n\n# bob has a managed attribute\n# Runs __getattr__\n# Runs __setattr__\n# Runs __delattr__\n# sue inherits property too\n# No equivalent here\n\nNotice that the attribute assignment in the __init__ constructor triggers __setattr__\ntoo—this method catches every attribute assignment, even those within the class itself.\nWhen this code is run, the same output is produced, but this time it’s the result of\nPython’s normal operator overloading mechanism and our attribute interception\nmethods:\nfetch...\nBob Smith\nchange...\nfetch...\nRobert Smith\nremove...\n-------------------fetch...\nSue Jones",
    "Also note that, unlike with properties and descriptors, there’s no direct notion of specifying documentation for our attribute here; managed attributes exist within the code\nof our interception methods, not as distinct objects.\nTo achieve exactly the same results with __getattribute__, replace __getattr__ in the\nexample with the following; because it catches all attribute fetches, this version must\nbe careful to avoid looping by passing new fetches to a superclass, and it can’t generally\nassume unknown names are errors:\n# Replace __getattr__ with this\ndef __getattribute__(self, attr):\nif attr == 'name':\nprint('fetch...')\nattr = '_name'\nreturn object.__getattribute__(self, attr)\n\n# On [obj.any]\n# Intercept all names\n# Map to internal name\n# Avoid looping here",
    "# On [obj.any]\n# Intercept all names\n# Map to internal name\n# Avoid looping here\n\nThis example is equivalent to that coded for properties and descriptors, but it’s a bit\nartificial, and it doesn’t really highlight these tools in practice. Because they are generic,\n__getattr__ and __getattribute__ are probably more commonly used in delegationbase code (as sketched earlier), where attribute access is validated and routed to an\nembedded object. Where just a single attribute must be managed, properties and descriptors might do as well or better.\n\n960 | Chapter 37: Managed Attributes\n\n\fComputed Attributes\nAs before, our prior example doesn’t really do anything but trace attribute fetches; it’s\nnot much more work to compute an attribute’s value when fetched. As for properties\nand descriptors, the following creates a virtual attribute X that runs a calculation when\nfetched:\nclass AttrSquare:\ndef __init__(self, start):\nself.value = start\n\n# Triggers __setattr__!",
    "Computed Attributes\nAs before, our prior example doesn’t really do anything but trace attribute fetches; it’s\nnot much more work to compute an attribute’s value when fetched. As for properties\nand descriptors, the following creates a virtual attribute X that runs a calculation when\nfetched:\nclass AttrSquare:\ndef __init__(self, start):\nself.value = start\n\n# Triggers __setattr__!\n\ndef __getattr__(self, attr):\nif attr == 'X':\nreturn self.value ** 2\nelse:\nraise AttributeError(attr)\n\n# On undefined attr fetch\n\ndef __setattr__(self, attr, value):\nif attr == 'X':\nattr = 'value'\nself.__dict__[attr] = value\n\n# On all attr assignments\n\n# value is not undefined\n\nA = AttrSquare(3)\nB = AttrSquare(32)\n\n# 2 instances of class with overloading\n# Each has different state information\n\nprint(A.X)\nA.X = 4\nprint(A.X)\nprint(B.X)\n\n# 3 ** 2\n# 4 ** 2\n# 32 ** 2",
    "# On undefined attr fetch\n\ndef __setattr__(self, attr, value):\nif attr == 'X':\nattr = 'value'\nself.__dict__[attr] = value\n\n# On all attr assignments\n\n# value is not undefined\n\nA = AttrSquare(3)\nB = AttrSquare(32)\n\n# 2 instances of class with overloading\n# Each has different state information\n\nprint(A.X)\nA.X = 4\nprint(A.X)\nprint(B.X)\n\n# 3 ** 2\n# 4 ** 2\n# 32 ** 2\n\nRunning this code results in the same output that we got earlier when using properties\nand descriptors, but this script’s mechanics are based on generic attribute interception\nmethods:\n9\n16\n1024\n\nAs before, we can achieve the same effect with __getattribute__ instead of\n__getattr__; the following replaces the fetch method with a __getattribute__ and\nchanges the __setattr__ assignment method to avoid looping by using direct superclass\nmethod calls instead of __dict__ keys:\nclass AttrSquare:\ndef __init__(self, start):\nself.value = start\n\n# Triggers __setattr__!",
    "As before, we can achieve the same effect with __getattribute__ instead of\n__getattr__; the following replaces the fetch method with a __getattribute__ and\nchanges the __setattr__ assignment method to avoid looping by using direct superclass\nmethod calls instead of __dict__ keys:\nclass AttrSquare:\ndef __init__(self, start):\nself.value = start\n\n# Triggers __setattr__!\n\ndef __getattribute__(self, attr):\n# On all attr fetches\nif attr == 'X':\nreturn self.value ** 2\n# Triggers __getattribute__ again!\nelse:\nreturn object.__getattribute__(self, attr)\ndef __setattr__(self, attr, value):\n\n# On all attr assignments\n\n__getattr__ and __getattribute__ | 961\n\n\fif attr == 'X':\nattr = 'value'\nobject.__setattr__(self, attr, value)",
    "def __getattribute__(self, attr):\n# On all attr fetches\nif attr == 'X':\nreturn self.value ** 2\n# Triggers __getattribute__ again!\nelse:\nreturn object.__getattribute__(self, attr)\ndef __setattr__(self, attr, value):\n\n# On all attr assignments\n\n__getattr__ and __getattribute__ | 961\n\n\fif attr == 'X':\nattr = 'value'\nobject.__setattr__(self, attr, value)\n\nWhen this version is run, the results are the same again. Notice the implicit routing\ngoing on in inside this class’s methods:\n• self.value=start inside the constructor triggers __setattr__\n• self.value inside __getattribute__ triggers __getattribute__ again\nIn fact, __getattribute__ is run twice each time we fetch attribute X. This doesn’t happen in the __getattr__ version, because the value attribute is not undefined. If you care\nabout speed and want to avoid this, change __getattribute__ to use the superclass to\nfetch value as well:\ndef __getattribute__(self, attr):\nif attr == 'X':\nreturn object.__getattribute__(self, 'value') ** 2",
    "Of course, this still incurs a call to the superclass method, but not an additional recursive call before we get there. Add print calls to these methods to trace how and when\nthey run.\n\n__getattr__ and __getattribute__ Compared\nTo summarize the coding differences between __getattr__ and __getattribute__, the\nfollowing example uses both to implement three attributes—attr1 is a class attribute,\nattr2 is an instance attribute, and attr3 is a virtual managed attribute computed when\nfetched:\nclass GetAttr:\nattr1 = 1\ndef __init__(self):\nself.attr2 = 2\ndef __getattr__(self, attr):\nprint('get: ' + attr)\nreturn 3\n\n# On undefined attrs only\n# Not attr1: inherited from class\n# Not attr2: stored on instance\n\nX = GetAttr()\nprint(X.attr1)\nprint(X.attr2)\nprint(X.attr3)\nprint('-'*40)\nclass GetAttribute(object):\nattr1 = 1\ndef __init__(self):\nself.attr2 = 2\ndef __getattribute__(self, attr):\nprint('get: ' + attr)\nif attr == 'attr3':\nreturn 3\n\n962 | Chapter 37: Managed Attributes",
    "# On undefined attrs only\n# Not attr1: inherited from class\n# Not attr2: stored on instance\n\nX = GetAttr()\nprint(X.attr1)\nprint(X.attr2)\nprint(X.attr3)\nprint('-'*40)\nclass GetAttribute(object):\nattr1 = 1\ndef __init__(self):\nself.attr2 = 2\ndef __getattribute__(self, attr):\nprint('get: ' + attr)\nif attr == 'attr3':\nreturn 3\n\n962 | Chapter 37: Managed Attributes\n\n# (object) needed in 2.6 only\n\n# On all attr fetches\n# Use superclass to avoid looping here\n\n\felse:\nreturn object.__getattribute__(self, attr)\nX = GetAttribute()\nprint(X.attr1)\nprint(X.attr2)\nprint(X.attr3)\n\nWhen run, the __getattr__ version intercepts only attr3 accesses, because it is undefined. The __getattribute__ version, on the other hand, intercepts all attribute fetches\nand must route those it does not manage to the superclass fetcher to avoid loops:\n1\n2\nget: attr3\n3\n---------------------------------------get: attr1\n1\nget: attr2\n2\nget: attr3\n3",
    "When run, the __getattr__ version intercepts only attr3 accesses, because it is undefined. The __getattribute__ version, on the other hand, intercepts all attribute fetches\nand must route those it does not manage to the superclass fetcher to avoid loops:\n1\n2\nget: attr3\n3\n---------------------------------------get: attr1\n1\nget: attr2\n2\nget: attr3\n3\n\nAlthough __getattribute__ can catch more attribute fetches than __getattr__, in practice they are often just variations on a theme—if attributes are not physically stored,\nthe two have the same effect.",
    "Although __getattribute__ can catch more attribute fetches than __getattr__, in practice they are often just variations on a theme—if attributes are not physically stored,\nthe two have the same effect.\n\nManagement Techniques Compared\nTo summarize the coding differences in all four attribute management schemes we’ve\nseen in this chapter, let’s quickly step through a more comprehensive\ncomputed-attribute example using each technique. The following version uses properties to intercept and calculate attributes named square and cube. Notice how their\nbase values are stored in names that begin with an underscore, so they don’t clash with\nthe names of the properties themselves:\n# 2 dynamically computed attributes with properties\nclass Powers:\ndef __init__(self, square, cube):\nself._square = square\nself._cube\n= cube\n\n# _square is the base value\n# square is the property name",
    "# _square is the base value\n# square is the property name\n\ndef getSquare(self):\nreturn self._square ** 2\ndef setSquare(self, value):\nself._square = value\nsquare = property(getSquare, setSquare)\ndef getCube(self):\nreturn self._cube ** 3\ncube = property(getCube)\n\n__getattr__ and __getattribute__ | 963\n\n\fX = Powers(3, 4)\nprint(X.square)\nprint(X.cube)\nX.square = 5\nprint(X.square)\n\n# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25",
    "X = Powers(3, 4)\nprint(X.square)\nprint(X.cube)\nX.square = 5\nprint(X.square)\n\n# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25\n\nTo do the same with descriptors, we define the attributes with complete classes. Note\nthat these descriptors store base values as instance state, so they must use leading underscores again so as not to clash with the names of descriptors (as we’ll see in the final\nexample of this chapter, we could avoid this renaming requirement by storing base\nvalues as descriptor state instead):\n# Same, but with descriptors\nclass DescSquare:\ndef __get__(self, instance, owner):\nreturn instance._square ** 2\ndef __set__(self, instance, value):\ninstance._square = value\nclass DescCube:\ndef __get__(self, instance, owner):\nreturn instance._cube ** 3\nclass Powers:\nsquare = DescSquare()\ncube\n= DescCube()\ndef __init__(self, square, cube):\nself._square = square\nself._cube\n= cube\nX = Powers(3, 4)\nprint(X.square)\nprint(X.cube)\nX.square = 5\nprint(X.square)\n\n# Use (object) in 2.6",
    "# Use (object) in 2.6\n\n# \"self.square = square\" works too,\n# because it triggers desc __set__!\n\n# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25\n\nTo achieve the same result with __getattr__ fetch interception, we again store base\nvalues with underscore-prefixed names so that accesses to managed names are undefined and thus invoke our method; we also need to code a __setattrr__ to intercept\nassignments, and take care to avoid its potential for looping:\n# Same, but with generic __getattr__ undefined attribute interception\nclass Powers:\ndef __init__(self, square, cube):\nself._square = square\nself._cube\n= cube\ndef __getattr__(self, name):\nif name == 'square':\nreturn self._square ** 2\nelif name == 'cube':\nreturn self._cube ** 3\n\n964 | Chapter 37: Managed Attributes",
    "964 | Chapter 37: Managed Attributes\n\n\felse:\nraise TypeError('unknown attr:' + name)\ndef __setattr__(self, name, value):\nif name == 'square':\nself.__dict__['_square'] = value\nelse:\nself.__dict__[name] = value\nX = Powers(3, 4)\nprint(X.square)\nprint(X.cube)\nX.square = 5\nprint(X.square)\n\n# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25",
    "# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25\n\nThe final option, coding this with __getattribute__, is similar to the prior version.\nBecause we catch every attribute now, though, we must route base value fetches to a\nsuperclass to avoid looping:\n# Same, but with generic __getattribute__ all attribute interception\nclass Powers:\ndef __init__(self, square, cube):\nself._square = square\nself._cube\n= cube\ndef __getattribute__(self, name):\nif name == 'square':\nreturn object.__getattribute__(self, '_square') ** 2\nelif name == 'cube':\nreturn object.__getattribute__(self, '_cube') ** 3\nelse:\nreturn object.__getattribute__(self, name)\ndef __setattr__(self, name, value):\nif name == 'square':\nself.__dict__['_square'] = value\nelse:\nself.__dict__[name] = value\nX = Powers(3, 4)\nprint(X.square)\nprint(X.cube)\nX.square = 5\nprint(X.square)\n\n# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25\n\nAs you can see, each technique takes a different form in code, but all four produce the\nsame result when run:\n9\n64\n25",
    "# 3 ** 2 = 9\n# 4 ** 3 = 64\n# 5 ** 2 = 25\n\nAs you can see, each technique takes a different form in code, but all four produce the\nsame result when run:\n9\n64\n25\n\nFor more on how these alternatives compare, and other coding options, stay tuned for\na more realistic application of them in the attribute validation example in the section\n“Example: Attribute Validations” on page 973. First, though, we need to study a\npitfall associated with two of these tools.\n__getattr__ and __getattribute__ | 965",
    "Intercepting Built-in Operation Attributes\nWhen I introduced __getattr__ and __getattribute__, I stated that they intercept undefined and all attribute fetches, respectively, which makes them ideal for delegationbased coding patterns. While this is true for normally named attributes, their behavior\nneeds some additional clarification: for method-name attributes implicitly fetched by\nbuilt-in operations, these methods may not be run at all. This means that operator\noverloading method calls cannot be delegated to wrapped objects unless wrapper\nclasses somehow redefine these methods themselves.\nFor example, attribute fetches for the __str__, __add__, and __getitem__ methods run\nimplicitly by printing, + expressions, and indexing, respectively, are not routed to the\ngeneric attribute interception methods in 3.0. Specifically:\n• In Python 3.0, neither __getattr__ nor __getattribute__ is run for such attributes.",
    "classes somehow redefine these methods themselves.\nFor example, attribute fetches for the __str__, __add__, and __getitem__ methods run\nimplicitly by printing, + expressions, and indexing, respectively, are not routed to the\ngeneric attribute interception methods in 3.0. Specifically:\n• In Python 3.0, neither __getattr__ nor __getattribute__ is run for such attributes.\n• In Python 2.6, __getattr__ is run for such attributes if they are undefined in the\nclass.\n• In Python 2.6, __getattribute__ is available for new-style classes only and works\nas it does in 3.0.\nIn other words, in Python 3.0 classes (and 2.6 new-style classes), there is no direct way\nto generically intercept built-in operations like printing and addition. In Python 2.X,\nthe methods such operations invoke are looked up at runtime in instances, like all other\nattributes; in Python 3.0 such methods are looked up in classes instead.\nThis change makes delegation-based coding patterns more complex in 3.0, since they",
    "to generically intercept built-in operations like printing and addition. In Python 2.X,\nthe methods such operations invoke are looked up at runtime in instances, like all other\nattributes; in Python 3.0 such methods are looked up in classes instead.\nThis change makes delegation-based coding patterns more complex in 3.0, since they\ncannot generically intercept operator overloading method calls and route them to an\nembedded object. This is not a showstopper—wrapper classes can work around this\nconstraint by redefining all relevant operator overloading methods in the wrapper itself,\nin order to delegate calls. These extra methods can be added either manually, with\ntools, or by definition in and inheritance from common superclasses. This does, however, make wrappers more work than they used to be when operator overloading\nmethods are a part of a wrapped object’s interface.\nKeep in mind that this issue applies only to __getattr__ and __getattribute__. Because",
    "in order to delegate calls. These extra methods can be added either manually, with\ntools, or by definition in and inheritance from common superclasses. This does, however, make wrappers more work than they used to be when operator overloading\nmethods are a part of a wrapped object’s interface.\nKeep in mind that this issue applies only to __getattr__ and __getattribute__. Because\nproperties and descriptors are defined for specific attributes only, they don’t really\napply to delegation-based classes at all—a single property or descriptor cannot be used\nto intercept arbitrary attributes. Moreover, a class that defines both operator overloading methods and attribute interception will work correctly, regardless of the type of\nattribute interception defined. Our concern here is only with classes that do not have\noperator overloading methods defined, but try to intercept them generically.\nConsider the following example, the file getattr.py, which tests various attribute",
    "attribute interception defined. Our concern here is only with classes that do not have\noperator overloading methods defined, but try to intercept them generically.\nConsider the following example, the file getattr.py, which tests various attribute\ntypes and built-in operations on instances of classes containing __getattr__ and\n__getattribute__ methods:",
    "966 | Chapter 37: Managed Attributes",
    "class GetAttr:\neggs = 88\n# eggs stored on class, spam on instance\ndef __init__(self):\nself.spam = 77\ndef __len__(self):\n# len here, else __getattr__ called with __len__\nprint('__len__: 42')\nreturn 42\ndef __getattr__(self, attr):\n# Provide __str__ if asked, else dummy func\nprint('getattr: ' + attr)\nif attr == '__str__':\nreturn lambda *args: '[Getattr str]'\nelse:\nreturn lambda *args: None\nclass GetAttribute(object):\n# object required in 2.6, implied in 3.0\neggs = 88\n# In 2.6 all are isinstance(object) auto\ndef __init__(self):\n# But must derive to get new-style tools,\nself.spam = 77\n# incl __getattribute__, some __X__ defaults\ndef __len__(self):\nprint('__len__: 42')\nreturn 42\ndef __getattribute__(self, attr):\nprint('getattribute: ' + attr)\nif attr == '__str__':\nreturn lambda *args: '[GetAttribute str]'\nelse:\nreturn lambda *args: None\nfor Class in GetAttr, GetAttribute:\nprint('\\n' + Class.__name__.ljust(50, '='))\nX = Class()\nX.eggs\nX.spam\nX.other\nlen(X)",
    "# Class attr\n# Instance attr\n# Missing attr\n# __len__ defined explicitly\n\n# New-styles must support [], +, call directly: redefine\nX[0]\n# __getitem__?\nexcept:\nprint('fail []')\ntry:\n\ntry:\n\nX + 99\nexcept:\nprint('fail +')\n\n# __add__?\n\ntry:\n\nX()\n# __call__? (implicit via built-in)\nexcept:\nprint('fail ()')\nX.__call__()\n# __call__? (explicit, not inherited)\nprint(X.__str__())\nprint(X)\n\n# __str__? (explicit, inherited from type)\n# __str__? (implicit via built-in)\n\n__getattr__ and __getattribute__ | 967",
    "# __str__? (explicit, inherited from type)\n# __str__? (implicit via built-in)\n\n__getattr__ and __getattribute__ | 967\n\n\fWhen run under Python 2.6, __getattr__ does receive a variety of implicit attribute\nfetches for built-in operations, because Python looks up such attributes in instances\nnormally. Conversely, __getattribute__ is not run for any of the operator overloading\nnames, because such names are looked up in classes only:\nC:\\misc> c:\\python26\\python getattr.py\nGetAttr===========================================\ngetattr: other\n__len__: 42\ngetattr: __getitem__\ngetattr: __coerce__\ngetattr: __add__\ngetattr: __call__\ngetattr: __call__\ngetattr: __str__\n[Getattr str]\ngetattr: __str__\n[Getattr str]\nGetAttribute======================================\ngetattribute: eggs\ngetattribute: spam\ngetattribute: other\n__len__: 42\nfail []\nfail +\nfail ()\ngetattribute: __call__\ngetattribute: __str__\n[GetAttribute str]\n<__main__.GetAttribute object at 0x025EA1D0>",
    "Note how __getattr__ intercepts both implicit and explicit fetches of __call__ and\n__str__ in 2.6 here. By contrast, __getattribute__ fails to catch implicit fetches of either\nattribute name for built-in operations.\nReally, the __getattribute__ case is the same in 2.6 as it is in 3.0, because in 2.6 classes\nmust be made new-style by deriving from object to use this method. This code’s\nobject derivation is optional in 3.0 because all classes are new-style.\nWhen run under Python 3.0, though, results for __getattr__ differ—none of the implicitly run operator overloading methods trigger either attribute interception method\nwhen their attributes are fetched by built-in operations. Python 3.0 skips the normal\ninstance lookup mechanism when resolving such names:\nC:\\misc> c:\\python30\\python getattr.py\nGetAttr===========================================\ngetattr: other\n__len__: 42\nfail []\nfail +\nfail ()\n\n968 | Chapter 37: Managed Attributes",
    "968 | Chapter 37: Managed Attributes\n\n\fgetattr: __call__\n<__main__.GetAttr object at 0x025D17F0>\n<__main__.GetAttr object at 0x025D17F0>\nGetAttribute======================================\ngetattribute: eggs\ngetattribute: spam\ngetattribute: other\n__len__: 42\nfail []\nfail +\nfail ()\ngetattribute: __call__\ngetattribute: __str__\n[GetAttribute str]\n<__main__.GetAttribute object at 0x025D1870>",
    "We can trace these outputs back to prints in the script to see how this works:\n• __str__ access fails to be caught twice by __getattr__ in 3.0: once for the built-in\nprint, and once for explicit fetches because a default is inherited from the class\n(really, from the built-in object, which is a superclass to every class).\n• __str__ fails to be caught only once by the __getattribute__ catchall, during the\nbuilt-in print operation; explicit fetches bypass the inherited version.\n• __call__ fails to be caught in both schemes in 3.0 for built-in call expressions, but\nit is intercepted by both when fetched explicitly; unlike with __str__, there is no\ninherited __call__ default to defeat __getattr__.\n• __len__ is caught by both classes, simply because it is an explicitly defined method\nin the classes themselves—its name it is not routed to either __getattr__ or __get\nattribute__ in 3.0 if we delete the class’s __len__ methods.",
    "it is intercepted by both when fetched explicitly; unlike with __str__, there is no\ninherited __call__ default to defeat __getattr__.\n• __len__ is caught by both classes, simply because it is an explicitly defined method\nin the classes themselves—its name it is not routed to either __getattr__ or __get\nattribute__ in 3.0 if we delete the class’s __len__ methods.\n• All other built-in operations fail to be intercepted by both schemes in 3.0.\nAgain, the net effect is that operator overloading methods implicitly run by built-in\noperations are never routed through either attribute interception method in 3.0: Python\n3.0 searches for such attributes in classes and skips instance lookup entirely.\nThis makes delegation-based wrapper classes more difficult to code in 3.0—if wrapped\nclasses may contain operator overloading methods, those methods must be redefined\nredundantly in the wrapper class in order to delegate to the wrapped object. In general",
    "3.0 searches for such attributes in classes and skips instance lookup entirely.\nThis makes delegation-based wrapper classes more difficult to code in 3.0—if wrapped\nclasses may contain operator overloading methods, those methods must be redefined\nredundantly in the wrapper class in order to delegate to the wrapped object. In general\ndelegation tools, this can add many extra methods.\nOf course, the addition of such methods can be partly automated by tools that augment\nclasses with new methods (the class decorators and metaclasses of the next two chapters\nmight help here). Moreover, a superclass might be able to define all these extra methods\nonce, for inheritance in delegation-based classes. Still, delegation coding patterns require extra work in 3.0.\nFor a more realistic illustration of this phenomenon as well as its workaround, see the\nPrivate decorator example in the following chapter. There, we’ll see that it’s also",
    "__getattr__ and __getattribute__ | 969",
    "possible to insert a __getattribute__ in the client class to retain its original type, although this method still won’t be called for operator overloading methods; printing\nstill runs a __str__ defined in such a class directly, for example, instead of routing the\nrequest through __getattribute__.\nAs another example, the next section resurrects our class tutorial example. Now that\nyou understand how attribute interception works, I’ll be able to explain one of its\nstranger bits.\nFor an example of this 3.0 change at work in Python itself, see the discussion of the 3.0 os.popen object in Chapter 14. Because it is implemented with a wrapper that uses __getattr__ to delegate attribute\nfetches to an embedded object, it does not intercept the next(X) builtin iterator function in Python 3.0, which is defined to run __next__. It\ndoes, however, intercept and delegate explicit X.__next__() calls, because these are not routed through the built-in and are not inherited",
    "fetches to an embedded object, it does not intercept the next(X) builtin iterator function in Python 3.0, which is defined to run __next__. It\ndoes, however, intercept and delegate explicit X.__next__() calls, because these are not routed through the built-in and are not inherited\nfrom a superclass like __str__ is.\nThis is equivalent to __call__ in our example—implicit calls for builtins do not trigger __getattr__, but explicit calls to names not inherited\nfrom the class type do. In other words, this change impacts not only our\ndelegators, but also those in the Python standard library! Given the\nscope of this change, it’s possible that this behavior may evolve in the\nfuture, so be sure to verify this issue in later releases.",
    "Delegation-Based Managers Revisited\nThe object-oriented tutorial of Chapter 27 presented a Manager class that used object\nembedding and method delegation to customize its superclass, rather than inheritance.\nHere is the code again for reference, with some irrelevant testing removed:\nclass Person:\ndef __init__(self, name, job=None, pay=0):\nself.name = name\nself.job = job\nself.pay = pay\ndef lastName(self):\nreturn self.name.split()[-1]\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\ndef __str__(self):\nreturn '[Person: %s, %s]' % (self.name, self.pay)\nclass Manager:\ndef __init__(self, name, pay):\nself.person = Person(name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):\nself.person.giveRaise(percent + bonus)\ndef __getattr__(self, attr):\nreturn getattr(self.person, attr)\n\n970 | Chapter 37: Managed Attributes\n\n# Embed a Person object\n# Intercept and delegate\n# Delegate all other attrs\n\n\fdef __str__(self):\nreturn str(self.person)\n\n# Must overload again (in 3.0)",
    "970 | Chapter 37: Managed Attributes\n\n# Embed a Person object\n# Intercept and delegate\n# Delegate all other attrs\n\n\fdef __str__(self):\nreturn str(self.person)\n\n# Must overload again (in 3.0)\n\nif __name__ == '__main__':\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(sue.lastName())\nsue.giveRaise(.10)\nprint(sue)\ntom = Manager('Tom Jones', 50000)\n# Manager.__init__\nprint(tom.lastName())\n# Manager.__getattr__ -> Person.lastName\ntom.giveRaise(.10)\n# Manager.giveRaise -> Person.giveRaise\nprint(tom)\n# Manager.__str__ -> Person.__str__",
    "# Must overload again (in 3.0)\n\nif __name__ == '__main__':\nsue = Person('Sue Jones', job='dev', pay=100000)\nprint(sue.lastName())\nsue.giveRaise(.10)\nprint(sue)\ntom = Manager('Tom Jones', 50000)\n# Manager.__init__\nprint(tom.lastName())\n# Manager.__getattr__ -> Person.lastName\ntom.giveRaise(.10)\n# Manager.giveRaise -> Person.giveRaise\nprint(tom)\n# Manager.__str__ -> Person.__str__\n\nComments at the end of this file show which methods are invoked for a line’s operation.\nIn particular, notice how lastName calls are undefined in Manager, and thus are routed\ninto the generic __getattr__ and from there on to the embedded Person object. Here\nis the script’s output—Sue receives a 10% raise from Person, but Tom gets 20% because\ngiveRaise is customized in Manager:\nC:\\misc> c:\\python30\\python getattr.py\nJones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]",
    "By contrast, though, notice what occurs when we print a Manager at the end of the script:\nthe wrapper class’s __str__ is invoked, and it delegates to the embedded Person object’s\n__str__. With that in mind, watch what happens if we delete the Manager.__str__\nmethod in this code:\n# Delete the Manager __str__ method\nclass Manager:\ndef __init__(self, name, pay):\nself.person = Person(name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):\nself.person.giveRaise(percent + bonus)\ndef __getattr__(self, attr):\nreturn getattr(self.person, attr)\n\n# Embed a Person object\n# Intercept and delegate\n# Delegate all other attrs",
    "# Embed a Person object\n# Intercept and delegate\n# Delegate all other attrs\n\nNow printing does not route its attribute fetch through the generic __getattr__ interceptor under Python 3.0 for Manager objects. Instead, a default __str__ display method\ninherited from the class’s implicit object superclass is looked up and run (sue still prints\ncorrectly, because Person has an explicit __str__):\nC:\\misc> c:\\python30\\python person.py\nJones\n[Person: Sue Jones, 110000]\nJones\n<__main__.Manager object at 0x02A5AE30>\n\nCuriously, running without a __str__ like this does trigger __getattr__ in Python 2.6,\nbecause operator overloading attributes are routed through this method, and classes\ndo not inherit a default for __str__:\n__getattr__ and __getattribute__ | 971\n\n\fC:\\misc> c:\\python26\\python person.py\nJones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]",
    "Curiously, running without a __str__ like this does trigger __getattr__ in Python 2.6,\nbecause operator overloading attributes are routed through this method, and classes\ndo not inherit a default for __str__:\n__getattr__ and __getattribute__ | 971\n\n\fC:\\misc> c:\\python26\\python person.py\nJones\n[Person: Sue Jones, 110000]\nJones\n[Person: Tom Jones, 60000]\n\nSwitching to __getattribute__ won’t help 3.0 here either—like __getattr__, it is not\nrun for operator overloading attributes implied by built-in operations in either Python\n2.6 or 3.0:\n# Replace __getattr_ with __getattribute__\nclass Manager:\ndef __init__(self, name, pay):\nself.person = Person(name, 'mgr', pay)\ndef giveRaise(self, percent, bonus=.10):\nself.person.giveRaise(percent + bonus)\ndef __getattribute__(self, attr):\nprint('**', attr)\nif attr in ['person', 'giveRaise']:\nreturn object.__getattribute__(self, attr)\nelse:\nreturn getattr(self.person, attr)\n\n# Use (object) in 2.6\n# Embed a Person object\n# Intercept and delegate",
    "# Use (object) in 2.6\n# Embed a Person object\n# Intercept and delegate\n\n# Fetch my attrs\n# Delegate all others\n\nRegardless of which attribute interception method is used in 3.0, we still must include\na redefined __str__ in Manager (as shown above) in order to intercept printing operations and route them to the embedded Person object:\nC:\\misc> c:\\python30\\python person.py\nJones\n[Person: Sue Jones, 110000]\n** lastName\n** person\nJones\n** giveRaise\n** person\n<__main__.Manager object at 0x028E0590>",
    "Notice that __getattribute__ gets called twice here for methods—once for the method\nname, and again for the self.person embedded object fetch. We could avoid that with\na different coding, but we would still have to redefine __str__ to catch printing, albeit\ndifferently here (self.person would cause this __getattribute__ to fail):\n# Code __getattribute__ differently to minimize extra calls\nclass Manager:\ndef __init__(self, name, pay):\nself.person = Person(name, 'mgr', pay)\ndef __getattribute__(self, attr):\nprint('**', attr)\nperson = object.__getattribute__(self, 'person')\nif attr == 'giveRaise':\nreturn lambda percent: person.giveRaise(percent+.10)\nelse:\nreturn getattr(person, attr)\n\n972 | Chapter 37: Managed Attributes\n\n\fdef __str__(self):\nperson = object.__getattribute__(self, 'person')\nreturn str(person)",
    "972 | Chapter 37: Managed Attributes\n\n\fdef __str__(self):\nperson = object.__getattribute__(self, 'person')\nreturn str(person)\n\nWhen this alternative runs, our object prints properly, but only because we’ve added\nan explicit __str__ in the wrapper—this attribute is still not routed to our generic attribute interception method:\nJones\n[Person: Sue Jones, 110000]\n** lastName\nJones\n** giveRaise\n[Person: Tom Jones, 60000]",
    "That short story here is that delegation-based classes like Manager must redefine some\noperator overloading methods (like __str__) to route them to embedded objects in\nPython 3.0, but not in Python 2.6 unless new-style classes are used. Our only direct\noptions seem to be using __getattr__ and Python 2.6, or redefining operator overloading methods in wrapper classes redundantly in 3.0.\nAgain, this isn’t an impossible task; many wrappers can predict the set of operator\noverloading methods required, and tools and superclasses can automate part of this\ntask. Moreover, not all classes use operator overloading methods (indeed, most application classes usually should not). It is, however, something to keep in mind for delegation coding models used in Python 3.0; when operator overloading methods are part\nof an object’s interface, wrappers must accommodate them portably by redefining them\nlocally.",
    "Example: Attribute Validations\nTo close out this chapter, let’s turn to a more realistic example, coded in all four of our\nattribute management schemes. The example we will use defines a CardHolder object\nwith four attributes, three of which are managed. The managed attributes validate or\ntransform values when fetched or stored. All four versions produce the same results for\nthe same test code, but they implement their attributes in very different ways. The\nexamples are included largely for self-study; although I won’t go through their code in\ndetail, they all use concepts we’ve already explored in this chapter.",
    "Using Properties to Validate\nOur first coding uses properties to manage three attributes. As usual, we could use\nsimple methods instead of managed attributes, but properties help if we have been\nusing attributes in existing code already. Properties run code automatically on attribute\naccess, but are focused on a specific set of attributes; they cannot be used to intercept\nall attributes generically.\n\nExample: Attribute Validations | 973",
    "To understand this code, it’s crucial to notice that the attribute assignments inside the\n__init__ constructor method trigger property setter methods too. When this method\nassigns to self.name, for example, it automatically invokes the setName method, which\ntransforms the value and assigns it to an instance attribute called __name so it won’t\nclash with the property’s name.\nThis renaming (sometimes called name mangling) is necessary because properties use\ncommon instance state and have none of their own. Data is stored in an attribute called\n__name, and the attribute called name is always a property, not data.\nIn the end, this class manages attributes called name, age, and acct; allows the attribute\naddr to be accessed directly; and provides a read-only attribute called remain that is\nentirely virtual and computed on demand. For comparison purposes, this propertybased coding weighs in at 39 lines of code:\nclass CardHolder:\nacctlen = 8\nretireage = 59.5\n\n# Class data",
    "# Class data\n\ndef __init__(self, acct, name, age, addr):\nself.acct = acct\n# Instance data\nself.name = name\n# These trigger prop setters too\nself.age = age\n# __X mangled to have class name\nself.addr = addr\n# addr is not managed\n# remain has no data\ndef getName(self):\nreturn self.__name\ndef setName(self, value):\nvalue = value.lower().replace(' ', '_')\nself.__name = value\nname = property(getName, setName)\ndef getAge(self):\nreturn self.__age\ndef setAge(self, value):\nif value < 0 or value > 150:\nraise ValueError('invalid age')\nelse:\nself.__age = value\nage = property(getAge, setAge)\ndef getAcct(self):\nreturn self.__acct[:-3] + '***'\ndef setAcct(self, value):\nvalue = value.replace('-', '')\nif len(value) != self.acctlen:\nraise TypeError('invald acct number')\nelse:\nself.__acct = value\nacct = property(getAcct, setAcct)\ndef remainGet(self):\n\n974 | Chapter 37: Managed Attributes\n\n# Could be a method, not attr\n\n\freturn self.retireage - self.age\nremain = property(remainGet)",
    "974 | Chapter 37: Managed Attributes\n\n# Could be a method, not attr\n\n\freturn self.retireage - self.age\nremain = property(remainGet)\n\n# Unless already using as attr\n\nSelf-test code\nThe following code tests our class; add this to the bottom of your file, or place the class\nin a module and import it first. We’ll use this same testing code for all four versions of\nthis example. When it runs, we make two instances of our managed-attribute class and\nfetch and change its various attributes. Operations expected to fail are wrapped in\ntry statements:\nbob = CardHolder('1234-5678', 'Bob Smith', 40, '123 main st')\nprint(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')\nbob.name = 'Bob Q. Smith'\nbob.age = 50\nbob.acct = '23-45-67-89'\nprint(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')\nsue = CardHolder('5678-12-34', 'Sue Jones', 35, '124 main st')\nprint(sue.acct, sue.name, sue.age, sue.remain, sue.addr, sep=' / ')\ntry:\nsue.age = 200\nexcept:\nprint('Bad age for Sue')\ntry:",
    "sue.remain = 5\nexcept:\nprint(\"Can't set sue.remain\")\ntry:\n\nsue.acct = '1234567'\nexcept:\nprint('Bad acct for Sue')\n\nHere is the output of our self-test code; again, this is the same for all versions of this\nexample. Trace through this code to see how the class’s methods are invoked; accounts\nare displayed with some digits hidden, names are converted to a standard format, and\ntime remaining until retirement is computed when fetched using a class attribute cutoff:\n12345*** / bob_smith / 40 / 19.5 / 123 main st\n23456*** / bob_q._smith / 50 / 9.5 / 123 main st\n56781*** / sue_jones / 35 / 24.5 / 124 main st\nBad age for Sue\nCan't set sue.remain\nBad acct for Sue\n\nUsing Descriptors to Validate\nNow, let’s recode our example using descriptors instead of properties. As we’ve seen,\ndescriptors are very similar to properties in terms of functionality and roles; in fact,\nproperties are basically a restricted form of descriptor. Like properties, descriptors are\n\nExample: Attribute Validations | 975",
    "designed to handle specific attributes, not generic attribute access. Unlike properties,\ndescriptors have their own state, and they’re a more general scheme.\nTo understand this code, it’s again important to notice that the attribute assignments\ninside the __init__ constructor method trigger descriptor __set__ methods. When the\nconstructor method assigns to self.name, for example, it automatically invokes the\nName.__set__() method, which transforms the value and assigns it to a descriptor attribute called name.\nUnlike in the prior property-based variant, though, in this case the actual name value is\nattached to the descriptor object, not the client class instance. Although we could store\nthis value in either instance or descriptor state, the latter avoids the need to mangle\nnames with underscores to avoid collisions. In the CardHolder client class, the attribute\ncalled name is always a descriptor object, not data.",
    "attached to the descriptor object, not the client class instance. Although we could store\nthis value in either instance or descriptor state, the latter avoids the need to mangle\nnames with underscores to avoid collisions. In the CardHolder client class, the attribute\ncalled name is always a descriptor object, not data.\nIn the end, this class implements the same attributes as the prior version: it manages\nattributes called name, age, and acct; allows the attribute addr to be accessed directly;\nand provides a read-only attribute called remain that is entirely virtual and computed\non demand. Notice how we must catch assignments to the remain name in its descriptor\nand raise an exception; as we learned earlier, if we did not do this, assigning to this\nattribute of an instance would silently create an instance attribute that hides the class\nattribute descriptor. For comparison purposes, this descriptor-based coding takes 45\nlines of code:\nclass CardHolder:\nacctlen = 8\nretireage = 59.5",
    "and raise an exception; as we learned earlier, if we did not do this, assigning to this\nattribute of an instance would silently create an instance attribute that hides the class\nattribute descriptor. For comparison purposes, this descriptor-based coding takes 45\nlines of code:\nclass CardHolder:\nacctlen = 8\nretireage = 59.5\ndef __init__(self, acct, name, age, addr):\nself.acct = acct\nself.name = name\nself.age = age\nself.addr = addr",
    "# Class data\n\n# Instance data\n# These trigger __set__ calls too\n# __X not needed: in descriptor\n# addr is not managed\n# remain has no data\n\nclass Name:\ndef __get__(self, instance, owner):\n# Class names: CardHolder locals\nreturn self.name\ndef __set__(self, instance, value):\nvalue = value.lower().replace(' ', '_')\nself.name = value\nname = Name()\nclass Age:\ndef __get__(self, instance, owner):\nreturn self.age\ndef __set__(self, instance, value):\nif value < 0 or value > 150:\nraise ValueError('invalid age')\nelse:\nself.age = value\nage = Age()\n\n976 | Chapter 37: Managed Attributes\n\n# Use descriptor data",
    "976 | Chapter 37: Managed Attributes\n\n# Use descriptor data\n\n\fclass Acct:\ndef __get__(self, instance, owner):\nreturn self.acct[:-3] + '***'\ndef __set__(self, instance, value):\nvalue = value.replace('-', '')\nif len(value) != instance.acctlen:\nraise TypeError('invald acct number')\nelse:\nself.acct = value\nacct = Acct()\nclass Remain:\ndef __get__(self, instance, owner):\nreturn instance.retireage - instance.age\ndef __set__(self, instance, value):\nraise TypeError('cannot set remain')\nremain = Remain()\n\n# Use instance class data\n\n# Triggers Age.__get__\n# Else set allowed here",
    "Using __getattr__ to Validate\nAs we’ve seen, the __getattr__ method intercepts all undefined attributes, so it can be\nmore generic than using properties or descriptors. For our example, we simply test the\nattribute name to know when a managed attribute is being fetched; others are stored\nphysically on the instance and so never reach __getattr__. Although this approach is\nmore general than using properties or descriptors, extra work may be required to imitate\nthe specific-attribute focus of other tools. We need to check names at runtime, and we\nmust code a __setattr__ in order to intercept and validate attribute assignments.\nAs for the property and descriptor versions of this example, it’s critical to notice that\nthe attribute assignments inside the __init__ constructor method trigger the class’s\n__setattr__ method too. When this method assigns to self.name, for example, it automatically invokes the __setattr__ method, which transforms the value and assigns",
    "As for the property and descriptor versions of this example, it’s critical to notice that\nthe attribute assignments inside the __init__ constructor method trigger the class’s\n__setattr__ method too. When this method assigns to self.name, for example, it automatically invokes the __setattr__ method, which transforms the value and assigns\nit to an instance attribute called name. By storing name on the instance, it ensures that\nfuture accesses will not trigger __getattr__. In contrast, acct is stored as _acct, so that\nlater accesses to acct do invoke __getattr__.\nIn the end, this class, like the prior two, manages attributes called name, age, and\nacct; allows the attribute addr to be accessed directly; and provides a read-only attribute\ncalled remain that is entirely virtual and is computed on demand.\nFor comparison purposes, this alternative comes in at 32 lines of code—7 fewer than\nthe property-based version, and 13 fewer than the version using descriptors. Clarity",
    "acct; allows the attribute addr to be accessed directly; and provides a read-only attribute\ncalled remain that is entirely virtual and is computed on demand.\nFor comparison purposes, this alternative comes in at 32 lines of code—7 fewer than\nthe property-based version, and 13 fewer than the version using descriptors. Clarity\nmatters more than code size, of course, but extra code can sometimes imply extra\ndevelopment and maintenance work. Probably more important here are roles: generic\ntools like __getattr__ may be better suited to generic delegation, while properties and\ndescriptors are more directly designed to manage specific attributes.\nAlso note that the code here incurs extra calls when setting unmanaged attributes (e.g.,\naddr), although no extra calls are incurred for fetching unmanaged attributes, since they",
    "Example: Attribute Validations | 977\n\n\fare defined. Though this will likely result in negligible overhead for most programs,\nproperties and descriptors incur an extra call only when managed attributes are\naccessed.\nHere’s the __getattr__ version of our code:\nclass CardHolder:\nacctlen = 8\nretireage = 59.5\ndef __init__(self, acct, name, age, addr):\nself.acct = acct\nself.name = name\nself.age = age\nself.addr = addr\ndef __getattr__(self, name):\nif name == 'acct':\nreturn self._acct[:-3] + '***'\nelif name == 'remain':\nreturn self.retireage - self.age\nelse:\nraise AttributeError(name)\n\n# Class data\n\n# Instance data\n# These trigger __setattr__ too\n# _acct not mangled: name tested\n# addr is not managed\n# remain has no data\n# On undefined attr fetches\n# name, age, addr are defined\n# Doesn't trigger __getattr__",
    "# Class data\n\n# Instance data\n# These trigger __setattr__ too\n# _acct not mangled: name tested\n# addr is not managed\n# remain has no data\n# On undefined attr fetches\n# name, age, addr are defined\n# Doesn't trigger __getattr__\n\ndef __setattr__(self, name, value):\nif name == 'name':\n# On all attr assignments\nvalue = value.lower().replace(' ', '_') # addr stored directly\nelif name == 'age':\n# acct mangled to _acct\nif value < 0 or value > 150:\nraise ValueError('invalid age')\nelif name == 'acct':\nname = '_acct'\nvalue = value.replace('-', '')\nif len(value) != self.acctlen:\nraise TypeError('invald acct number')\nelif name == 'remain':\nraise TypeError('cannot set remain')\nself.__dict__[name] = value\n# Avoid looping",
    "Using __getattribute__ to Validate\nOur final variant uses the __getattribute__ catchall to intercept attribute fetches and\nmanage them as needed. Every attribute fetch is caught here, so we test the attribute\nnames to detect managed attributes and route all others to the superclass for normal\nfetch processing. This version uses the same __setattr__ to catch assignments as the\nprior version.\nThe code works very much like the __getattr__ version, so I won’t repeat the full\ndescription here. Note, though, that because every attribute fetch is routed to\n__getattribute__, we don’t need to mangle names to intercept them here (acct is stored\nas acct). On the other hand, this code must take care to route nonmanaged attribute\nfetches to a superclass to avoid looping.\n\n978 | Chapter 37: Managed Attributes",
    "978 | Chapter 37: Managed Attributes\n\n\fAlso notice that this version incurs extra calls for both setting and fetching unmanaged\nattributes (e.g., addr); if speed is paramount, this alternative may be the slowest of the\nbunch. For comparison purposes, this version amounts to 32 lines of code, just like the\nprior version:\nclass CardHolder:\nacctlen = 8\nretireage = 59.5\ndef __init__(self, acct, name, age, addr):\nself.acct = acct\nself.name = name\nself.age = age\nself.addr = addr\n\n# Class data\n\n# Instance data\n# These trigger __setattr__ too\n# acct not mangled: name tested\n# addr is not managed\n# remain has no data",
    "# Class data\n\n# Instance data\n# These trigger __setattr__ too\n# acct not mangled: name tested\n# addr is not managed\n# remain has no data\n\ndef __getattribute__(self, name):\nsuperget = object.__getattribute__\n# Don't loop: one level up\nif name == 'acct':\n# On all attr fetches\nreturn superget(self, 'acct')[:-3] + '***'\nelif name == 'remain':\nreturn superget(self, 'retireage') - superget(self, 'age')\nelse:\nreturn superget(self, name)\n# name, age, addr: stored\ndef __setattr__(self, name, value):\nif name == 'name':\n# On all attr assignments\nvalue = value.lower().replace(' ', '_')\n# addr stored directly\nelif name == 'age':\nif value < 0 or value > 150:\nraise ValueError('invalid age')\nelif name == 'acct':\nvalue = value.replace('-', '')\nif len(value) != self.acctlen:\nraise TypeError('invald acct number')\nelif name == 'remain':\nraise TypeError('cannot set remain')\nself.__dict__[name] = value\n# Avoid loops, orig names",
    "Be sure to study and run this section’s code on your own for more pointers on managed\nattribute coding techniques.\n\nChapter Summary\nThis chapter covered the various techniques for managing access to attributes in Python, including the __getattr__ and __getattribute__ operator overloading methods,\nclass properties, and attribute descriptors. Along the way, it compared and contrasted\nthese tools and presented a handful of use cases to demonstrate their behavior.\nChapter 38 continues our tool-building survey with a look at decorators—code run\nautomatically at function and class creation time, rather than on attribute access. Before\nwe continue, though, let’s work through a set of questions to review what we’ve covered\nhere.\nChapter Summary | 979",
    "Test Your Knowledge: Quiz\n1. How do __getattr__ and __getattribute__ differ?\n2. How do properties and descriptors differ?\n3. How are properties and decorators related?\n4. What are the main functional differences between __getattr__ and __getattri\nbute__ and properties and descriptors?\n5. Isn’t all this feature comparison just a kind of argument?",
    "Test Your Knowledge: Answers\n1. The __getattr__ method is run for fetches of undefined attributes only—i.e., those\nnot present on an instance and not inherited from any of its classes. By contrast,\nthe __getattribute__ method is called for every attribute fetch, whether the attribute is defined or not. Because of this, code inside a __getattr__ can freely fetch\nother attributes if they are defined, whereas __getattribute__ must use special code\nfor all such attribute fetches to avoid looping (it must route fetches to a superclass\nto skip itself).\n2. Properties serve a specific role, while descriptors are more general. Properties define\nget, set, and delete functions for a specific attribute; descriptors provide a class\nwith methods for these actions, too, but they provide extra flexibility to support\nmore arbitrary actions. In fact, properties are really a simple way to create a specific\nkind of descriptor—one that runs functions on attribute accesses. Coding differs",
    "get, set, and delete functions for a specific attribute; descriptors provide a class\nwith methods for these actions, too, but they provide extra flexibility to support\nmore arbitrary actions. In fact, properties are really a simple way to create a specific\nkind of descriptor—one that runs functions on attribute accesses. Coding differs\ntoo: a property is created with a built-in function, and a descriptor is coded with\na class; as such, descriptors can leverage all the usual OOP features of classes, such\nas inheritance. Moreover, in addition to the instance’s state information, descriptors have local state of their own, so they can avoid name collisions in the instance.\n3. Properties can be coded with decorator syntax. Because the property built-in accepts a single function argument, it can be used directly as a function decorator to\ndefine a fetch access property. Due to the name rebinding behavior of decorators,",
    "3. Properties can be coded with decorator syntax. Because the property built-in accepts a single function argument, it can be used directly as a function decorator to\ndefine a fetch access property. Due to the name rebinding behavior of decorators,\nthe name of the decorated function is assigned to a property whose get accessor is\nset to the original function decorated (name = property(name)). Property setter\nand deleter attributes allow us to further add set and delete accessors with decoration syntax—they set the accessor to the decorated function and return the augmented property.",
    "980 | Chapter 37: Managed Attributes",
    "4. The __getattr__ and __getattribute__ methods are more generic: they can be used\nto catch arbitrarily many attributes. In contrast, each property or descriptor provides access interception for only one specific attribute—we can’t catch every attribute fetch with a single property or descriptor. On the other hand, properties\nand descriptors handle both attribute fetch and assignment by design:\n__getattr__ and __getattribute__ handle fetches only; to intercept assignments\nas well, __setattr__ must also be coded. The implementation is also different:\n__getattr__ and __getattribute__ are operator overloading methods, whereas\nproperties and descriptors are objects manually assigned to class attributes.\n5. No it isn’t. To quote from Python namesake Monty Python’s Flying Circus:\nAn argument is a connected series of statements intended to establish a\nproposition.\nNo it isn't.\nYes it is! It's not just contradiction.\nLook, if I argue with you, I must take up a contrary position.",
    "properties and descriptors are objects manually assigned to class attributes.\n5. No it isn’t. To quote from Python namesake Monty Python’s Flying Circus:\nAn argument is a connected series of statements intended to establish a\nproposition.\nNo it isn't.\nYes it is! It's not just contradiction.\nLook, if I argue with you, I must take up a contrary position.\nYes, but that's not just saying \"No it isn't.\"\nYes it is!\nNo it isn't!\nYes it is!\nNo it isn't. Argument is an intellectual process. Contradiction is just\nthe automatic gainsaying of any statement the other person makes.\n(short pause)\nNo it isn't.\nIt is.\nNot at all.\nNow look...",
    "Test Your Knowledge: Quiz | 981\n\n\f\fCHAPTER 38\n\nDecorators",
    "In the advanced class topics chapter of this book (Chapter 31), we met static and class\nmethods and took a quick look at the @ decorator syntax Python offers for declaring\nthem. We also met function decorators briefly in the prior chapter (Chapter 37), while\nexploring the property built-in’s ability to serve as a decorator, and in Chapter 28 while\nstudying the notion of abstract superclasses.\nThis chapter picks up where the previous decorator coverage left off. Here, we’ll dig\ndeeper into the inner workings of decorators and study more advanced ways to code\nnew decorators ourselves. As we’ll see, many of the concepts we studied in earlier\nchapters, such as state retention, show up regularly in decorators.\nThis is a somewhat advanced topic, and decorator construction tends to be of more\ninterest to tool builders than to application programmers. Still, given that decorators",
    "new decorators ourselves. As we’ll see, many of the concepts we studied in earlier\nchapters, such as state retention, show up regularly in decorators.\nThis is a somewhat advanced topic, and decorator construction tends to be of more\ninterest to tool builders than to application programmers. Still, given that decorators\nare becoming increasingly common in popular Python frameworks, a basic understanding can help demystify their role, even if you’re just a decorator user.\nBesides covering decorator construction details, this chapter serves as a more realistic\ncase study of Python in action. Because its examples are somewhat larger than most of\nthe others we’ve seen in this book, they better illustrate how code comes together into\nmore complete systems and tools. As an extra perk, much of the code we’ll write here\nmay be used as general-purpose tools in your day-to-day programs.",
    "What’s a Decorator?\nDecoration is a way to specify management code for functions and classes. Decorators\nthemselves take the form of callable objects (e.g., functions) that process other callable\nobjects. As we saw earlier in this book, Python decorators come in two related flavors:\n• Function decorators do name rebinding at function definition time, providing a\nlayer of logic that can manage functions and methods, or later calls to them.\n• Class decorators do name rebinding at class definition time, providing a layer of\nlogic that can manage classes, or the instances created by calling them later.\n\n983\n\n\fIn short, decorators provide a way to insert automatically run code at the end of function\nand class definition statements—at the end of a def for function decorators, and at the\nend of a class for class decorators. Such code can play a variety of roles, as described\nin the following sections.",
    "Managing Calls and Instances\nFor example, in typical use, this automatically run code may be used to augment calls\nto functions and classes. It arranges this by installing wrapper objects to be invoked later:\n• Function decorators install wrapper objects to intercept later function calls and\nprocess them as needed.\n• Class decorators install wrapper objects to intercept later instance creation calls\nand process them as required.\nDecorators achieve these effects by automatically rebinding function and class names\nto other callables, at the end of def and class statements. When later invoked, these\ncallables can perform tasks such as tracing and timing function calls, managing access\nto class instance attributes, and so on.",
    "Managing Functions and Classes\nAlthough most examples in this chapter deal with using wrappers to intercept later\ncalls to functions and classes, this is not the only way decorators can be used:\n• Function decorators can also be used to manage function objects, instead of later\ncalls to them—to register a function to an API, for instance. Our primary focus\nhere, though, will be on their more commonly used call wrapper application.\n• Class decorators can also be used to manage class objects directly, instead of instance creation calls—to augment a class with new methods, for example. Because\nthis role intersects strongly with that of metaclasses (indeed, both run at the end\nof the class creation process), we’ll see additional use cases in the next chapter.\nIn other words, function decorators can be used to manage both function calls and\nfunction objects, and class decorators can be used to manage both class instances and",
    "this role intersects strongly with that of metaclasses (indeed, both run at the end\nof the class creation process), we’ll see additional use cases in the next chapter.\nIn other words, function decorators can be used to manage both function calls and\nfunction objects, and class decorators can be used to manage both class instances and\nclasses themselves. By returning the decorated object itself instead of a wrapper, decorators become a simple post-creation step for functions and classes.\nRegardless of the role they play, decorators provide a convenient and explicit way to\ncode tools useful both during program development and in live production systems.",
    "Using and Defining Decorators\nDepending on your job description, you might encounter decorators as a user or a\nprovider. As we’ve seen, Python itself comes with built-in decorators that have specialized roles—static method declaration, property creation, and more. In addition,\n984 | Chapter 38: Decorators",
    "many popular Python toolkits include decorators to perform tasks such as managing\ndatabase or user-interface logic. In such cases, we can get by without knowing how the\ndecorators are coded.\nFor more general tasks, programmers can code arbitrary decorators of their own. For\nexample, function decorators may be used to augment functions with code that adds\ncall tracing, performs argument validity testing during debugging, automatically acquires and releases thread locks, times calls made to function for optimization, and so\non. Any behavior you can imagine adding to a function call is a candidate for custom\nfunction decorators.\nOn the other hand, function decorators are designed to augment only a specific function\nor method call, not an entire object interface. Class decorators fill the latter role better—\nbecause they can intercept instance creation calls, they can be used to implement arbitrary object interface augmentation or management tasks. For example, custom class",
    "function decorators.\nOn the other hand, function decorators are designed to augment only a specific function\nor method call, not an entire object interface. Class decorators fill the latter role better—\nbecause they can intercept instance creation calls, they can be used to implement arbitrary object interface augmentation or management tasks. For example, custom class\ndecorators can trace or validate every attribute reference made for an object. They can\nalso be used to implement proxy objects, singleton classes, and other common coding\npatterns. In fact, we’ll find that many class decorators bear a strong resemblance to the\ndelegation coding pattern we met in Chapter 30.",
    "Why Decorators?\nLike many advanced Python tools, decorators are never strictly required from a purely\ntechnical perspective: their functionality can often be implemented instead using simple helper function calls or other techniques (and at a base level, we can always manually\ncode the name rebinding that decorators perform automatically).\nThat said, decorators provide an explicit syntax for such tasks, which makes intent\nclearer, can minimize augmentation code redundancy, and may help ensure correct\nAPI usage:\n• Decorators have a very explicit syntax, which makes them easier to spot than helper\nfunction calls that may be arbitrarily far-removed from the subject functions or\nclasses.\n• Decorators are applied once, when the subject function or class is defined; it’s not\nnecessary to add extra code (which may have to be changed in the future) at every\ncall to the class or function.\n• Because of both of the prior points, decorators make it less likely that a user of an",
    "function calls that may be arbitrarily far-removed from the subject functions or\nclasses.\n• Decorators are applied once, when the subject function or class is defined; it’s not\nnecessary to add extra code (which may have to be changed in the future) at every\ncall to the class or function.\n• Because of both of the prior points, decorators make it less likely that a user of an\nAPI will forget to augment a function or class according to API requirements.\nIn other words, beyond their technical model, decorators offer some advantages in\nterms of code maintenance and aesthetics. Moreover, as structuring tools, decorators\nnaturally foster encapsulation of code, which reduces redundancy and makes future\nchanges easier.",
    "What’s a Decorator? | 985\n\n\fDecorators do have some potential drawbacks, too—when they insert wrapper logic,\nthey can alter the types of the decorated objects, and they may incur extra calls. On the\nother hand, the same considerations apply to any technique that adds wrapping logic\nto objects.\nWe’ll explore these tradeoffs in the context of real code later in this chapter. Although\nthe choice to use decorators is still somewhat subjective, their advantages are compelling enough that they are quickly becoming best practice in the Python world. To help\nyou decide for yourself, let’s turn to the details.\n\nThe Basics\nLet’s get started with a first-pass look at decoration behavior from a symbolic perspective. We’ll write real code soon, but since most of the magic of decorators boils down\nto an automatic rebinding operation, it’s important to understand this mapping first.",
    "The Basics\nLet’s get started with a first-pass look at decoration behavior from a symbolic perspective. We’ll write real code soon, but since most of the magic of decorators boils down\nto an automatic rebinding operation, it’s important to understand this mapping first.\n\nFunction Decorators\nFunction decorators have been available in Python since version 2.5. As we saw earlier\nin this book, they are largely just syntactic sugar that runs one function through another\nat the end of a def statement, and rebinds the original function name to the result.",
    "Function Decorators\nFunction decorators have been available in Python since version 2.5. As we saw earlier\nin this book, they are largely just syntactic sugar that runs one function through another\nat the end of a def statement, and rebinds the original function name to the result.\n\nUsage\nA function decorator is a kind of runtime declaration about the function whose definition follows. The decorator is coded on a line just before the def statement that defines\na function or method, and it consists of the @ symbol followed by a reference to a\nmetafunction—a function (or other callable object) that manages another function.\nIn terms of code, function decorators automatically map the following syntax:\n@decorator\ndef F(arg):\n...\n\n# Decorate function\n\nF(99)\n\n# Call function\n\ninto this equivalent form, where decorator is a one-argument callable object that returns a callable object with the same number of arguments as F:\ndef F(arg):\n...\nF = decorator(F)",
    "# Decorate function\n\nF(99)\n\n# Call function\n\ninto this equivalent form, where decorator is a one-argument callable object that returns a callable object with the same number of arguments as F:\ndef F(arg):\n...\nF = decorator(F)\n\n# Rebind function name to decorator result\n\nF(99)\n\n# Essentially calls decorator(F)(99)\n\n986 | Chapter 38: Decorators\n\n\fThis automatic name rebinding works on any def statement, whether it’s for a simple\nfunction or a method within a class. When the function F is later called, it’s actually\ncalling the object returned by the decorator, which may be either another object that\nimplements required wrapping logic, or the original function itself.\nIn other words, decoration essentially maps the first of the following into the second\n(though the decorator is really run only once, at decoration time):\nfunc(6, 7)\ndecorator(func)(6, 7)",
    "This automatic name rebinding accounts for the static method and property decoration\nsyntax we met earlier in the book:\nclass C:\n@staticmethod\ndef meth(...): ...\n\n# meth = staticmethod(meth)\n\nclass C:\n@property\ndef name(self): ...\n\n# name = property(name)\n\nIn both cases, the method name is rebound to the result of a built-in function decorator,\nat the end of the def statement. Calling the original name later invokes whatever object\nthe decorator returns.",
    "# meth = staticmethod(meth)\n\nclass C:\n@property\ndef name(self): ...\n\n# name = property(name)\n\nIn both cases, the method name is rebound to the result of a built-in function decorator,\nat the end of the def statement. Calling the original name later invokes whatever object\nthe decorator returns.\n\nImplementation\nA decorator itself is a callable that returns a callable. That is, it returns the object to be\ncalled later when the decorated function is invoked through its original name—either\na wrapper object to intercept later calls, or the original function augmented in some\nway. In fact, decorators can be any type of callable and return any type of callable: any\ncombination of functions and classes may be used, though some are better suited to\ncertain contexts.\nFor example, to tap into the decoration protocol in order to manage a function just\nafter it is created, we might code a decorator of this form:\ndef decorator(F):\n# Process function F\nreturn F\n@decorator\ndef func(): ...",
    "# func = decorator(func)\n\nBecause the original decorated function is assigned back to its name, this simply adds\na post-creation step to function definition. Such a structure might be used to register a\nfunction to an API, assign function attributes, and so on.\n\nThe Basics | 987\n\n\fIn more typical use, to insert logic that intercepts later calls to a function, we might\ncode a decorator to return a different object than the original function:\ndef decorator(F):\n# Save or use function F\n# Return a different callable: nested def, class with __call__, etc.\n@decorator\ndef func(): ...\n\n# func = decorator(func)",
    "# func = decorator(func)\n\nThis decorator is invoked at decoration time, and the callable it returns is invoked when\nthe original function name is later called. The decorator itself receives the decorated\nfunction; the callable returned receives whatever arguments are later passed to the\ndecorated function’s name. This works the same for class methods: the implied instance\nobject simply shows up in the first argument of the returned callable.\nIn skeleton terms, here’s one common coding pattern that captures this idea—the decorator returns a wrapper that retains the original function in an enclosing scope:\ndef decorator(F):\ndef wrapper(*args):\n# Use F and args\n# F(*args) calls original function\nreturn wrapper\n\n# On @ decoration\n# On wrapped function call\n\n@decorator\ndef func(x, y):\n...\n\n# func = decorator(func)\n# func is passed to decorator's F\n\nfunc(6, 7)\n\n# 6, 7 are passed to wrapper's *args",
    "# On @ decoration\n# On wrapped function call\n\n@decorator\ndef func(x, y):\n...\n\n# func = decorator(func)\n# func is passed to decorator's F\n\nfunc(6, 7)\n\n# 6, 7 are passed to wrapper's *args\n\nWhen the name func is later called, it really invokes the wrapper function returned by\ndecorator; the wrapper function can then run the original func because it is still available\nin an enclosing scope. When coded this way, each decorated function produces a new\nscope to retain state.\nTo do the same with classes, we can overload the call operation and use instance attributes instead of enclosing scopes:\nclass decorator:\ndef __init__(self, func):\n# On @ decoration\nself.func = func\ndef __call__(self, *args):\n# On wrapped function call\n# Use self.func and args\n# self.func(*args) calls original function\n@decorator\ndef func(x, y):\n...\n\n# func = decorator(func)\n# func is passed to __init__\n\nfunc(6, 7)\n\n# 6, 7 are passed to __call__'s *args",
    "# func = decorator(func)\n# func is passed to __init__\n\nfunc(6, 7)\n\n# 6, 7 are passed to __call__'s *args\n\nWhen the name func is later called now, it really invokes the __call__ operator overloading method of the instance created by decorator; the __call__ method can then\n\n988 | Chapter 38: Decorators\n\n\frun the original func because it is still available in an instance attribute. When coded\nthis way, each decorated function produces a new instance to retain state.\n\nSupporting method decoration\nOne subtle point about the prior class-based coding is that while it works to intercept\nsimple function calls, it does not quite work when applied to class method functions:\nclass decorator:\ndef __init__(self, func):\n# func is method without instance\nself.func = func\ndef __call__(self, *args):\n# self is decorator instance\n# self.func(*args) fails! # C instance not in args!\nclass C:\n@decorator\ndef method(self, x, y):\n...\n\n# method = decorator(method)\n# Rebound to decorator instance",
    "# method = decorator(method)\n# Rebound to decorator instance\n\nWhen coded this way, the decorated method is rebound to an instance of the decorator\nclass, instead of a simple function.\nThe problem with this is that the self in the decorator’s __call__ receives the\ndecorator class instance when the method is later run, and the instance of class C is\nnever included in *args. This makes it impossible to dispatch the call to the original\nmethod—the decorator object retains the original method function, but it has no instance to pass to it.\nTo support both functions and methods, the nested function alternative works better:\ndef decorator(F):\ndef wrapper(*args):\n# F(*args) runs func or method\nreturn wrapper\n@decorator\ndef func(x, y):\n...\nfunc(6, 7)\n\n# F is func or method without instance\n# class instance in args[0] for method\n\n# func = decorator(func)\n# Really calls wrapper(6, 7)\n\nclass C:\n@decorator\ndef method(self, x, y):\n...\n\n# method = decorator(method)\n# Rebound to simple function",
    "# F is func or method without instance\n# class instance in args[0] for method\n\n# func = decorator(func)\n# Really calls wrapper(6, 7)\n\nclass C:\n@decorator\ndef method(self, x, y):\n...\n\n# method = decorator(method)\n# Rebound to simple function\n\nX = C()\nX.method(6, 7)\n\n# Really calls wrapper(X, 6, 7)\n\nWhen coded this way wrapper receives the C class instance in its first argument, so it\ncan dispatch to the original method and access state information.\nTechnically, this nested-function version works because Python creates a bound\nmethod object and thus passes the subject class instance to the self argument only\nwhen a method attribute references a simple function; when it references an instance\nThe Basics | 989",
    "of a callable class instead, the callable class’s instance is passed to self to give the\ncallable class access to its own state information. We’ll see how this subtle difference\ncan matter in more realistic examples later in this chapter.\nAlso note that nested functions are perhaps the most straightforward way to support\ndecoration of both functions and methods, but not necessarily the only way. The prior\nchapter’s descriptors, for example, receive both the descriptor and subject class instance\nwhen called. Though more complex, later in this chapter we’ll see how this tool can be\nleveraged in this context as well.",
    "Class Decorators\nFunction decorators proved so useful that the model was extended to allow class decoration in Python 2.6 and 3.0. Class decorators are strongly related to function decorators; in fact, they use the same syntax and very similar coding patterns. Rather than\nwrapping individual functions or methods, though, class decorators are a way to manage classes, or wrap up instance construction calls with extra logic that manages or\naugments instances created from a class.\n\nUsage\nSyntactically, class decorators appear just before class statements (just as function\ndecorators appear just before function definitions). In symbolic terms, assuming that\ndecorator is a one-argument function that returns a callable, the class decorator syntax:\n@decorator\nclass C:\n...\n\n# Decorate class\n\nx = C(99)\n\n# Make an instance",
    "Usage\nSyntactically, class decorators appear just before class statements (just as function\ndecorators appear just before function definitions). In symbolic terms, assuming that\ndecorator is a one-argument function that returns a callable, the class decorator syntax:\n@decorator\nclass C:\n...\n\n# Decorate class\n\nx = C(99)\n\n# Make an instance\n\nis equivalent to the following—the class is automatically passed to the decorator function, and the decorator’s result is assigned back to the class name:\nclass C:\n...\nC = decorator(C)\n\n# Rebind class name to decorator result\n\nx = C(99)\n\n# Essentially calls decorator(C)(99)\n\nThe net effect is that calling the class name later to create an instance winds up triggering\nthe callable returned by the decorator, instead of calling the original class itself.",
    "# Rebind class name to decorator result\n\nx = C(99)\n\n# Essentially calls decorator(C)(99)\n\nThe net effect is that calling the class name later to create an instance winds up triggering\nthe callable returned by the decorator, instead of calling the original class itself.\n\nImplementation\nNew class decorators are coded using many of the same techniques used for function\ndecorators. Because a class decorator is also a callable that returns a callable, most\ncombinations of functions and classes suffice.\n\n990 | Chapter 38: Decorators\n\n\fHowever it’s coded, the decorator’s result is what runs when an instance is later created.\nFor example, to simply manage a class just after it is created, return the original class\nitself:\ndef decorator(C):\n# Process class C\nreturn C\n@decorator\nclass C: ...\n\n# C = decorator(C)",
    "990 | Chapter 38: Decorators\n\n\fHowever it’s coded, the decorator’s result is what runs when an instance is later created.\nFor example, to simply manage a class just after it is created, return the original class\nitself:\ndef decorator(C):\n# Process class C\nreturn C\n@decorator\nclass C: ...\n\n# C = decorator(C)\n\nTo instead insert a wrapper layer that intercepts later instance creation calls, return a\ndifferent callable object:\ndef decorator(C):\n# Save or use class C\n# Return a different callable: nested def, class with __call__, etc.\n@decorator\nclass C: ...\n\n# C = decorator(C)",
    "# C = decorator(C)\n\nTo instead insert a wrapper layer that intercepts later instance creation calls, return a\ndifferent callable object:\ndef decorator(C):\n# Save or use class C\n# Return a different callable: nested def, class with __call__, etc.\n@decorator\nclass C: ...\n\n# C = decorator(C)\n\nThe callable returned by such a class decorator typically creates and returns a new\ninstance of the original class, augmented in some way to manage its interface. For\nexample, the following inserts an object that intercepts undefined attributes of a class\ninstance:\ndef decorator(cls):\n# On @ decoration\nclass Wrapper:\ndef __init__(self, *args):\n# On instance creation\nself.wrapped = cls(*args)\ndef __getattr__(self, name):\n# On attribute fetch\nreturn getattr(self.wrapped, name)\nreturn Wrapper\n@decorator\nclass C:\ndef __init__(self, x, y):\nself.attr = 'spam'\n\n# C = decorator(C)\n# Run by Wrapper.__init__\n\nx = C(6, 7)\nprint(x.attr)\n\n# Really calls Wrapper(6, 7)\n# Runs Wrapper.__getattr__, prints \"spam\"",
    "# C = decorator(C)\n# Run by Wrapper.__init__\n\nx = C(6, 7)\nprint(x.attr)\n\n# Really calls Wrapper(6, 7)\n# Runs Wrapper.__getattr__, prints \"spam\"\n\nIn this example, the decorator rebinds the class name to another class, which retains\nthe original class in an enclosing scope and creates and embeds an instance of the\noriginal class when it’s called. When an attribute is later fetched from the instance, it\nis intercepted by the wrapper’s __getattr__ and delegated to the embedded instance\nof the original class. Moreover, each decorated class creates a new scope, which remembers the original class. We’ll flesh out this example into some more useful code\nlater in this chapter.\n\nThe Basics | 991",
    "The Basics | 991\n\n\fLike function decorators, class decorators are commonly coded as either “factory”\nfunctions that create and return callables, classes that use __init__ or __call__ methods\nto intercept call operations, or some combination thereof. Factory functions typically\nretain state in enclosing scope references, and classes in attributes.\n\nSupporting multiple instances\nAs with function decorators, with class decorators some callable type combinations\nwork better than others. Consider the following invalid alternative to the class decorator of the prior example:\nclass Decorator:\ndef __init__(self, C):\n# On @ decoration\nself.C = C\ndef __call__(self, *args):\n# On instance creation\nself.wrapped = self.C(*args)\nreturn self\ndef __getattr__(self, attrname):\n# On atrribute fetch\nreturn getattr(self.wrapped, attrname)\n@Decorator\nclass C: ...\n\n# C = Decorator(C)\n\nx = C()\ny = C()\n\n# Overwrites x!",
    "# C = Decorator(C)\n\nx = C()\ny = C()\n\n# Overwrites x!\n\nThis code handles multiple decorated classes (each makes a new Decorator instance)\nand will intercept instance creation calls (each runs __call__). Unlike the prior version,\nhowever, this version fails to handle multiple instances of a given class—each instance\ncreation call overwrites the prior saved instance. The original version does support\nmultiple instances, because each instance creation call makes a new independent wrapper object. More generally, either of the following patterns supports multiple wrapped\ninstances:\ndef decorator(C):\nclass Wrapper:\ndef __init__(self, *args):\nself.wrapped = C(*args)\nreturn Wrapper\nclass Wrapper: ...\ndef decorator(C):\ndef onCall(*args):\nreturn Wrapper(C(*args))\nreturn onCall\n\n# On @ decoration\n# On instance creation\n\n# On @ decoration\n# On instance creation\n# Embed instance in instance",
    "# On @ decoration\n# On instance creation\n\n# On @ decoration\n# On instance creation\n# Embed instance in instance\n\nWe’ll study this phenomenon in a more realistic context later in the chapter; in practice,\nthough, we must be careful to combine callable types properly to support our intent.\n\n992 | Chapter 38: Decorators\n\n\fDecorator Nesting\nSometimes one decorator isn’t enough. To support multiple steps of augmentation,\ndecorator syntax allows you to add multiple layers of wrapper logic to a decorated\nfunction or method. When this feature is used, each decorator must appear on a line\nof its own. Decorator syntax of this form:\n@A\n@B\n@C\ndef f(...):\n...\n\nruns the same as the following:\ndef f(...):\n...\nf = A(B(C(f)))",
    "runs the same as the following:\ndef f(...):\n...\nf = A(B(C(f)))\n\nHere, the original function is passed through three different decorators, and the resulting callable object is assigned back to the original name. Each decorator processes\nthe result of the prior, which may be the original function or an inserted wrapper.\nIf all the decorators insert wrappers, the net effect is that when the original function\nname is called, three different layers of wrapping object logic will be invoked, to augment the original function in three different ways. The last decorator listed is the first\napplied, and the most deeply nested (insert joke about “interior decorators” here...).\nJust as for functions, multiple class decorators result in multiple nested function calls,\nand possibly multiple levels of wrapper logic around instance creation calls. For example, the following code:\n@spam\n@eggs\nclass C:\n...\nX = C()\n\nis equivalent to the following:\nclass C:\n...\nC = spam(eggs(C))\nX = C()",
    "is equivalent to the following:\nclass C:\n...\nC = spam(eggs(C))\nX = C()\n\nAgain, each decorator is free to return either the original class or an inserted wrapper\nobject. With wrappers, when an instance of the original C class is finally requested, the\ncall is redirected to the wrapping layer objects provided by both the spam and eggs\ndecorators, which may have arbitrarily different roles.\n\nThe Basics | 993\n\n\fFor example, the following do-nothing decorators simply return the decorated\nfunction:\ndef d1(F): return F\ndef d2(F): return F\ndef d3(F): return F\n@d1\n@d2\n@d3\ndef func():\nprint('spam')\nfunc()\n\n# func = d1(d2(d3(func)))\n# Prints \"spam\"",
    "The Basics | 993\n\n\fFor example, the following do-nothing decorators simply return the decorated\nfunction:\ndef d1(F): return F\ndef d2(F): return F\ndef d3(F): return F\n@d1\n@d2\n@d3\ndef func():\nprint('spam')\nfunc()\n\n# func = d1(d2(d3(func)))\n# Prints \"spam\"\n\nThe same syntax works on classes, as do these same do-nothing decorators.\nWhen decorators insert wrapper function objects, though, they may augment the original function when called—the following concatenates to its result in the decorator\nlayers, as it runs the layers from inner to outer:\ndef d1(F): return lambda: 'X' + F()\ndef d2(F): return lambda: 'Y' + F()\ndef d3(F): return lambda: 'Z' + F()\n@d1\n@d2\n@d3\ndef func():\nreturn 'spam'\nprint(func())\n\n# func = d1(d2(d3(func)))\n# Prints \"XYZspam\"",
    "# func = d1(d2(d3(func)))\n# Prints \"XYZspam\"\n\nWe use lambda functions to implement wrapper layers here (each retains the wrapped\nfunction in an enclosing scope); in practice, wrappers can take the form of functions,\ncallable classes, and more. When designed well, decorator nesting allows us to combine\naugmentation steps in a wide variety of ways.\n\nDecorator Arguments\nBoth function and class decorators can also seem to take arguments, although really\nthese arguments are passed to a callable that in effect returns the decorator, which in\nturn returns a callable. The following, for instance:\n@decorator(A, B)\ndef F(arg):\n...\nF(99)\n\nis automatically mapped into this equivalent form, where decorator is a callable that\nreturns the actual decorator. The returned decorator in turn returns the callable run\nlater for calls to the original function name:\n\n994 | Chapter 38: Decorators\n\n\fdef F(arg):\n...\nF = decorator(A, B)(F)\n\n# Rebind F to result of decorator's return value\n\nF(99)",
    "is automatically mapped into this equivalent form, where decorator is a callable that\nreturns the actual decorator. The returned decorator in turn returns the callable run\nlater for calls to the original function name:\n\n994 | Chapter 38: Decorators\n\n\fdef F(arg):\n...\nF = decorator(A, B)(F)\n\n# Rebind F to result of decorator's return value\n\nF(99)\n\n# Essentially calls decorator(A, B)(F)(99)\n\nDecorator arguments are resolved before decoration ever occurs, and they are usually\nused to retain state information for use in later calls. The decorator function in this\nexample, for instance, might take a form like the following:\ndef decorator(A, B):\n# Save or use A, B\ndef actualDecorator(F):\n# Save or use function F\n# Return a callable: nested def, class with __call__, etc.\nreturn callable\nreturn actualDecorator",
    "The outer function in this structure generally saves the decorator arguments away as\nstate information, for use in the actual decorator, the callable it returns, or both. This\ncode snippet retains the state information argument in enclosing function scope references, but class attributes are commonly used as well.\nIn other words, decorator arguments often imply three levels of callables: a callable to\naccept decorator arguments, which returns a callable to serve as decorator, which returns a callable to handle calls to the original function or class. Each of the three levels\nmay be a function or class and may retain state in the form of scopes or class attributes.\nWe’ll see concrete examples of decorator arguments employed later in this chapter.",
    "Decorators Manage Functions and Classes, Too\nAlthough much of the rest of this chapter focuses on wrapping later calls to functions\nand classes, I should underscore that the decorator mechanism is more general than\nthis—it is a protocol for passing functions and classes through a callable immediately\nafter they are created. As such, it can also be used to invoke arbitrary post-creation\nprocessing:\ndef decorate(O):\n# Save or augment function or class O\nreturn O\n@decorator\ndef F(): ...\n\n# F = decorator(F)\n\n@decorator\nclass C: ...\n\n# C = decorator(C)\n\nAs long as we return the original decorated object this way instead of a wrapper, we\ncan manage functions and classes themselves, not just later calls to them. We’ll see\nmore realistic examples later in this chapter that use this idea to register callable objects\nto an API with decoration and assign attributes to functions when they are created.\n\nThe Basics | 995",
    "# C = decorator(C)\n\nAs long as we return the original decorated object this way instead of a wrapper, we\ncan manage functions and classes themselves, not just later calls to them. We’ll see\nmore realistic examples later in this chapter that use this idea to register callable objects\nto an API with decoration and assign attributes to functions when they are created.\n\nThe Basics | 995\n\n\fCoding Function Decorators\nOn to the code—in the rest of this chapter, we are going to study working examples\nthat demonstrate the decorator concepts we just explored. This section presents a\nhandful of function decorators at work, and the next shows class decorators in action.\nFollowing that, we’ll close out with some larger case studies of class and function decorator usage.",
    "The Basics | 995\n\n\fCoding Function Decorators\nOn to the code—in the rest of this chapter, we are going to study working examples\nthat demonstrate the decorator concepts we just explored. This section presents a\nhandful of function decorators at work, and the next shows class decorators in action.\nFollowing that, we’ll close out with some larger case studies of class and function decorator usage.\n\nTracing Calls\nTo get started, let’s revive the call tracer example we met in Chapter 31. The following\ndefines and applies a function decorator that counts the number of calls made to the\ndecorated function and prints a trace message for each call:\nclass tracer:\ndef __init__(self, func):\n# On @ decoration: save original func\nself.calls = 0\nself.func = func\ndef __call__(self, *args):\n# On later calls: run original func\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))\nself.func(*args)\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)",
    "# spam = tracer(spam)\n# Wraps spam in a decorator object\n\nNotice how each function decorated with this class will create a new instance, with its\nown saved function object and calls counter. Also observe how the *args argument\nsyntax is used to pack and unpack arbitrarily many passed-in arguments. This generality enables this decorator to be used to wrap any function with any number of arguments (this version doesn’t yet work on class methods, but we’ll fix that later in this\nsection).\nNow, if we import this module’s function and test it interactively, we get the following\nsort of behavior—each call generates a trace message initially, because the decorator\nclass intercepts it. This code runs under both Python 2.6 and 3.0, as does all code in\nthis chapter unless otherwise noted:\n>>> from decorator1 import spam\n>>> spam(1, 2, 3)\ncall 1 to spam\n6\n\n# Really calls the tracer wrapper object\n\n>>> spam('a', 'b', 'c')\ncall 2 to spam\nabc\n\n# Invokes __call__ in class\n\n>>> spam.calls\n2",
    "# Really calls the tracer wrapper object\n\n>>> spam('a', 'b', 'c')\ncall 2 to spam\nabc\n\n# Invokes __call__ in class\n\n>>> spam.calls\n2\n\n# Number calls in wrapper state information\n\n996 | Chapter 38: Decorators\n\n\f>>> spam\n<decorator1.tracer object at 0x02D9A730>",
    ">>> spam.calls\n2\n\n# Number calls in wrapper state information\n\n996 | Chapter 38: Decorators\n\n\f>>> spam\n<decorator1.tracer object at 0x02D9A730>\n\nWhen run, the tracer class saves away the decorated function, and intercepts later calls\nto it, in order to add a layer of logic that counts and prints each call. Notice how the\ntotal number of calls shows up as an attribute of the decorated function—spam is really\nan instance of the tracer class when decorated (a finding that may have ramifications\nfor programs that do type checking, but is generally benign).\nFor function calls, the @ decoration syntax can be more convenient than modifying each\ncall to account for the extra logic level, and it avoids accidentally calling the original\nfunction directly. Consider a nondecorator equivalent such as the following:\ncalls = 0\ndef tracer(func, *args):\nglobal calls\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nfunc(*args)\ndef spam(a, b, c):\nprint(a, b, c)\n>>> spam(1, 2, 3)\n1 2 3",
    "# Normal non-traced call: accidental?\n\n>>> tracer(spam, 1, 2, 3)\ncall 1 to spam\n1 2 3\n\n# Special traced call without decorators\n\nThis alternative can be used on any function without the special @ syntax, but unlike\nthe decorator version, it requires extra syntax at every place where the function is called\nin your code; furthermore, its intent may not be as obvious, and it does not ensure that\nthe extra layer will be invoked for normal calls. Although decorators are never required (we can always rebind names manually), they are often the most convenient\noption.",
    "State Information Retention Options\nThe last example of the prior section raises an important issue. Function decorators\nhave a variety of options for retaining state information provided at decoration time,\nfor use during the actual function call. They generally need to support multiple decorated objects and multiple calls, but there are a number of ways to implement these\ngoals: instance attributes, global variables, nonlocal variables, and function attributes\ncan all be used for retaining state.\n\nCoding Function Decorators | 997",
    "Coding Function Decorators | 997\n\n\fClass instance attributes\nFor example, here is an augmented version of the prior example, which adds support\nfor keyword arguments and returns the wrapped function’s result to support more use\ncases:\nclass tracer:\n# State via instance attributes\ndef __init__(self, func):\n# On @ decorator\nself.calls = 0\n# Save func for later call\nself.func = func\ndef __call__(self, *args, **kwargs):\n# On call to original function\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))\nreturn self.func(*args, **kwargs)\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)\n\n# Same as: spam = tracer(spam)\n# Triggers tracer.__init__\n\n@tracer\ndef eggs(x, y):\nprint(x ** y)\n\n# Same as: eggs = tracer(eggs)\n# Wraps eggs in a tracer object\n\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)\n\n# Really calls tracer instance: runs tracer.__call__\n# spam is an instance attribute\n\neggs(2, 16)\neggs(4, y=4)",
    "# Same as: spam = tracer(spam)\n# Triggers tracer.__init__\n\n@tracer\ndef eggs(x, y):\nprint(x ** y)\n\n# Same as: eggs = tracer(eggs)\n# Wraps eggs in a tracer object\n\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)\n\n# Really calls tracer instance: runs tracer.__call__\n# spam is an instance attribute\n\neggs(2, 16)\neggs(4, y=4)\n\n# Really calls tracer instance, self.func is eggs\n# self.calls is per-function here (need 3.0 nonlocal)\n\nLike the original, this uses class instance attributes to save state explicitly. Both the\nwrapped function and the calls counter are per-instance information—each decoration\ngets its own copy. When run as a script under either 2.6 or 3.0, the output of this version\nis as follows; notice how the spam and eggs functions each have their own calls counter,\nbecause each decoration creates a new class instance:\ncall 1 to spam\n6\ncall 2 to spam\n15\ncall 1 to eggs\n65536\ncall 2 to eggs\n256",
    "While useful for decorating functions, this coding scheme has issues when applied to\nmethods (more on this later).\n\nEnclosing scopes and globals\nEnclosing def scope references and nested defs can often achieve the same effect, especially for static data like the decorated original function. In this example, though, we\nwould also need a counter in the enclosing scope that changes on each call, and that’s\n\n998 | Chapter 38: Decorators\n\n\fnot possible in Python 2.6. In 2.6, we can either use classes and attributes, as we did\nearlier, or move the state variable out to the global scope, with global declarations:\ncalls = 0\ndef tracer(func):\n# State via enclosing scope and global\ndef wrapper(*args, **kwargs):\n# Instead of class attributes\nglobal calls\n# calls is global, not per-function\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nreturn func(*args, **kwargs)\nreturn wrapper\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)\n\n# Same as: spam = tracer(spam)",
    "# Same as: spam = tracer(spam)\n\n@tracer\ndef eggs(x, y):\nprint(x ** y)\n\n# Same as: eggs = tracer(eggs)\n\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)\n\n# Really calls wrapper, bound to func\n# wrapper calls spam\n\neggs(2, 16)\neggs(4, y=4)\n\n# Really calls wrapper, bound to eggs\n# Global calls is not per-function here!\n\nUnfortunately, moving the counter out to the common global scope to allow it to be\nchanged like this also means that it will be shared by every wrapped function. Unlike\nclass instance attributes, global counters are cross-program, not per-function—the\ncounter is incremented for any traced function call. You can tell the difference if you\ncompare this version’s output with the prior version’s—the single, shared global call\ncounter is incorrectly updated by calls to every decorated function:\ncall 1 to spam\n6\ncall 2 to spam\n15\ncall 3 to eggs\n65536\ncall 4 to eggs\n256",
    "Enclosing scopes and nonlocals\nShared global state may be what we want in some cases. If we really want a\nper-function counter, though, we can either use classes as before, or make use of the\nnew nonlocal statement in Python 3.0, described in Chapter 17. Because this new\nstatement allows enclosing function scope variables to be changed, they can serve as\nper-decoration and changeable data:\ndef tracer(func):\ncalls = 0\ndef wrapper(*args, **kwargs):\n\n# State via enclosing scope and nonlocal\n# Instead of class attrs or global\n# calls is per-function, not global\n\nCoding Function Decorators | 999\n\n\fnonlocal calls\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nreturn func(*args, **kwargs)\nreturn wrapper\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)\n\n# Same as: spam = tracer(spam)\n\n@tracer\ndef eggs(x, y):\nprint(x ** y)\n\n# Same as: eggs = tracer(eggs)\n\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)\n\n# Really calls wrapper, bound to func\n# wrapper calls spam\n\neggs(2, 16)\neggs(4, y=4)",
    "nonlocal calls\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nreturn func(*args, **kwargs)\nreturn wrapper\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)\n\n# Same as: spam = tracer(spam)\n\n@tracer\ndef eggs(x, y):\nprint(x ** y)\n\n# Same as: eggs = tracer(eggs)\n\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)\n\n# Really calls wrapper, bound to func\n# wrapper calls spam\n\neggs(2, 16)\neggs(4, y=4)\n\n# Really calls wrapper, bound to eggs\n# Nonlocal calls _is_ not per-function here\n\nNow, because enclosing scope variables are not cross-program globals, each wrapped\nfunction gets its own counter again, just as for classes and attributes. Here’s the new\noutput when run under 3.0:\ncall 1 to spam\n6\ncall 2 to spam\n15\ncall 1 to eggs\n65536\ncall 2 to eggs\n256",
    "Function attributes\nFinally, if you are not using Python 3.X and don’t have a nonlocal statement, you may\nstill be able to avoid globals and classes by making use of function attributes for some\nchangeable state instead. In recent Pythons, we can assign arbitrary attributes to functions to attach them, with func.attr=value. In our example, we can simply use\nwrapper.calls for state. The following works the same as the preceding nonlocal version because the counter is again per-decorated-function, but it also runs in Python 2.6:\ndef tracer(func):\n# State via enclosing scope and func attr\ndef wrapper(*args, **kwargs):\n# calls is per-function, not global\nwrapper.calls += 1\nprint('call %s to %s' % (wrapper.calls, func.__name__))\nreturn func(*args, **kwargs)\nwrapper.calls = 0\nreturn wrapper",
    "Notice that this only works because the name wrapper is retained in the enclosing\ntracer function’s scope. When we later increment wrapper.calls, we are not changing\nthe name wrapper itself, so no nonlocal declaration is required.\n\n1000 | Chapter 38: Decorators",
    "This scheme was almost relegated to a footnote, because it is more obscure than\nnonlocal in 3.0 and is probably better saved for cases where other schemes don’t help.\nHowever, we will employ it in an answer to one of the end-of-chapter questions, where\nwe’ll need to access the saved state from outside the decorator’s code; nonlocals can\nonly be seen inside the nested function itself, but function attributes have wider\nvisibility.\nBecause decorators often imply multiple levels of callables, you can combine functions\nwith enclosing scopes and classes with attributes to achieve a variety of coding structures. As we’ll see later, though, this sometimes may be subtler than you expect—each\ndecorated function should have its own state, and each decorated class may require\nstate both for itself and for each generated instance.\nIn fact, as the next section will explain, if we want to apply function decorators to class",
    "decorated function should have its own state, and each decorated class may require\nstate both for itself and for each generated instance.\nIn fact, as the next section will explain, if we want to apply function decorators to class\nmethods, too, we also have to be careful about the distinction Python makes between\ndecorators coded as callable class instance objects and decorators coded as functions.",
    "Class Blunders I: Decorating Class Methods\nWhen I wrote the first tracer function decorator above, I naively assumed that it could\nalso be applied to any method—decorated methods should work the same, but the\nautomatic self instance argument would simply be included at the front of *args. Unfortunately, I was wrong: when applied to a class’s method, the first version of the\ntracer fails, because self is the instance of the decorator class and the instance of the\ndecorated subject class in not included in *args. This is true in both Python 3.0 and 2.6.\nI introduced this phenomenon earlier in this chapter, but now we can see it in the\ncontext of realistic working code. Given the class-based tracing decorator:\nclass tracer:\ndef __init__(self, func):\n# On @ decorator\nself.calls = 0\n# Save func for later call\nself.func = func\ndef __call__(self, *args, **kwargs):\n# On call to original function\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))",
    "context of realistic working code. Given the class-based tracing decorator:\nclass tracer:\ndef __init__(self, func):\n# On @ decorator\nself.calls = 0\n# Save func for later call\nself.func = func\ndef __call__(self, *args, **kwargs):\n# On call to original function\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))\nreturn self.func(*args, **kwargs)",
    "decoration of simple functions works as advertised earlier:\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)\n\n# spam = tracer(spam)\n# Triggers tracer.__init__\n\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)\n\n# Runs tracer.__call__\n# spam is an instance attribute\n\nCoding Function Decorators | 1001\n\n\fHowever, decoration of class methods fails (more lucid readers might recognize this as\nour Person class resurrected from the object-oriented tutorial in Chapter 27):\nclass Person:\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\n@tracer\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\n\n# giveRaise = tracer(giverRaise)\n\n@tracer\ndef lastName(self):\nreturn self.name.split()[-1]\n\n# lastName = tracer(lastName)\n\nbob = Person('Bob Smith', 50000)\nbob.giveRaise(.25)\nprint(bob.lastName())\n\n# tracer remembers method funcs\n# Runs tracer.__call__(???, .25)\n# Runs tracer.__call__(???)",
    "The root of the problem here is in the self argument of the tracer class’s __call__\nmethod—is it a tracer instance or a Person instance? We really need both as it’s coded:\nthe tracer for decorator state, and the Person for routing on to the original method.\nReally, self must be the tracer object, to provide access to tracer’s state information;\nthis is true whether decorating a simple function or a method.\nUnfortunately, when our decorated method name is rebound to a class instance object\nwith a __call__, Python passes only the tracer instance to self; it doesn’t pass along\nthe Person subject in the arguments list at all. Moreover, because the tracer knows\nnothing about the Person instance we are trying to process with method calls, there’s\nno way to create a bound method with an instance, and thus no way to correctly dispatch the call.\nIn fact, the prior listing winds up passing too few arguments to the decorated method,",
    "the Person subject in the arguments list at all. Moreover, because the tracer knows\nnothing about the Person instance we are trying to process with method calls, there’s\nno way to create a bound method with an instance, and thus no way to correctly dispatch the call.\nIn fact, the prior listing winds up passing too few arguments to the decorated method,\nand results in an error. Add a line to the decorator’s __call__ to print all its arguments\nto verify this; as you can see, self is the tracer, and the Person instance is entirely absent:\n<__main__.tracer object at 0x02D6AD90> (0.25,) {}\ncall 1 to giveRaise\nTraceback (most recent call last):\nFile \"C:/misc/tracer.py\", line 56, in <module>\nbob.giveRaise(.25)\nFile \"C:/misc/tracer.py\", line 9, in __call__\nreturn self.func(*args, **kwargs)\nTypeError: giveRaise() takes exactly 2 positional arguments (1 given)",
    "As mentioned earlier, this happens because Python passes the implied subject instance\nto self when a method name is bound to a simple function only; when it is an instance\nof a callable class, that class’s instance is passed instead. Technically, Python only\nmakes a bound method object containing the subject instance when the method is a\nsimple function.\n\n1002 | Chapter 38: Decorators",
    "Using nested functions to decorate methods\nIf you want your function decorators to work on both simple functions and class methods, the most straightforward solution lies in using one of the other state retention\nsolutions described earlier—code your function decorator as nested defs, so that you\ndon’t depend on a single self instance argument to be both the wrapper class instance\nand the subject class instance.\nThe following alternative applies this fix using Python 3.0 nonlocals. Because decorated\nmethods are rebound to simple functions instead of instance objects, Python correctly\npasses the Person object as the first argument, and the decorator propagates it on in the\nfirst item of *args to the self argument of the real, decorated methods:\n# A decorator for both functions and methods\ndef tracer(func):\n# Use function, not class with __call__\ncalls = 0\n# Else \"self\" is decorator instance only!\ndef onCall(*args, **kwargs):\nnonlocal calls\ncalls += 1",
    "passes the Person object as the first argument, and the decorator propagates it on in the\nfirst item of *args to the self argument of the real, decorated methods:\n# A decorator for both functions and methods\ndef tracer(func):\n# Use function, not class with __call__\ncalls = 0\n# Else \"self\" is decorator instance only!\ndef onCall(*args, **kwargs):\nnonlocal calls\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nreturn func(*args, **kwargs)\nreturn onCall\n# Applies to simple functions\n@tracer\ndef spam(a, b, c):\nprint(a + b + c)\nspam(1, 2, 3)\nspam(a=4, b=5, c=6)",
    "# spam = tracer(spam)\n# onCall remembers spam\n# Runs onCall(1, 2, 3)\n\n# Applies to class method functions too!\nclass Person:\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\n@tracer\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\n@tracer\ndef lastName(self):\nreturn self.name.split()[-1]\n\n# giveRaise = tracer(giverRaise)\n# onCall remembers giveRaise\n# lastName = tracer(lastName)\n\nprint('methods...')\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nprint(bob.name, sue.name)\n\nCoding Function Decorators | 1003\n\n\fsue.giveRaise(.10)\nprint(sue.pay)\nprint(bob.lastName(), sue.lastName())\n\n# Runs onCall(sue, .10)\n# Runs onCall(bob), lastName in scopes\n\nThis version works the same on both functions and methods:\ncall 1 to spam\n6\ncall 2 to spam\n15\nmethods...\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones",
    "# Runs onCall(sue, .10)\n# Runs onCall(bob), lastName in scopes\n\nThis version works the same on both functions and methods:\ncall 1 to spam\n6\ncall 2 to spam\n15\nmethods...\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones\n\nUsing descriptors to decorate methods\nAlthough the nested function solution illustrated in the prior section is the most\nstraightforward way to support decorators that apply to both functions and class methods, other schemes are possible. The descriptor feature we explored in the prior chapter,\nfor example, can help here as well.\nRecall from our discussion in that chapter that a descriptor may be a class attribute\nassigned to objects with a __get__ method run automatically when that attribute is\nreferenced and fetched (object derivation is required in Python 2.6, but not 3.0):\nclass Descriptor(object):\ndef __get__(self, instance, owner): ...\nclass Subject:\nattr = Descriptor()\nX = Subject()\nX.attr",
    "# Roughly runs Descriptor.__get__(Subject.attr, X, Subject)\n\nDescriptors may also have __set__ and __del__ access methods, but we don’t need\nthem here. Now, because the descriptor’s __get__ method receives both the descriptor\nclass and subject class instances when invoked, it’s well suited to decorating methods\nwhen we need both the decorator’s state and the original class instance for dispatching\ncalls. Consider the following alternative tracing decorator, which is also a descriptor:\nclass tracer(object):\ndef __init__(self, func):\n# On @ decorator\nself.calls = 0\n# Save func for later call\nself.func = func\ndef __call__(self, *args, **kwargs):\n# On call to original func\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))\nreturn self.func(*args, **kwargs)\ndef __get__(self, instance, owner):\n# On method attribute fetch\nreturn wrapper(self, instance)\n\n1004 | Chapter 38: Decorators",
    "1004 | Chapter 38: Decorators\n\n\fclass wrapper:\ndef __init__(self, desc, subj):\n# Save both instances\nself.desc = desc\n# Route calls back to decr\nself.subj = subj\ndef __call__(self, *args, **kwargs):\nreturn self.desc(self.subj, *args, **kwargs) # Runs tracer.__call__\n@tracer\ndef spam(a, b, c):\n...same as prior...\n\n# spam = tracer(spam)\n# Uses __call__ only\n\nclass Person:\n@tracer\ndef giveRaise(self, percent):\n...same as prior...\n\n# giveRaise = tracer(giverRaise)\n# Makes giveRaise a descriptor\n\nThis works the same as the preceding nested function coding. Decorated functions\ninvoke only its __call__, while decorated methods invoke its __get__ first to resolve\nthe method name fetch (on instance.method); the object returned by __get__ retains\nthe subject class instance and is then invoked to complete the call expression, thereby\ntriggering __call__ (on (args...)). For example, the test code’s call to:\nsue.giveRaise(.10)\n\n# Runs __get__ then __call__",
    "run’s tracer.__get__ first, because the giveRaise attribute in the Person class has been\nrebound to a descriptor by the function decorator. The call expression then triggers the\n__call__ method of the returned wrapper object, which in turn invokes\ntracer.__call__.\nThe wrapper object retains both descriptor and subject instances, so it can route control\nback to the original decorator/descriptor class instance. In effect, the wrapper object\nsaves the subject class instance available during method attribute fetch and adds it to\nthe later call’s arguments list, which is passed to __call__. Routing the call back to the\ndescriptor class instance this way is required in this application so that all calls to a\nwrapped method use the same calls counter state information in the descriptor instance object.\nAlternatively, we could use a nested function and enclosing scope references to achieve",
    "the later call’s arguments list, which is passed to __call__. Routing the call back to the\ndescriptor class instance this way is required in this application so that all calls to a\nwrapped method use the same calls counter state information in the descriptor instance object.\nAlternatively, we could use a nested function and enclosing scope references to achieve\nthe same effect—the following version works the same as the preceding one, by swapping a class and object attributes for a nested function and scope references, but it\nrequires noticeably less code:\nclass tracer(object):\ndef __init__(self, func):\n# On @ decorator\nself.calls = 0\n# Save func for later call\nself.func = func\ndef __call__(self, *args, **kwargs):\n# On call to original func\nself.calls += 1\nprint('call %s to %s' % (self.calls, self.func.__name__))\nreturn self.func(*args, **kwargs)\ndef __get__(self, instance, owner):\n# On method fetch\ndef wrapper(*args, **kwargs):\n# Retain both inst",
    "Coding Function Decorators | 1005\n\n\freturn self(instance, *args, **kwargs)\nreturn wrapper\n\n# Runs __call__",
    "Add print statements to these alternatives’ methods to trace the two-step get/call\nprocess on your own, and run them with the same test code as in the nested function\nalternative shown earlier. In either coding, this descriptor-based scheme is also substantially subtler than the nested function option, and so is probably a second choice\nhere; it may be a useful coding pattern in other contexts, though.\nIn the rest of this chapter we’re going to be fairly casual about using classes or functions\nto code our function decorators, as long as they are applied only to functions. Some\ndecorators may not require the instance of the original class, and will still work on both\nfunctions and methods if coded as a class—something like Python’s own\nstaticmethod decorator, for example, wouldn’t require an instance of the subject class\n(indeed, its whole point is to remove the instance from the call).\nThe moral of this story, though, is that if you want your decorators to work on both",
    "decorators may not require the instance of the original class, and will still work on both\nfunctions and methods if coded as a class—something like Python’s own\nstaticmethod decorator, for example, wouldn’t require an instance of the subject class\n(indeed, its whole point is to remove the instance from the call).\nThe moral of this story, though, is that if you want your decorators to work on both\nsimple functions and class methods, you’re better off using the nested-function-based\ncoding pattern outlined here instead of a class with call interception.",
    "Timing Calls\nTo sample the fuller flavor of what function decorators are capable of, let’s turn to a\ndifferent use case. Our next decorator times calls made to a decorated function—both\nthe time for one call, and the total time among all calls. The decorator is applied to two\nfunctions, in order to compare the time requirements of list comprehensions and the\nmap built-in call (for comparison, also see Chapter 20 for another nondecorator example\nthat times iteration alternatives like these):\nimport time\nclass timer:\ndef __init__(self, func):\nself.func\n= func\nself.alltime = 0\ndef __call__(self, *args, **kargs):\nstart\n= time.clock()\nresult = self.func(*args, **kargs)\nelapsed = time.clock() - start\nself.alltime += elapsed\nprint('%s: %.5f, %.5f' % (self.func.__name__, elapsed, self.alltime))\nreturn result\n@timer\ndef listcomp(N):\nreturn [x * 2 for x in range(N)]\n@timer\ndef mapcall(N):\nreturn map((lambda x: x * 2), range(N))\n\n1006 | Chapter 38: Decorators",
    "1006 | Chapter 38: Decorators\n\n\fresult = listcomp(5)\n# Time for this call, all calls, return value\nlistcomp(50000)\nlistcomp(500000)\nlistcomp(1000000)\nprint(result)\nprint('allTime = %s' % listcomp.alltime)\n# Total time for all listcomp calls\nprint('')\nresult = mapcall(5)\nmapcall(50000)\nmapcall(500000)\nmapcall(1000000)\nprint(result)\nprint('allTime = %s' % mapcall.alltime)\n\n# Total time for all mapcall calls\n\nprint('map/comp = %s' % round(mapcall.alltime / listcomp.alltime, 3))",
    "# Total time for all mapcall calls\n\nprint('map/comp = %s' % round(mapcall.alltime / listcomp.alltime, 3))\n\nIn this case, a nondecorator approach would allow the subject functions to be used\nwith or without timing, but it would also complicate the call signature when timing is\ndesired (we’d need to add code at every call instead of once at the def), and there would\nbe no direct way to guarantee that all list builder calls in a program are routed through\ntimer logic, short of finding and potentially changing them all.\nWhen run in Python 2.6, the output of this file’s self-test code is as follows:\nlistcomp: 0.00002, 0.00002\nlistcomp: 0.00910, 0.00912\nlistcomp: 0.09105, 0.10017\nlistcomp: 0.17605, 0.27622\n[0, 2, 4, 6, 8]\nallTime = 0.276223304917\nmapcall: 0.00003, 0.00003\nmapcall: 0.01363, 0.01366\nmapcall: 0.13579, 0.14945\nmapcall: 0.27648, 0.42593\n[0, 2, 4, 6, 8]\nallTime = 0.425933533452\nmap/comp = 1.542",
    "Testing subtlety: I didn’t run this under Python 3.0 because, as described in Chapter 14, the map built-in returns an iterator in 3.0, instead of an actual list as in 2.6. Hence,\n3.0’s map doesn’t quite compare directly to a list comprehension’s work (as is, the map\ntest takes virtually no time at all in 3.0!).\nIf you wish to run this under 3.0, too, use list(map()) to force it to build a list like the\nlist comprehension does, or else you’re not really comparing apples to apples. Don’t\ndo so in 2.6, though—if you do, the map test will be charged for building two lists, not\none.\nThe following sort of code would pick fairly for 2.6 and 3.0; note, though, that while\nthis makes the comparison between list comprehensions and map more fair in either 2.6\n\nCoding Function Decorators | 1007",
    "Coding Function Decorators | 1007\n\n\for 3.0, because range is also an iterator in 3.0, the results for 2.6 and 3.0 won’t compare\ndirectly:\n...\nimport sys\n@timer\ndef listcomp(N):\nreturn [x * 2 for x in range(N)]\nif sys.version_info[0] == 2:\n@timer\ndef mapcall(N):\nreturn map((lambda x: x * 2), range(N))\nelse:\n@timer\ndef mapcall(N):\nreturn list(map((lambda x: x * 2), range(N)))\n...\n\nFinally, as we learned in the modules part of this book if you want to be able to reuse\nthis decorator in other modules, you should indent the self-test code at the bottom of\nthe file under a __name__ == '__main__' test so it runs only when the file is run, not\nwhen it’s imported. We won’t do this, though, because we’re about to add another\nfeature to our code.",
    "Finally, as we learned in the modules part of this book if you want to be able to reuse\nthis decorator in other modules, you should indent the self-test code at the bottom of\nthe file under a __name__ == '__main__' test so it runs only when the file is run, not\nwhen it’s imported. We won’t do this, though, because we’re about to add another\nfeature to our code.\n\nAdding Decorator Arguments\nThe timer decorator of the prior section works, but it would be nice if it was more\nconfigurable—providing an output label and turning trace messages on and off, for\ninstance, might be useful in a general-purpose tool like this. Decorator arguments come\nin handy here: when they’re coded properly, we can use them to specify configuration\noptions that can vary for each decorated function. A label, for instance, might be added\nas follows:\ndef timer(label=''):\ndef decorator(func):\ndef onCall(*args):\n...\nprint(label, ...\nreturn onCall\nreturn decorator",
    "# args passed to function\n# func retained in enclosing scope\n# label retained in enclosing scope\n\n@timer('==>')\ndef listcomp(N): ...\n\n# Like listcomp = timer('==>')(listcomp)\n# listcomp is rebound to decorator\n\nlistcomp(...)\n\n# Really calls decorator\n\n# Returns that actual decorator\n\nThis code adds an enclosing scope to retain a decorator argument for use on a later\nactual call. When the listcomp function is defined, it really invokes decorator (the result\nof timer, run before decoration actually occurs), with the label value available in its\nenclosing scope. That is, timer returns the decorator, which remembers both the\n1008 | Chapter 38: Decorators",
    "decorator argument and the original function and returns a callable which invokes the\noriginal function on later calls.\nWe can put this structure to use in our timer to allow a label and a trace control flag to\nbe passed in at decoration time. Here’s an example that does just that, coded in a\nmodule file named mytools.py so it can be imported as a general tool:\nimport time\ndef timer(label='', trace=True):\n# On decorator args: retain args\nclass Timer:\ndef __init__(self, func):\n# On @: retain decorated func\nself.func\n= func\nself.alltime = 0\ndef __call__(self, *args, **kargs):\n# On calls: call original\nstart\n= time.clock()\nresult = self.func(*args, **kargs)\nelapsed = time.clock() - start\nself.alltime += elapsed\nif trace:\nformat = '%s %s: %.5f, %.5f'\nvalues = (label, self.func.__name__, elapsed, self.alltime)\nprint(format % values)\nreturn result\nreturn Timer",
    "Mostly all we’ve done here is embed the original Timer class in an enclosing function,\nin order to create a scope that retains the decorator arguments. The outer timer function\nis called before decoration occurs, and it simply returns the Timer class to serve as the\nactual decorator. On decoration, an instance of Timer is made that remembers the decorated function itself, but also has access to the decorator arguments in the enclosing\nfunction scope.\nThis time, rather than embedding self-test code in this file, we’ll run the decorator in\na different file. Here’s a client of our timer decorator, the module file testseqs.py, applying it to sequence iteration alternatives again:\nfrom mytools import timer\n@timer(label='[CCC]==>')\ndef listcomp(N):\nreturn [x * 2 for x in range(N)]\n\n# Like listcomp = timer(...)(listcomp)\n# listcomp(...) triggers Timer.__call__",
    "# Like listcomp = timer(...)(listcomp)\n# listcomp(...) triggers Timer.__call__\n\n@timer(trace=True, label='[MMM]==>')\ndef mapcall(N):\nreturn map((lambda x: x * 2), range(N))\nfor func in (listcomp, mapcall):\nprint('')\nresult = func(5)\n# Time for this call, all calls, return value\nfunc(50000)\nfunc(500000)\nfunc(1000000)\nprint(result)\n\nCoding Function Decorators | 1009\n\n\fprint('allTime = %s' % func.alltime)\n\n# Total time for all calls\n\nprint('map/comp = %s' % round(mapcall.alltime / listcomp.alltime, 3))",
    "Coding Function Decorators | 1009\n\n\fprint('allTime = %s' % func.alltime)\n\n# Total time for all calls\n\nprint('map/comp = %s' % round(mapcall.alltime / listcomp.alltime, 3))\n\nAgain, if you wish to run this fairly in 3.0, wrap the map function in a list call. When\nrun as-is in 2.6, this file prints the following output—each decorated function now has\na label of its own, defined by decorator arguments:\n[CCC]==> listcomp: 0.00003, 0.00003\n[CCC]==> listcomp: 0.00640, 0.00643\n[CCC]==> listcomp: 0.08687, 0.09330\n[CCC]==> listcomp: 0.17911, 0.27241\n[0, 2, 4, 6, 8]\nallTime = 0.272407666337\n[MMM]==> mapcall: 0.00004, 0.00004\n[MMM]==> mapcall: 0.01340, 0.01343\n[MMM]==> mapcall: 0.13907, 0.15250\n[MMM]==> mapcall: 0.27907, 0.43157\n[0, 2, 4, 6, 8]\nallTime = 0.431572169089\nmap/comp = 1.584",
    "As usual, we can also test this interactively to see how the configuration arguments\ncome into play:\n>>> from mytools import timer\n>>> @timer(trace=False)\n... def listcomp(N):\n...\nreturn [x * 2 for x in range(N)]\n...\n>>> x = listcomp(5000)\n>>> x = listcomp(5000)\n>>> x = listcomp(5000)\n>>> listcomp\n<mytools.Timer instance at 0x025C77B0>\n>>> listcomp.alltime\n0.0051938863738243413\n>>> @timer(trace=True, label='\\t=>')\n... def listcomp(N):\n...\nreturn [x * 2 for x in range(N)]\n...\n>>> x = listcomp(5000)\n=> listcomp: 0.00155, 0.00155\n>>> x = listcomp(5000)\n=> listcomp: 0.00156, 0.00311\n>>> x = listcomp(5000)\n=> listcomp: 0.00174, 0.00486\n>>> listcomp.alltime\n0.0048562736325408196\n\n# No tracing, collect total time\n\n# Turn on tracing\n\nThis timing function decorator can be used for any function, both in modules and\ninteractively. In other words, it automatically qualifies as a general-purpose tool for\ntiming code in our scripts. Watch for another example of decorator arguments in the",
    "# No tracing, collect total time\n\n# Turn on tracing\n\nThis timing function decorator can be used for any function, both in modules and\ninteractively. In other words, it automatically qualifies as a general-purpose tool for\ntiming code in our scripts. Watch for another example of decorator arguments in the\n\n1010 | Chapter 38: Decorators\n\n\fsection “Implementing Private Attributes” on page 1023, and again in “A Basic RangeTesting Decorator for Positional Arguments” on page 1035.\nTiming methods: This section’s timer decorator works on any function,\nbut a minor rewrite is required to be able to apply it to class methods\ntoo. In short, as our earlier section “Class Blunders I: Decorating Class\nMethods” on page 1001 illustrated, it must avoid using a nested class.\nBecause this mutation will be a subject of one of our end-of-chapter quiz\nquestions, though, I’ll avoid giving away the answer completely here.",
    "Coding Class Decorators\nSo far we’ve been coding function decorators to manage function calls, but as we’ve\nseen, Python 2.6 and 3.0 extend decorators to work on classes too. As described earlier,\nwhile similar in concept to function decorators, class decorators are applied to classes\ninstead—they may be used either to manage classes themselves, or to intercept instance\ncreation calls in order to manage instances. Also like function decorators, class decorators are really just optional syntactic sugar, though many believe that they make a\nprogrammer’s intent more obvious and minimize erroneous calls.",
    "Singleton Classes\nBecause class decorators may intercept instance creation calls, they can be used to either\nmanage all the instances of a class, or augment the interfaces of those instances. To\ndemonstrate, here’s a first class decorator example that does the former—managing all\ninstances of a class. This code implements the classic singleton coding pattern, where\nat most one instance of a class ever exists. Its singleton function defines and returns a\nfunction for managing instances, and the @ syntax automatically wraps up a subject\nclass in this function:\ninstances = {}\ndef getInstance(aClass, *args):\nif aClass not in instances:\ninstances[aClass] = aClass(*args)\nreturn instances[aClass]\ndef singleton(aClass):\ndef onCall(*args):\nreturn getInstance(aClass, *args)\nreturn onCall\n\n# Manage global table\n# Add **kargs for keywords\n# One dict entry per class\n# On @ decoration\n# On instance creation",
    "# Manage global table\n# Add **kargs for keywords\n# One dict entry per class\n# On @ decoration\n# On instance creation\n\nTo use this, decorate the classes for which you want to enforce a single-instance model:\n@singleton\nclass Person:\ndef __init__(self, name, hours, rate):\nself.name = name\nself.hours = hours\n\n# Person = singleton(Person)\n# Rebinds Person to onCall\n# onCall remembers Person\n\nCoding Class Decorators | 1011\n\n\fself.rate = rate\ndef pay(self):\nreturn self.hours * self.rate\n@singleton\nclass Spam:\ndef __init__(self, val):\nself.attr = val\n\n# Spam = singleton(Spam)\n# Rebinds Spam to onCall\n# onCall remembers Spam\n\nbob = Person('Bob', 40, 10)\nprint(bob.name, bob.pay())\n\n# Really calls onCall\n\nsue = Person('Sue', 50, 20)\nprint(sue.name, sue.pay())\n\n# Same, single object\n\nX = Spam(42)\nY = Spam(99)\nprint(X.attr, Y.attr)\n\n# One Person, one Spam",
    "# Spam = singleton(Spam)\n# Rebinds Spam to onCall\n# onCall remembers Spam\n\nbob = Person('Bob', 40, 10)\nprint(bob.name, bob.pay())\n\n# Really calls onCall\n\nsue = Person('Sue', 50, 20)\nprint(sue.name, sue.pay())\n\n# Same, single object\n\nX = Spam(42)\nY = Spam(99)\nprint(X.attr, Y.attr)\n\n# One Person, one Spam\n\nNow, when the Person or Spam class is later used to create an instance, the wrapping\nlogic layer provided by the decorator routes instance construction calls to onCall, which\nin turn calls getInstance to manage and share a single instance per class, regardless of\nhow many construction calls are made. Here’s this code’s output:\nBob 400\nBob 400\n42 42",
    "# One Person, one Spam\n\nNow, when the Person or Spam class is later used to create an instance, the wrapping\nlogic layer provided by the decorator routes instance construction calls to onCall, which\nin turn calls getInstance to manage and share a single instance per class, regardless of\nhow many construction calls are made. Here’s this code’s output:\nBob 400\nBob 400\n42 42\n\nInterestingly, you can code a more self-contained solution here if you’re able to use the\nnonlocal statement (available in Python 3.0 and later) to change enclosing scope names,\nas described earlier—the following alternative achieves an identical effect, by using one\nenclosing scope per class, instead of one global table entry per class:\ndef singleton(aClass):\ninstance = None\ndef onCall(*args):\nnonlocal instance\nif instance == None:\ninstance = aClass(*args)\nreturn instance\nreturn onCall\n\n# On @ decoration\n# On instance creation\n# 3.0 and later nonlocal\n# One scope per class",
    "# On @ decoration\n# On instance creation\n# 3.0 and later nonlocal\n# One scope per class\n\nThis version works the same, but it does not depend on names in the global scope\noutside the decorator. In either Python 2.6 or 3.0, you can also code a self-contained\nsolution with a class instead—the following uses one instance per class, rather than an\nenclosing scope or global table, and works the same as the other two versions (in fact,\nit relies on the same coding pattern that we will later see is a common decorator class\nblunder; here we want just one instance, but that’s not always the case):\nclass singleton:\ndef __init__(self, aClass):\nself.aClass = aClass\nself.instance = None\ndef __call__(self, *args):\n\n1012 | Chapter 38: Decorators\n\n# On @ decoration\n# On instance creation\n\n\fif self.instance == None:\nself.instance = self.aClass(*args) # One instance per class\nreturn self.instance",
    "1012 | Chapter 38: Decorators\n\n# On @ decoration\n# On instance creation\n\n\fif self.instance == None:\nself.instance = self.aClass(*args) # One instance per class\nreturn self.instance\n\nTo make this decorator a fully general-purpose tool, store it in an importable module\nfile, indent the self-test code under a __name__ check, and add support for keyword\narguments in construction calls with **kargs syntax (I’ll leave this as a suggested\nexercise).",
    "Tracing Object Interfaces\nThe singleton example of the prior section illustrated using class decorators to manage\nall the instances of a class. Another common use case for class decorators augments\nthe interface of each generated instance. Class decorators can essentially install on instances a wrapper logic layer that manages access to their interfaces in some way.\nFor example, in Chapter 30, the __getattr__ operator overloading method is shown as\na way to wrap up entire object interfaces of embedded instances, in order to implement\nthe delegation coding pattern. We saw similar examples in the managed attribute coverage of the prior chapter. Recall that __getattr__ is run when an undefined attribute\nname is fetched; we can use this hook to intercept method calls in a controller class\nand propagate them to an embedded object.\nFor reference, here’s the original nondecorator delegation example, working on two\nbuilt-in type objects:\nclass Wrapper:\ndef __init__(self, object):",
    "name is fetched; we can use this hook to intercept method calls in a controller class\nand propagate them to an embedded object.\nFor reference, here’s the original nondecorator delegation example, working on two\nbuilt-in type objects:\nclass Wrapper:\ndef __init__(self, object):\nself.wrapped = object\ndef __getattr__(self, attrname):\nprint('Trace:', attrname)\nreturn getattr(self.wrapped, attrname)",
    "# Save object\n# Trace fetch\n# Delegate fetch\n\n>>> x = Wrapper([1,2,3])\n>>> x.append(4)\nTrace: append\n>>> x.wrapped\n[1, 2, 3, 4]\n\n# Wrap a list\n# Delegate to list method\n\n>>> x = Wrapper({\"a\": 1, \"b\": 2})\n>>> list(x.keys())\nTrace: keys\n['a', 'b']\n\n# Wrap a dictionary\n# Delegate to dictionary method\n# Use list() in 3.0\n\n# Print my member\n\nIn this code, the Wrapper class intercepts access to any of the wrapped object’s attributes,\nprints a trace message, and uses the getattr built-in to pass off the request to the\nwrapped object. Specifically, it traces attribute accesses made outside the wrapped object’s class; accesses inside the wrapped object’s methods are not caught and run normally by design. This whole-interface model differs from the behavior of function decorators, which wrap up just one specific method.\n\nCoding Class Decorators | 1013",
    "Coding Class Decorators | 1013\n\n\fClass decorators provide an alternative and convenient way to code this __getattr__\ntechnique to wrap an entire interface. In 2.6 and 3.0, for example, the prior class example can be coded as a class decorator that triggers wrapped instance creation, instead\nof passing a pre-made instance into the wrapper’s constructor (also augmented here to\nsupport keyword arguments with **kargs and to count the number of accesses made):\ndef Tracer(aClass):\nclass Wrapper:\ndef __init__(self, *args, **kargs):\nself.fetches = 0\nself.wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attrname):\nprint('Trace: ' + attrname)\nself.fetches += 1\nreturn getattr(self.wrapped, attrname)\nreturn Wrapper\n@Tracer\nclass Spam:\ndef display(self):\nprint('Spam!' * 8)\n@Tracer\nclass Person:\ndef __init__(self, name, hours, rate):\nself.name = name\nself.hours = hours\nself.rate = rate\ndef pay(self):\nreturn self.hours * self.rate",
    "# On @ decorator\n# On instance creation\n# Use enclosing scope name\n# Catches all but own attrs\n# Delegate to wrapped obj\n\n# Spam = Tracer(Spam)\n# Spam is rebound to Wrapper\n\n# Person = Tracer(Person)\n# Wrapper remembers Person\n\n# Accesses outside class traced\n# In-method accesses not traced\n\nfood = Spam()\nfood.display()\nprint([food.fetches])\n\n# Triggers Wrapper()\n# Triggers __getattr__\n\nbob = Person('Bob', 40, 50)\nprint(bob.name)\nprint(bob.pay())\n\n# bob is really a Wrapper\n# Wrapper embeds a Person\n\nprint('')\nsue = Person('Sue', rate=100, hours=60)\nprint(sue.name)\nprint(sue.pay())\nprint(bob.name)\nprint(bob.pay())\nprint([bob.fetches, sue.fetches])\n\n# sue is a different Wrapper\n# with a different Person\n# bob has different state\n# Wrapper attrs not traced",
    "bob = Person('Bob', 40, 50)\nprint(bob.name)\nprint(bob.pay())\n\n# bob is really a Wrapper\n# Wrapper embeds a Person\n\nprint('')\nsue = Person('Sue', rate=100, hours=60)\nprint(sue.name)\nprint(sue.pay())\nprint(bob.name)\nprint(bob.pay())\nprint([bob.fetches, sue.fetches])\n\n# sue is a different Wrapper\n# with a different Person\n# bob has different state\n# Wrapper attrs not traced\n\nIt’s important to note that this is very different from the tracer decorator we met earlier.\nIn “Coding Function Decorators” on page 996, we looked at decorators that enabled\nus to trace and time calls to a given function or method. In contrast, by intercepting\ninstance creation calls, the class decorator here allows us to trace an entire object\ninterface—i.e., accesses to any of its attributes.\n\n1014 | Chapter 38: Decorators",
    "1014 | Chapter 38: Decorators\n\n\fThe following is the output produced by this code under both 2.6 and 3.0: attribute\nfetches on instances of both the Spam and Person classes invoke the __getattr__ logic\nin the Wrapper class, because food and bob are really instances of Wrapper, thanks to the\ndecorator’s redirection of instance creation calls:\nTrace: display\nSpam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!\n[1]\nTrace: name\nBob\nTrace: pay\n2000\nTrace: name\nSue\nTrace: pay\n6000\nTrace: name\nBob\nTrace: pay\n2000\n[4, 2]",
    "Notice that the preceding code decorates a user-defined class. Just like in the original\nexample in Chapter 30, we can also use the decorator to wrap up a built-in type such\nas a list, as long as we either subclass to allow decoration syntax or perform the decoration manually—decorator syntax requires a class statement for the @ line.\nIn the following, x is really a Wrapper again due to the indirection of decoration (I moved\nthe decorator class to module file tracer.py in order to reuse it this way):\n>>> from tracer import Tracer\n\n# Decorator moved to a module file\n\n>>> @Tracer\n... class MyList(list): pass\n\n# MyList = Tracer(MyList)\n\n>>> x = MyList([1, 2, 3])\n>>> x.append(4)\nTrace: append\n>>> x.wrapped\n[1, 2, 3, 4]\n\n# Triggers Wrapper()\n# Triggers __getattr__, append\n\n>>> WrapList = Tracer(list)\n>>> x = WrapList([4, 5, 6])\n>>> x.append(7)\nTrace: append\n>>> x.wrapped\n[4, 5, 6, 7]\n\n# Or perform decoration manually\n# Else subclass statement required",
    ">>> @Tracer\n... class MyList(list): pass\n\n# MyList = Tracer(MyList)\n\n>>> x = MyList([1, 2, 3])\n>>> x.append(4)\nTrace: append\n>>> x.wrapped\n[1, 2, 3, 4]\n\n# Triggers Wrapper()\n# Triggers __getattr__, append\n\n>>> WrapList = Tracer(list)\n>>> x = WrapList([4, 5, 6])\n>>> x.append(7)\nTrace: append\n>>> x.wrapped\n[4, 5, 6, 7]\n\n# Or perform decoration manually\n# Else subclass statement required\n\nThe decorator approach allows us to move instance creation into the decorator itself,\ninstead of requiring a premade object to be passed in. Although this seems like a minor\ndifference, it lets us retain normal instance creation syntax and realize all the benefits\n\nCoding Class Decorators | 1015\n\n\fof decorators in general. Rather than requiring all instance creation calls to route objects\nthrough a wrapper manually, we need only augment classes with decorator syntax:\n@Tracer\nclass Person: ...\nbob = Person('Bob', 40, 50)\nsue = Person('Sue', rate=100, hours=60)\n\n# Decorator approach",
    "Coding Class Decorators | 1015\n\n\fof decorators in general. Rather than requiring all instance creation calls to route objects\nthrough a wrapper manually, we need only augment classes with decorator syntax:\n@Tracer\nclass Person: ...\nbob = Person('Bob', 40, 50)\nsue = Person('Sue', rate=100, hours=60)\n\n# Decorator approach\n\nclass Person: ...\n# Non-decorator approach\nbob = Wrapper(Person('Bob', 40, 50))\nsue = Wrapper(Person('Sue', rate=100, hours=60))",
    "Assuming you will make more than one instance of a class, decorators will generally\nbe a net win in terms of both code size and code maintenance.\nAttribute version skew note: As we learned in Chapter 37, __getattr__\nwill intercept accesses to operator overloading methods like __str__ and\n__repr__ in Python 2.6, but not in 3.0.\nIn Python 3.0, class instances inherit defaults for some (but not all) of\nthese names from the class (really, from the automatic object superclass), because all classes are “new-style.” Moreover, in 3.0 implicitly\ninvoked attributes for built-in operations like printing and + are not\nrouted through __getattr__ (or its cousin, __getattribute__). Newstyle classes look up such methods in classes and skip the normal\ninstance lookup entirely.\nHere, this means that the __getattr__-based tracing wrapper will automatically trace and propagate operator overloading calls in 2.6, but not",
    "invoked attributes for built-in operations like printing and + are not\nrouted through __getattr__ (or its cousin, __getattribute__). Newstyle classes look up such methods in classes and skip the normal\ninstance lookup entirely.\nHere, this means that the __getattr__-based tracing wrapper will automatically trace and propagate operator overloading calls in 2.6, but not\nin 3.0. To see this, display “x” directly at the end of the preceding interactive session—in 2.6 the attribute __repr__ is traced and the list\nprints as expected, but in 3.0 no trace occurs and the list prints using a\ndefault display for the Wrapper class:\n>>> x\nTrace: __repr__\n[4, 5, 6, 7]\n>>> x\n<tracer.Wrapper object at 0x026C07D0>",
    "# 2.6\n# 3.0\n\nTo work the same in 3.0, operator overloading methods generally need\nto be redefined redundantly in the wrapper class, either by hand, by\ntools, or by definition in superclasses. Only simple named attributes will\nwork the same in both versions. We’ll see this version skew at work\nagain in a Private decorator later in this chapter.\n\nClass Blunders II: Retaining Multiple Instances\nCuriously, the decorator function in this example can almost be coded as a class instead\nof a function, with the proper operator overloading protocol. The following slightly\nsimplified alternative works similarly because its __init__ is triggered when the @ decorator is applied to the class, and its __call__ is triggered when a subject class instance\n1016 | Chapter 38: Decorators",
    "is created. Our objects are really instances of Tracer this time, and we essentially just\ntrade an enclosing scope reference for an instance attribute here:\nclass Tracer:\ndef __init__(self, aClass):\n# On @decorator\nself.aClass = aClass\n# Use instance attribute\ndef __call__(self, *args):\n# On instance creation\nself.wrapped = self.aClass(*args)\n# ONE (LAST) INSTANCE PER CLASS!\nreturn self\ndef __getattr__(self, attrname):\nprint('Trace: ' + attrname)\nreturn getattr(self.wrapped, attrname)\n@Tracer\nclass Spam:\ndef display(self):\nprint('Spam!' * 8)\n...\nfood = Spam()\nfood.display()\n\n# Triggers __init__\n# Like: Spam = Tracer(Spam)\n\n# Triggers __call__\n# Triggers __getattr__",
    "# Triggers __init__\n# Like: Spam = Tracer(Spam)\n\n# Triggers __call__\n# Triggers __getattr__\n\nAs we saw in the abstract earlier, though, this class-only alternative handles multiple\nclasses as before, but it won’t quite work for multiple instances of a given class: each\ninstance construction call triggers __call__, which overwrites the prior instance. The\nnet effect is that Tracer saves just one instance—the last one created. Experiment with\nthis yourself to see how, but here’s an example of the problem:\n@Tracer\nclass Person:\ndef __init__(self, name):\nself.name = name\nbob = Person('Bob')\nprint(bob.name)\nSue = Person('Sue')\nprint(sue.name)\nprint(bob.name)\n\n# Person = Tracer(Person)\n# Wrapper bound to Person\n# bob is really a Wrapper\n# Wrapper embeds a Person\n# sue overwrites bob\n# OOPS: now bob's name is 'Sue'!\n\nThis code’s output follows—because this tracer only has a single shared instance, the\nsecond overwrites the first:\nTrace: name\nBob\nTrace: name\nSue\nTrace: name\nSue",
    "# Person = Tracer(Person)\n# Wrapper bound to Person\n# bob is really a Wrapper\n# Wrapper embeds a Person\n# sue overwrites bob\n# OOPS: now bob's name is 'Sue'!\n\nThis code’s output follows—because this tracer only has a single shared instance, the\nsecond overwrites the first:\nTrace: name\nBob\nTrace: name\nSue\nTrace: name\nSue\n\nThe problem here is bad state retention—we make one decorator instance per class,\nbut not per class instance, such that only the last instance is retained. The solution, as\nin our prior class blunder for decorating methods, lies in abandoning class-based\ndecorators.\n\nCoding Class Decorators | 1017",
    "The problem here is bad state retention—we make one decorator instance per class,\nbut not per class instance, such that only the last instance is retained. The solution, as\nin our prior class blunder for decorating methods, lies in abandoning class-based\ndecorators.\n\nCoding Class Decorators | 1017\n\n\fThe earlier function-based Tracer version does work for multiple instances, because\neach instance construction call makes a new Wrapper instance, instead of overwriting\nthe state of a single shared Tracer instance; the original nondecorator version handles\nmultiple instances correctly for the same reason. Decorators are not only arguably\nmagical, they can also be incredibly subtle!",
    "The earlier function-based Tracer version does work for multiple instances, because\neach instance construction call makes a new Wrapper instance, instead of overwriting\nthe state of a single shared Tracer instance; the original nondecorator version handles\nmultiple instances correctly for the same reason. Decorators are not only arguably\nmagical, they can also be incredibly subtle!\n\nDecorators Versus Manager Functions\nRegardless of such subtleties, the Tracer class decorator example ultimately still relies\non __getattr__ to intercept fetches on a wrapped and embedded instance object. As\nwe saw earlier, all we’ve really accomplished is moving the instance creation call inside\na class, instead of passing the instance into a manager function. With the original nondecorator tracing example, we would simply code instance creation differently:\nclass Spam:\n...\nfood = Wrapper(Spam())\n\n# Non-decorator version\n# Any class will do\n# Special creation syntax",
    "# Non-decorator version\n# Any class will do\n# Special creation syntax\n\n@Tracer\nclass Spam:\n...\nfood = Spam()\n\n# Decorator version\n# Requires @ syntax at class\n# Normal creation syntax\n\nEssentially, class decorators shift special syntax requirements from the instance creation\ncall to the class statement itself. This is also true for the singleton example earlier in\nthis section—rather than decorating a class and using normal instance creation calls,\nwe could simply pass the class and its construction arguments into a manager function:\ninstances = {}\ndef getInstance(aClass, *args):\nif aClass not in instances:\ninstances[aClass] = aClass(*args)\nreturn instances[aClass]\nbob = getInstance(Person, 'Bob', 40, 10)\n\n# Versus: bob = Person('Bob', 40, 10)",
    "# Versus: bob = Person('Bob', 40, 10)\n\nAlternatively, we could use Python’s introspection facilities to fetch the class from an\nalready-created instance (assuming creating an initial instance is acceptable):\ninstances = {}\ndef getInstance(object):\naClass = object.__class__\nif aClass not in instances:\ninstances[aClass] = object\nreturn instances[aClass]\nbob = getInstance(Person('Bob', 40, 10))\n\n# Versus: bob = Person('Bob', 40, 10)\n\nThe same holds true for function decorators like the tracer we wrote earlier: rather than\ndecorating a function with logic that intercepts later calls, we could simply pass the\nfunction and its arguments into a manager that dispatches the call:\n\n1018 | Chapter 38: Decorators\n\n\fdef func(x, y):\n...\nresult = tracer(func, (1, 2))\n\n# Nondecorator version\n# def tracer(func, args): ... func(*args)\n# Special call syntax\n\n@tracer\ndef func(x, y):\n...\nresult = func(1, 2)\n\n# Decorator version\n# Rebinds name: func = tracer(func)\n# Normal call syntax",
    "1018 | Chapter 38: Decorators\n\n\fdef func(x, y):\n...\nresult = tracer(func, (1, 2))\n\n# Nondecorator version\n# def tracer(func, args): ... func(*args)\n# Special call syntax\n\n@tracer\ndef func(x, y):\n...\nresult = func(1, 2)\n\n# Decorator version\n# Rebinds name: func = tracer(func)\n# Normal call syntax\n\nManager function approaches like this place the burden of using special syntax on\ncalls, instead of expecting decoration syntax at function and class definitions.",
    "Why Decorators? (Revisited)\nSo why did I just show you ways to not use decorators to implement singletons? As I\nmentioned at the start of this chapter, decorators present us with tradeoffs. Although\nsyntax matters, we all too often forget to ask the “why” questions when confronted\nwith new tools. Now that we’ve seen how decorators actually work, let’s step back for\na minute to glimpse the big picture here.\nLike most language features, decorators have both pros and cons. For example, in the\nnegatives column, class decorators suffer from two potential drawbacks:\nType changes\nAs we’ve seen, when wrappers are inserted, a decorated function or class does not\nretain its original type—its name is rebound to a wrapper object, which might\nmatter in programs that use object names or test object types. In the singleton\nexample, both the decorator and manager function approaches retain the original",
    "Type changes\nAs we’ve seen, when wrappers are inserted, a decorated function or class does not\nretain its original type—its name is rebound to a wrapper object, which might\nmatter in programs that use object names or test object types. In the singleton\nexample, both the decorator and manager function approaches retain the original\nclass type for instances; in the tracer code, neither approach does, because wrappers are required.\nExtra calls\nA wrapping layer added by decoration incurs the additional performance cost of\nan extra call each time the decorated object is invoked—calls are relatively timeexpensive operations, so decoration wrappers can make a program slower. In the\ntracer code, both approaches require each attribute to be routed through a wrapper\nlayer; the singleton example avoids extra calls by retaining the original class type.",
    "an extra call each time the decorated object is invoked—calls are relatively timeexpensive operations, so decoration wrappers can make a program slower. In the\ntracer code, both approaches require each attribute to be routed through a wrapper\nlayer; the singleton example avoids extra calls by retaining the original class type.\nSimilar concerns apply with function decorators: both decoration and manager functions incur extra calls, and type changes generally occur when decorating (but not\notherwise).\nThat said, neither of these is a very serious issue. For most programs, the type difference\nissue is unlikely to matter and the speed hit of the extra calls will be insignificant;\nfurthermore, the latter occurs only when wrappers are used, can often be negated by\nsimply removing the decorator when optimal performance is required, and is also incurred by nondecorator solutions that add wrapping logic (including metaclasses, as\nwe’ll see in Chapter 39).",
    "Coding Class Decorators | 1019",
    "Conversely, as we saw at the start of this chapter, decorators have three main advantages. Compared to the manager (a.k.a. “helper”) function solutions of the prior section, decorators offer:\nExplicit syntax\nDecorators make augmentation explicit and obvious. Their @ syntax is easier to\nrecognize than special code in calls that may appear anywhere in a source file—in\nour singleton and tracer examples, for instance, the decorator lines seem more\nlikely to be noticed than extra code at calls would be. Moreover, decorators allow\nfunction and instance creation calls to use normal syntax familiar to all Python\nprogrammers.\nCode maintenance\nDecorators avoid repeated augmentation code at each function or class call. Because they appear just once, at the definition of the class or function itself, they\nobviate redundancy and simplify future code maintenance. For our singleton and\ntracer cases, we need to use special code at each call to use a manager function",
    "programmers.\nCode maintenance\nDecorators avoid repeated augmentation code at each function or class call. Because they appear just once, at the definition of the class or function itself, they\nobviate redundancy and simplify future code maintenance. For our singleton and\ntracer cases, we need to use special code at each call to use a manager function\napproach—extra work is required both initially and for any modifications that\nmust be made in the future.\nConsistency\nDecorators make it less likely that a programmer will forget to use required wrapping logic. This derives mostly from the two prior advantages—because decoration\nis explicit and appears only once, at the decorated objects themselves, decorators\npromote more consistent and uniform API usage than special code that must be\nincluded at each call. In the singleton example, for instance, it would be easy to\nforget to route all class creation calls through special code, which would subvert\nthe singleton management altogether.",
    "is explicit and appears only once, at the decorated objects themselves, decorators\npromote more consistent and uniform API usage than special code that must be\nincluded at each call. In the singleton example, for instance, it would be easy to\nforget to route all class creation calls through special code, which would subvert\nthe singleton management altogether.\nDecorators also promote code encapsulation to reduce redundancy and minimize future\nmaintenance effort; although other code structuring tools do too, decorators make this\nnatural for augmentation tasks.\nNone of these benefits completely requires decorator syntax to be achieved, though,\nand decorator usage is ultimately a stylistic choice. That said, most programmers find\nthem to be a net win, especially as a tool for using libraries and APIs correctly.\nI can recall similar arguments being made both for and against constructor functions\nin classes—prior to the introduction of __init__ methods, the same effect was often",
    "and decorator usage is ultimately a stylistic choice. That said, most programmers find\nthem to be a net win, especially as a tool for using libraries and APIs correctly.\nI can recall similar arguments being made both for and against constructor functions\nin classes—prior to the introduction of __init__ methods, the same effect was often\nachieved by running an instance through a method manually when creating it (e.g.,\nX=Class().init()). Over time, though, despite being fundamentally a stylistic choice,\nthe __init__ syntax came to be universally preferred because it was more explicit, consistent, and maintainable. Although you should be the judge, decorators seem to bring\nmany of the same assets to the table.",
    "1020 | Chapter 38: Decorators",
    "Managing Functions and Classes Directly\nMost of our examples in this chapter have been designed to intercept function and\ninstance creation calls. Although this is typical for decorators, they are not limited to\nthis role. Because decorators work by running new functions and classes through decorator code, they can also be used to manage function and class objects themselves,\nnot just later calls made to them.\nImagine, for example, that you require methods or classes used by an application to be\nregistered to an API for later processing (perhaps that API will call the objects later, in\nresponse to events). Although you could provide a registration function to be called\nmanually after the objects are defined, decorators make your intent more explicit.\nThe following simple implementation of this idea defines a decorator that can be applied to both functions and classes, to add the object to a dictionary-based registry.",
    "response to events). Although you could provide a registration function to be called\nmanually after the objects are defined, decorators make your intent more explicit.\nThe following simple implementation of this idea defines a decorator that can be applied to both functions and classes, to add the object to a dictionary-based registry.\nBecause it returns the object itself instead of a wrapper, it does not intercept later calls:\n# Registering decorated objects to an API\nregistry = {}\ndef register(obj):\nregistry[obj.__name__] = obj\nreturn obj",
    "# Both class and func decorator\n# Add to registry\n# Return obj itself, not a wrapper\n\n@register\ndef spam(x):\nreturn(x ** 2)\n\n# spam = register(spam)\n\n@register\ndef ham(x):\nreturn(x ** 3)\n@register\nclass Eggs:\ndef __init__(self, x):\nself.data = x ** 4\ndef __str__(self):\nreturn str(self.data)\n\n# Eggs = register(Eggs)\n\nprint('Registry:')\nfor name in registry:\nprint(name, '=>', registry[name], type(registry[name]))\nprint('\\nManual calls:')\nprint(spam(2))\nprint(ham(2))\nX = Eggs(2)\nprint(X)\nprint('\\nRegistry calls:')\nfor name in registry:\nprint(name, '=>', registry[name](3))\n\n# Invoke objects manually\n# Later calls not intercepted\n\n# Invoke from registry\n\nManaging Functions and Classes Directly | 1021",
    "print('Registry:')\nfor name in registry:\nprint(name, '=>', registry[name], type(registry[name]))\nprint('\\nManual calls:')\nprint(spam(2))\nprint(ham(2))\nX = Eggs(2)\nprint(X)\nprint('\\nRegistry calls:')\nfor name in registry:\nprint(name, '=>', registry[name](3))\n\n# Invoke objects manually\n# Later calls not intercepted\n\n# Invoke from registry\n\nManaging Functions and Classes Directly | 1021\n\n\fWhen this code is run the decorated objects are added to the registry by name, but they\nstill work as originally coded when they’re called later, without being routed through\na wrapper layer. In fact, our objects can be run both manually and from inside the\nregistry table:\nRegistry:\nEggs => <class '__main__.Eggs'> <class 'type'>\nham => <function ham at 0x02CFB738> <class 'function'>\nspam => <function spam at 0x02CFB6F0> <class 'function'>\nManual calls:\n4\n8\n16\nRegistry calls:\nEggs => 81\nham => 27\nspam => 9",
    "A user interface might use this technique, for example, to register callback handlers for\nuser actions. Handlers might be registered by function or class name, as done here, or\ndecorator arguments could be used to specify the subject event; an extra def statement\nenclosing our decorator could be used to retain such arguments for use on decoration.\nThis example is artificial, but its technique is very general. For example, function decorators might also be used to process function attributes, and class decorators might\ninsert new class attributes, or even new methods, dynamically. Consider the following\nfunction decorators—they assign function attributes to record information for later use\nby an API, but they do not insert a wrapper layer to intercept later calls:\n# Augmenting decorated objects directly\n>>> def decorate(func):\n...\nfunc.marked = True\n...\nreturn func\n...\n>>> @decorate\n... def spam(a, b):\n...\nreturn a + b\n...\n>>> spam.marked\nTrue\n>>> def annotate(text):\n...",
    "function decorators—they assign function attributes to record information for later use\nby an API, but they do not insert a wrapper layer to intercept later calls:\n# Augmenting decorated objects directly\n>>> def decorate(func):\n...\nfunc.marked = True\n...\nreturn func\n...\n>>> @decorate\n... def spam(a, b):\n...\nreturn a + b\n...\n>>> spam.marked\nTrue\n>>> def annotate(text):\n...\ndef decorate(func):\n...\nfunc.label = text\n...\nreturn func\n...\nreturn decorate\n...\n>>> @annotate('spam data')\n... def spam(a, b):\n...\nreturn a + b\n...",
    "1022 | Chapter 38: Decorators\n\n# Assign function attribute for later use\n\n# Same, but value is decorator argument\n\n# spam = annotate(...)(spam)\n\n\f>>> spam(1, 2), spam.label\n(3, 'spam data')\n\nSuch decorators augment functions and classes directly, without catching later calls to\nthem. We’ll see more examples of class decorations managing classes directly in the\nnext chapter, because this turns out to encroach on the domain of metaclasses; for the\nremainder of this chapter, let’s turn to two larger case studies of decorators at work.\n\nExample: “Private” and “Public” Attributes\nThe final two sections of this chapter present larger examples of decorator use. Both\nare presented with minimal description, partly because this chapter has exceeded its\nsize limits, but mostly because you should already understand decorator basics well\nenough to study these on your own. Being general-purpose tools, these examples give\nus a chance to see how decorator concepts come together in more useful code.",
    "Implementing Private Attributes\nThe following class decorator implements a Private declaration for class instance attributes—that is, attributes stored on an instance, or inherited from one of its classes.\nIt disallows fetch and change access to such attributes from outside the decorated class,\nbut still allows the class itself to access those names freely within its methods. It’s not\nexactly C++ or Java, but it provides similar access control as an option in Python.\nWe saw an incomplete first-cut implementation of instance attribute privacy for\nchanges only in Chapter 29. The version here extends this concept to validate attribute\nfetches too, and it uses delegation instead of inheritance to implement the model. In\nfact, in a sense this is just an extension to the attribute tracer class decorator we met\nearlier.\nAlthough this example utilizes the new syntactic sugar of class decorators to code attribute privacy, its attribute interception is ultimately still based upon the",
    "fetches too, and it uses delegation instead of inheritance to implement the model. In\nfact, in a sense this is just an extension to the attribute tracer class decorator we met\nearlier.\nAlthough this example utilizes the new syntactic sugar of class decorators to code attribute privacy, its attribute interception is ultimately still based upon the\n__getattr__ and __setattr__ operator overloading methods we met in prior chapters.\nWhen a private attribute access is detected, this version uses the raise statement to\nraise an exception, along with an error message; the exception may be caught in a\ntry or allowed to terminate the script.\nHere is the code, along with a self test at the bottom of the file. It will work under both\nPython 2.6 and 3.0 because it employs 3.0 print and raise syntax, though it catches\noperator overloading method attributes in 2.6 only (more on this in a moment):\n\"\"\"\nPrivacy for attributes fetched from class instances.",
    "try or allowed to terminate the script.\nHere is the code, along with a self test at the bottom of the file. It will work under both\nPython 2.6 and 3.0 because it employs 3.0 print and raise syntax, though it catches\noperator overloading method attributes in 2.6 only (more on this in a moment):\n\"\"\"\nPrivacy for attributes fetched from class instances.\nSee self-test code at end of file for a usage example.\nDecorator same as: Doubler = Private('data', 'size')(Doubler).\nPrivate returns onDecorator, onDecorator returns onInstance,\nand each onInstance instance embeds a Doubler instance.\n\"\"\"",
    "Example: “Private” and “Public” Attributes | 1023",
    "traceMe = False\ndef trace(*args):\nif traceMe: print('[' + ' '.join(map(str, args)) + ']')\ndef Private(*privates):\n# privates in enclosing scope\ndef onDecorator(aClass):\n# aClass in enclosing scope\nclass onInstance:\n# wrapped in instance attribute\ndef __init__(self, *args, **kargs):\nself.wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attr):\n# My attrs don't call getattr\ntrace('get:', attr)\n# Others assumed in wrapped\nif attr in privates:\nraise TypeError('private attribute fetch: ' + attr)\nelse:\nreturn getattr(self.wrapped, attr)\ndef __setattr__(self, attr, value):\n# Outside accesses\ntrace('set:', attr, value)\n# Others run normally\nif attr == 'wrapped':\n# Allow my attrs\nself.__dict__[attr] = value\n# Avoid looping\nelif attr in privates:\nraise TypeError('private attribute change: ' + attr)\nelse:\nsetattr(self.wrapped, attr, value)\n# Wrapped obj attrs\nreturn onInstance\n# Or use __dict__\nreturn onDecorator\nif __name__ == '__main__':\ntraceMe = True\n@Private('data', 'size')",
    "trace('set:', attr, value)\n# Others run normally\nif attr == 'wrapped':\n# Allow my attrs\nself.__dict__[attr] = value\n# Avoid looping\nelif attr in privates:\nraise TypeError('private attribute change: ' + attr)\nelse:\nsetattr(self.wrapped, attr, value)\n# Wrapped obj attrs\nreturn onInstance\n# Or use __dict__\nreturn onDecorator\nif __name__ == '__main__':\ntraceMe = True\n@Private('data', 'size')\n# Doubler = Private(...)(Doubler)\nclass Doubler:\ndef __init__(self, label, start):\nself.label = label\n# Accesses inside the subject class\nself.data = start\n# Not intercepted: run normally\ndef size(self):\nreturn len(self.data)\n# Methods run with no checking\ndef double(self):\n# Because privacy not inherited\nfor i in range(self.size()):\nself.data[i] = self.data[i] * 2\ndef display(self):\nprint('%s => %s' % (self.label, self.data))\nX = Doubler('X is', [1, 2, 3])\nY = Doubler('Y is', [−10, −20, −30])\n# The followng all succeed\nprint(X.label)\nX.display(); X.double(); X.display()\nprint(Y.label)",
    "return len(self.data)\n# Methods run with no checking\ndef double(self):\n# Because privacy not inherited\nfor i in range(self.size()):\nself.data[i] = self.data[i] * 2\ndef display(self):\nprint('%s => %s' % (self.label, self.data))\nX = Doubler('X is', [1, 2, 3])\nY = Doubler('Y is', [−10, −20, −30])\n# The followng all succeed\nprint(X.label)\nX.display(); X.double(); X.display()\nprint(Y.label)\nY.display(); Y.double()\nY.label = 'Spam'\nY.display()",
    "1024 | Chapter 38: Decorators\n\n# Accesses outside subject class\n# Intercepted: validated, delegated\n\n\f# The following all fail properly\n\"\"\"\nprint(X.size())\n# prints \"TypeError: private attribute fetch: size\"\nprint(X.data)\nX.data = [1, 1, 1]\nX.size = lambda S: 0\nprint(Y.data)\nprint(Y.size())\n\"\"\"\n\nWhen traceMe is True, the module file’s self-test code produces the following output.\nNotice how the decorator catches and validates both attribute fetches and assignments\nrun outside of the wrapped class, but does not catch attribute accesses inside the class\nitself:\n[set: wrapped <__main__.Doubler object at 0x02B2AAF0>]\n[set: wrapped <__main__.Doubler object at 0x02B2AE70>]\n[get: label]\nX is\n[get: display]\nX is => [1, 2, 3]\n[get: double]\n[get: display]\nX is => [2, 4, 6]\n[get: label]\nY is\n[get: display]\nY is => [−10, −20, −30]\n[get: double]\n[set: label Spam]\n[get: display]\nSpam => [−20, −40, −60]",
    "Implementation Details I\nThis code is a bit complex, and you’re probably best off tracing through it on your own\nto see how it works. To help you study, though, here are a few highlights worth\nmentioning.\n\nInheritance versus delegation\nThe first-cut privacy example shown in Chapter 29 used inheritance to mix in a\n__setattr__ to catch accesses. Inheritance makes this difficult, however, because dif-\n\nferentiating between accesses from inside or outside the class is not straightforward\n(inside access should be allowed to run normally, and outside access should be restricted). To work around this, the Chapter 29 example requires inheriting classes to use\n__dict__ assignments to set attributes—an incomplete solution at best.\nThe version here uses delegation (embedding one object inside another) instead of inheritance; this pattern is better suited to our task, as it makes it much easier to distinguish between accesses inside and outside of the subject class. Attribute accesses from",
    "Example: “Private” and “Public” Attributes | 1025\n\n\foutside the subject class are intercepted by the wrapper layer’s overloading methods\nand delegated to the class if valid; accesses inside the class itself (i.e., through self\ninside its methods’ code) are not intercepted and are allowed to run normally without\nchecks, because privacy is not inherited here.\nDecorator arguments. The class decorator used here accepts any number of arguments, to\nname private attributes. What really happens, though, is that the arguments are passed\nto the Private function, and Private returns the decorator function to be applied to the\nsubject class. That is, the arguments are used before decoration ever occurs; Private\nreturns the decorator, which in turn “remembers” the privates list as an enclosing scope\nreference.",
    "State retention and enclosing scopes\nSpeaking of enclosing scopes, there are actually three levels of state retention at work\nin this code:\n• The arguments to Private are used before decoration occurs and are retained as\nan enclosing scope reference for use in both onDecorator and onInstance.\n• The class argument to onDecorator is used at decoration time and is retained as an\nenclosing scope reference for use at instance construction time.\n• The wrapped instance object is retained as an instance attribute in onInstance, for\nuse when attributes are later accessed from outside the class.\nThis all works fairly naturally, given Python’s scope and namespace rules.",
    "Using __dict__ and __slots__\nThe __setattr__ in this code relies on an instance object’s __dict__ attribute namespace\ndictionary in order to set onInstance’s own wrapped attribute. As we learned in the prior\nchapter, it cannot assign an attribute directly without looping. However, it uses the\nsetattr built-in instead of __dict__ to set attributes in the wrapped object itself. Moreover, getattr is used to fetch attributes in the wrapped object, since they may be stored\nin the object itself or inherited by it.\nBecause of that, this code will work for most classes. You may recall from Chapter 31\nthat new-style classes with __slots__ may not store attributes in a __dict__. However,\nbecause we only rely on a __dict__ at the onInstance level here, not in the wrapped\ninstance, and because setattr and getattr apply to attributes based on both\n__dict__ and __slots__, our decorator applies to classes using either storage scheme.",
    "Generalizing for Public Declarations, Too\nNow that we have a Private implementation, it’s straightforward to generalize the code\nto allow for Public declarations too—they are essentially the inverse of Private declarations, so we need only negate the inner test. The example listed in this section allows\n\n1026 | Chapter 38: Decorators",
    "a class to use decorators to define a set of either Private or Public instance attributes\n(attributes stored on an instance or inherited from its classes), with the following\nsemantics:\n• Private declares attributes of a class’s instances that cannot be fetched or assigned,\nexcept from within the code of the class’s methods. That is, any name declared\nPrivate cannot be accessed from outside the class, while any name not declared\nPrivate can be freely fetched or assigned from outside the class.\n• Public declares attributes of a class’s instances that can be fetched or assigned from\nboth outside the class and within the class’s methods. That is, any name declared\nPublic can be freely accessed anywhere, while any name not declared Public cannot\nbe accessed from outside the class.\nPrivate and Public declarations are intended to be mutually exclusive: when using",
    "• Public declares attributes of a class’s instances that can be fetched or assigned from\nboth outside the class and within the class’s methods. That is, any name declared\nPublic can be freely accessed anywhere, while any name not declared Public cannot\nbe accessed from outside the class.\nPrivate and Public declarations are intended to be mutually exclusive: when using\nPrivate, all undeclared names are considered Public, and when using Public, all undeclared names are considered Private. They are essentially inverses, though unde-",
    "clared names not created by class methods behave slightly differently—they can be\nassigned and thus created outside the class under Private (all undeclared names are\naccessible), but not under Public (all undeclared names are inaccessible).\nAgain, study this code on your own to get a feel for how this works. Notice that this\nscheme adds an additional fourth level of state retention at the top, beyond that described in the preceding section: the test functions used by the lambdas are saved in an extra\nenclosing scope. This example is coded to run under either Python 2.6 or 3.0, though\nit comes with a caveat when run under 3.0 (explained briefly in the file’s docstring and\nexpanded on after the code):\n\"\"\"\nClass decorator with Private and Public attribute declarations.\nControls access to attributes stored on an instance, or inherited\nby it from its classes. Private declares attribute names that\ncannot be fetched or assigned outside the decorated class, and",
    "it comes with a caveat when run under 3.0 (explained briefly in the file’s docstring and\nexpanded on after the code):\n\"\"\"\nClass decorator with Private and Public attribute declarations.\nControls access to attributes stored on an instance, or inherited\nby it from its classes. Private declares attribute names that\ncannot be fetched or assigned outside the decorated class, and\nPublic declares all the names that can. Caveat: this works in\n3.0 for normally named attributes only: __X__ operator overloading\nmethods implicitly run for built-in operations do not trigger\neither __getattr__ or __getattribute__ in new-style classes.\nAdd __X__ methods here to intercept and delegate built-ins.\n\"\"\"\ntraceMe = False\ndef trace(*args):\nif traceMe: print('[' + ' '.join(map(str, args)) + ']')\ndef accessControl(failIf):\ndef onDecorator(aClass):\nclass onInstance:\ndef __init__(self, *args, **kargs):\nself.__wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attr):\ntrace('get:', attr)",
    "Example: “Private” and “Public” Attributes | 1027\n\n\fif failIf(attr):\nraise TypeError('private attribute fetch: ' + attr)\nelse:\nreturn getattr(self.__wrapped, attr)\ndef __setattr__(self, attr, value):\ntrace('set:', attr, value)\nif attr == '_onInstance__wrapped':\nself.__dict__[attr] = value\nelif failIf(attr):\nraise TypeError('private attribute change: ' + attr)\nelse:\nsetattr(self.__wrapped, attr, value)\nreturn onInstance\nreturn onDecorator\ndef Private(*attributes):\nreturn accessControl(failIf=(lambda attr: attr in attributes))\ndef Public(*attributes):\nreturn accessControl(failIf=(lambda attr: attr not in attributes))",
    "See the prior example’s self-test code for a usage example. Here’s a quick look at these\nclass decorators in action at the interactive prompt (they work the same in 2.6 and 3.0);\nas advertised, non-Private or Public names can be fetched and changed from outside\nthe subject class, but Private or non-Public names cannot:\n>>> from access import Private, Public\n>>> @Private('age')\n... class Person:\n...\ndef __init__(self, name, age):\n...\nself.name = name\n...\nself.age = age\n...\n>>> X = Person('Bob', 40)\n>>> X.name\n'Bob'\n>>> X.name = 'Sue'\n>>> X.name\n'Sue'\n>>> X.age\nTypeError: private attribute fetch: age\n>>> X.age = 'Tom'\nTypeError: private attribute change: age\n>>> @Public('name')\n... class Person:\n...\ndef __init__(self, name, age):\n...\nself.name = name\n...\nself.age = age\n...\n>>> X = Person('bob', 40)\n>>> X.name\n'bob'\n>>> X.name = 'Sue'\n\n1028 | Chapter 38: Decorators",
    "1028 | Chapter 38: Decorators\n\n# Person = Private('age')(Person)\n# Person = onInstance with state\n# Inside accesses run normally\n# Outside accesses validated\n\n# X is an onInstance\n# onInstance embeds Person\n\n\f>>> X.name\n'Sue'\n>>> X.age\nTypeError: private attribute fetch: age\n>>> X.age = 'Tom'\nTypeError: private attribute change: age\n\nImplementation Details II\nTo help you analyze the code, here are a few final notes on this version. Since this is\njust a generalization of the preceding section’s example, most of the notes there apply\nhere as well.",
    "Implementation Details II\nTo help you analyze the code, here are a few final notes on this version. Since this is\njust a generalization of the preceding section’s example, most of the notes there apply\nhere as well.\n\nUsing __X pseudoprivate names\nBesides generalizing, this version also makes use of Python’s __X pseudoprivate name\nmangling feature (which we met in Chapter 30) to localize the wrapped attribute to the\ncontrol class, by automatically prefixing it with the class name. This avoids the prior\nversion’s risk for collisions with a wrapped attribute that may be used by the real, wrapped class, and it’s useful in a general tool like this. It’s not quite “privacy,” though,\nbecause the mangled name can be used freely outside the class. Notice that we also\nhave to use the fully expanded name string ('_onInstance__wrapped') in __setattr__,\nbecause that’s what Python changes it to.",
    "Breaking privacy\nAlthough this example does implement access controls for attributes of an instance and\nits classes, it is possible to subvert these controls in various ways—for instance, by\ngoing through the expanded version of the wrapped attribute explicitly (bob.pay might\nnot work, but the fully mangled bob._onInstance__wrapped.pay could!). If you have to\nexplicitly try to do so, though, these controls are probably sufficient for normal\nintended use. Of course, privacy controls can generally be subverted in any language\nif you try hard enough (#define private public may work in some C++ implementations, too). Although access controls can reduce accidental changes, much of this is up\nto programmers in any language; whenever source code may be changed, access control\nwill always be a bit of a pipe dream.",
    "Decorator tradeoffs\nWe could again achieve the same results without decorators, by using manager functions or coding the name rebinding of decorators manually; the decorator syntax, however, makes this consistent and a bit more obvious in the code. The chief potential\ndownsides of this and any other wrapper-based approach are that attribute access incurs an extra call, and instances of decorated classes are not really instances of the\noriginal decorated class—if you test their type with X.__class__ or isinstance(X, C),\n\nExample: “Private” and “Public” Attributes | 1029\n\n\ffor example, you’ll find that they are instances of the wrapper class. Unless you plan\nto do introspection on objects’ types, though, the type issue is probably irrelevant.\n\nOpen Issues\nAs is, this example works as planned under Python 2.6 and 3.0 (provided operator\noverloading methods to be delegated are redefined in the wrapper). As with most software, though, there is always room for improvement.",
    "Caveat: operator overloading methods fail to delegate under 3.0\nLike all delegation-based classes that use __getattr__, this decorator works crossversion for normally named attributes only; operator overloading methods like\n__str__ and __add__ work differently for new-style classes and so fail to reach the embedded object if defined there when this runs under 3.0.\nAs we learned in the prior chapter, classic classes look up operator overloading names\nin instances at runtime normally, but new-style classes do not—they skip the instance\nentirely and look up such methods in classes. Hence, the __X__ operator overloading\nmethods implicitly run for built-in operations do not trigger either __getattr__ or\n__getattribute__ in new-style classes in 2.6 and all classes in 3.0; such attribute fetches\nskip our onInstance.__getattr__ altogether, so they cannot be validated or delegated.\nOur decorator’s class is not coded as new-style (by deriving from object), so it will",
    "methods implicitly run for built-in operations do not trigger either __getattr__ or\n__getattribute__ in new-style classes in 2.6 and all classes in 3.0; such attribute fetches\nskip our onInstance.__getattr__ altogether, so they cannot be validated or delegated.\nOur decorator’s class is not coded as new-style (by deriving from object), so it will\ncatch operator overloading methods if run under 2.6. Since all classes are new-style\nautomatically in 3.0, though, such methods will fail if they are coded on the embedded\nobject. The simplest workaround in 3.0 is to redefine redundantly in onInstance all the\noperator overloading methods that can possibly be used in wrapped objects. Such extra\nmethods can be added by hand, by tools that partly automate the task (e.g., with class\ndecorators or the metaclasses discussed in the next chapter), or by definition in\nsuperclasses.\nTo see the difference yourself, try applying the decorator to a class that uses operator",
    "operator overloading methods that can possibly be used in wrapped objects. Such extra\nmethods can be added by hand, by tools that partly automate the task (e.g., with class\ndecorators or the metaclasses discussed in the next chapter), or by definition in\nsuperclasses.\nTo see the difference yourself, try applying the decorator to a class that uses operator\noverloading methods under 2.6; validations work as before, and both the __str__\nmethod used by printing and the __add__ method run for + invoke the decorator’s\n__getattr__ and hence wind up being validated and delegated to the subject Person\nobject correctly:\nC:\\misc> c:\\python26\\python\n>>> from access import Private\n>>> @Private('age')\n... class Person:\n...\ndef __init__(self):\n...\nself.age = 42\n...\ndef __str__(self):\n...\nreturn 'Person: ' + str(self.age)\n...\ndef __add__(self, yrs):\n...\nself.age += yrs\n...",
    "1030 | Chapter 38: Decorators\n\n\f>>> X = Person()\n>>> X.age\nTypeError: private attribute fetch: age\n>>> print(X)\nPerson: 42\n>>> X + 10\n>>> print(X)\nPerson: 52\n\n# Name validations fail correctly\n# __getattr__ => runs Person.__str__\n# __getattr__ => runs Person.__add__\n# __getattr__ => runs Person.__str__",
    "When the same code is run under Python 3.0, though, the implicitly invoked __str__\nand __add__ skip the decorator’s __getattr__ and look for definitions in or above the\ndecorator class itself; print winds up finding the default display inherited from the class\ntype (technically, from the implied object superclass in 3.0), and + generates an error\nbecause no default is inherited:\nC:\\misc> c:\\python30\\python\n>>> from access import Private\n>>> @Private('age')\n... class Person:\n...\ndef __init__(self):\n...\nself.age = 42\n...\ndef __str__(self):\n...\nreturn 'Person: ' + str(self.age)\n...\ndef __add__(self, yrs):\n...\nself.age += yrs\n...\n>>> X = Person()\n# Name validations still work\n>>> X.age\n# But 3.0 fails to delegate built-ins!\nTypeError: private attribute fetch: age\n>>> print(X)\n<access.onInstance object at 0x025E0790>\n>>> X + 10\nTypeError: unsupported operand type(s) for +: 'onInstance' and 'int'\n>>> print(X)\n<access.onInstance object at 0x025E0790>",
    "Using the alternative __getattribute__ method won’t help here—although it is defined\nto catch every attribute reference (not just undefined names), it is also not run by builtin operations. Python’s property feature, which we met in Chapter 37, won’t help here\neither; recall that properties are automatically run code associated with specific\nattributes defined when a class is written, and are not designed to handle arbitrary\nattributes in wrapped objects.\nAs mentioned earlier, the most straightforward solution under 3.0 is to redundantly\nredefine operator overloading names that may appear in embedded objects in\ndelegation-based classes like our decorator. This isn’t ideal because it creates some code\nredundancy, especially compared to 2.6 solutions. However, it isn’t too major a coding\neffort, can be automated to some extent with tools or superclasses, suffices to make\nour decorator work in 3.0, and allows operator overloading names to be declared",
    "delegation-based classes like our decorator. This isn’t ideal because it creates some code\nredundancy, especially compared to 2.6 solutions. However, it isn’t too major a coding\neffort, can be automated to some extent with tools or superclasses, suffices to make\nour decorator work in 3.0, and allows operator overloading names to be declared\nPrivate or Public too (assuming each overloading method runs the failIf test\ninternally):",
    "Example: “Private” and “Public” Attributes | 1031\n\n\fdef accessControl(failIf):\ndef onDecorator(aClass):\nclass onInstance:\ndef __init__(self, *args, **kargs):\nself.__wrapped = aClass(*args, **kargs)\n# Intercept and delegate operator overloading methods\ndef __str__(self):\nreturn str(self.__wrapped)\ndef __add__(self, other):\nreturn self.__wrapped + other\ndef __getitem__(self, index):\nreturn self.__wrapped[index]\n# If needed\ndef __call__(self, *args, **kargs):\nreturn self.__wrapped(*arg, *kargs) # If needed\n...plus any others needed...\n# Intercept and delegate named attributes\ndef __getattr__(self, attr):\n...\ndef __setattr__(self, attr, value):\n...\nreturn onInstance\nreturn onDecorator",
    "With such operator overloading methods added, the prior example with __str__ and\n__add__ works the same under 2.6 and 3.0, although a substantial amount of extra code\nmay be required to accommodate 3.0—in principle, every operator overloading method\nthat is not run automatically will need to be defined redundantly for 3.0 in a general\ntool class like this (which is why this extension is omitted in our code). Since every class\nis new-style in 3.0, delegation-based code is more difficult (though not impossible) in\nthis release.\nOn the other hand, delegation wrappers could simply inherit from a common superclass that redefines operator overloading methods once, with standard delegation code.\nMoreover, tools such as additional class decorators or metaclasses might automate\nsome of the work of adding such methods to delegation classes (see the class augmentation examples in Chapter 39 for details). Though still not as simple as the 2.6 solution,",
    "Moreover, tools such as additional class decorators or metaclasses might automate\nsome of the work of adding such methods to delegation classes (see the class augmentation examples in Chapter 39 for details). Though still not as simple as the 2.6 solution,\nsuch techniques might help make 3.0 delegation classes more general.",
    "Implementation alternatives: __getattribute__ inserts, call stack inspection\nAlthough redundantly defining operator overloading methods in wrappers is probably\nthe most straightforward workaround to Python 3.0 dilemma outlined in the prior\nsection, it’s not necessarily the only one. We don’t have space to explore this issue\nmuch further here, so investigating other potential solutions is relegated to a suggested\nexercise. Because one dead-end alternative underscores class concepts well, though, it\nmerits a brief mention.\nOne downside of this example is that instance objects are not truly instances of the\noriginal class—they are instances of the wrapper instead. In some programs that rely\n1032 | Chapter 38: Decorators",
    "on type testing, this might matter. To support such cases, we might try to achieve similar\neffects by inserting a __getattribute__ method into the original class, to catch every\nattribute reference made on its instances. This inserted method would pass valid\nrequests up to its superclass to avoid loops, using the techniques we studied in the prior\nchapter. Here is the potential change to our class decorator’s code:\n# trace support as before\ndef accessControl(failIf):\ndef onDecorator(aClass):\ndef getattributes(self, attr):\ntrace('get:', attr)\nif failIf(attr):\nraise TypeError('private attribute fetch: ' + attr)\nelse:\nreturn object.__getattribute__(self, attr)\naClass.__getattribute__ = getattributes\nreturn aClass\nreturn onDecorator\ndef Private(*attributes):\nreturn accessControl(failIf=(lambda attr: attr in attributes))\ndef Public(*attributes):\nreturn accessControl(failIf=(lambda attr: attr not in attributes))",
    "This alternative addresses the type-testing issue but suffers from others. For example,\nit handles only attribute fetches—as is, this version allows private names to be assigned freely. Intercepting assignments would still have to use __setattr__, and either\nan instance wrapper object or another class method insertion. Adding an instance\nwrapper to catch assignments would change the type again, and inserting methods fails\nif the original class is using a __setattr__ of its own (or a __getattribute__, for that\nmatter!). An inserted __setattr__ would also have to allow for a __slots__ in the client\nclass.\nIn addition, this scheme does not address the built-in operation attributes issue\ndescribed in the prior section, since __getattribute__ is not run in these contexts,\neither. In our case, if Person had a __str__ it would be run by print operations, but only\nbecause it was actually present in that class. As before, the __str__ attribute would",
    "class.\nIn addition, this scheme does not address the built-in operation attributes issue\ndescribed in the prior section, since __getattribute__ is not run in these contexts,\neither. In our case, if Person had a __str__ it would be run by print operations, but only\nbecause it was actually present in that class. As before, the __str__ attribute would\nnot be routed to the inserted __getattribute__ method generically—printing would\nbypass this method altogether and call the class’s __str__ directly.\nAlthough this is probably better than not supporting operator overloading methods in\na wrapped object at all (barring redefinition, at least), this scheme still cannot intercept\nand validate __X__ methods, making it impossible for any of them to be Private. Although most operator overloading methods are meant to be public, some might not be.\nMuch",
    "worse,\n\nbecause\n\nthis\n\nnonwrapper\n\napproach\n\nworks\n\nby\n\nadding\n\na\n\n__getattribute__ to the decorated class, it also intercepts attribute accesses made by\n\nExample: “Private” and “Public” Attributes | 1033",
    "the class itself and validates them the same as accesses made from outside—this means\nthe class’s method won’t be able to use Private names, either!\nIn fact, inserting methods this way is functionally equivalent to inheriting them, and\nimplies the same constraints as our original Chapter 29 privacy code. To know whether\nan attribute access originated inside or outside the class, our method might need to\ninspect frame objects on the Python call stack. This might ultimately yield a solution\n(replace private attributes with properties or descriptors that check the stack, for example), but it would slow access further and is far too dark a magic for us to explore\nhere.\nWhile interesting, and possibly relevant for some other use cases, this method insertion\ntechnique doesn’t meet our goals. We won’t explore this option’s coding pattern further here because we will study class augmentation techniques in the next chapter, in",
    "here.\nWhile interesting, and possibly relevant for some other use cases, this method insertion\ntechnique doesn’t meet our goals. We won’t explore this option’s coding pattern further here because we will study class augmentation techniques in the next chapter, in\nconjunction with metaclasses. As we’ll see there, metaclasses are not strictly required\nfor changing classes this way, because class decorators can often serve the same role.",
    "Python Isn’t About Control\nNow that I’ve gone to such great lengths to add Private and Public attribute declarations for Python code, I must again remind you that it is not entirely Pythonic to add\naccess controls to your classes like this. In fact, most Python programmers will probably\nfind this example to be largely or totally irrelevant, apart from serving as a demonstration of decorators in action. Most large Python programs get by successfully without\nany such controls at all. If you do wish to regulate attribute access in order to eliminate\ncoding mistakes, though, or happen to be a soon-to-be-ex-C++-or-Java programmer,\nmost things are possible with Python’s operator overloading and introspection tools.",
    "Example: Validating Function Arguments\nAs a final example of the utility of decorators, this section develops a function decorator that automatically tests whether arguments passed to a function or method are\nwithin a valid numeric range. It’s designed to be used during either development or\nproduction, and it can be used as a template for similar tasks (e.g., argument type\ntesting, if you must). Because this chapter’s size limits has been broached, this example’s code is largely self-study material, with limited narrative; as usual, browse the\ncode for more details.\n\nThe Goal\nIn the object-oriented tutorial of Chapter 27, we wrote a class that gave a raise to objects\nrepresenting people based upon a passed-in percentage:\nclass Person:\n...\n\n1034 | Chapter 38: Decorators\n\n\fdef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))",
    "The Goal\nIn the object-oriented tutorial of Chapter 27, we wrote a class that gave a raise to objects\nrepresenting people based upon a passed-in percentage:\nclass Person:\n...\n\n1034 | Chapter 38: Decorators\n\n\fdef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\n\nThere, we noted that if we wanted the code to be robust it would be a good idea to\ncheck the percentage to make sure it’s not too large or too small. We could implement\nsuch a check with either if or assert statements in the method itself, using inline tests:\nclass Person:\ndef giveRaise(self, percent):\n# Validate with inline code\nif percent < 0.0 or percent > 1.0:\nraise TypeError, 'percent invalid'\nself.pay = int(self.pay * (1 + percent))\nclass Person:\n# Validate with asserts\ndef giveRaise(self, percent):\nassert percent >= 0.0 and percent <= 1.0, 'percent invalid'\nself.pay = int(self.pay * (1 + percent))",
    "However, this approach clutters up the method with inline tests that will probably be\nuseful only during development. For more complex cases, this can become tedious\n(imagine trying to inline the code needed to implement the attribute privacy provided\nby the last section’s decorator). Perhaps worse, if the validation logic ever needs to\nchange, there may be arbitrarily many inline copies to find and update.\nA more useful and interesting alternative would be to develop a general tool that can\nperform range tests for us automatically, for the arguments of any function or method\nwe might code now or in the future. A decorator approach makes this explicit and\nconvenient:\nclass Person:\n@rangetest(percent=(0.0, 1.0))\n# Use decorator to validate\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))",
    "Isolating validation logic in a decorator simplifies both clients and future maintenance.\nNotice that our goal here is different than the attribute validations coded in the prior\nchapter’s final example. Here, we mean to validate the values of function arguments\nwhen passed, rather than attribute values when set. Python’s decorator and introspection tools allow us to code this new task just as easily.\n\nA Basic Range-Testing Decorator for Positional Arguments\nLet’s start with a basic range test implementation. To keep things simple, we’ll begin\nby coding a decorator that works only for positional arguments and assumes they always appear at the same position in every call; they cannot be passed by keyword name,\nand we don’t support additional **args keywords in calls because this can invalidate\nthe positions declared in the decorator. Code the following in a file called devtools.py:\ndef rangetest(*argchecks):\ndef onDecorator(func):\nif not __debug__:",
    "# Validate positional arg ranges\n# True if \"python -O main.py args...\"\n\nExample: Validating Function Arguments | 1035\n\n\freturn func\n# No-op: call original directly\nelse:\n# Else wrapper while debugging\ndef onCall(*args):\nfor (ix, low, high) in argchecks:\nif args[ix] < low or args[ix] > high:\nerrmsg = 'Argument %s not in %s..%s' % (ix, low, high)\nraise TypeError(errmsg)\nreturn func(*args)\nreturn onCall\nreturn onDecorator",
    "As is, this code is mostly a rehash of the coding patterns we explored earlier: we use\ndecorator arguments, nested scopes for state retention, and so on.\nWe also use nested def statements to ensure that this works for both simple functions\nand methods, as we learned earlier. When used for a class method, onCall receives the\nsubject class’s instance in the first item in *args and passes this along to self in the\noriginal method function; argument numbers in range tests start at 1 in this case, not 0.\nAlso notice this code’s use of the __debug__ built-in variable, though—Python sets this\nto True, unless it’s being run with the –O optimize command-line flag (e.g., python –O\nmain.py). When __debug__ is False, the decorator returns the origin function unchanged, to avoid extra calls and their associated performance penalty.\nThis first iteration solution is used as follows:\n# File devtools_test.py\nfrom devtools import rangetest\nprint(__debug__)\n\n# False if \"python –O main.py\"",
    "# False if \"python –O main.py\"\n\n@rangetest((1, 0, 120))\n# persinfo = rangetest(...)(persinfo)\ndef persinfo(name, age):\n# age must be in 0..120\nprint('%s is %s years old' % (name, age))\n@rangetest([0, 1, 12], [1, 1, 31], [2, 0, 2009])\ndef birthday(M, D, Y):\nprint('birthday = {0}/{1}/{2}'.format(M, D, Y))\nclass Person:\ndef __init__(self, name, job, pay):\nself.job = job\nself.pay = pay\n@rangetest([1, 0.0, 1.0])\n# giveRaise = rangetest(...)(giveRaise)\ndef giveRaise(self, percent):\n# Arg 0 is the self instance here\nself.pay = int(self.pay * (1 + percent))\n# Comment lines raise TypeError unless \"python -O\" used on shell command line\npersinfo('Bob Smith', 45)\n#persinfo('Bob Smith', 200)\nbirthday(5, 31, 1963)\n#birthday(5, 32, 1963)\n\n1036 | Chapter 38: Decorators\n\n# Really runs onCall(...) with state\n# Or person if –O cmd line argument\n\n\fsue = Person('Sue Jones', 'dev', 100000)\nsue.giveRaise(.10)\nprint(sue.pay)\n#sue.giveRaise(1.10)\n#print(sue.pay)",
    "1036 | Chapter 38: Decorators\n\n# Really runs onCall(...) with state\n# Or person if –O cmd line argument\n\n\fsue = Person('Sue Jones', 'dev', 100000)\nsue.giveRaise(.10)\nprint(sue.pay)\n#sue.giveRaise(1.10)\n#print(sue.pay)\n\n# Really runs onCall(self, .10)\n# Or giveRaise(self, .10) if –O\n\nWhen run, valid calls in this code produce the following output (all the code in this\nsection works the same under Python 2.6 and 3.0, because function decorators are\nsupported in both, we’re not using attribute delegation, and we use 3.0-style print calls\nand exception construction syntax):\nC:\\misc> C:\\python30\\python devtools_test.py\nTrue\nBob Smith is 45 years old\nbirthday = 5/31/1963\n110000",
    "When run, valid calls in this code produce the following output (all the code in this\nsection works the same under Python 2.6 and 3.0, because function decorators are\nsupported in both, we’re not using attribute delegation, and we use 3.0-style print calls\nand exception construction syntax):\nC:\\misc> C:\\python30\\python devtools_test.py\nTrue\nBob Smith is 45 years old\nbirthday = 5/31/1963\n110000\n\nUncommenting any of the invalid calls causes a TypeError to be raised by the decorator.\nHere’s the result when the last two lines are allowed to run (as usual, I’ve omitted some\nof the error message text here to save space):\nC:\\misc> C:\\python30\\python devtools_test.py\nTrue\nBob Smith is 45 years old\nbirthday = 5/31/1963\n110000\nTypeError: Argument 1 not in 0.0..1.0",
    "Uncommenting any of the invalid calls causes a TypeError to be raised by the decorator.\nHere’s the result when the last two lines are allowed to run (as usual, I’ve omitted some\nof the error message text here to save space):\nC:\\misc> C:\\python30\\python devtools_test.py\nTrue\nBob Smith is 45 years old\nbirthday = 5/31/1963\n110000\nTypeError: Argument 1 not in 0.0..1.0\n\nRunning Python with its –O flag at a system command line will disable range testing,\nbut also avoid the performance overhead of the wrapping layer—we wind up calling\nthe original undecorated function directly. Assuming this is a debugging tool only, you\ncan use this flag to optimize your program for production use:\nC:\\misc> C:\\python30\\python –O devtools_test.py\nFalse\nBob Smith is 45 years old\nbirthday = 5/31/1963\n110000\n231000",
    "Generalizing for Keywords and Defaults, Too\nThe prior version illustrates the basics we need to employ, but it’s fairly limited—it\nsupports validating arguments passed by position only, and it does not validate keyword arguments (in fact, it assumes that no keywords are passed in a way that makes\nargument position numbers incorrect). Additionally, it does nothing about arguments\nwith defaults that may be omitted in a given call. That’s fine if all your arguments are\npassed by position and never defaulted, but less than ideal in a general tool. Python\nsupports much more flexible argument-passing modes, which we’re not yet addressing.\n\nExample: Validating Function Arguments | 1037",
    "The mutation of our example shown next does better. By matching the wrapped function’s expected arguments against the actual arguments passed in a call, it supports\nrange validations for arguments passed by either position or keyword name, and it skips\ntesting for default arguments omitted in the call. In short, arguments to be validated\nare specified by keyword arguments to the decorator, which later steps through both\nthe *pargs positionals tuple and the **kargs keywords dictionary to validate.\n\"\"\"\nFile devtools.py: function decorator that performs range-test\nvalidation for passed arguments. Arguments are specified by\nkeyword to the decorator. In the actual call, arguments may\nbe passed by position or keyword, and defaults may be omitted.\nSee devtools_test.py for example use cases.\n\"\"\"\ntrace = True\ndef rangetest(**argchecks):\n# Validate ranges for both+defaults\ndef onDecorator(func):\n# onCall remembers func and argchecks\nif not __debug__:\n# True if \"python –O main.py args...\"",
    "keyword to the decorator. In the actual call, arguments may\nbe passed by position or keyword, and defaults may be omitted.\nSee devtools_test.py for example use cases.\n\"\"\"\ntrace = True\ndef rangetest(**argchecks):\n# Validate ranges for both+defaults\ndef onDecorator(func):\n# onCall remembers func and argchecks\nif not __debug__:\n# True if \"python –O main.py args...\"\nreturn func\n# Wrap if debugging; else use original\nelse:\nimport sys\ncode\n= func.__code__\nallargs = code.co_varnames[:code.co_argcount]\nfuncname = func.__name__\ndef onCall(*pargs, **kargs):\n# All pargs match first N expected args by position\n# The rest must be in kargs or be omitted defaults\npositionals = list(allargs)\npositionals = positionals[:len(pargs)]\nfor (argname, (low, high)) in argchecks.items():\n# For all args to be checked\nif argname in kargs:\n# Was passed by name\nif kargs[argname] < low or kargs[argname] > high:\nerrmsg = '{0} argument \"{1}\" not in {2}..{3}'\nerrmsg = errmsg.format(funcname, argname, low, high)",
    "# The rest must be in kargs or be omitted defaults\npositionals = list(allargs)\npositionals = positionals[:len(pargs)]\nfor (argname, (low, high)) in argchecks.items():\n# For all args to be checked\nif argname in kargs:\n# Was passed by name\nif kargs[argname] < low or kargs[argname] > high:\nerrmsg = '{0} argument \"{1}\" not in {2}..{3}'\nerrmsg = errmsg.format(funcname, argname, low, high)\nraise TypeError(errmsg)\nelif argname in positionals:\n# Was passed by position\nposition = positionals.index(argname)\nif pargs[position] < low or pargs[position] > high:\nerrmsg = '{0} argument \"{1}\" not in {2}..{3}'\nerrmsg = errmsg.format(funcname, argname, low, high)\nraise TypeError(errmsg)\nelse:\n# Assume not passed: default\nif trace:\nprint('Argument \"{0}\" defaulted'.format(argname))",
    "1038 | Chapter 38: Decorators\n\n\freturn func(*pargs, **kargs)\nreturn onCall\nreturn onDecorator\n\n# OK: run original call",
    "# OK: run original call\n\nThe following test script shows how the decorator is used—arguments to be validated\nare given by keyword decorator arguments, and at actual calls we can pass by name or\nposition and omit arguments with defaults even if they are to be validated otherwise:\n# File devtools_test.py\n# Comment lines raise TypeError unless \"python –O\" used on shell command line\nfrom devtools import rangetest\n# Test functions, positional and keyword\n@rangetest(age=(0, 120))\n# persinfo = rangetest(...)(persinfo)\ndef persinfo(name, age):\nprint('%s is %s years old' % (name, age))\n@rangetest(M=(1, 12), D=(1, 31), Y=(0, 2009))\ndef birthday(M, D, Y):\nprint('birthday = {0}/{1}/{2}'.format(M, D, Y))\npersinfo('Bob', 40)\npersinfo(age=40, name='Bob')\nbirthday(5, D=1, Y=1963)\n#persinfo('Bob', 150)\n#persinfo(age=150, name='Bob')\n#birthday(5, D=40, Y=1963)\n# Test methods, positional and keyword\nclass Person:\ndef __init__(self, name, job, pay):\nself.job = job\nself.pay = pay",
    "# giveRaise = rangetest(...)(giveRaise)\n@rangetest(percent=(0.0, 1.0))\n# percent passed by name or position\ndef giveRaise(self, percent):\nself.pay = int(self.pay * (1 + percent))\n\nbob = Person('Bob Smith', 'dev', 100000)\nsue = Person('Sue Jones', 'dev', 100000)\nbob.giveRaise(.10)\nsue.giveRaise(percent=.20)\nprint(bob.pay, sue.pay)\n#bob.giveRaise(1.10)\n#bob.giveRaise(percent=1.20)\n# Test omitted defaults: skipped\n@rangetest(a=(1, 10), b=(1, 10), c=(1, 10), d=(1, 10))\ndef omitargs(a, b=7, c=8, d=9):\n\nExample: Validating Function Arguments | 1039\n\n\fprint(a, b, c, d)\nomitargs(1, 2, 3, 4)\nomitargs(1, 2, 3)\nomitargs(1, 2, 3, d=4)\nomitargs(1, d=4)\nomitargs(d=4, a=1)\nomitargs(1, b=2, d=4)\nomitargs(d=8, c=7, a=1)\n#omitargs(1, 2, 3, 11)\n#omitargs(1, 2, 11)\n#omitargs(1, 2, 3, d=11)\n#omitargs(11, d=4)\n#omitargs(d=4, a=11)\n#omitargs(1, b=11, d=4)\n#omitargs(d=8, c=7, a=11)\n\n# Bad d\n# Bad c\n# Bad d\n# Bad a\n# Bad a\n# Bad b\n# Bad a",
    "# Bad d\n# Bad c\n# Bad d\n# Bad a\n# Bad a\n# Bad b\n# Bad a\n\nWhen this script is run, out-of-range arguments raise an exception as before, but arguments may be passed by either name or position, and omitted defaults are not validated. This code runs on both 2.6 and 3.0, but extra tuple parentheses print in 2.6.\nTrace its output and test this further on your own to experiment; it works as before,\nbut its scope has been broadened:\nC:\\misc> C:\\python30\\python devtools_test.py\nBob is 40 years old\nBob is 40 years old\nbirthday = 5/1/1963\n110000 120000\n1 2 3 4\nArgument \"d\" defaulted\n1 2 3 9\n1 2 3 4\nArgument \"c\" defaulted\nArgument \"b\" defaulted\n1 7 8 4\nArgument \"c\" defaulted\nArgument \"b\" defaulted\n1 7 8 4\nArgument \"c\" defaulted\n1 2 8 4\nArgument \"b\" defaulted\n1 7 7 8\n\nOn validation errors, we get an exception as before (unless the –O command-line argument is passed to Python) when one of the method test lines is uncommented:\nTypeError: giveRaise argument \"percent\" not in 0.0..1.0",
    "On validation errors, we get an exception as before (unless the –O command-line argument is passed to Python) when one of the method test lines is uncommented:\nTypeError: giveRaise argument \"percent\" not in 0.0..1.0\n\nImplementation Details\nThis decorator’s code relies on both introspection APIs and subtle constraints of argument passing. To be fully general we could in principle try to mimic Python’s argument matching logic in its entirety to see which names have been passed in which\n1040 | Chapter 38: Decorators\n\n\fmodes, but that’s far too much complexity for our tool. It would be better if we could\nsomehow match arguments passed by name against the set of all expected arguments’\nnames, in order to determine which position arguments actually appear in during a\ngiven call.",
    "modes, but that’s far too much complexity for our tool. It would be better if we could\nsomehow match arguments passed by name against the set of all expected arguments’\nnames, in order to determine which position arguments actually appear in during a\ngiven call.\n\nFunction introspection\nIt turns out that the introspection API available on function objects and their associated\ncode objects has exactly the tool we need. This API was briefly introduced in Chapter 19, but we’ll actually put it to use here. The set of expected argument names is\nsimply the first N variable names attached to a function’s code object:\n# In Python 3.0 (and 2.6 for compatibility):\n>>> def func(a, b, c, d):\n...\nx = 1\n...\ny = 2\n...\n>>> code = func.__code__\n>>> code.co_nlocals\n6\n>>> code.co_varnames\n('a', 'b', 'c', 'd', 'x', 'y')\n>>> code.co_varnames[:code.co_argcount]\n('a', 'b', 'c', 'd')\n\n# Code object of function object\n# All local var names\n# First N locals are expected args",
    "# Code object of function object\n# All local var names\n# First N locals are expected args\n\n>>> import sys\n# For backward compatibility\n>>> sys.version_info\n# [0] is major release number\n(3, 0, 0, 'final', 0)\n>>> code = func.__code__ if sys.version_info[0] == 3 else func.func_code\n\nThe same API is available in older Pythons, but the func.__code__ attribute is spelled\nas func.func_code in 2.5 and earlier (the newer __code__ attribute is also redundantly\navailable in 2.6 for portability). Run a dir call on function and code objects for more\ndetails.",
    "Argument assumptions\nGiven this set of expected argument names, the solution relies on two constraints on\nargument passing order imposed by Python (these still hold true in both 2.6 and 3.0):\n• At the call, all positional arguments appear before all keyword arguments.\n• In the def, all nondefault arguments appear before all default arguments.\nThat is, a nonkeyword argument cannot generally follow a keyword argument at a call,\nand a nondefault argument cannot follow a default argument at a definition. All\n“name=value” syntax must appear after any simple “name” in both places.\nTo simplify our work, we can also make the assumption that a call is valid in general—\ni.e., that all arguments either will receive values (by name or position), or will be omitted\nintentionally to pick up defaults. This assumption won’t necessarily hold, because the\nfunction has not yet actually been called when the wrapper logic tests validity—the call\nExample: Validating Function Arguments | 1041",
    "may still fail later when invoked by the wrapper layer, due to incorrect argument passing. As long as that doesn’t cause the wrapper to fail any more badly, though, we can\nfinesse the validity of the call. This helps, because validating calls before they are actually made would require us to emulate Python’s argument-matching algorithm in\nfull—again, too complex a procedure for our tool.",
    "Matching algorithm\nNow, given these constraints and assumptions, we can allow for both keywords and\nomitted default arguments in the call with this algorithm. When a call is intercepted,\nwe can make the following assumptions:\n• All N passed positional arguments in *pargs must match the first N expected arguments obtained from the function’s code object. This is true per Python’s call\nordering rules, outlined earlier, since all positionals precede all keywords.\n• To obtain the names of arguments actually passed by position, we can slice the list\nof all expected arguments up to the length N of the *pargs positionals tuple.\n• Any arguments after the first N expected arguments either were passed by keyword\nor were defaulted by omission at the call.\n• For each argument name to be validated, if it is in **kargs it was passed by name,\nand if it is in the first N expected arguments it was passed by position (in which",
    "of all expected arguments up to the length N of the *pargs positionals tuple.\n• Any arguments after the first N expected arguments either were passed by keyword\nor were defaulted by omission at the call.\n• For each argument name to be validated, if it is in **kargs it was passed by name,\nand if it is in the first N expected arguments it was passed by position (in which\ncase its relative position in the expected list gives its relative position in *pargs);\notherwise, we can assume it was omitted in the call and defaulted and need not be\nchecked.\nIn other words, we can skip tests for arguments that were omitted in a call by assuming\nthat the first N actually passed positional arguments in *pargs must match the first N\nargument names in the list of all expected arguments, and that any others must either\nhave been passed by keyword and thus be in **kargs, or have been defaulted. Under",
    "checked.\nIn other words, we can skip tests for arguments that were omitted in a call by assuming\nthat the first N actually passed positional arguments in *pargs must match the first N\nargument names in the list of all expected arguments, and that any others must either\nhave been passed by keyword and thus be in **kargs, or have been defaulted. Under\nthis scheme, the decorator will simply skip any argument to be checked that was omitted between the rightmost positional argument and the leftmost keyword argument,\nbetween keyword arguments, or after the rightmost positional in general. Trace\nthrough the decorator and its test script to see how this is realized in code.",
    "Open Issues\nAlthough our range-testing tool works as planned, two caveats remain. First, as mentioned earlier, calls to the original function that are not valid still fail in our final decorator. The following both trigger exceptions, for example:\nomitargs()\nomitargs(d=8, c=7, b=6)\n\nThese only fail, though, where we try to invoke the original function, at the end of the\nwrapper. While we could try to imitate Python’s argument matching to avoid this,\n\n1042 | Chapter 38: Decorators",
    "there’s not much reason to do so—since the call would fail at this point anyhow, we\nmight as well let Python’s own argument-matching logic detect the problem for us.\nLastly, although our final version handles positional arguments, keyword arguments,\nand omitted defaults, it still doesn’t do anything explicit about *args and **args that\nmay be used in a decorated function that accepts arbitrarily many arguments. We\nprobably don’t need to care for our purposes, though:\n• If an extra keyword argument is passed, its name will show up in **kargs and can\nbe tested normally if mentioned to the decorator.\n• If an extra keyword argument is not passed, its name won’t be in either **kargs or\nthe sliced expected positionals list, and it will thus not be checked—it is treated as\nthough it were defaulted, even though it is really an optional extra argument.",
    "• If an extra keyword argument is passed, its name will show up in **kargs and can\nbe tested normally if mentioned to the decorator.\n• If an extra keyword argument is not passed, its name won’t be in either **kargs or\nthe sliced expected positionals list, and it will thus not be checked—it is treated as\nthough it were defaulted, even though it is really an optional extra argument.\n• If an extra positional argument is passed, there’s no way to reference it in the decorator anyhow—its name won’t be in either **kargs or the sliced expected arguments list, so it will simply be skipped. Because such arguments are not listed in\nthe function’s definition, there’s no way to map a name given to the decorator back\nto an expected relative position.\nIn other words, as it is the code supports testing arbitrary keyword arguments by name,\nbut not arbitrary positionals that are unnamed and hence have no set position in the\nfunction’s argument signature.",
    "the function’s definition, there’s no way to map a name given to the decorator back\nto an expected relative position.\nIn other words, as it is the code supports testing arbitrary keyword arguments by name,\nbut not arbitrary positionals that are unnamed and hence have no set position in the\nfunction’s argument signature.\nIn principle, we could extend the decorator’s interface to support *args in the decorated\nfunction, too, for the rare cases where this might be useful (e.g., a special argument\nname with a test to apply to all arguments in the wrapper’s *pargs beyond the length\nof the expected arguments list). Since we’ve already exhausted the space allocation for\nthis example, though, if you care about such improvements you’ve officially crossed\nover into the realm of suggested exercises.",
    "Decorator Arguments Versus Function Annotations\nInterestingly, the function annotation feature introduced in Python 3.0 could provide\nan alternative to the decorator arguments used by our example to specify range tests.\nAs we learned in Chapter 19, annotations allow us to associate expressions with arguments and return values, by coding them in the def header line itself; Python collects\nannotations in a dictionary and attaches it to the annotated function.\nWe could use this in our example to code range limits in the header line, instead of in\ndecorator arguments. We would still need a function decorator to wrap the function\nin order to intercept later calls, but we would essentially trade decorator argument\nsyntax:\n@rangetest(a=(1, 5), c=(0.0, 1.0))\ndef func(a, b, c):\nprint(a + b + c)\n\n# func = rangetest(...)(func)\n\nExample: Validating Function Arguments | 1043\n\n\ffor annotation syntax like this:\n@rangetest\ndef func(a:(1, 5), b, c:(0.0, 1.0)):\nprint(a + b + c)",
    "# func = rangetest(...)(func)\n\nExample: Validating Function Arguments | 1043\n\n\ffor annotation syntax like this:\n@rangetest\ndef func(a:(1, 5), b, c:(0.0, 1.0)):\nprint(a + b + c)\n\nThat is, the range constraints would be moved into the function itself, instead of being\ncoded externally. The following script illustrates the structure of the resulting decorators under both schemes, in incomplete skeleton code. The decorator arguments code\npattern is that of our complete solution shown earlier; the annotation alternative requires one less level of nesting, because it doesn’t need to retain decorator arguments:\n# Using decorator arguments\ndef rangetest(**argchecks):\ndef onDecorator(func):\ndef onCall(*pargs, **kargs):\nprint(argchecks)\nfor check in argchecks: pass\nreturn func(*pargs, **kargs)\nreturn onCall\nreturn onDecorator\n\n# Add validation code here\n\n@rangetest(a=(1, 5), c=(0.0, 1.0))\ndef func(a, b, c):\nprint(a + b + c)\n\n# func = rangetest(...)(func)\n\nfunc(1, 2, c=3)",
    "# Add validation code here\n\n@rangetest(a=(1, 5), c=(0.0, 1.0))\ndef func(a, b, c):\nprint(a + b + c)\n\n# func = rangetest(...)(func)\n\nfunc(1, 2, c=3)\n\n# Runs onCall, argchecks in scope\n\n# Using function annotations\ndef rangetest(func):\ndef onCall(*pargs, **kargs):\nargchecks = func.__annotations__\nprint(argchecks)\nfor check in argchecks: pass\nreturn func(*pargs, **kargs)\nreturn onCall\n\n# Add validation code here\n\n@rangetest\ndef func(a:(1, 5), b, c:(0.0, 1.0)):\nprint(a + b + c)\n\n# func = rangetest(func)\n\nfunc(1, 2, c=3)\n\n# Runs onCall, annotations on func\n\nWhen run, both schemes have access to the same validation test information, but in\ndifferent forms—the decorator argument version’s information is retained in an argument in an enclosing scope, and the annotation version’s information is retained in an\nattribute of the function itself:\n{'a': (1, 5), 'c': (0.0, 1.0)}\n6\n{'a': (1, 5), 'c': (0.0, 1.0)}\n6\n\n1044 | Chapter 38: Decorators",
    "I’ll leave fleshing out the rest of the annotation-based version as a suggested exercise;\nits code would be identical to that of our complete solution shown earlier, because\nrange-test information is simply on the function instead of in an enclosing scope. Really,\nall this buys us is a different user interface for our tool—it will still need to match\nargument names against expected argument names to obtain relative positions as\nbefore.\nIn fact, using annotation instead of decorator arguments in this example actually limits\nits utility. For one thing, annotation only works under Python 3.0, so 2.6 is no longer\nsupported; function decorators with arguments, on the other hand, work in both\nversions.\nMore importantly, by moving the validation specifications into the def header, we essentially commit the function to a single role—since annotation allows us to code only\none expression per argument, it can have only one purpose. For instance, we cannot",
    "supported; function decorators with arguments, on the other hand, work in both\nversions.\nMore importantly, by moving the validation specifications into the def header, we essentially commit the function to a single role—since annotation allows us to code only\none expression per argument, it can have only one purpose. For instance, we cannot\nuse range-test annotations for any other role.\nBy contrast, because decorator arguments are coded outside the function itself, they\nare both easier to remove and more general—the code of the function itself does not\nimply a single decoration purpose. In fact, by nesting decorators with arguments, we\ncan apply multiple augmentation steps to the same function; annotation directly supports only one. With decorator arguments, the function itself also retains a simpler,\nnormal appearance.\nStill, if you have a single purpose in mind, and you can commit to supporting 3.X only,",
    "imply a single decoration purpose. In fact, by nesting decorators with arguments, we\ncan apply multiple augmentation steps to the same function; annotation directly supports only one. With decorator arguments, the function itself also retains a simpler,\nnormal appearance.\nStill, if you have a single purpose in mind, and you can commit to supporting 3.X only,\nthe choice between annotation and decorator arguments is largely stylistic and subjective. As is so often true in life, one person’s annotation may well be another’s syntactic\nclutter....",
    "Other Applications: Type Testing (If You Insist!)\nThe coding pattern we’ve arrived at for processing arguments in decorators could be\napplied in other contexts. Checking argument data types at development time, for example, is a straightforward extension:\ndef typetest(**argchecks):\ndef onDecorator(func):\n....\ndef onCall(*pargs, **kargs):\npositionals = list(allargs)[:len(pargs)]\nfor (argname, type) in argchecks.items():\nif argname in kargs:\nif not isinstance(kargs[argname], type):\n...\nraise TypeError(errmsg)\nelif argname in positionals:\nposition = positionals.index(argname)\nif not isinstance(pargs[position], type):\n...\nraise TypeError(errmsg)\n\nExample: Validating Function Arguments | 1045\n\n\felse:\n# Assume not passed: default\nreturn func(*pargs, **kargs)\nreturn onCall\nreturn onDecorator\n@typetest(a=int, c=float)\ndef func(a, b, c, d):\n...\n\n# func = typetest(...)(func)\n\nfunc(1, 2, 3.0, 4)\nfunc('spam', 2, 99, 4)\n\n# Okay\n# Triggers exception correctly",
    "Example: Validating Function Arguments | 1045\n\n\felse:\n# Assume not passed: default\nreturn func(*pargs, **kargs)\nreturn onCall\nreturn onDecorator\n@typetest(a=int, c=float)\ndef func(a, b, c, d):\n...\n\n# func = typetest(...)(func)\n\nfunc(1, 2, 3.0, 4)\nfunc('spam', 2, 99, 4)\n\n# Okay\n# Triggers exception correctly\n\nIn fact, we might even generalize further by passing in a test function, much as we did\nto add Public decorations earlier; a single copy of this sort of code would suffice for\nboth range and type testing. Using function annotations instead of decorator arguments\nfor such a decorator, as described in the prior section, would make this look even more\nlike type declarations in other languages:\n@typetest\ndef func(a: int, b, c: float, d):\n...\n\n# func = typetest(func)\n# Gasp!...",
    "# func = typetest(func)\n# Gasp!...\n\nAs you should have learned in this book, though, this particular role is generally a bad\nidea in working code, and not at all Pythonic (in fact, it’s often a symptom of an\nex-C++ programmer’s first attempts to use Python).\nType testing restricts your function to work on specific types only, instead of allowing\nit to operate on any types with compatible interfaces. In effect, it limits your code and\nbreaks its flexibility. On the other hand, every rule has exceptions; type checking may\ncome in handy in isolated cases while debugging and when interfacing with code written in more restrictive languages, such as C++. This general pattern of argument processing might also be applicable in a variety of less controversial roles.",
    "Chapter Summary\nIn this chapter, we explored decorators—both the function and class varieties. As we\nlearned, decorators are a way to insert code to be run automatically when a function\nor class is defined. When a decorator is used, Python rebinds a function or class name\nto the callable object it returns. This hook allows us to add a layer of wrapper logic to\nfunction calls and class instance creation calls, in order to manage functions and instances. As we also saw, manager functions and manual name rebinding can achieve\nthe same effect, but decorators provide a more explicit and uniform solution.\nAs we’ll see in the next chapter, class decorators can also be used to manage classes\nthemselves, rather than just their instances. Because this functionality overlaps with\nmetaclasses, the topic of the next chapter, you’ll have to read ahead for the rest of this\nstory. First, though, work through the following quiz. Because this chapter was mostly\n\n1046 | Chapter 38: Decorators",
    "1046 | Chapter 38: Decorators\n\n\ffocused on its larger examples, its quiz will ask you to modify some of its code in order\nto review.",
    "Test Your Knowledge: Quiz\n1. As mentioned in one of this chapter’s Notes, the timer function decorator with\ndecorator arguments that we wrote in the section “Adding Decorator Arguments” on page 1008 can be applied only to simple functions, because it uses a\nnested class with a __call__ operator overloading method to catch calls. This\nstructure does not work for class methods because the decorator instance is passed\nto self, not the subject class instance. Rewrite this decorator so that it can be\napplied to both simple functions and class methods, and test it on both functions\nand methods. (Hint: see the section “Class Blunders I: Decorating Class Methods” on page 1001 for pointers.) Note that you may make use of assigning function\nobject attributes to keep track of total time, since you won’t have a nested class for\nstate retention and can’t access nonlocals from outside the decorator code.\n2. The Public/Private class decorators we wrote in this chapter will add overhead to",
    "object attributes to keep track of total time, since you won’t have a nested class for\nstate retention and can’t access nonlocals from outside the decorator code.\n2. The Public/Private class decorators we wrote in this chapter will add overhead to\nevery attribute fetch in a decorated class. Although we could simply delete the @\ndecoration line to gain speed, we could also augment the decorator itself to check\nthe __debug__ switch and perform no wrapping at all when the –O Python flag is\npassed on the command line (just as we did for the argument range-test decorators).\nThat way, we can speed our program without changing its source, via commandline arguments (python –O main.py...). Code and test this extension.",
    "Test Your Knowledge: Answers\n1. Here’s one way to code the first question’s solution, and its output (albeit with\nclass methods that run too fast to time). The trick lies in replacing nested classes\nwith nested functions, so the self argument is not the decorator’s instance, and\nassigning the total time to the decorator function itself so it can be fetched later\nthrough the original rebound name (see the section “State Information Retention\nOptions” on page 997 of this chapter for details—functions support arbitrary attribute attachment, and the function name is an enclosing scope reference in this\ncontext).\nimport time\ndef timer(label='', trace=True):\ndef onDecorator(func):\ndef onCall(*args, **kargs):\nstart\n= time.clock()\nresult = func(*args, **kargs)\nelapsed = time.clock() - start\n\n# On decorator args: retain args\n# On @: retain decorated func\n# On calls: call original\n# State is scopes + func attr\n\nTest Your Knowledge: Answers | 1047",
    "# On decorator args: retain args\n# On @: retain decorated func\n# On calls: call original\n# State is scopes + func attr\n\nTest Your Knowledge: Answers | 1047\n\n\fonCall.alltime += elapsed\nif trace:\nformat = '%s%s: %.5f, %.5f'\nvalues = (label, func.__name__, elapsed, onCall.alltime)\nprint(format % values)\nreturn result\nonCall.alltime = 0\nreturn onCall\nreturn onDecorator\n# Test on functions\n@timer(trace=True, label='[CCC]==>')\ndef listcomp(N):\nreturn [x * 2 for x in range(N)]\n\n# Like listcomp = timer(...)(listcomp)\n# listcomp(...) triggers onCall\n\n@timer(trace=True, label='[MMM]==>')\ndef mapcall(N):\nreturn list(map((lambda x: x * 2), range(N)))\n\n# list() for 3.0 views",
    "# Like listcomp = timer(...)(listcomp)\n# listcomp(...) triggers onCall\n\n@timer(trace=True, label='[MMM]==>')\ndef mapcall(N):\nreturn list(map((lambda x: x * 2), range(N)))\n\n# list() for 3.0 views\n\nfor func in (listcomp, mapcall):\nresult = func(5)\n# Time for this call, all calls, return value\nfunc(5000000)\nprint(result)\nprint('allTime = %s\\n' % func.alltime) # Total time for all calls\n# Test on methods\nclass Person:\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\n@timer()\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\n\n# giveRaise = timer()(giveRaise)\n# tracer remembers giveRaise\n\n@timer(label='**')\ndef lastName(self):\nreturn self.name.split()[-1]\n\n# lastName = timer(...)(lastName)\n# alltime per class, not instance",
    "# giveRaise = timer()(giveRaise)\n# tracer remembers giveRaise\n\n@timer(label='**')\ndef lastName(self):\nreturn self.name.split()[-1]\n\n# lastName = timer(...)(lastName)\n# alltime per class, not instance\n\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nbob.giveRaise(.10)\nsue.giveRaise(.20)\n# runs onCall(sue, .10)\nprint(bob.pay, sue.pay)\nprint(bob.lastName(), sue.lastName())\n# runs onCall(bob), remembers lastName\nprint('%.5f %.5f' % (Person.giveRaise.alltime, Person.lastName.alltime))\n# Expected output\n[CCC]==>listcomp: 0.00002, 0.00002\n[CCC]==>listcomp: 1.19636, 1.19638\n[0, 2, 4, 6, 8]\nallTime = 1.19637775192\n\n1048 | Chapter 38: Decorators\n\n\f[MMM]==>mapcall: 0.00002, 0.00002\n[MMM]==>mapcall: 2.29260, 2.29262\n[0, 2, 4, 6, 8]\nallTime = 2.2926232943\ngiveRaise: 0.00001, 0.00001\ngiveRaise: 0.00001, 0.00002\n55000.0 120000.0\n**lastName: 0.00001, 0.00001\n**lastName: 0.00001, 0.00002\nSmith Jones\n0.00002 0.00002",
    "2. The following satisfies the second question—it’s been augmented to return the\noriginal class in optimized mode (–O), so attribute accesses don’t incur a speed hit.\nReally, all I did was add the debug mode test statements and indent the class further\nto the right. Add operator overloading method redefinitions to the wrapper class\nif you want to support delegation of these to the subject class in 3.0, too (2.6 routes\nthese through __getattr__, but 3.0 and new-style classes in 2.6 do not).\ntraceMe = False\ndef trace(*args):\nif traceMe: print('[' + ' '.join(map(str, args)) + ']')\ndef accessControl(failIf):\ndef onDecorator(aClass):\nif not __debug__:\nreturn aClass\nelse:\nclass onInstance:\ndef __init__(self, *args, **kargs):\nself.__wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attr):\ntrace('get:', attr)\nif failIf(attr):\nraise TypeError('private attribute fetch: ' + attr)\nelse:\nreturn getattr(self.__wrapped, attr)\ndef __setattr__(self, attr, value):\ntrace('set:', attr, value)",
    "def onDecorator(aClass):\nif not __debug__:\nreturn aClass\nelse:\nclass onInstance:\ndef __init__(self, *args, **kargs):\nself.__wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attr):\ntrace('get:', attr)\nif failIf(attr):\nraise TypeError('private attribute fetch: ' + attr)\nelse:\nreturn getattr(self.__wrapped, attr)\ndef __setattr__(self, attr, value):\ntrace('set:', attr, value)\nif attr == '_onInstance__wrapped':\nself.__dict__[attr] = value\nelif failIf(attr):\nraise TypeError('private attribute change: ' + attr)\nelse:\nsetattr(self.__wrapped, attr, value)\nreturn onInstance\nreturn onDecorator\ndef Private(*attributes):\nreturn accessControl(failIf=(lambda attr: attr in attributes))\ndef Public(*attributes):\nreturn accessControl(failIf=(lambda attr: attr not in attributes))",
    "Test Your Knowledge: Answers | 1049\n\n\f# Test code: split me off to another file to reuse decorator\n@Private('age')\nclass Person:\ndef __init__(self, name, age):\nself.name = name\nself.age = age\nX = Person('Bob', 40)\nprint(X.name)\nX.name = 'Sue'\nprint(X.name)\n#print(X.age)\n# FAILS unles \"python -O\"\n#X.age = 999\n# ditto\n#print(X.age)\n# ditto\n\n# Person = Private('age')(Person)\n# Person = onInstance with state\n# Inside accesses run normally\n# Outside accesses validated\n\n@Public('name')\nclass Person:\ndef __init__(self, name, age):\nself.name = name\nself.age = age\nX = Person('bob', 40)\n# X is an onInstance\nprint(X.name)\n# onInstance embeds Person\nX.name = 'Sue'\nprint(X.name)\n#print(X.age)\n# FAILS unless \"python –O main.py\"\n#X.age = 999\n# ditto\n#print(X.age)\n# ditto\n\n1050 | Chapter 38: Decorators\n\n\fCHAPTER 39\n\nMetaclasses",
    "In the prior chapter, we explored decorators and studied various examples of their use.\nIn this final chapter of the book, we’re going continue our tool-builders focus and\ninvestigate another advanced topic: metaclasses.\nIn a sense, metaclasses simply extend the code-insertion model of decorators. As we\nlearned in the prior chapter, function and class decorators allow us to intercept and\naugment function calls and class instance creation calls. In a similar sprit, metaclasses\nallow us to intercept and augment class creation—they provide an API for inserting\nextra logic to be run at the conclusion of a class statement, albeit in different ways than\ndecorators. As such, they provide a general protocol for managing class objects in a\nprogram.\nLike all the subjects dealt with in this part of the book, this is an advanced topic that\ncan be investigated on an as-needed basis. In practice, metaclasses allow us to gain a",
    "extra logic to be run at the conclusion of a class statement, albeit in different ways than\ndecorators. As such, they provide a general protocol for managing class objects in a\nprogram.\nLike all the subjects dealt with in this part of the book, this is an advanced topic that\ncan be investigated on an as-needed basis. In practice, metaclasses allow us to gain a\nhigh level of control over how a set of classes work. This is a powerful concept, and\nmetaclasses are not intended for most application programmers (nor, frankly, the faint\nof heart!).\nOn the other hand, metaclasses open the door to a variety of coding patterns that may\nbe difficult or impossible to achieve otherwise, and they are especially of interest to\nprogrammers seeking to write flexible APIs or programming tools for others to use.\nEven if you don’t fall into that category, metaclasses can teach you much about Python’s\nclass model in general.",
    "of heart!).\nOn the other hand, metaclasses open the door to a variety of coding patterns that may\nbe difficult or impossible to achieve otherwise, and they are especially of interest to\nprogrammers seeking to write flexible APIs or programming tools for others to use.\nEven if you don’t fall into that category, metaclasses can teach you much about Python’s\nclass model in general.\nAs in the prior chapter, part of our goal here is also to show more realistic code examples\nthan we did earlier in this book. Although metaclasses are a core language topic and\nnot themselves an application domain, part of this chapter’s goal is to spark your interest in exploring larger application-programming examples after you finish this book.",
    "1051\n\n\fTo Metaclass or Not to Metaclass\nMetaclasses are perhaps the most advanced topic in this book, if not the Python language as a whole. To borrow a quote from the comp.lang.python newsgroup by veteran\nPython core developer Tim Peters (who is also the author of the famous “import this”\nPython motto):\n[Metaclasses] are deeper magic than 99% of users should ever worry about. If you wonder\nwhether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).",
    "In other words, metaclasses are primarily intended for programmers building APIs and\ntools for others to use. In many (if not most) cases, they are probably not the best choice\nin applications work. This is especially true if you’re developing code that other people\nwill use in the future. Coding something “because it seems cool” is not generally a\nreasonable justification, unless you are experimenting or learning.\nStill, metaclasses have a wide variety of potential roles, and it’s important to know when\nthey can be useful. For example, they can be used to enhance classes with features like\ntracing, object persistence, exception logging, and more. They can also be used to construct portions of a class at runtime based upon configuration files, apply function\ndecorators to every method of a class generically, verify conformance to expected\ninterfaces, and so on.",
    "they can be useful. For example, they can be used to enhance classes with features like\ntracing, object persistence, exception logging, and more. They can also be used to construct portions of a class at runtime based upon configuration files, apply function\ndecorators to every method of a class generically, verify conformance to expected\ninterfaces, and so on.\nIn their more grandiose incarnations, metaclasses can even be used to implement alternative coding patterns such as aspect-oriented programming, object/relational mappers (ORMs) for databases, and more. Although there are often alternative ways to\nachieve such results (as we’ll see, the roles of class decorators and metaclasses often\nintersect), metaclasses provide a formal model tailored to those tasks. We don’t have\nspace to explore all such applications first-hand in this chapter but you should feel free\nto search the Web for additional use cases after studying the basics here.",
    "achieve such results (as we’ll see, the roles of class decorators and metaclasses often\nintersect), metaclasses provide a formal model tailored to those tasks. We don’t have\nspace to explore all such applications first-hand in this chapter but you should feel free\nto search the Web for additional use cases after studying the basics here.\nProbably the reason for studying metaclasses most relevant to this book is that this\ntopic can help demystify Python’s class mechanics in general. Although you may or\nmay not code or reuse them in your work, a cursory understanding of metaclasses can\nimpart a deeper understanding of Python at large.",
    "Increasing Levels of Magic\nMost of this book has focused on straightforward application-coding techniques, as\nmost programmers spend their time writing modules, functions, and classes to achieve\nreal-world goals. They may use classes and make instances, and might even do a bit of\noperator overloading, but they probably won’t get too deep into the details of how their\nclasses actually work.\n\n1052 | Chapter 39: Metaclasses",
    "However, in this book we’ve also seen a variety of tools that allow us to control Python’s\nbehavior in generic ways, and that often have more to do with Python internals or tool\nbuilding than with application-programming domains:\nIntrospection attributes\nSpecial attributes like __class__ and __dict__ allow us to inspect internal implementation aspects of Python objects, in order to process them generically—to list\nall attributes of an object, display a class’s name, and so on.\nOperator overloading methods\nSpecially named methods such as __str__ and __add__ coded in classes intercept\nand provide behavior for built-in operations applied to class instances, such as\nprinting, expression operators, and so on. They are run automatically in response\nto built-in operations and allow classes to conform to expected interfaces.\nAttribute interception methods\nA special category of operator overloading methods provide a way to intercept",
    "and provide behavior for built-in operations applied to class instances, such as\nprinting, expression operators, and so on. They are run automatically in response\nto built-in operations and allow classes to conform to expected interfaces.\nAttribute interception methods\nA special category of operator overloading methods provide a way to intercept\nattribute accesses on instances generically: __getattr__, __setattr__, and\n__getattribute__ allow wrapper classes to insert automatically run code that may\nvalidate attribute requests and delegate them to embedded objects. They allow any\nnumber of attributes of an object—either selected attributes, or all of them—to be\ncomputed when accessed.\nClass properties\nThe property built-in allows us to associate code with a specific class attribute that\nis automatically run when the attribute is fetched, assigned, or deleted. Though\nnot as generic as the prior paragraph’s tools, properties allow for automatic code",
    "number of attributes of an object—either selected attributes, or all of them—to be\ncomputed when accessed.\nClass properties\nThe property built-in allows us to associate code with a specific class attribute that\nis automatically run when the attribute is fetched, assigned, or deleted. Though\nnot as generic as the prior paragraph’s tools, properties allow for automatic code\ninvocation on access to specific attributes.\nClass attribute descriptors\nReally, property is a succinct way to define an attribute descriptor that runs functions on access automatically. Descriptors allow us to code in a separate class\n__get__, __set__, and __delete__ handler methods that are run automatically when\nan attribute assigned to an instance of that class is accessed. They provide a general\nway to insert automatically run code when a specific attribute is accessed, and they\nare triggered after an attribute is looked up normally.\nFunction and class decorators",
    "__get__, __set__, and __delete__ handler methods that are run automatically when\nan attribute assigned to an instance of that class is accessed. They provide a general\nway to insert automatically run code when a specific attribute is accessed, and they\nare triggered after an attribute is looked up normally.\nFunction and class decorators\nAs we saw in Chapter 38, the special @callable syntax for decorators allows us to\nadd logic to be automatically run when a function is called or a class instance is\ncreated. This wrapper logic can trace or time calls, validate arguments, manage all\ninstances of a class, augment instances with extra behavior such as attribute fetch\nvalidation, and more. Decorator syntax inserts name-rebinding logic to be run at\nthe end of function and class definition statements—decorated function and class\nnames are rebound to callable objects that intercept later calls.",
    "To Metaclass or Not to Metaclass | 1053",
    "As mentioned in this chapter’s introduction, metaclasses are a continuation of this\nstory—they allow us to insert logic to be run automatically when a class object is created, at the end of a class statement. This logic doesn’t rebind the class name to a\ndecorator callable, but rather routes creation of the class itself to specialized logic.\nIn other words, metaclasses are ultimately just another way to define automatically run\ncode. Via metaclasses and the other tools just listed, Python provides ways for us to\ninterject logic in a variety of contexts—at operator evaluation, attribute access, function\ncalls, class instance creation, and now class object creation.\nUnlike class decorators, which usually add logic to be run at instance creation time,\nmetaclasses run at class creation time; as such, they are hooks generally used for managing or augmenting classes, instead of their instances.\nFor example, metaclasses can be used to add decoration to all methods of classes",
    "calls, class instance creation, and now class object creation.\nUnlike class decorators, which usually add logic to be run at instance creation time,\nmetaclasses run at class creation time; as such, they are hooks generally used for managing or augmenting classes, instead of their instances.\nFor example, metaclasses can be used to add decoration to all methods of classes\nautomatically, register all classes in use to an API, add user-interface logic to classes\nautomatically, create or extend classes from simplified specifications in text files, and\nso on. Because we can control how classes are made (and by proxy the behavior their\ninstances acquire), their applicability is potentially very wide.\nAs we’ve also seen, many of these advanced Python tools have intersecting roles. For\nexample, attributes can often be managed with properties, descriptors, or attribute\ninterception methods. As we’ll see in this chapter, class decorators and metaclasses can",
    "instances acquire), their applicability is potentially very wide.\nAs we’ve also seen, many of these advanced Python tools have intersecting roles. For\nexample, attributes can often be managed with properties, descriptors, or attribute\ninterception methods. As we’ll see in this chapter, class decorators and metaclasses can\noften be used interchangeably as well. Although class decorators are often used to\nmanage instances, they can be used to manage classes instead; similarly, while metaclasses are designed to augment class construction, they can often insert code to manage\ninstances, too. Since the choice of which technique to use is sometimes purely subjective, knowledge of the alternatives can help you pick the right tool for a given task.",
    "The Downside of “Helper” Functions\nAlso like the decorators of the prior chapter, metaclasses are often optional, from a\ntheoretical perspective. We can usually achieve the same effect by passing class objects\nthrough manager functions (sometimes known as “helper” functions), much as we can\nachieve the goals of decorators by passing functions and instances through manager\ncode. Just like decorators, though, metaclasses:\n• Provide a more formal and explicit structure\n• Help ensure that application programmers won’t forget to augment their classes\naccording to an API’s requirements\n• Avoid code redundancy and its associated maintenance costs by factoring class\ncustomization logic into a single location, the metaclass\nTo illustrate, suppose we want to automatically insert a method into a set of classes.\nOf course, we could do this with simple inheritance, if the subject method is known\n\n1054 | Chapter 39: Metaclasses",
    "1054 | Chapter 39: Metaclasses\n\n\fwhen we code the classes. In that case, we can simply code the method in a superclass\nand have all the classes in question inherit from it:\nclass Extras:\ndef extra(self, args):\n...\n\n# Normal inheritance: too static\n\nclass Client1(Extras): ...\nclass Client2(Extras): ...\nclass Client3(Extras): ...\n\n# Clients inherit extra methods\n\nX = Client1()\nX.extra()\n\n# Make an instance\n# Run the extra methods\n\nSometimes, though, it’s impossible to predict such augmentation when classes are coded. Consider the case where classes are augmented in response to choices made in a\nuser interface at runtime, or to specifications typed in a configuration file. Although\nwe could code every class in our imaginary set to manually check these, too, it’s a lot\nto ask of clients (required is abstract here—it’s something to be filled in):\ndef extra(self, arg): ...\nclass Client1: ...\nif required():\nClient1.extra = extra\n\n# Client augments: too distributed",
    "# Client augments: too distributed\n\nclass Client2: ...\nif required():\nClient2.extra = extra\nclass Client3: ...\nif required():\nClient3.extra = extra\nX = Client1()\nX.extra()\n\nWe can add methods to a class after the class statement like this because a class method\nis just a function that is associated with a class and has a first argument to receive the\nself instance. Although this works, it puts all the burden of augmentation on client\nclasses (and assumes they’ll remember to do this at all!).\nIt would be better from a maintenance perspective to isolate the choice logic in a single\nplace. We might encapsulate some of this extra work by routing classes though a\nmanager function—such a manager function would extend the class as required and\nhandle all the work of runtime testing and configuration:\ndef extra(self, arg): ...\ndef extras(Class):\nif required():\nClass.extra = extra\n\n# Manager function: too manual\n\nclass Client1: ...\n\nTo Metaclass or Not to Metaclass | 1055",
    "# Manager function: too manual\n\nclass Client1: ...\n\nTo Metaclass or Not to Metaclass | 1055\n\n\fextras(Client1)\nclass Client2: ...\nextras(Client2)\nclass Client3: ...\nextras(Client3)\nX = Client1()\nX.extra()",
    "This code runs the class through a manager function immediately after it is created.\nAlthough manager functions like this one can achieve our goal here, they still put a\nfairly heavy burden on class coders, who must understand the requirements and adhere\nto them in their code. It would be better if there were a simple way to enforce the\naugmentation in the subject classes, so that they don’t need to deal with and can’t forget\nto use the augmentation. In other words, we’d like to be able to insert some code to\nrun automatically at the end of a class statement, to augment the class.\nThis is exactly what metaclasses do—by declaring a metaclass, we tell Python to route\nthe creation of the class object to another class we provide:\ndef extra(self, arg): ...\nclass Extras(type):\ndef __init__(Class, classname, superclasses, attributedict):\nif required():\nClass.extra = extra\nclass Client1(metaclass=Extras): ...\nclass Client2(metaclass=Extras): ...\nclass Client3(metaclass=Extras): ...",
    "# Metaclass declaration only\n# Client class is instance of meta\n\nX = Client1()\nX.extra()\n\n# X is instance of Client1\n\nBecause Python invokes the metaclass automatically at the end of the class statement\nwhen the new class is created, it can augment, register, or otherwise manage the class\nas needed. Moreover, the only requirement for the client classes is that they declare the\nmetaclass; every class that does so will automatically acquire whatever augmentation\nthe metaclass provides, both now and in the future if the metaclass changes. Although\nit may be difficult to see in this small example, metaclasses generally handle such tasks\nbetter than other approaches.",
    "Metaclasses Versus Class Decorators: Round 1\nHaving said that, it’s also interesting to note that the class decorators described in the\npreceding chapter sometimes overlap with metaclasses in terms of functionality. Although they are typically used for managing or augmenting instances, class decorators\ncan also augment classes, independent of any created instances.\n\n1056 | Chapter 39: Metaclasses\n\n\fFor example, suppose we coded our manager function to return the augmented class,\ninstead of simply modifying it in-place. This would allow a greater degree of flexibility,\nbecause the manager would be free to return any type of object that implements the\nclass’s expected interface:\ndef extra(self, arg): ...\ndef extras(Class):\nif required():\nClass.extra = extra\nreturn Class\nclass Client1: ...\nClient1 = extras(Client1)\nclass Client2: ...\nClient2 = extras(Client2)\nclass Client3: ...\nClient3 = extras(Client3)\nX = Client1()\nX.extra()",
    "If you think this is starting to look reminiscent of class decorators, you’re right. In the\nprior chapter we presented class decorators as a tool for augmenting instance creation\ncalls. Because they work by automatically rebinding a class name to the result of a\nfunction, though, there’s no reason that we can’t use them to augment the class before\nany instances are ever created. That is, class decorators can apply extra logic to\nclasses, not just instances, at creation time:\ndef extra(self, arg): ...\ndef extras(Class):\nif required():\nClass.extra = extra\nreturn Class\n@extras\nclass Client1: ...\n\n# Client1 = extras(Client1)\n\n@extras\nclass Client2: ...\n\n# Rebinds class independent of instances\n\n@extras\nclass Client3: ...\nX = Client1()\nX.extra()\n\n# Makes instance of augmented class\n# X is instance of original Client1\n\nDecorators essentially automate the prior example’s manual name rebinding here. Just\nlike with metaclasses, because the decorator returns the original class, instances are",
    "# Client1 = extras(Client1)\n\n@extras\nclass Client2: ...\n\n# Rebinds class independent of instances\n\n@extras\nclass Client3: ...\nX = Client1()\nX.extra()\n\n# Makes instance of augmented class\n# X is instance of original Client1\n\nDecorators essentially automate the prior example’s manual name rebinding here. Just\nlike with metaclasses, because the decorator returns the original class, instances are\n\nTo Metaclass or Not to Metaclass | 1057",
    "made from it, not from a wrapper object. In fact, instance creation is not intercepted\nat all.\nIn this specific case—adding methods to a class when it’s created—the choice between\nmetaclasses and decorators is somewhat arbitrary. Decorators can be used to manage\nboth instances and classes, and they intersect with metaclasses in the second of these\nroles.\nHowever, this really addresses only one operational mode of metaclasses. As we’ll see,\ndecorators correspond to metaclass __init__ methods in this role, but metaclasses have\nadditional customization hooks. As we’ll also see, in addition to class initialization,\nmetaclasses can perform arbitrary construction tasks that might be more difficult with\ndecorators.\nMoreover, although decorators can manage both instances and classes, the converse is\nnot as direct—metaclasses are designed to manage classes, and applying them to managing instances is less straightforward. We’ll explore this difference in code later in this\nchapter.",
    "metaclasses can perform arbitrary construction tasks that might be more difficult with\ndecorators.\nMoreover, although decorators can manage both instances and classes, the converse is\nnot as direct—metaclasses are designed to manage classes, and applying them to managing instances is less straightforward. We’ll explore this difference in code later in this\nchapter.\nMuch of this section’s code has been abstract, but we’ll flesh it out into a real working\nexample later in this chapter. To fully understand how metaclasses work, though, we\nfirst need to get a clearer picture of their underlying model.",
    "The Metaclass Model\nTo really understand how metaclasses do their work, you need to understand a bit more\nabout Python’s type model and what happens at the end of a class statement.",
    "Classes Are Instances of type\nSo far in this book, we’ve done most of our work by making instances of built-in types\nlike lists and strings, as well as instances of classes we code ourselves. As we’ve seen,\ninstances of classes have some state information attributes of their own, but they also\ninherit behavioral attributes from the classes from which they are made. The same holds\ntrue for built-in types; list instances, for example, have values of their own, but they\ninherit methods from the list type.\nWhile we can get a lot done with such instance objects, Python’s type model turns out\nto be a bit richer than I’ve formally described. Really, there’s a hole in the model we’ve\nseen thus far: if instances are created from classes, what is it that creates our classes? It\nturns out that classes are instances of something, too:\n• In Python 3.0, user-defined class objects are instances of the object named type,\nwhich is itself a class.",
    "to be a bit richer than I’ve formally described. Really, there’s a hole in the model we’ve\nseen thus far: if instances are created from classes, what is it that creates our classes? It\nturns out that classes are instances of something, too:\n• In Python 3.0, user-defined class objects are instances of the object named type,\nwhich is itself a class.\n• In Python 2.6, new-style classes inherit from object, which is a subclass of type;\nclassic classes are instances of type and are not created from a class.",
    "1058 | Chapter 39: Metaclasses\n\n\fWe explored the notion of types in Chapter 9 and the relationship of classes to types\nin Chapter 31, but let’s review the basics here so we can see how they apply to\nmetaclasses.\nRecall that the type built-in returns the type of any object (which is itself an object).\nFor built-in types like lists, the type of the instance is the built-in list type, but the type\nof the list type is the type type itself—the type object at the top of the hierarchy creates\nspecific types, and specific types create instances. You can see this for yourself at the\ninteractive prompt. In Python 3.0, for example:\nC:\\misc> c:\\python30\\python\n>>> type([])\n<class 'list'>\n>>> type(type([]))\n<class 'type'>\n>>> type(list)\n<class 'type'>\n>>> type(type)\n<class 'type'>\n\n# In 3.0 list is instance of list type\n# Type of list is type class\n# Same, but with type names\n# Type of type is type: top of hierarchy",
    "# In 3.0 list is instance of list type\n# Type of list is type class\n# Same, but with type names\n# Type of type is type: top of hierarchy\n\nAs we learned when studying new-style class changes in Chapter 31, the same is generally true in Python 2.6 (and older), but types are not quite the same as classes—\ntype is a unique kind of built-in object that caps the type hierarchy and is used to\nconstruct types:\nC:\\misc> c:\\python26\\python\n>>> type([])\n<type 'list'>\n>>> type(type([]))\n<type 'type'>\n\n# In 2.6, type is a bit different\n\n>>> type(list)\n<type 'type'>\n>>> type(type)\n<type 'type'>",
    "# In 2.6, type is a bit different\n\n>>> type(list)\n<type 'type'>\n>>> type(type)\n<type 'type'>\n\nIt turns out that the type/instance relationship holds true for classes as well: instances\nare created from classes, and classes are created from type. In Python 3.0, though, the\nnotion of a “type” is merged with the notion of a “class.” In fact, the two are essentially\nsynonyms—classes are types, and types are classes. That is:\n• Types are defined by classes that derive from type.\n• User-defined classes are instances of type classes.\n• User-defined classes are types that generate instances of their own.\nAs we saw earlier, this equivalence effects code that tests the type of instances: the type\nof an instance is the class from which it was generated. It also has implications for the\nway that classes are created that turn out to be the key to this chapter’s subject. Because\nclasses are normally created from a root type class by default, most programmers don’t\n\nThe Metaclass Model | 1059",
    "The Metaclass Model | 1059\n\n\fneed to think about this type/class equivalence. However, it opens up new possibilities\nfor customizing both classes and their instances.\nFor example, classes in 3.0 (and new-style classes in 2.6) are instances of the type class,\nand instance objects are instances of their classes; in fact, classes now have a\n__class__ that links to type, just as an instance has a __class__ that links to the class\nfrom which it was made:\nC:\\misc> c:\\python30\\python\n>>> class C: pass\n...\n>>> X = C()\n\n# 3.0 class object (new-style)\n# Class instance object\n\n>>> type(X)\n<class '__main__.C'>\n>>> X.__class__\n<class '__main__.C'>\n\n# Instance is instance of class\n\n>>> type(C)\n<class 'type'>\n>>> C.__class__\n<class 'type'>\n\n# Class is instance of type\n\n# Instance's class\n\n# Class's class is type",
    "# 3.0 class object (new-style)\n# Class instance object\n\n>>> type(X)\n<class '__main__.C'>\n>>> X.__class__\n<class '__main__.C'>\n\n# Instance is instance of class\n\n>>> type(C)\n<class 'type'>\n>>> C.__class__\n<class 'type'>\n\n# Class is instance of type\n\n# Instance's class\n\n# Class's class is type\n\nNotice especially the last two lines here—classes are instances of the type class, just as\nnormal instances are instances of a class. This works the same for both built-ins and\nuser-defined class types in 3.0. In fact, classes are not really a separate concept at all:\nthey are simply user-defined types, and type itself is defined by a class.\nIn Python 2.6, things work similarly for new-style classes derived from object, because\nthis enables 3.0 class behavior:\nC:\\misc> c:\\python26\\python\n>>> class C(object): pass\n...\n>>> X = C()\n\n# In 2.6 new-style classes,\n# classes have a class too",
    "# In 2.6 new-style classes,\n# classes have a class too\n\n>>> type(X)\n<class '__main__.C'>\n>>> type(C)\n<type 'type'>\n>>> X.__class__\n<class '__main__.C'>\n>>> C.__class__\n<type 'type'>\n\nClassic classes in 2.6 are a bit different, though—because they reflect the class model\nin older Python releases, they do not have a __class__ link, and like built-in types in\n2.6 they are instances of type, not a type class:\nC:\\misc> c:\\python26\\python\n>>> class C: pass\n...\n>>> X = C()\n\n1060 | Chapter 39: Metaclasses\n\n# In 2.6 classic classes,\n# classes have no class themselves\n\n\f>>> type(X)\n<type 'instance'>\n>>> type(C)\n<type 'classobj'>\n>>> X.__class__\n<class __main__.C at 0x005F85A0>\n>>> C.__class__\nAttributeError: class C has no attribute '__class__'",
    "Metaclasses Are Subclasses of Type\nSo why do we care that classes are instances of a type class in 3.0? It turns out that this\nis the hook that allows us to code metaclasses. Because the notion of type is the same\nas class today, we can subclass type with normal object-oriented techniques and class\nsyntax to customize it. And because classes are really instances of the type class,\ncreating classes from customized subclasses of type allows us to implement custom\nkinds of classes. In full detail, this all works out quite naturally—in 3.0, and in 2.6 newstyle classes:\n• type is a class that generates user-defined classes.\n• Metaclasses are subclasses of the type class.\n• Class objects are instances of the type class, or a subclass thereof.\n• Instance objects are generated from a class.\nIn other words, to control the way classes are created and augment their behavior, all",
    "• type is a class that generates user-defined classes.\n• Metaclasses are subclasses of the type class.\n• Class objects are instances of the type class, or a subclass thereof.\n• Instance objects are generated from a class.\nIn other words, to control the way classes are created and augment their behavior, all\nwe need to do is specify that a user-defined class be created from a user-defined metaclass instead of the normal type class.\nNotice that this type instance relationship is not quite the same as inheritance: userdefined classes may also have superclasses from which they and their instances inherit\nattributes (inheritance superclasses are listed in parentheses in the class statement and\nshow up in a class’s __bases__ tuple). The type from which a class is created, and of\nwhich it is an instance, is a different relationship. The next section describes the procedure Python follows to implement this instance-of type relationship.",
    "Class Statement Protocol\nSubclassing the type class to customize it is really only half of the magic behind metaclasses. We still need to somehow route a class’s creation to the metaclass, instead of\nthe default type. To fully understand how this is arranged, we also need to know how\nclass statements do their business.\nWe’ve already learned that when Python reaches a class statement, it runs its nested\nblock of code to create its attributes—all the names assigned at the top level of the\nnested code block generate attributes in the resulting class object. These names are\n\nThe Metaclass Model | 1061",
    "The Metaclass Model | 1061\n\n\fusually method functions created by nested defs, but they can also be arbitrary attributes assigned to create class data shared by all instances.\nTechnically speaking, Python follows a standard protocol to make this happen: at the\nend of a class statement, and after running all its nested code in a namespace dictionary,\nit calls the type object to create the class object:\nclass = type(classname, superclasses, attributedict)\n\nThe type object in turn defines a __call__ operator overloading method that runs two\nother methods when the type object is called:\ntype.__new__(typeclass, classname, superclasses, attributedict)\ntype.__init__(class, classname, superclasses, attributedict)",
    "The type object in turn defines a __call__ operator overloading method that runs two\nother methods when the type object is called:\ntype.__new__(typeclass, classname, superclasses, attributedict)\ntype.__init__(class, classname, superclasses, attributedict)\n\nThe __new__ method creates and returns the new class object, and then the __init__\nmethod initializes the newly created object. As we’ll see in a moment, these are the\nhooks that metaclass subclasses of type generally use to customize classes.\nFor example, given a class definition like the following:\nclass Spam(Eggs):\ndata = 1\ndef meth(self, arg):\npass\n\n# Inherits from Eggs\n# Class data attribute\n# Class method attribute\n\nPython will internally run the nested code block to create two attributes of the class\n(data and meth), and then call the type object to generate the class object at the end of\nthe class statement:\nSpam = type('Spam', (Eggs,), {'data': 1, 'meth': meth, '__module__': '__main__'})",
    "# Inherits from Eggs\n# Class data attribute\n# Class method attribute\n\nPython will internally run the nested code block to create two attributes of the class\n(data and meth), and then call the type object to generate the class object at the end of\nthe class statement:\nSpam = type('Spam', (Eggs,), {'data': 1, 'meth': meth, '__module__': '__main__'})\n\nBecause this call is made at the end of the class statement, it’s an ideal hook for augmenting or otherwise processing a class. The trick lies in replacing type with a custom\nsubclass that will intercept this call. The next section shows how.",
    "Because this call is made at the end of the class statement, it’s an ideal hook for augmenting or otherwise processing a class. The trick lies in replacing type with a custom\nsubclass that will intercept this call. The next section shows how.\n\nDeclaring Metaclasses\nAs we’ve just seen, classes are created by the type class by default. To tell Python to\ncreate a class with a custom metaclass instead, you simply need to declare a metaclass\nto intercept the normal class creation call. How you do so depends on which Python\nversion you are using. In Python 3.0, list the desired metaclass as a keyword argument\nin the class header:\nclass Spam(metaclass=Meta):\n\n# 3.0 and later\n\nInheritance superclasses can be listed in the header as well, before the metaclass. In the\nfollowing, for example, the new class Spam inherits from Eggs but is also an instance of\nand is created by Meta:\nclass Spam(Eggs, metaclass=Meta):\n\n1062 | Chapter 39: Metaclasses\n\n# Other supers okay",
    "# 3.0 and later\n\nInheritance superclasses can be listed in the header as well, before the metaclass. In the\nfollowing, for example, the new class Spam inherits from Eggs but is also an instance of\nand is created by Meta:\nclass Spam(Eggs, metaclass=Meta):\n\n1062 | Chapter 39: Metaclasses\n\n# Other supers okay\n\n\fWe can get the same effect in Python 2.6, but we must specify the metaclass\ndifferently—using a class attribute instead of a keyword argument. The object derivation is required to make this a new-style class, and this form no longer works in 3.0 as\nthe attribute is simply ignored:\nclass spam(object):\n__metaclass__ = Meta\n\n# 2.6 version (only)",
    "1062 | Chapter 39: Metaclasses\n\n# Other supers okay\n\n\fWe can get the same effect in Python 2.6, but we must specify the metaclass\ndifferently—using a class attribute instead of a keyword argument. The object derivation is required to make this a new-style class, and this form no longer works in 3.0 as\nthe attribute is simply ignored:\nclass spam(object):\n__metaclass__ = Meta\n\n# 2.6 version (only)\n\nIn 2.6, a module-global __metaclass__ variable is also available to link all classes in the\nmodule to a metaclass. This is no longer supported in 3.0, as it was intended as a\ntemporary measure to make it easier to default to new-style classes without deriving\nevery class from object.\nWhen declared in these ways, the call to create the class object run at the end of the\nclass statement is modified to invoke the metaclass instead of the type default:\nclass = Meta(classname, superclasses, attributedict)",
    "And because the metaclass is a subclass of type, the type class’s __call__ delegates the\ncalls to create and initialize the new class object to the metaclass, if it defines custom\nversions of these methods:\nMeta.__new__(Meta, classname, superclasses, attributedict)\nMeta.__init__(class, classname, superclasses, attributedict)\n\nTo demonstrate, here’s the prior section’s example again, augmented with a 3.0\nmetaclass specification:\nclass Spam(Eggs, metaclass=Meta):\ndata = 1\ndef meth(self, arg):\npass\n\n# Inherits from Eggs, instance of Meta\n# Class data attribute\n# Class method attribute\n\nAt the end of this class statement, Python internally runs the following to create the\nclass object:\nSpam = Meta('Spam', (Eggs,), {'data': 1, 'meth': meth, '__module__': '__main__'})",
    "# Inherits from Eggs, instance of Meta\n# Class data attribute\n# Class method attribute\n\nAt the end of this class statement, Python internally runs the following to create the\nclass object:\nSpam = Meta('Spam', (Eggs,), {'data': 1, 'meth': meth, '__module__': '__main__'})\n\nIf the metaclass defines its own versions of __new__ or __init__, they will be invoked\nin turn during this call by the inherited type class’s __call__ method, to create and\ninitialize the new class. The next section shows how we might go about coding this\nfinal piece of the metaclass puzzle.",
    "If the metaclass defines its own versions of __new__ or __init__, they will be invoked\nin turn during this call by the inherited type class’s __call__ method, to create and\ninitialize the new class. The next section shows how we might go about coding this\nfinal piece of the metaclass puzzle.\n\nCoding Metaclasses\nSo far, we’ve seen how Python routes class creation calls to a metaclass, if one is provided. How, though, do we actually code a metaclass that customizes type?\nIt turns out that you already know most of the story—metaclasses are coded with\nnormal Python class statements and semantics. Their only substantial distinctions are\nthat Python calls them automatically at the end of a class statement, and that they\nmust adhere to the interface expected by the type superclass.\nCoding Metaclasses | 1063",
    "A Basic Metaclass\nPerhaps the simplest metaclass you can code is simply a subclass of type with a\n__new__ method that creates the class object by running the default version in type. A\nmetaclass __new__ like this is run by the __call__ method inherited from type; it typically performs whatever customization is required and calls the type superclass’s\n__new__ method to create and return the new class object:\nclass Meta(type):\ndef __new__(meta, classname, supers, classdict):\n# Run by inherited type.__call__\nreturn type.__new__(meta, classname, supers, classdict)",
    "This metaclass doesn’t really do anything (we might as well let the default type class\ncreate the class), but it demonstrates the way a metaclass taps into the metaclass hook\nto customize—because the metaclass is called at the end of a class statement, and\nbecause the type object’s __call__ dispatches to the __new__ and __init__ methods,\ncode we provide in these methods can manage all the classes created from the metaclass.\nHere’s our example in action again, with prints added to the metaclass and the file at\nlarge to trace:\nclass MetaOne(type):\ndef __new__(meta, classname, supers, classdict):\nprint('In MetaOne.new:', classname, supers, classdict, sep='\\n...')\nreturn type.__new__(meta, classname, supers, classdict)\nclass Eggs:\npass\nprint('making class')\nclass Spam(Eggs, metaclass=MetaOne):\ndata = 1\ndef meth(self, arg):\npass\n\n# Inherits from Eggs, instance of Meta\n# Class data attribute\n# Class method attribute\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)",
    "# Inherits from Eggs, instance of Meta\n# Class data attribute\n# Class method attribute\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)\n\nHere, Spam inherits from Eggs and is an instance of MetaOne, but X is an instance of and\ninherits from Spam. When this code is run with Python 3.0, notice how the metaclass\nis invoked at the end of the class statement, before we ever make an instance—\nmetaclasses are for processing classes, and classes are for processing instances:\nmaking class\nIn MetaOne.new:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02AEBA08>}\nmaking instance\ndata: 1\n\n1064 | Chapter 39: Metaclasses",
    "1064 | Chapter 39: Metaclasses\n\n\fCustomizing Construction and Initialization\nMetaclasses can also tap into the __init__ protocol invoked by the type object’s\n__call__: in general, __new__ creates and returns the class object, and __init__ initializes the already created class. Metaclasses can use both hooks to manage the class at\ncreation time:\nclass MetaOne(type):\ndef __new__(meta, classname, supers, classdict):\nprint('In MetaOne.new: ', classname, supers, classdict, sep='\\n...')\nreturn type.__new__(meta, classname, supers, classdict)\ndef __init__(Class, classname, supers, classdict):\nprint('In MetaOne init:', classname, supers, classdict, sep='\\n...')\nprint('...init class object:', list(Class.__dict__.keys()))\nclass Eggs:\npass\nprint('making class')\nclass Spam(Eggs, metaclass=MetaOne):\ndata = 1\ndef meth(self, arg):\npass\n\n# Inherits from Eggs, instance of Meta\n# Class data attribute\n# Class method attribute\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)",
    "# Inherits from Eggs, instance of Meta\n# Class data attribute\n# Class method attribute\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)\n\nIn this case, the class initialization method is run after the class construction method,\nbut both run at the end of the class statement before any instances are made:\nmaking class\nIn MetaOne.new:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02AAB810>}\nIn MetaOne init:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02AAB810>}\n...init class object: ['__module__', 'data', 'meth', '__doc__']\nmaking instance\ndata: 1\n\nOther Metaclass Coding Techniques\nAlthough redefining the type superclass’s __new__ and __init__ methods is the most\ncommon way metaclasses insert logic into the class object creation process, other\nschemes are possible, too.\n\nCoding Metaclasses | 1065",
    "Coding Metaclasses | 1065\n\n\fUsing simple factory functions\nFor example, metaclasses need not really be classes at all. As we’ve learned, the class\nstatement issues a simple call to create a class at the conclusion of its processing. Because of this, any callable object can in principle be used as a metaclass, provided it\naccepts the arguments passed and returns an object compatible with the intended class.\nIn fact, a simple object factory function will serve just as well as a class:\n# A simple function can serve as a metaclass too\ndef MetaFunc(classname, supers, classdict):\nprint('In MetaFunc: ', classname, supers, classdict, sep='\\n...')\nreturn type(classname, supers, classdict)\nclass Eggs:\npass\nprint('making class')\nclass Spam(Eggs, metaclass=MetaFunc):\ndata = 1\ndef meth(self, args):\npass\n\n# Run simple function at end\n# Function returns class\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)",
    "# Run simple function at end\n# Function returns class\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)\n\nWhen run, the function is called at the end of the declaring class statement, and it\nreturns the expected new class object. The function is simply catching the call that the\ntype object’s __call__ normally intercepts by default:\nmaking class\nIn MetaFunc:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02B8B6A8>}\nmaking instance\ndata: 1",
    "Overloading class creation calls with metaclasses\nSince they participate in normal OOP mechanics, it’s also possible for metaclasses to\ncatch the creation call at the end of a class statement directly, by redefining the type\nobject’s __call__. The required protocol is a bit involved, though:\n# __call__ can be redefined, metas can have metas\nclass SuperMeta(type):\ndef __call__(meta, classname, supers, classdict):\nprint('In SuperMeta.call: ', classname, supers, classdict, sep='\\n...')\nreturn type.__call__(meta, classname, supers, classdict)\nclass SubMeta(type, metaclass=SuperMeta):\ndef __new__(meta, classname, supers, classdict):\n\n1066 | Chapter 39: Metaclasses",
    "1066 | Chapter 39: Metaclasses\n\n\fprint('In SubMeta.new: ', classname, supers, classdict, sep='\\n...')\nreturn type.__new__(meta, classname, supers, classdict)\ndef __init__(Class, classname, supers, classdict):\nprint('In SubMeta init:', classname, supers, classdict, sep='\\n...')\nprint('...init class object:', list(Class.__dict__.keys()))\nclass Eggs:\npass\nprint('making class')\nclass Spam(Eggs, metaclass=SubMeta):\ndata = 1\ndef meth(self, arg):\npass\nprint('making instance')\nX = Spam()\nprint('data:', X.data)",
    "When this code is run, all three redefined methods run in turn. This is essentially what\nthe type object does by default:\nmaking class\nIn SuperMeta.call:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02B7BA98>}\nIn SubMeta.new:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02B7BA98>}\nIn SubMeta init:\n...Spam\n...(<class '__main__.Eggs'>,)\n...{'__module__': '__main__', 'data': 1, 'meth': <function meth at 0x02B7BA98>}\n...init class object: ['__module__', 'data', 'meth', '__doc__']\nmaking instance\ndata: 1",
    "Overloading class creation calls with normal classes\nThe preceding example is complicated by the fact that metaclasses are used to create\nclass objects, but don’t generate instances of themselves. Because of this, with metaclasses name lookup rules are somewhat different than what we are accustomed to.\nThe __call__ method, for example, is looked up in the class of an object; for metaclasses, this means the metaclass of a metaclass.\nTo use normal inheritance-based name lookup, we can achieve the same effect with\nnormal classes and instances. The output of the following is the same as the preceding\nversion, but note that __new__ and __init__ must have different names here, or else\nthey will run when the SubMeta instance is created, not when it is later called as a\nmetaclass:\n\nCoding Metaclasses | 1067",
    "Coding Metaclasses | 1067\n\n\fclass SuperMeta:\ndef __call__(self, classname, supers, classdict):\nprint('In SuperMeta.call: ', classname, supers, classdict, sep='\\n...')\nClass = self.__New__(classname, supers, classdict)\nself.__Init__(Class, classname, supers, classdict)\nreturn Class\nclass SubMeta(SuperMeta):\ndef __New__(self, classname, supers, classdict):\nprint('In SubMeta.new: ', classname, supers, classdict, sep='\\n...')\nreturn type(classname, supers, classdict)\ndef __Init__(self, Class, classname, supers, classdict):\nprint('In SubMeta init:', classname, supers, classdict, sep='\\n...')\nprint('...init class object:', list(Class.__dict__.keys()))\nclass Eggs:\npass\nprint('making class')\nclass Spam(Eggs, metaclass=SubMeta()):\ndata = 1\ndef meth(self, arg):\npass\n\n# Meta is normal class instance\n# Called at end of statement\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)",
    "# Meta is normal class instance\n# Called at end of statement\n\nprint('making instance')\nX = Spam()\nprint('data:', X.data)\n\nAlthough these alternative forms work, most metaclasses get their work done by redefining the type superclass’s __new__ and __init__; in practice, this is usually as much\ncontrol as is required, and it’s often simpler than other schemes. However, we’ll see\nlater that a simple function-based metaclass can often work much like a class decorator,\nwhich allows the metaclasses to manage instances as well as classes.",
    "Instances Versus Inheritance\nBecause metaclasses are specified in similar ways to inheritance superclasses, they can\nbe a bit confusing at first glance. A few key points should help summarize and clarify\nthe model:\n• Metaclasses inherit from the type class. Although they have a special role,\nmetaclasses are coded with class statements and follow the usual OOP model in\nPython. For example, as subclasses of type, they can redefine the type object’s\nmethods, overriding and customizing them as needed. Metaclasses typically redefine the type class’s __new__ and __init__ to customize class creation and initialization, but they can also redefine __call__ if they wish to catch the end-of-class\ncreation call directly. Although it’s unusual, they can even be simple functions that\nreturn arbitrary objects, instead of type subclasses.\n\n1068 | Chapter 39: Metaclasses",
    "• Metaclass declarations are inherited by subclasses. The metaclass=M declaration in a user-defined class is inherited by the class’s subclasses, too, so the metaclass will run for the construction of each class that inherits this specification in a\nsuperclass chain.\n• Metaclass attributes are not inherited by class instances. Metaclass declarations specify an instance relationship, which is not the same as inheritance. Because\nclasses are instances of metaclasses, the behavior defined in a metaclass applies to\nthe class, but not the class’s later instances. Instances obtain behavior from their\nclasses and superclasses, but not from any metaclasses. Technically, instance attribute lookups usually search only the __dict__ dictionaries of the instance and\nall its classes; the metaclass is not included in inheritance lookup.\nTo illustrate the last two points, consider the following example:\nclass MetaOne(type):\ndef __new__(meta, classname, supers, classdict):\n# Redefine type method",
    "classes and superclasses, but not from any metaclasses. Technically, instance attribute lookups usually search only the __dict__ dictionaries of the instance and\nall its classes; the metaclass is not included in inheritance lookup.\nTo illustrate the last two points, consider the following example:\nclass MetaOne(type):\ndef __new__(meta, classname, supers, classdict):\n# Redefine type method\nprint('In MetaOne.new:', classname)\nreturn type.__new__(meta, classname, supers, classdict)\ndef toast(self):\nprint('toast')\nclass Super(metaclass=MetaOne):\ndef spam(self):\nprint('spam')",
    "# Metaclass inherited by subs too\n# MetaOne run twice for two classes\n\nclass C(Super):\ndef eggs(self):\nprint('eggs')\n\n# Superclass: inheritance versus instance\n# Classes inherit from superclasses\n# But not from metclasses\n\nX = C()\nX.eggs()\nX.spam()\nX.toast()\n\n# Inherited from C\n# Inherited from Super\n# Not inherited from metaclass\n\nWhen this code is run, the metaclass handles construction of both client classes, and\ninstances inherit class attributes but not metaclass attributes:\nIn MetaOne.new: Super\nIn MetaOne.new: C\neggs\nspam\nAttributeError: 'C' object has no attribute 'toast'",
    "When this code is run, the metaclass handles construction of both client classes, and\ninstances inherit class attributes but not metaclass attributes:\nIn MetaOne.new: Super\nIn MetaOne.new: C\neggs\nspam\nAttributeError: 'C' object has no attribute 'toast'\n\nAlthough detail matters, it’s important to keep the big picture in mind when dealing\nwith metaclasses. Metaclasses like those we’ve seen here will be run automatically for\nevery class that declares them. Unlike the helper function approaches we saw earlier,\nsuch classes will automatically acquire whatever augmentation the metaclass provides.\nMoreover, changes in such augmentation only need to be coded in one place—the\nmetaclass—which simplifies making modifications as our needs evolve. Like so many\ntools in Python, metaclasses ease maintenance work by eliminating redundancy. To\nfully sample their power, though, we need to move on to some larger use-case examples.\nCoding Metaclasses | 1069",
    "Example: Adding Methods to Classes\nIn this and the following section, we’re going to study examples of two common use\ncases for metaclasses: adding methods to a class, and decorating all methods automatically. These are just two of the many metaclass roles, which unfortunately consume\nthe space we have left for this chapter; again, you should consult the Web for more\nadvanced applications. These examples are representative of metaclasses in action,\nthough, and they suffice to illustrate the basics.\nMoreover, both give us an opportunity to contrast class decorators and metaclasses—\nour first example compares metaclass- and decorator-based implementations of class\naugmentation and instance wrapping, and the second applies a decorator with a\nmetaclass first and then with another decorator. As you’ll see, the two tools are often\ninterchangeable, and even complementary.",
    "Manual Augmentation\nEarlier in this chapter, we looked at skeleton code that augmented classes by adding\nmethods to them in various ways. As we saw, simple class-based inheritance suffices if\nthe extra methods are statically known when the class is coded. Composition via object\nembedding can often achieve the same effect too. For more dynamic scenarios, though,\nother techniques are sometimes required—helper functions can usually suffice, but\nmetaclasses provide an explicit structure and minimize the maintenance costs of\nchanges in the future.\nLet’s put these ideas in action here with working code. Consider the following example\nof manual class augmentation—it adds two methods to two classes, after they have\nbeen created:\n# Extend manually - adding new methods to classes\nclass Client1:\ndef __init__(self, value):\nself.value = value\ndef spam(self):\nreturn self.value * 2\nclass Client2:\nvalue = 'ni?'\ndef eggsfunc(obj):\nreturn obj.value * 4\ndef hamfunc(obj, value):\nreturn value + 'ham'",
    "of manual class augmentation—it adds two methods to two classes, after they have\nbeen created:\n# Extend manually - adding new methods to classes\nclass Client1:\ndef __init__(self, value):\nself.value = value\ndef spam(self):\nreturn self.value * 2\nclass Client2:\nvalue = 'ni?'\ndef eggsfunc(obj):\nreturn obj.value * 4\ndef hamfunc(obj, value):\nreturn value + 'ham'\nClient1.eggs = eggsfunc\nClient1.ham = hamfunc\nClient2.eggs = eggsfunc",
    "1070 | Chapter 39: Metaclasses\n\n\fClient2.ham\n\n= hamfunc\n\nX = Client1('Ni!')\nprint(X.spam())\nprint(X.eggs())\nprint(X.ham('bacon'))\nY = Client2()\nprint(Y.eggs())\nprint(Y.ham('bacon'))\n\nThis works because methods can always be assigned to a class after it’s been created,\nas long as the methods assigned are functions with an extra first argument to receive\nthe subject self instance—this argument can be used to access state information accessible from the class instance, even though the function is defined independently of\nthe class.\nWhen this code runs, we receive the output of a method coded inside the first class, as\nwell as the two methods added to the classes after the fact:\nNi!Ni!\nNi!Ni!Ni!Ni!\nbaconham\nni?ni?ni?ni?\nbaconham",
    "This scheme works well in isolated cases and can be used to fill out a class arbitrarily\nat runtime. It suffers from a potentially major downside, though: we have to repeat the\naugmentation code for every class that needs these methods. In our case, it wasn’t too\nonerous to add the two methods to both classes, but in more complex scenarios this\napproach can be time-consuming and error-prone. If we ever forget to do this consistently, or we ever need to change the augmentation, we can run into problems.",
    "Metaclass-Based Augmentation\nAlthough manual augmentation works, in larger programs it would be better if we could\napply such changes to an entire set of classes automatically. That way, we’d avoid the\nchance of the augmentation being botched for any given class. Moreover, coding the\naugmentation in a single location better supports future changes—all classes in the set\nwill pick up changes automatically.\nOne way to meet this goal is to use metaclasses. If we code the augmentation in a\nmetaclass, every class that declares that metaclass will be augmented uniformly and\ncorrectly and will automatically pick up any changes made in the future. The following\ncode demonstrates:\n# Extend with a metaclass - supports future changes better\ndef eggsfunc(obj):\nreturn obj.value * 4\n\nExample: Adding Methods to Classes | 1071",
    "Example: Adding Methods to Classes | 1071\n\n\fdef hamfunc(obj, value):\nreturn value + 'ham'\nclass Extender(type):\ndef __new__(meta, classname, supers, classdict):\nclassdict['eggs'] = eggsfunc\nclassdict['ham'] = hamfunc\nreturn type.__new__(meta, classname, supers, classdict)\nclass Client1(metaclass=Extender):\ndef __init__(self, value):\nself.value = value\ndef spam(self):\nreturn self.value * 2\nclass Client2(metaclass=Extender):\nvalue = 'ni?'\nX = Client1('Ni!')\nprint(X.spam())\nprint(X.eggs())\nprint(X.ham('bacon'))\nY = Client2()\nprint(Y.eggs())\nprint(Y.ham('bacon'))\n\nThis time, both of the client classes are extended with the new methods because they\nare instances of a metaclass that performs the augmentation. When run, this version’s\noutput is the same as before—we haven’t changed what the code does, we’ve just refactored it to encapsulate the augmentation more cleanly:\nNi!Ni!\nNi!Ni!Ni!Ni!\nbaconham\nni?ni?ni?ni?\nbaconham",
    "Notice that the metaclass in this example still performs a fairly static task: adding two\nknown methods to every class that declares it. In fact, if all we need to do is always add\nthe same two methods to a set of classes, we might as well code them in a normal\nsuperclass and inherit in subclasses. In practice, though, the metaclass structure supports much more dynamic behavior. For instance, the subject class might also be configured based upon arbitrary logic at runtime:\n# Can also configure class based on runtime tests\nclass MetaExtend(type):\ndef __new__(meta, classname, supers, classdict):\nif sometest():\nclassdict['eggs'] = eggsfunc1\nelse:\nclassdict['eggs'] = eggsfunc2\nif someothertest():\n\n1072 | Chapter 39: Metaclasses\n\n\fclassdict['ham'] = hamfunc\nelse:\nclassdict['ham'] = lambda *args: 'Not supported'\nreturn type.__new__(meta, classname, supers, classdict)",
    "Metaclasses Versus Class Decorators: Round 2\nJust in case this chapter has not yet managed to make your head explode, keep in mind\nagain that the prior chapter’s class decorators often overlap with this chapter’s metaclasses in terms of functionality. This derives from the fact that:\n• Class decorators rebind class names to the result of a function at the end of a\nclass statement.\n• Metaclasses work by routing class object creation through an object at the end of\na class statement.\nAlthough these are slightly different models, in practice they can usually achieve the\nsame goals, albeit in different ways. In fact, class decorators can be used to manage\nboth instances of a class and the class itself. While decorators can manage classes naturally, though, it’s somewhat less straightforward for metaclasses to manage instances.\nMetaclasses are probably best used for class object management.",
    "Decorator-based augmentation\nFor example, the prior section’s metaclass example, which adds methods to a class on\ncreation, can also be coded as a class decorator; in this mode, decorators roughly correspond to the __init__ method of metaclasses, since the class object has already been\ncreated by the time the decorator is invoked. Also like with metaclasses, the original\nclass type is retained, since no wrapper object layer is inserted. The output of the following is the same as that of the prior metaclass code:\n# Extend with a decorator: same as providing __init__ in a metaclass\ndef eggsfunc(obj):\nreturn obj.value * 4\ndef hamfunc(obj, value):\nreturn value + 'ham'\ndef Extender(aClass):\naClass.eggs = eggsfunc\naClass.ham = hamfunc\nreturn aClass\n@Extender\nclass Client1:\ndef __init__(self, value):\nself.value = value\ndef spam(self):\nreturn self.value * 2\n\n# Manages class, not instance\n# Equiv to metaclass __init__\n\n# Client1 = Extender(Client1)\n# Rebound at end of class stmt",
    "# Manages class, not instance\n# Equiv to metaclass __init__\n\n# Client1 = Extender(Client1)\n# Rebound at end of class stmt\n\nExample: Adding Methods to Classes | 1073\n\n\f@Extender\nclass Client2:\nvalue = 'ni?'\nX = Client1('Ni!')\nprint(X.spam())\nprint(X.eggs())\nprint(X.ham('bacon'))\n\n# X is a Client1 instance\n\nY = Client2()\nprint(Y.eggs())\nprint(Y.ham('bacon'))\n\nIn other words, at least in certain cases, decorators can manage classes as easily as\nmetaclasses. The converse isn’t quite so straightforward, though; metaclasses can be\nused to manage instances, but only with a certain amount of magic. The next section\ndemonstrates.",
    "Managing instances instead of classes\nAs we’ve just seen, class decorators can often serve the same class-management role as\nmetaclasses. Metaclasses can often serve the same instance-management role as decorators, too, but this is a bit more complex. That is:\n• Class decorators can manage both classes and instances.\n• Metaclasses can manage both classes and instances, but instances take extra work.\nThat said, certain applications may be better coded in one or the other. For example,\nconsider the following class decorator example from the prior chapter; it’s used to print\na trace message whenever any normally named attribute of a class instance is fetched:\n# Class decorator to trace external instance attribute fetches\ndef Tracer(aClass):\nclass Wrapper:\ndef __init__(self, *args, **kargs):\nself.wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attrname):\nprint('Trace:', attrname)\nreturn getattr(self.wrapped, attrname)\nreturn Wrapper\n@Tracer\nclass Person:",
    "a trace message whenever any normally named attribute of a class instance is fetched:\n# Class decorator to trace external instance attribute fetches\ndef Tracer(aClass):\nclass Wrapper:\ndef __init__(self, *args, **kargs):\nself.wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attrname):\nprint('Trace:', attrname)\nreturn getattr(self.wrapped, attrname)\nreturn Wrapper\n@Tracer\nclass Person:\ndef __init__(self, name, hours, rate):\nself.name = name\nself.hours = hours\nself.rate = rate\ndef pay(self):\nreturn self.hours * self.rate\nbob = Person('Bob', 40, 50)",
    "1074 | Chapter 39: Metaclasses\n\n# On @ decorator\n# On instance creation\n# Use enclosing scope name\n# Catches all but .wrapped\n# Delegate to wrapped object\n\n# Person = Tracer(Person)\n# Wrapper remembers Person\n# In-method fetch not traced\n\n# bob is really a Wrapper\n\n\f# Wrapper embeds a Person\n# Triggers __getattr__\n\nprint(bob.name)\nprint(bob.pay())\n\nWhen this code is run, the decorator uses class name rebinding to wrap instance objects\nin an object that produces the trace lines in the following output:\nTrace: name\nBob\nTrace: pay\n2000",
    "print(bob.name)\nprint(bob.pay())\n\nWhen this code is run, the decorator uses class name rebinding to wrap instance objects\nin an object that produces the trace lines in the following output:\nTrace: name\nBob\nTrace: pay\n2000\n\nAlthough it’s possible for a metaclass to achieve the same effect, it seems less straightforward conceptually. Metaclasses are designed explicitly to manage class object creation, and they have an interface tailored for this purpose. To use a metaclass to manage\ninstances, we have to rely on a bit more magic. The following metaclass has the same\neffect and output as the prior decorator:\n# Manage instances like the prior example, but with a metaclass\ndef Tracer(classname, supers, classdict):\naClass = type(classname, supers, classdict)\nclass Wrapper:\ndef __init__(self, *args, **kargs):\nself.wrapped = aClass(*args, **kargs)\ndef __getattr__(self, attrname):\nprint('Trace:', attrname)\nreturn getattr(self.wrapped, attrname)\nreturn Wrapper",
    "# On class creation call\n# Make client class\n\nclass Person(metaclass=Tracer):\ndef __init__(self, name, hours, rate):\nself.name = name\nself.hours = hours\nself.rate = rate\ndef pay(self):\nreturn self.hours * self.rate\n\n# Make Person with Tracer\n# Wrapper remembers Person\n\nbob = Person('Bob', 40, 50)\nprint(bob.name)\nprint(bob.pay())\n\n# bob is really a Wrapper\n# Wrapper embeds a Person\n# Triggers __getattr__\n\n# On instance creation\n# Catches all but .wrapped\n# Delegate to wrapped object\n\n# In-method fetch not traced",
    "# Make Person with Tracer\n# Wrapper remembers Person\n\nbob = Person('Bob', 40, 50)\nprint(bob.name)\nprint(bob.pay())\n\n# bob is really a Wrapper\n# Wrapper embeds a Person\n# Triggers __getattr__\n\n# On instance creation\n# Catches all but .wrapped\n# Delegate to wrapped object\n\n# In-method fetch not traced\n\nThis works, but it relies on two tricks. First, it must use a simple function instead of a\nclass, because type subclasses must adhere to object creation protocols. Second, it must\nmanually create the subject class by calling type manually; it needs to return an instance\nwrapper, but metaclasses are also responsible for creating and returning the subject\nclass. Really, we’re using the metaclass protocol to imitate decorators in this example,\nrather than vice versa; because both run at the conclusion of a class statement, in many\nroles they are just variations on a theme. This metaclass version produces the same\noutput as the decorator when run live:\nTrace: name\nBob\nTrace: pay\n2000",
    "Example: Adding Methods to Classes | 1075\n\n\fYou should study both versions of these examples for yourself to weigh their tradeoffs.\nIn general, though, metaclasses are probably best suited to class management, due to\ntheir design; class decorators can manage either instances or classes, though they may\nnot be the best option for more advanced metaclass roles that we don’t have space to\ncover in this book (if you want to learn more about decorators and metaclasses after\nreading this chapter, search the Web or Python’s standard manuals). The next section\nconcludes this chapter with one more common use case—applying operations to a\nclass’s methods automatically.",
    "Example: Applying Decorators to Methods\nAs we saw in the prior section, because they are both run at the end of a class statement,\nmetaclasses and decorators can often be used interchangeably, albeit with different\nsyntax. The choice between the two is arbitrary in many contexts. It’s also possible to\nuse them in combination, as complementary tools. In this section, we’ll explore an\nexample of just such a combination—applying a function decorator to all the methods\nof a class.",
    "Tracing with Decoration Manually\nIn the prior chapter we coded two function decorators, one that traced and counted all\ncalls made to a decorated function and another that timed such calls. They took various\nforms there, some of which were applicable to both functions and methods and some\nof which were not. The following collects both decorators’ final forms into a module\nfile for reuse and reference here:\n# File mytools.py: assorted decorator tools\ndef tracer(func):\n# Use function, not class with __call__\ncalls = 0\n# Else self is decorator instance only\ndef onCall(*args, **kwargs):\nnonlocal calls\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nreturn func(*args, **kwargs)\nreturn onCall\nimport time\ndef timer(label='', trace=True):\n# On decorator args: retain args\ndef onDecorator(func):\n# On @: retain decorated func\ndef onCall(*args, **kargs):\n# On calls: call original\nstart\n= time.clock()\n# State is scopes + func attr\nresult = func(*args, **kargs)",
    "nonlocal calls\ncalls += 1\nprint('call %s to %s' % (calls, func.__name__))\nreturn func(*args, **kwargs)\nreturn onCall\nimport time\ndef timer(label='', trace=True):\n# On decorator args: retain args\ndef onDecorator(func):\n# On @: retain decorated func\ndef onCall(*args, **kargs):\n# On calls: call original\nstart\n= time.clock()\n# State is scopes + func attr\nresult = func(*args, **kargs)\nelapsed = time.clock() - start\nonCall.alltime += elapsed\nif trace:\nformat = '%s%s: %.5f, %.5f'\nvalues = (label, func.__name__, elapsed, onCall.alltime)\nprint(format % values)",
    "1076 | Chapter 39: Metaclasses\n\n\freturn result\nonCall.alltime = 0\nreturn onCall\nreturn onDecorator\n\nAs we learned in the prior chapter, to use these decorators manually, we simply import\nthem from the module and code the decoration @ syntax before each method we wish\nto trace or time:\nfrom mytools import tracer\nclass Person:\n@tracer\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\n@tracer\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\n@tracer\ndef lastName(self):\nreturn self.name.split()[-1]\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nprint(bob.name, sue.name)\nsue.giveRaise(.10)\nprint(sue.pay)\nprint(bob.lastName(), sue.lastName())\n\n# giveRaise = tracer(giverRaise)\n# onCall remembers giveRaise\n# lastName = tracer(lastName)\n\n# Runs onCall(sue, .10)\n# Runs onCall(bob), remembers lastName",
    "# giveRaise = tracer(giverRaise)\n# onCall remembers giveRaise\n# lastName = tracer(lastName)\n\n# Runs onCall(sue, .10)\n# Runs onCall(bob), remembers lastName\n\nWhen this code is run, we get the following output—calls to decorated methods are\nrouted to logic that intercepts and then delegates the call, because the original method\nnames have been bound to the decorator:\ncall 1 to __init__\ncall 2 to __init__\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones\n\nTracing with Metaclasses and Decorators\nThe manual decoration scheme of the prior section works, but it requires us to add\ndecoration syntax before each method we wish to trace and to later remove that syntax\nwhen we no longer desire tracing. If we want to trace every method of a class, this can\nbecome tedious in larger programs. It would be better if we could somehow apply the\ntracer decorator to all of a class’s methods automatically.\n\nExample: Applying Decorators to Methods | 1077",
    "Example: Applying Decorators to Methods | 1077\n\n\fWith metaclasses, we can do exactly that—because they are run when a class is constructed, they are a natural place to add decoration wrappers to a class’s methods. By\nscanning the class’s attribute dictionary and testing for function objects there, we can\nautomatically run methods through the decorator and rebind the original names to the\nresults. The effect is the same as the automatic method name rebinding of decorators,\nbut we can apply it more globally:\n# Metaclass that adds tracing decorator to every method of a client class\nfrom types import FunctionType\nfrom mytools import tracer\nclass MetaTrace(type):\ndef __new__(meta, classname, supers, classdict):\nfor attr, attrval in classdict.items():\nif type(attrval) is FunctionType:\nclassdict[attr] = tracer(attrval)\nreturn type.__new__(meta, classname, supers, classdict)\n\n# Method?\n# Decorate it\n# Make class",
    "# Method?\n# Decorate it\n# Make class\n\nclass Person(metaclass=MetaTrace):\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\ndef lastName(self):\nreturn self.name.split()[-1]\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nprint(bob.name, sue.name)\nsue.giveRaise(.10)\nprint(sue.pay)\nprint(bob.lastName(), sue.lastName())\n\nWhen this code is run, the results are the same as before—calls to methods are routed\nto the tracing decorator first for tracing, and then propagated on to the original method:\ncall 1 to __init__\ncall 2 to __init__\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones",
    "When this code is run, the results are the same as before—calls to methods are routed\nto the tracing decorator first for tracing, and then propagated on to the original method:\ncall 1 to __init__\ncall 2 to __init__\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones\n\nThe result you see here is a combination of decorator and metaclass work—the metaclass automatically applies the function decorator to every method at class creation\ntime, and the function decorator automatically intercepts method calls in order to print\nthe trace messages in this output. The combination “just works,” thanks to the generality of both tools.\n\n1078 | Chapter 39: Metaclasses",
    "Applying Any Decorator to Methods\nThe prior metaclass example works for just one specific function decorator—tracing.\nHowever, it’s trivial to generalize this to apply any decorator to all the methods of a\nclass. All we have to do is add an outer scope layer to retain the desired decorator, much\nlike we did for decorators in the prior chapter. The following, for example, codes such\na generalization and then uses it to apply the tracer decorator again:\n# Metaclass factory: apply any decorator to all methods of a class\nfrom types import FunctionType\nfrom mytools import tracer, timer\ndef decorateAll(decorator):\nclass MetaDecorate(type):\ndef __new__(meta, classname, supers, classdict):\nfor attr, attrval in classdict.items():\nif type(attrval) is FunctionType:\nclassdict[attr] = decorator(attrval)\nreturn type.__new__(meta, classname, supers, classdict)\nreturn MetaDecorate\nclass Person(metaclass=decorateAll(tracer)):\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay",
    "def decorateAll(decorator):\nclass MetaDecorate(type):\ndef __new__(meta, classname, supers, classdict):\nfor attr, attrval in classdict.items():\nif type(attrval) is FunctionType:\nclassdict[attr] = decorator(attrval)\nreturn type.__new__(meta, classname, supers, classdict)\nreturn MetaDecorate\nclass Person(metaclass=decorateAll(tracer)):\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\ndef lastName(self):\nreturn self.name.split()[-1]",
    "# Apply a decorator to all\n\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nprint(bob.name, sue.name)\nsue.giveRaise(.10)\nprint(sue.pay)\nprint(bob.lastName(), sue.lastName())\n\nWhen this code is run as it is, the output is again the same as that of the previous\nexamples—we’re still ultimately decorating every method in a client class with the\ntracer function decorator, but we’re doing so in a more generic fashion:\ncall 1 to __init__\ncall 2 to __init__\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones\n\nNow, to apply a different decorator to the methods, we can simply replace the decorator\nname in the class header line. To use the timer function decorator shown earlier, for\nexample, we could use either of the last two header lines in the following when defining\nExample: Applying Decorators to Methods | 1079",
    "Now, to apply a different decorator to the methods, we can simply replace the decorator\nname in the class header line. To use the timer function decorator shown earlier, for\nexample, we could use either of the last two header lines in the following when defining\nExample: Applying Decorators to Methods | 1079\n\n\four class—the first accepts the timer’s default arguments, and the second specifies label\ntext:\nclass Person(metaclass=decorateAll(tracer)):\n\n# Apply tracer\n\nclass Person(metaclass=decorateAll(timer())):\n\n# Apply timer, defaults\n\nclass Person(metaclass=decorateAll(timer(label='**'))):\n\n# Decorator arguments",
    "our class—the first accepts the timer’s default arguments, and the second specifies label\ntext:\nclass Person(metaclass=decorateAll(tracer)):\n\n# Apply tracer\n\nclass Person(metaclass=decorateAll(timer())):\n\n# Apply timer, defaults\n\nclass Person(metaclass=decorateAll(timer(label='**'))):\n\n# Decorator arguments\n\nNotice that this scheme cannot support nondefault decorator arguments differing per\nmethod, but it can pass in decorator arguments that apply to all methods, as done here.\nTo test, use the last of these metaclass declarations to apply the timer, and add the\nfollowing lines at the end of the script:\n# If using timer: total time per method\nprint('-'*40)\nprint('%.5f' % Person.__init__.alltime)\nprint('%.5f' % Person.giveRaise.alltime)\nprint('%.5f' % Person.lastName.alltime)",
    "The new output is as follows—the metaclass wraps methods in timer decorators now,\nso we can tell how long each and every call takes, for every method of the class:\n**__init__: 0.00001, 0.00001\n**__init__: 0.00001, 0.00002\nBob Smith Sue Jones\n**giveRaise: 0.00001, 0.00001\n110000.0\n**lastName: 0.00001, 0.00001\n**lastName: 0.00001, 0.00002\nSmith Jones\n---------------------------------------0.00002\n0.00001\n0.00002",
    "Metaclasses Versus Class Decorators: Round 3\nClass decorators intersect with metaclasses here, too. The following version replaces\nthe preceding example’s metaclass with a class decorator. It defines and uses a class\ndecorator that applies a function decorator to all methods of a class. Although the prior\nsentence may sound more like a Zen statement than a technical description, this\nall works quite naturally—Python’s decorators support arbitrary nesting and\ncombinations:\n# Class decorator factory: apply any decorator to all methods of a class\nfrom types import FunctionType\nfrom mytools import tracer, timer\ndef decorateAll(decorator):\ndef DecoDecorate(aClass):\n\n1080 | Chapter 39: Metaclasses",
    "1080 | Chapter 39: Metaclasses\n\n\ffor attr, attrval in aClass.__dict__.items():\nif type(attrval) is FunctionType:\nsetattr(aClass, attr, decorator(attrval))\nreturn aClass\nreturn DecoDecorate\n@decorateAll(tracer)\nclass Person:\ndef __init__(self, name, pay):\nself.name = name\nself.pay = pay\ndef giveRaise(self, percent):\nself.pay *= (1.0 + percent)\ndef lastName(self):\nreturn self.name.split()[-1]\n\n# Not __dict__\n\n# Use a class decorator\n# Applies func decorator to methods\n# Person = decorateAll(..)(Person)\n# Person = DecoDecorate(Person)\n\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nprint(bob.name, sue.name)\nsue.giveRaise(.10)\nprint(sue.pay)\nprint(bob.lastName(), sue.lastName())",
    "# Not __dict__\n\n# Use a class decorator\n# Applies func decorator to methods\n# Person = decorateAll(..)(Person)\n# Person = DecoDecorate(Person)\n\nbob = Person('Bob Smith', 50000)\nsue = Person('Sue Jones', 100000)\nprint(bob.name, sue.name)\nsue.giveRaise(.10)\nprint(sue.pay)\nprint(bob.lastName(), sue.lastName())\n\nWhen this code is run as it is, the class decorator applies the tracer function decorator\nto every method and produces a trace message on calls (the output is the same as that\nof the preceding metaclass version of this example):\ncall 1 to __init__\ncall 2 to __init__\nBob Smith Sue Jones\ncall 1 to giveRaise\n110000.0\ncall 1 to lastName\ncall 2 to lastName\nSmith Jones",
    "Notice that the class decorator returns the original, augmented class, not a wrapper\nlayer for it (as is common when wrapping instance objects instead). As for the metaclass\nversion, we retain the type of the original class—an instance of Person is an instance of\nPerson, not of some wrapper class. In fact, this class decorator deals with class creation\nonly; instance creation calls are not intercepted at all.\nThis distinction can matter in programs that require type testing for instances to yield\nthe original class, not a wrapper. When augmenting a class instead of an instance, class\ndecorators can retain the original class type. The class’s methods are not their original\nfunctions because they are rebound to decorators, but this is less important in practice,\nand it’s true in the metaclass alternative as well.\nAlso note that, like the metaclass version, this structure cannot support function decorator arguments that differ per method, but it can handle such arguments if they apply",
    "functions because they are rebound to decorators, but this is less important in practice,\nand it’s true in the metaclass alternative as well.\nAlso note that, like the metaclass version, this structure cannot support function decorator arguments that differ per method, but it can handle such arguments if they apply\nto all methods. To use this scheme to apply the timer decorator, for example, either of\nthe last two decoration lines in the following will suffice if coded just before our class",
    "Example: Applying Decorators to Methods | 1081\n\n\fdefinition—the first uses decorator argument defaults, and the second provides one\nexplicitly:\n@decorateAll(tracer)\n\n# Decorate all with tracer\n\n@decorateAll(timer())\n\n# Decorate all with timer, defaults\n\n@decorateAll(timer(label='@@'))\n\n# Same but pass a decorator argument\n\nAs before, let’s use the last of these decorator lines and add the following at the end of\nthe script to test our example with a different decorator:\n# If using timer: total time per method\nprint('-'*40)\nprint('%.5f' % Person.__init__.alltime)\nprint('%.5f' % Person.giveRaise.alltime)\nprint('%.5f' % Person.lastName.alltime)",
    "@decorateAll(timer(label='@@'))\n\n# Same but pass a decorator argument\n\nAs before, let’s use the last of these decorator lines and add the following at the end of\nthe script to test our example with a different decorator:\n# If using timer: total time per method\nprint('-'*40)\nprint('%.5f' % Person.__init__.alltime)\nprint('%.5f' % Person.giveRaise.alltime)\nprint('%.5f' % Person.lastName.alltime)\n\nThe same sort of output appears—for every method we get timing data for each and\nall calls, but we’ve passed a different label argument to the timer decorator:\n@@__init__: 0.00001, 0.00001\n@@__init__: 0.00001, 0.00002\nBob Smith Sue Jones\n@@giveRaise: 0.00001, 0.00001\n110000.0\n@@lastName: 0.00001, 0.00001\n@@lastName: 0.00001, 0.00002\nSmith Jones\n---------------------------------------0.00002\n0.00001\n0.00002",
    "As you can see, metaclasses and class decorators are not only often interchangeable,\nbut also commonly complementary. Both provide advanced but powerful ways to customize and manage both class and instance objects, because both ultimately allow you\nto insert code into the class creation process. Although some more advanced applications may be better coded with one or the other, the way you choose or combine these\ntwo tools in many cases is largely up to you.",
    "“Optional” Language Features\nI included a quote near the start of this chapter about metaclasses not being of interest\nto 99% of Python programmers, to underscore their relative obscurity. That statement\nis not quite accurate, though, and not just numerically so.\nThe quote’s author is a friend of mine from the early days of Python, and I don’t mean\nto pick on anyone unfairly. Moreover, I’ve often made such statements about language\nfeature obscurity myself—in this very book, in fact.\nThe problem, though, is that such statements really only apply to people who work\nalone and only ever use code that they’ve written themselves. As soon as an “optional”\n1082 | Chapter 39: Metaclasses",
    "advanced language feature is used by anyone in an organization, it is no longer\noptional—it is effectively imposed on everyone in the organization. The same holds\ntrue for externally developed software you use in your systems—if the software’s author\nuses an advanced language feature, it’s no longer entirely optional for you, because you\nhave to understand the feature to use or change the code.\nThis observation applies to all the advanced tools listed near the beginning of this\nchapter—decorators, properties, descriptors, metaclasses, and so on. If any person or\nprogram you need to work with uses them, they automatically become part of your\nrequired knowledge base too. That is, nothing is truly “optional” if nothing is truly optional. Most of us don’t get to pick and choose.\nThis is why some Python old-timers (myself included) sometimes lament that Python",
    "chapter—decorators, properties, descriptors, metaclasses, and so on. If any person or\nprogram you need to work with uses them, they automatically become part of your\nrequired knowledge base too. That is, nothing is truly “optional” if nothing is truly optional. Most of us don’t get to pick and choose.\nThis is why some Python old-timers (myself included) sometimes lament that Python\nseems to have grown larger and more complex over time. New features added by veterans seem to have raised the intellectual bar for newcomers. Although Python’s core\nideas, like dynamic typing and built-in types, have remained essentially the same, its\nadvanced additions can become required reading for any Python programmer. I chose\nto cover these topics here for this reason, despite the omission of most in prior editions.\nIt’s not possible to skip the advanced stuff if it’s in code you have to understand.\nOn the other hand, many new learners can pick up advanced topics as needed. And",
    "advanced additions can become required reading for any Python programmer. I chose\nto cover these topics here for this reason, despite the omission of most in prior editions.\nIt’s not possible to skip the advanced stuff if it’s in code you have to understand.\nOn the other hand, many new learners can pick up advanced topics as needed. And\nfrankly, application programmers tend to spend most of their time dealing with libraries\nand extensions, not advanced and sometimes arcane language features. For instance,\nthe book Programming Python, a follow-up to this one, deals mostly with the marriage\nof Python to application libraries for tasks such as GUIs, databases, and the Web, not\nwith esoteric language tools.\nThe flipside of this growth is that Python has become more powerful. When used well,\ntools like decorators and metaclasses are not only arguably “cool,” but allow creative\nprogrammers to build more flexible and useful APIs for other programmers to use. As",
    "of Python to application libraries for tasks such as GUIs, databases, and the Web, not\nwith esoteric language tools.\nThe flipside of this growth is that Python has become more powerful. When used well,\ntools like decorators and metaclasses are not only arguably “cool,” but allow creative\nprogrammers to build more flexible and useful APIs for other programmers to use. As\nwe’ve seen, they can also provide good solutions to problems of encapsulation and\nmaintenance.\nWhether this justifies the potential expansion of required Python knowledge is up to\nyou to decide. Unfortunately, a person’s skill level often decides this issue by default—\nmore advanced programmers like more advanced tools and tend to forget about their\nimpact on other camps. Fortunately, though, this isn’t an absolute; good programmers\nalso understand that simplicity is good engineering, and advanced tools should be used\nonly when warranted. This is true in any programming language, but especially in a",
    "more advanced programmers like more advanced tools and tend to forget about their\nimpact on other camps. Fortunately, though, this isn’t an absolute; good programmers\nalso understand that simplicity is good engineering, and advanced tools should be used\nonly when warranted. This is true in any programming language, but especially in a\nlanguage like Python that is frequently exposed to new or novice programmers as an\nextension tool.\nIf you’re still not buying this, keep in mind that there are very many Python users who\nare not comfortable with even basic OOP and classes. Trust me on this; I’ve met thousands of them. Python-based systems that require their users to master the nuances of\nmetaclasses, decorators, and the like should probably scale their market expectations\naccordingly.",
    "Example: Applying Decorators to Methods | 1083",
    "Chapter Summary\nIn this chapter, we studied metaclasses and explored examples of them in action.\nMetaclasses allow us to tap into the class creation protocol of Python, in order to manage or augment user-defined classes. Because they automate this process, they can provide better solutions for API writers then manual code or helper functions; because\nthey encapsulate such code, they can minimize maintenance costs better than some\nother approaches.\nAlong the way, we also saw how the roles of class decorators and metaclasses often\nintersect: because both run at the conclusion of a class statement, they can sometimes\nbe used interchangeably. Class decorators can be used to manage both class and instance objects; metaclasses can, too, although they are more directly targeted toward\nclasses.\nSince this chapter covered an advanced topic, we’ll work through just a few quiz questions to review the basics (if you’ve made it this far in a chapter on metaclasses, you",
    "be used interchangeably. Class decorators can be used to manage both class and instance objects; metaclasses can, too, although they are more directly targeted toward\nclasses.\nSince this chapter covered an advanced topic, we’ll work through just a few quiz questions to review the basics (if you’ve made it this far in a chapter on metaclasses, you\nprobably already deserve extra credit!). Because this is the last part of the book, we’ll\nforego the end-of-part exercises. Be sure to see the appendixes that follow for pointers\non installation steps, and the solutions to the prior parts’ exercises.\nOnce you finish the quiz, you’ve officially reached the end of this book. Now that you\nknow Python inside and out, your next step, should you choose to take it, is to explore\nthe libraries, techniques, and tools available in the application domains in which you\nwork. Because Python is so widely used, you’ll find ample resources for using it in",
    "Once you finish the quiz, you’ve officially reached the end of this book. Now that you\nknow Python inside and out, your next step, should you choose to take it, is to explore\nthe libraries, techniques, and tools available in the application domains in which you\nwork. Because Python is so widely used, you’ll find ample resources for using it in\nalmost any application you can think of—from GUIs, the Web, and databases to numeric programming, robotics, and system administration.\nThis is where Python starts to become truly fun, but this is also where this book’s story\nends, and others’ begin. For pointers on where to turn after this book, see the list of\nrecommended follow-up texts in the Preface. Good luck with your journey. And of\ncourse, “Always look on the bright side of Life!”",
    "Test Your Knowledge: Quiz\n1. What is a metaclass?\n2. How do you declare the metaclass of a class?\n3. How do class decorators overlap with metaclasses for managing classes?\n4. How do class decorators overlap with metaclasses for managing instances?\n5. Would you rather count decorators or metaclasses amongst your weaponry? (And\nplease phrase your answer in terms of a popular Monty Python skit.)\n\n1084 | Chapter 39: Metaclasses",
    "Test Your Knowledge: Answers\n1. A metaclass is a class used to create a class. Normal classes are instances of the\ntype class by default. Metaclasses are usually subclasses of the type class, which\nredefines class creation protocol methods in order to customize the class creation\ncall issued at the end of a class statement; they typically redefine the methods\n__new__ and __init__ to tap into the class creation protocol. Metaclasses can also\nbe coded other ways—as simple functions, for example—but they are responsible\nfor making and returning an object for the new class.\n2. In Python 3.0 and later, use a keyword argument in the class header line:\nclass C(metaclass=M). In Python 2.X, use a class attribute instead: __metaclass__\n= M. In 3.0, the class header line can also name normal superclasses (a.k.a. base\nclasses) before the metaclass keyword argument.\n3. Because both are automatically triggered at the end of a class statement, class",
    "2. In Python 3.0 and later, use a keyword argument in the class header line:\nclass C(metaclass=M). In Python 2.X, use a class attribute instead: __metaclass__\n= M. In 3.0, the class header line can also name normal superclasses (a.k.a. base\nclasses) before the metaclass keyword argument.\n3. Because both are automatically triggered at the end of a class statement, class\ndecorators and metaclasses can both be used to manage classes. Decorators rebind\na class name to a callable’s result and metaclasses route class creation through a\ncallable, but both hooks can be used for similar purposes. To manage classes,\ndecorators simply augment and return the original class objects. Metaclasses augment a class after they create it.\n4. Because both are automatically triggered at the end of a class statement, class\ndecorators and metaclasses can both be used to manage class instances, by inserting\na wrapper object to catch instance creation calls. Decorators may rebind the class",
    "decorators simply augment and return the original class objects. Metaclasses augment a class after they create it.\n4. Because both are automatically triggered at the end of a class statement, class\ndecorators and metaclasses can both be used to manage class instances, by inserting\na wrapper object to catch instance creation calls. Decorators may rebind the class\nname to a callable run on instance creation that retains the original class object.\nMetaclasses can do the same, but they must also create the class object, so their\nusage is somewhat more complex in this role.\n5. Our chief weapon is decorators...decorators and metaclasses...metaclasses and\ndecorators.... Our two weapons are metaclasses and decorators...and ruthless efficiency.... Our three weapons are metaclasses, decorators, and ruthless efficiency...and an almost fanatical devotion to Guido.... Our four...no....Amongst our",
    "usage is somewhat more complex in this role.\n5. Our chief weapon is decorators...decorators and metaclasses...metaclasses and\ndecorators.... Our two weapons are metaclasses and decorators...and ruthless efficiency.... Our three weapons are metaclasses, decorators, and ruthless efficiency...and an almost fanatical devotion to Guido.... Our four...no....Amongst our\nweapons.... Amongst our weaponry...are such elements as metaclasses, decorators.... I’ll come in again....",
    "Test Your Knowledge: Answers | 1085\n\n\f\fPART IX\n\nAppendixes\n\n\f\fAPPENDIX A\n\nInstallation and Configuration\n\nThis appendix provides additional installation and configuration details as a resource\nfor people new to such topics.\n\nInstalling the Python Interpreter\nBecause you need the Python interpreter to run Python scripts, the first step in using\nPython is usually installing Python. Unless one is already available on your machine,\nyou’ll need to fetch, install, and possibly configure a recent version of Python on your\ncomputer. You’ll only need to do this once per machine, and if you will be running a\nfrozen binary (described in Chapter 2) or self-installing system, you may not need to\ndo much more.",
    "Is Python Already Present?\nBefore you do anything else, check whether you already have a recent Python on your\nmachine. If you are working on Linux, Mac OS X, or some Unix systems, Python is\nprobably already installed on your computer, though it may be one or two releases\nbehind the cutting edge. Here’s how to check:\n• On Windows, check whether there is a Python entry in the Start button’s All Programs menu (at the bottom left of the screen).\n• On Mac OS X, open a Terminal window (Applications→Utilities→Terminal) and\ntype python at the prompt.\n• On Linux and Unix, type python at a shell prompt (a.k.a. terminal window), and\nsee what happens. Alternatively, try searching for “python” in the usual\nplaces—/usr/bin, /usr/local/bin, etc.\nIf you find a Python, make sure it’s a recent version. Although any recent Python will\ndo for most of this text, this edition focuses on Python 3.0 and 2.6 specifically, so you\nmay want to install one of these to run some of the examples in this book.",
    "1089\n\n\fSpeaking of versions, I recommend starting out with Python 3.0 or later if you’re learning Python anew and don’t need to deal with existing 2.X code; otherwise, you should\ngenerally use Python 2.6. Some popular Python-based systems still use older releases,\nthough (2.5 is still widespread), so if you’re working with existing systems be sure to\nuse a version relevant to your needs; the next section describes locations where you can\nfetch a variety of Python versions.",
    "Where to Get Python\nIf there is no Python on your machine, you will need to install one yourself. The good\nnews is that Python is an open source system that is freely available on the Web and\nvery easy to install on most platforms.\nYou can always fetch the latest and greatest standard Python release from http://www\n.python.org, Python’s official website. Look for the Downloads link on that page, and\nchoose a release for the platform on which you will be working. You’ll find prebuilt\nself-installer files for Windows (run to install), Installer Disk Images for Mac OS X\n(installed per Mac conventions), the full source code distribution (typically compiled\non Linux, Unix, or OS X machines to generate an interpreter), and more.\nAlthough Python is standard on Linux these days, you can also find RPMs for Linux\non the Web (unpack them with rpm). Python’s website also has links to pages where\nversions for other platforms are maintained, either at Python.org itself or offsite. A",
    "on Linux, Unix, or OS X machines to generate an interpreter), and more.\nAlthough Python is standard on Linux these days, you can also find RPMs for Linux\non the Web (unpack them with rpm). Python’s website also has links to pages where\nversions for other platforms are maintained, either at Python.org itself or offsite. A\nGoogle web search is another great way to find Python packages. Among other platforms, you can find Python pre-built for iPods, Palm handhelds, Nokia cell phones,\nPlayStation and PSP, Solaris, AS/400, and Windows Mobile.\nIf you find yourself pining for a Unix environment on a Windows machine, you might\nalso be interested in installing Cygwin and its version of Python (see http://www.cygwin\n.com). Cygwin is a GPL-licensed library and toolset that provides full Unix functionality\non Windows machines, and it includes a prebuilt Python that makes use of the all the\nUnix tools provided.\nYou can also find Python on CD-ROMs supplied with Linux distributions, included",
    "also be interested in installing Cygwin and its version of Python (see http://www.cygwin\n.com). Cygwin is a GPL-licensed library and toolset that provides full Unix functionality\non Windows machines, and it includes a prebuilt Python that makes use of the all the\nUnix tools provided.\nYou can also find Python on CD-ROMs supplied with Linux distributions, included\nwith some products and computer systems, and enclosed with some other Python\nbooks. These tend to lag behind the current release somewhat, but usually not seriously\nso.\nIn addition, you can find Python in some free and commercial development bundles.\nFor example, ActiveState distributes Python as part of its ActivePython, a package that\ncombines standard Python with extensions for Windows development such as\nPyWin32, an IDE called PythonWin (described in Chapter 3), and other commonly\nused extensions. Python can also be had today in the Enthought Python Distribution—",
    "For example, ActiveState distributes Python as part of its ActivePython, a package that\ncombines standard Python with extensions for Windows development such as\nPyWin32, an IDE called PythonWin (described in Chapter 3), and other commonly\nused extensions. Python can also be had today in the Enthought Python Distribution—\na package aimed at scientific computing needs—as well as in Portable Python, preconfigured to run directly from a portable device. Search the Web for details.",
    "1090 | Appendix A: Installation and Configuration\n\n\fFinally, if you are interested in alternative Python implementations, run a web search\nto check out Jython (the Python port to the Java environment) and IronPython (Python\nfor the C#/.NET world), both of which are described in Chapter 2. Installation of these\nsystems is beyond the scope of this book.",
    "Installation Steps\nOnce you’ve downloaded Python, you need to install it. Installation steps are very\nplatform-specific, but here are a few pointers for the major Python platforms:\nWindows\nOn Windows, Python comes as a self-installer MSI program file—simply doubleclick on its file icon, and answer Yes or Next at every prompt to perform a default\ninstall. The default install includes Python’s documentation set and support for\ntkinter (Tkinter in Python 2.6) GUIs, shelve databases, and the IDLE development\nGUI. Python 3.0 and 2.6 are normally installed in the directories C:\\Python30 and\nC:\\Python26, though this can be changed at install time.\nFor convenience, after the install Python shows up in the Start button’s All Programs menu. Python’s menu there has five entries that give quick access to common\ntasks: starting the IDLE user interface, reading module documentation, starting an",
    "GUI. Python 3.0 and 2.6 are normally installed in the directories C:\\Python30 and\nC:\\Python26, though this can be changed at install time.\nFor convenience, after the install Python shows up in the Start button’s All Programs menu. Python’s menu there has five entries that give quick access to common\ntasks: starting the IDLE user interface, reading module documentation, starting an\ninteractive session, reading Python’s standard manuals in a web browser, and uninstalling. Most of these options involve concepts explored in detail elsewhere in\nthis text.\nWhen installed on Windows, Python also by default automatically registers itself\nto be the program that opens Python files when their icons are clicked (a program\nlaunch technique described in Chapter 3). It is also possible to build Python from\nits source code on Windows, but this is not commonly done.\nOne note for Windows Vista users: security features of the some versions of Vista",
    "this text.\nWhen installed on Windows, Python also by default automatically registers itself\nto be the program that opens Python files when their icons are clicked (a program\nlaunch technique described in Chapter 3). It is also possible to build Python from\nits source code on Windows, but this is not commonly done.\nOne note for Windows Vista users: security features of the some versions of Vista\nchange some of the rules for using MSI installer files. Although this may be a\nnonissue by the time you read these words, see the sidebar “The Python MSI Installer on Windows Vista” on page 1092 in this appendix for assistance if the\ncurrent Python installer does not work, or does not place Python in the correct\nplace on your machine.\nLinux\nOn Linux, Python is available as one or more RPM files, which you unpack in the\nusual way (consult the RPM manpage for details). Depending on which RPMs you\ndownload, there may be one for Python itself, and another that adds support for",
    "current Python installer does not work, or does not place Python in the correct\nplace on your machine.\nLinux\nOn Linux, Python is available as one or more RPM files, which you unpack in the\nusual way (consult the RPM manpage for details). Depending on which RPMs you\ndownload, there may be one for Python itself, and another that adds support for\ntkinter GUIs and the IDLE environment. Because Linux is a Unix-like system, the\nnext paragraph applies as well.\nUnix\nOn Unix systems, Python is usually compiled from its full C source code distribution. This usually only requires you to unpack the file and run simple config and\nmake commands; Python configures its own build procedure automatically,\nInstalling the Python Interpreter | 1091",
    "according to the system on which it is being compiled. However, be sure to see the\npackage’s README file for more details on this process. Because Python is open\nsource, its source code may be used and distributed free of charge.\nOn other platforms the installation details can differ widely, but they generally follow\nthe platform’s normal conventions. Installing the “Pippy” port of Python for PalmOS,\nfor example, requires a hotsync operation with your PDA, and Python for the Sharp\nZaurus Linux-based PDA comes as one or more .ipk files, which you simply run to\ninstall it. Because additional install procedures for both executable and source forms\nare well documented, though, we’ll skip further details here.",
    "The Python MSI Installer on Windows Vista\nAs I write this, the Python self-installer for Windows is an .msi installation file. This\nformat works fine on Windows XP (simply double-click on the file, and it runs), but it\ncan have issues on some versions of Windows Vista. In particular, running the MSI\ninstaller by clicking on it may cause Python to be installed at the root of the C: drive,\ninstead of in the correct C:\\PythonXX directory. Python still works in the root directory,\nbut this is not the correct place to install it.\nThis is a Vista security-related issue; in short, MSI files are not true executables, so they\ndo not correctly inherit administrator permissions, even if run by the administrator\nuser. Instead, MSI files are run via the Windows Registry—their filenames are associated with the MSI installer program.\nThis problem seems to be either Python- or Vista-version specific. On a recent laptop,",
    "This is a Vista security-related issue; in short, MSI files are not true executables, so they\ndo not correctly inherit administrator permissions, even if run by the administrator\nuser. Instead, MSI files are run via the Windows Registry—their filenames are associated with the MSI installer program.\nThis problem seems to be either Python- or Vista-version specific. On a recent laptop,\nfor example, Python 2.6 and 3.0 installed without issue. To install Python 2.5.2 on my\nVista-based OQO handheld, though, I had to use a command-line approach to force\nthe required administrator permissions.\nIf Python doesn’t install in the right place for you, here’s the workaround: go to your\nStart button, select the All Programs entry, choose Accessories, right-click on the Command Prompt entry there, choose “Run as administrator,” and select Continue in the\naccess control dialog. Now, within the Command Prompt window, issue a cd command",
    "the required administrator permissions.\nIf Python doesn’t install in the right place for you, here’s the workaround: go to your\nStart button, select the All Programs entry, choose Accessories, right-click on the Command Prompt entry there, choose “Run as administrator,” and select Continue in the\naccess control dialog. Now, within the Command Prompt window, issue a cd command\nto change to the directory where your Python MSI installer file resides (e.g.,\ncd C:\\user\\downloads), and then run the MSI installer manually by typing a command\nline of the form msiexec /i python-2.5.1.msi. Finally, follow the usual GUI interactions\nto complete the install.\nNaturally, this behavior may change over time. This procedure may not be required in\nevery version of Vista, and additional workarounds may be possible (such as disabling\nVista security, if you dare). It’s also possible that the Python self-installer may eventually",
    "line of the form msiexec /i python-2.5.1.msi. Finally, follow the usual GUI interactions\nto complete the install.\nNaturally, this behavior may change over time. This procedure may not be required in\nevery version of Vista, and additional workarounds may be possible (such as disabling\nVista security, if you dare). It’s also possible that the Python self-installer may eventually\nbe provided in a different format that obviates this problem—as a true executable, for\ninstance. Be sure to try your installer by simply clicking its icon to see if it works properly\nbefore attempting any workarounds.",
    "1092 | Appendix A: Installation and Configuration\n\n\fConfiguring Python\nAfter you’ve installed Python, you may want to configure some system settings that\nimpact the way Python runs your code. (If you are just getting started with the language,\nyou can probably skip this section completely; there is usually no need to specify any\nsystem settings for basic programs.)\nGenerally speaking, parts of the Python interpreter’s behavior can be configured with\nenvironment variable settings and command-line options. In this section, we’ll take a\nbrief look at both, but be sure to see other documentation sources for more details on\nthe topics we introduce here.",
    "Python Environment Variables\nEnvironment variables—known to some as shell variables, or DOS variables—are\nsystem-wide settings that live outside Python and thus can be used to customize the\ninterpreter’s behavior each time it is run on a given computer. Python recognizes a\nhandful of environment variable settings, but only a few are used often enough to warrant explanation here. Table A-1 summarizes the main Python-related environment\nvariable settings.\nTable A-1. Important environment variables\nVariable\n\nRole\n\nPATH (or path)\n\nSystem shell search path (for finding “python”)\n\nPYTHONPATH\n\nPython module search path (for imports)\n\nPYTHONSTARTUP\n\nPath to Python interactive startup file\n\nTCL_LIBRARY, TK_LIBRARY\n\nGUI extension variables (tkinter)\n\nThese variables are straightforward to use, but here are a few pointers:\nPATH",
    "PYTHONSTARTUP\n\nPath to Python interactive startup file\n\nTCL_LIBRARY, TK_LIBRARY\n\nGUI extension variables (tkinter)\n\nThese variables are straightforward to use, but here are a few pointers:\nPATH\n\nThe PATH setting lists a set of directories that the operating system searches for\nexecutable programs. It should normally include the directory where your Python\ninterpreter lives (the python program on Unix, or the python.exe file on Windows).\nYou don’t need to set this variable at all if you are willing to work in the directory\nwhere Python resides, or type the full path to Python in command lines. On Windows, for instance, the PATH is irrelevant if you run a cd C:\\Python30 before running\nany code (to change to the directory where Python lives), or always type\nC:\\Python30\\python instead of just python (giving a full path). Also, note that\nPATH settings are mostly for launching programs from command lines; they are\nusually irrelevant when launching via icon clicks and IDEs.",
    "Configuring Python | 1093\n\n\fPYTHONPATH\nThe PYTHONPATH setting serves a role similar to PATH: the Python interpreter consults\nthe PYTHONPATH variable to locate module files when you import them in a program.",
    "If used, this variable is set to a platform-dependent list of directory names, separated by colons on Unix and semicolons on Windows. This list normally includes\njust your own source code directories. Its content is merged into the sys.path\nmodule import search path, along with the script’s directory, any path file settings,\nand standard library directories.\nYou don’t need to set this variable unless you will be performing cross-directory\nimports—because Python always searches the home directory of the program’s\ntop-level file automatically, this setting is required only if a module needs to import\nanother module that lives in a different directory. See also the discussion of .pth\npath files later in this appendix for an alternative to PYTHONPATH. For more on the\nmodule search path, refer to Chapter 21.\nPYTHONSTARTUP\nIf PYTHONSTARTUP is set to the pathname of a file of Python code, Python executes",
    "the file’s code automatically whenever you start the interactive interpreter, as\nthough you had typed it at the interactive command line. This is a rarely used but\nhandy way to make sure you always load certain utilities when working interactively; it saves an import.\ntkinter settings\nIf you wish to use the tkinter GUI toolkit (named Tkinter in 2.6), you might have\nto set the two GUI variables in the last line of Table A-1 to the names of the source\nlibrary directories of the Tcl and Tk systems (much like PYTHONPATH). However,\nthese settings are not required on Windows systems (where tkinter support is\ninstalled alongside Python), and they’re usually not required elsewhere if Tcl and\nTk reside in standard directories.\nNote that because these environment settings are external to Python itself, when you\nset them is usually irrelevant: this can be done before or after Python is installed, as\nlong as they are set the way you require before Python is actually run.",
    "Getting tkinter (and IDLE) GUI Support on Linux\nThe IDLE interface described in Chapter 2 is a Python tkinter GUI program. The\ntkinter module (named Tkinter in 2.6) is a GUI toolkit, and it’s a complete, standard\ncomponent of Python on Windows and some other platforms. On some Linux systems,\nthough, the underlying GUI library may not be a standard installed component. To add\nGUI support to your Python on Linux if needed, try running a command line of the\nform yum tkinter to automatically install tkinter’s underlying libraries. This should\nwork on Linux distributions (and some other systems) on which the yum installation\nprogram is available.\n\n1094 | Appendix A: Installation and Configuration",
    "1094 | Appendix A: Installation and Configuration\n\n\fHow to Set Configuration Options\nThe way to set Python-related environment variables, and what to set them to, depends\non the type of computer you’re working on. And again, remember that you won’t\nnecessarily have to set these at all right away; especially if you’re working in IDLE\n(described in Chapter 3), configuration is not required up front.\nBut suppose, for illustration, that you have generally useful module files in directories\ncalled utilities and package1 somewhere on your machine, and you want to be able to\nimport these modules from files located in other directories. That is, to load a file called\nspam.py from the utilities directory, you want to be able to say:\nimport spam\n\nfrom another file located anywhere on your computer. To make this work, you’ll have\nto configure your module search path one way or another to include the directory\ncontaining spam.py. Here are a few tips on this process.",
    "from another file located anywhere on your computer. To make this work, you’ll have\nto configure your module search path one way or another to include the directory\ncontaining spam.py. Here are a few tips on this process.\n\nUnix/Linux shell variables\nOn Unix systems, the way to set environment variables depends on the shell you use.\nUnder the csh shell, you might add a line like the following in your .cshrc or .login file\nto set the Python module search path:\nsetenv PYTHONPATH /usr/home/pycode/utilities:/usr/lib/pycode/package1\n\nThis tells Python to look for imported modules in two user-defined directories. Alternatively, if you’re using the ksh shell, the setting might instead appear in your .kshrc\nfile and look like this:\nexport PYTHONPATH=\"/usr/home/pycode/utilities:/usr/lib/pycode/package1\"\n\nOther shells may use different (but analogous) syntax.",
    "This tells Python to look for imported modules in two user-defined directories. Alternatively, if you’re using the ksh shell, the setting might instead appear in your .kshrc\nfile and look like this:\nexport PYTHONPATH=\"/usr/home/pycode/utilities:/usr/lib/pycode/package1\"\n\nOther shells may use different (but analogous) syntax.\n\nDOS variables (Windows)\nIf you are using MS-DOS, or some older flavors of Windows, you may need to add an\nenvironment variable configuration command to your C:\\autoexec.bat file, and reboot\nyour machine for the changes to take effect. The configuration command on such machines has a syntax unique to DOS:\nset PYTHONPATH=c:\\pycode\\utilities;d:\\pycode\\package1\n\nYou can type such a command in a DOS console window, too, but the setting will then\nbe active only for that one console window. Changing your .bat file makes the change\npermanent and global to all programs.",
    "You can type such a command in a DOS console window, too, but the setting will then\nbe active only for that one console window. Changing your .bat file makes the change\npermanent and global to all programs.\n\nWindows environment variable GUI\nOn more recent versions of Windows, including XP and Vista, you can instead set\nPYTHONPATH and other variables via the system environment variable GUI without having\n\nConfiguring Python | 1095",
    "Windows environment variable GUI\nOn more recent versions of Windows, including XP and Vista, you can instead set\nPYTHONPATH and other variables via the system environment variable GUI without having\n\nConfiguring Python | 1095\n\n\fto edit files or reboot. On XP, select the Control Panel, choose the System icon, pick\nthe Advanced tab, and click the Environment Variables button to edit or add new\nvariables (PYTHONPATH is usually a user variable). Use the same variable name and values\nsyntax shown in the DOS set command earlier. The procedure is similar on Vista, but\nyou may have to verify operations along the way.\nYou do not need to reboot your machine, but be sure to restart Python if it’s open so\nthat it picks up your changes—it configures its path at startup time only. If you’re\nworking in a Windows Command Prompt window, you’ll probably need to restart that\nto pick up your changes as well.",
    "Windows registry\nIf you are an experienced Windows user, you may also be able to configure the module\nsearch path by using the Windows Registry Editor. Go to Start→Run... and type\nregedit. Assuming the typical registry tool is on your machine, you can then navigate\nto Python’s entries and make your changes. This is a delicate and error-prone procedure, though, so unless you’re familiar with the registry, I suggest using other options\n(indeed, this is akin to performing brain surgery on your computer, so be careful!).\n\nPath files\nFinally, if you choose to extend the module search path with a .pth file instead of the\nPYTHONPATH variable, you might instead code a text file that looks like the following on\nWindows (e.g., file C:\\Python30\\mypath.pth):\nc:\\pycode\\utilities\nd:\\pycode\\package1",
    "Its contents will differ per platform, and its container directory may differ per both\nplatform and Python release. Python locates this file automatically when it starts up.\nDirectory names in path files may be absolute, or relative to the directory containing\nthe path file; multiple .pth files can be used (all their directories are added), and .pth\nfiles may appear in various automatically checked directories that are platform- and\nversion-specific. In general, a Python release numbered Python N.M typically looks for\npath files in C:\\PythonNM and C:\\PythonNM\\Lib\\site-packages on Windows, and\nin /usr/local/lib/pythonN.M/site-packages and /usr/local/lib/site-python on Unix and\nLinux. See Chapter 21 for more on using path files to configure the sys.path import\nsearch path.\nBecause environment settings are often optional, and because this isn’t a book on operating system shells, I’ll defer to other sources for further details. Consult your system",
    "in /usr/local/lib/pythonN.M/site-packages and /usr/local/lib/site-python on Unix and\nLinux. See Chapter 21 for more on using path files to configure the sys.path import\nsearch path.\nBecause environment settings are often optional, and because this isn’t a book on operating system shells, I’ll defer to other sources for further details. Consult your system\nshell’s manpages or other documentation for more information, and if you have trouble\nfiguring out what your settings should be, ask your system administrator or another\nlocal expert for help.",
    "1096 | Appendix A: Installation and Configuration\n\n\fPython Command-Line Options\nWhen you start Python from a system command line (a.k.a. a shell prompt), you can\npass in a variety of option flags to control how Python runs. Unlike system-wide environment variables, command-line options can be different each time you run a script.\nThe complete form of a Python command-line invocation in 3.0 looks like this (2.6 is\nroughly the same, with a few option differences):\npython [-bBdEhiOsSuvVWx?] [-c command | -m module-name | script | - ] [args]\n\nMost command lines only make use of the script and args parts of this format, to run\na program’s source file with arguments to be used by the program itself. To illustrate,\nconsider the following script file, main,py, which prints the command-line arguments\nlist made available to the script as sys.argv:\n# File main.py\nimport sys\nprint(sys.argv)",
    "Most command lines only make use of the script and args parts of this format, to run\na program’s source file with arguments to be used by the program itself. To illustrate,\nconsider the following script file, main,py, which prints the command-line arguments\nlist made available to the script as sys.argv:\n# File main.py\nimport sys\nprint(sys.argv)\n\nIn the following command line, both python and main.py can also be complete directory\npaths, and the three arguments (a b –c) meant for the script show up in the sys.argv\nlist. The first item in sys.argv is always the script file’s name, when it is known:\nc:\\Python30> python main.py a b –c\n['main.py', 'a', 'b', '-c']\n\n# Most common: run a script file",
    "In the following command line, both python and main.py can also be complete directory\npaths, and the three arguments (a b –c) meant for the script show up in the sys.argv\nlist. The first item in sys.argv is always the script file’s name, when it is known:\nc:\\Python30> python main.py a b –c\n['main.py', 'a', 'b', '-c']\n\n# Most common: run a script file\n\nOther code format specification options allow you to specify Python code to be run on\nthe command line itself (-c), to accept code to run from the standard input stream (a\n– means read from a pipe or redirected input stream file), and so on:\nc:\\Python30> python -c \"print(2 ** 100)\"\n1267650600228229401496703205376\n\n# Read code from command argument\n\nc:\\Python30> python -c \"import main\"\n['-c']\n\n# Import a file to run its code\n\nc:\\Python30> python - < main.py a b –c\n['-', 'a', 'b', '-c']\n\n# Read code from standard input\n\nc:\\Python30> python - a b -c < main.py\n['-', 'a', 'b', '-c']\n\n# Same effect as prior line",
    "# Read code from command argument\n\nc:\\Python30> python -c \"import main\"\n['-c']\n\n# Import a file to run its code\n\nc:\\Python30> python - < main.py a b –c\n['-', 'a', 'b', '-c']\n\n# Read code from standard input\n\nc:\\Python30> python - a b -c < main.py\n['-', 'a', 'b', '-c']\n\n# Same effect as prior line\n\nThe –m code specification locates a module on Python’s module search path\n(sys.path) and runs it as a top-level script (as module __main__). Leave off the “.py”\nsuffix here, since the filename is a module:\nc:\\Python30> python -m main a b –c\n['c:\\\\Python30\\\\main.py', 'a', 'b', '-c']\n\n# Locate/run module as script\n\nThe –m option also supports running modules in packages with relative import syntax,\nas well as modules located in .zip archives. This switch is commonly used to run the\npdb debugger and profile profiler modules from a command line for a script invocation\nrather than interactively, though this usage mode seems to have changed somewhat in\n\nConfiguring Python | 1097",
    "# Locate/run module as script\n\nThe –m option also supports running modules in packages with relative import syntax,\nas well as modules located in .zip archives. This switch is commonly used to run the\npdb debugger and profile profiler modules from a command line for a script invocation\nrather than interactively, though this usage mode seems to have changed somewhat in\n\nConfiguring Python | 1097\n\n\f3.0 (profile appears to have been affected by the removal of execfile in 3.0, and pdb\nsteps into superfluous input/output code in the new 3.0 io module):\nc:\\Python30> python -m pdb main.py a b -c\n--Return-> c:\\python30\\lib\\io.py(762)closed()->False\n-> return self.raw.closed\n(Pdb) c\n\n# Debug a script\n\nc:\\Python30> C:\\python26\\python -m pdb main.py a b -c # Better in 2.6?\n> c:\\python30\\main.py(1)<module>()\n-> import sys\n(Pdb) c\nc:\\Python30> python -m profile main.py a b -c\n\n# Profile a script\n\nc:\\Python30> python -m cProfile main.py a b -c\n\n# Low-overhead profiler",
    "# Debug a script\n\nc:\\Python30> C:\\python26\\python -m pdb main.py a b -c # Better in 2.6?\n> c:\\python30\\main.py(1)<module>()\n-> import sys\n(Pdb) c\nc:\\Python30> python -m profile main.py a b -c\n\n# Profile a script\n\nc:\\Python30> python -m cProfile main.py a b -c\n\n# Low-overhead profiler\n\nImmediately after the “python” and before the designation of code to be run, Python\naccepts additional arguments that control its own behavior. These arguments are consumed by Python itself and are not meant for the script being run. For example, -O runs\nPython in optimized mode, -u forces standard streams to be unbuffered, and –i enters\ninteractive mode after running a script:\nc:\\Python30> python –u main.py a b -c\n\n# Unbuffered output streams",
    "# Unbuffered output streams\n\nPython 2.6 supports additional options that promote 3.0 compatibility (−3, -Q) and\ndetecting inconsistent tab indentation usage, which is always detected and reported in\n3.0 (-t; see Chapter 12). See the Python manuals or reference texts for more details on\navailable command-line options. Or better yet, ask Python itself—run a command-line\nform like this:\nc:\\Python30> python -?\n\nto request Python’s help display, which documents available command-line options.\nIf you deal with complex command lines, be sure to also check out the standard library\nmodules getopt and optparse, which support more sophisticated command-line\nprocessing.",
    "to request Python’s help display, which documents available command-line options.\nIf you deal with complex command lines, be sure to also check out the standard library\nmodules getopt and optparse, which support more sophisticated command-line\nprocessing.\n\nFor More Help\nPython’s standard manual set today includes valuable pointers for usage on various\nplatforms. The standard manual set is available in your Start button on Windows after\nPython is installed (option “Python Manuals”), and online at http://www.python.org.\nLook for the manual set’s top-level section titled “Using Python” for more platformspecific pointers and hints, as well as up-to-date cross-platform environment and\ncommand-line details.\n\n1098 | Appendix A: Installation and Configuration",
    "1098 | Appendix A: Installation and Configuration\n\n\fAs always, the Web is your friend, too, especially in a field that often evolves faster than\nbooks like this can be updated. Given Python’s widespread adoption, chances are good\nthat answers to any usage questions you may have can be found with a web search.\n\nFor More Help | 1099\n\n\f\fAPPENDIX B\n\nSolutions to End-of-Part Exercises\n\nPart I, Getting Started\nSee “Test Your Knowledge: Part I Exercises” on page 70 in Chapter 3 for the exercises.\n1. Interaction. Assuming Python is configured properly, the interaction should look\nsomething like the following (you can run this any way you like (in IDLE, from a\nshell prompt, and so on):\n% python\n...copyright information lines...\n>>> \"Hello World!\"\n'Hello World!'\n>>>\n# Use Ctrl-D or Ctrl-Z to exit, or close window",
    "2. Programs. Your code (i.e., module) file module1.py and the operating system shell\ninteractions should look like this:\nprint('Hello module world!')\n% python module1.py\nHello module world!\n\nAgain, feel free to run this other ways—by clicking the file’s icon, by using IDLE’s\nRun→Run Module menu option, and so on.\n3. Modules. The following interaction listing illustrates running a module file by importing it:\n% python\n>>> import module1\nHello module world!\n>>>\n\nRemember that you will need to reload the module to run it again without stopping\nand restarting the interpreter. The question about moving the file to a different\ndirectory and importing it again is a trick question: if Python generates a\nmodule1.pyc file in the original directory, it uses that when you import the module,\neven if the source code (.py) file has been moved to a directory not in Python’s\n1101",
    "search path. The .pyc file is written automatically if Python has access to the source\nfile’s directory; it contains the compiled byte code version of a module. See Chapter 3 for more on modules.\n4. Scripts. Assuming your platform supports the #! trick, your solution will look like\nthe following (although your #! line may need to list another path on your\nmachine):\n#!/usr/local/bin/python\nprint('Hello module world!')\n% chmod +x module1.py\n\n(or #!/usr/bin/env python)\n\n% module1.py\nHello module world!",
    "5. Errors. The following interaction (run in Python 3.0) demonstrates the sorts of\nerror messages you’ll get when you complete this exercise. Really, you’re triggering\nPython exceptions; the default exception-handling behavior terminates the running Python program and prints an error message and stack trace on the screen\nThe stack trace shows where you were in a program when the exception occurred\n(if function calls are active when the error happens, the “Traceback” section displays all active call levels). In Part VII, you will learn that you can catch exceptions\nusing try statements and process them arbitrarily; you’ll also see there that Python\nincludes a full-blown source code debugger for special error-detection requirements. For now, notice that Python gives meaningful messages when programming\nerrors occur, instead of crashing silently:\n% python\n>>> 2 ** 500\n32733906078961418700131896968275991522166420460430647894832913680961337964046745",
    "using try statements and process them arbitrarily; you’ll also see there that Python\nincludes a full-blown source code debugger for special error-detection requirements. For now, notice that Python gives meaningful messages when programming\nerrors occur, instead of crashing silently:\n% python\n>>> 2 ** 500\n32733906078961418700131896968275991522166420460430647894832913680961337964046745\n54883270092325904157150886684127560071009217256545885393053328527589376\n>>>\n>>> 1 / 0\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nZeroDivisionError: int division or modulo by zero\n>>>\n>>> spam\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined",
    "6. Breaks and cycles. When you type this code:\nL = [1, 2]\nL.append(L)\n\nyou create a cyclic data structure in Python. In Python releases before 1.5.1, the\nPython printer wasn’t smart enough to detect cycles in objects, and it would print\nan unending stream of [1, 2, [1, 2, [1, 2, [1, 2, and so on, until you hit the\nbreak-key combination on your machine (which, technically, raises a keyboardinterrupt exception that prints a default message). Beginning with Python 1.5.1,\n\n1102 | Appendix B: Solutions to End-of-Part Exercises",
    "the printer is clever enough to detect cycles and prints [[...]] instead to let you\nknow that it has detected a loop in the object’s structure and avoided getting stuck\nprinting forever.\nThe reason for the cycle is subtle and requires information you will glean in\nPart II, so this is something of a preview. But in short, assignments in Python always\ngenerate references to objects, not copies of them. You can think of objects as\nchunks of memory and of references as implicitly followed pointers. When you run\nthe first assignment above, the name L becomes a named reference to a two-item\nlist object—a pointer to a piece of memory. Python lists are really arrays of object\nreferences, with an append method that changes the array in-place by tacking on\nanother object reference at the end. Here, the append call adds a reference to the\nfront of L at the end of L, which leads to the cycle illustrated in Figure B-1: a pointer\nat the end of the list that points back to the front of the list.",
    "references, with an append method that changes the array in-place by tacking on\nanother object reference at the end. Here, the append call adds a reference to the\nfront of L at the end of L, which leads to the cycle illustrated in Figure B-1: a pointer\nat the end of the list that points back to the front of the list.\nBesides being printed specially, as you’ll learn in Chapter 6 cyclic objects must also\nbe handled specially by Python’s garbage collector, or their space will remain unreclaimed even when they are no longer in use. Though rare in practice, in some\nprograms that traverse arbitrary objects or structures you might have to detect such\ncycles yourself by keeping track of where you’ve been to avoid looping. Believe it\nor not, cyclic data structures can sometimes be useful, despite their special-case\nprinting.",
    "Figure B-1. A cyclic object, created by appending a list to itself. By default, Python appends a reference\nto the original list, not a copy of the list.\n\nPart II, Types and Operations\nSee “Test Your Knowledge: Part II Exercises” on page 255 in Chapter 9 for the\nexercises.\n1. The basics. Here are the sorts of results you should get, along with a few comments\nabout their meaning. Again, note that ; is used in a few of these to squeeze more\nthan one statement onto a single line (the ; is a statement separator), and commas\nPart II, Types and Operations | 1103",
    "build up tuples displayed in parentheses. Also keep in mind that the / division\nresult near the top differs in Python 2.6 and 3.0 (see Chapter 5 for details), and the\nlist wrapper around dictionary method calls is needed to display results in 3.0,\nbut not 2.6 (see Chapter 8):\n# Numbers\n>>> 2 ** 16\n# 2 raised to the power 16\n65536\n>>> 2 / 5, 2 / 5.0\n# Integer / truncates in 2.6, but not 3.0\n(0.40000000000000002, 0.40000000000000002)\n# Strings\n>>> \"spam\" + \"eggs\"\n'spameggs'\n>>> S = \"ham\"\n>>> \"eggs \" + S\n'eggs ham'\n>>> S * 5\n'hamhamhamhamham'\n>>> S[:0]\n''\n\n# Concatenation\n\n# Repetition\n# An empty slice at the front -- [0:0]\n# Empty of same type as object sliced\n\n>>> \"green %s and %s\" % (\"eggs\", S)\n# Formatting\n'green eggs and ham'\n>>> 'green {0} and {1}'.format('eggs', S)\n'green eggs and ham'\n# Tuples\n>>> ('x',)[0]\n'x'\n>>> ('x', 'y')[1]\n'y'\n\n# Indexing a single-item tuple\n# Indexing a 2-item tuple",
    "# Concatenation\n\n# Repetition\n# An empty slice at the front -- [0:0]\n# Empty of same type as object sliced\n\n>>> \"green %s and %s\" % (\"eggs\", S)\n# Formatting\n'green eggs and ham'\n>>> 'green {0} and {1}'.format('eggs', S)\n'green eggs and ham'\n# Tuples\n>>> ('x',)[0]\n'x'\n>>> ('x', 'y')[1]\n'y'\n\n# Indexing a single-item tuple\n# Indexing a 2-item tuple\n\n# Lists\n>>> L = [1,2,3] + [4,5,6]\n# List operations\n>>> L, L[:], L[:0], L[-2], L[-2:]\n([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [], 5, [5, 6])\n>>> ([1,2,3]+[4,5,6])[2:4]\n[3, 4]\n>>> [L[2], L[3]]\n# Fetch from offsets; store in a list\n[3, 4]\n>>> L.reverse(); L\n# Method: reverse list in-place\n[6, 5, 4, 3, 2, 1]\n>>> L.sort(); L\n# Method: sort list in-place\n[1, 2, 3, 4, 5, 6]\n>>> L.index(4)\n# Method: offset of first 4 (search)\n3\n# Dictionaries\n>>> {'a':1, 'b':2}['b']\n\n1104 | Appendix B: Solutions to End-of-Part Exercises\n\n# Index a dictionary by key\n\n\f2\n>>> D = {'x':1, 'y':2, 'z':3}\n>>> D['w'] = 0\n>>> D['x'] + D['w']\n1\n>>> D[(1,2,3)] = 4",
    "1104 | Appendix B: Solutions to End-of-Part Exercises\n\n# Index a dictionary by key\n\n\f2\n>>> D = {'x':1, 'y':2, 'z':3}\n>>> D['w'] = 0\n>>> D['x'] + D['w']\n1\n>>> D[(1,2,3)] = 4\n\n# Create a new entry\n# A tuple used as a key (immutable)\n\n>>> D\n{'w': 0, 'z': 3, 'y': 2, (1, 2, 3): 4, 'x': 1}\n>>> list(D.keys()), list(D.values()), (1,2,3) in D\n(['w', 'z', 'y', (1, 2, 3), 'x'], [0, 3, 2, 4, 1], True)\n\n# Methods, key test\n\n# Empties\n>>> [[]], [\"\",[],(),{},None]\n([[]], ['', [], (), {}, None])\n\n# Lots of nothings: empty objects",
    "2. Indexing and slicing. Indexing out of bounds (e.g., L[4]) raises an error; Python\nalways checks to make sure that all offsets are within the bounds of a sequence.\nOn the other hand, slicing out of bounds (e.g., L[-1000:100]) works because Python\nscales out-of-bounds slices so that they always fit (the limits are set to zero and the\nsequence length, if required).\nExtracting a sequence in reverse, with the lower bound greater than the higher\nbound (e.g., L[3:1]), doesn’t really work. You get back an empty slice ([ ]) because\nPython scales the slice limits to make sure that the lower bound is always less than\nor equal to the upper bound (e.g., L[3:1] is scaled to L[3:3], the empty insertion\npoint at offset 3). Python slices are always extracted from left to right, even if you\nuse negative indexes (they are first converted to positive indexes by adding the\nsequence length). Note that Python 2.3’s three-limit slices modify this behavior",
    "or equal to the upper bound (e.g., L[3:1] is scaled to L[3:3], the empty insertion\npoint at offset 3). Python slices are always extracted from left to right, even if you\nuse negative indexes (they are first converted to positive indexes by adding the\nsequence length). Note that Python 2.3’s three-limit slices modify this behavior\nsomewhat. For instance, L[3:1:-1] does extract from right to left:\n>>> L = [1, 2, 3, 4]\n>>> L[4]\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nIndexError: list index out of range\n>>> L[-1000:100]\n[1, 2, 3, 4]\n>>> L[3:1]\n[]\n>>> L\n[1, 2, 3, 4]\n>>> L[3:1] = ['?']\n>>> L\n[1, 2, 3, '?', 4]",
    "3. Indexing, slicing, and del. Your interaction with the interpreter should look something like the following code. Note that assigning an empty list to an offset stores\nan empty list object there, but assigning an empty list to a slice deletes the slice.\nSlice assignment expects another sequence, or you’ll get a type error; it inserts items\ninside the sequence assigned, not the sequence itself:\nPart II, Types and Operations | 1105\n\n\f>>> L = [1,2,3,4]\n>>> L[2] = []\n>>> L\n[1, 2, [], 4]\n>>> L[2:3] = []\n>>> L\n[1, 2, 4]\n>>> del L[0]\n>>> L\n[2, 4]\n>>> del L[1:]\n>>> L\n[2]\n>>> L[1:2] = 1\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: illegal argument type for built-in operation",
    ">>> L = [1,2,3,4]\n>>> L[2] = []\n>>> L\n[1, 2, [], 4]\n>>> L[2:3] = []\n>>> L\n[1, 2, 4]\n>>> del L[0]\n>>> L\n[2, 4]\n>>> del L[1:]\n>>> L\n[2]\n>>> L[1:2] = 1\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: illegal argument type for built-in operation\n\n4. Tuple assignment. The values of X and Y are swapped. When tuples appear on the\nleft and right of an assignment symbol (=), Python assigns objects on the right to\ntargets on the left according to their positions. This is probably easiest to understand by noting that the targets on the left aren’t a real tuple, even though they\nlook like one; they are simply a set of independent assignment targets. The items\non the right are a tuple, which gets unpacked during the assignment (the tuple\nprovides the temporary assignment needed to achieve the swap effect):\n>>> X = 'spam'\n>>> Y = 'eggs'\n>>> X, Y = Y, X\n>>> X\n'eggs'\n>>> Y\n'spam'",
    "5. Dictionary keys. Any immutable object can be used as a dictionary key, including\nintegers, tuples, strings, and so on. This really is a dictionary, even though some\nof its keys look like integer offsets. Mixed-type keys work fine, too:\n>>> D = {}\n>>> D[1] = 'a'\n>>> D[2] = 'b'\n>>> D[(1, 2, 3)] = 'c'\n>>> D\n{1: 'a', 2: 'b', (1, 2, 3): 'c'}\n\n6. Dictionary indexing. Indexing a nonexistent key (D['d']) raises an error; assigning\nto a nonexistent key (D['d']='spam') creates a new dictionary entry. On the other\nhand, out-of-bounds indexing for lists raises an error too, but so do out-of-bounds\nassignments. Variable names work like dictionary keys; they must have already\nbeen assigned when referenced, but they are created when first assigned. In fact,\nvariable names can be processed as dictionary keys if you wish (they’re made visible\nin module namespace or stack-frame dictionaries):\n\n1106 | Appendix B: Solutions to End-of-Part Exercises",
    "1106 | Appendix B: Solutions to End-of-Part Exercises\n\n\f>>> D = {'a':1, 'b':2, 'c':3}\n>>> D['a']\n1\n>>> D['d']\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nKeyError: d\n>>> D['d'] = 4\n>>> D\n{'b': 2, 'd': 4, 'a': 1, 'c': 3}\n>>>\n>>> L = [0, 1]\n>>> L[2]\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nIndexError: list index out of range\n>>> L[2] = 3\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nIndexError: list assignment index out of range",
    "7. Generic operations. Question answers:\n• The + operator doesn’t work on different/mixed types (e.g., string + list, list +\ntuple).\n• + doesn’t work for dictionaries, as they aren’t sequences.\n• The append method works only for lists, not strings, and keys works only on\ndictionaries. append assumes its target is mutable, since it’s an in-place extension; strings are immutable.\n• Slicing and concatenation always return a new object of the same type as the\nobjects processed:\n>>> \"x\" + 1\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: illegal argument type for built-in operation\n>>>\n>>> {} + {}\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: bad operand type(s) for +\n>>>\n>>> [].append(9)\n>>> \"\".append('s')\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nAttributeError: attribute-less object\n>>>\n>>> list({}.keys())\n# list needed in 3.0, not 2.6\n[]\n>>> [].keys()\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nAttributeError: keys",
    "Part II, Types and Operations | 1107\n\n\f>>>\n>>> [][:]\n[]\n>>> \"\"[:]\n''\n\n8. String indexing. This is a bit of a trick question—Because strings are collections of\none-character strings, every time you index a string, you get back a string that can\nbe indexed again. S[0][0][0][0][0] just keeps indexing the first character over and\nover. This generally doesn’t work for lists (lists can hold arbitrary objects) unless\nthe list contains strings:\n>>> S = \"spam\"\n>>> S[0][0][0][0][0]\n's'\n>>> L = ['s', 'p']\n>>> L[0][0][0]\n's'\n\n9. Immutable types. Either of the following solutions works. Index assignment\ndoesn’t, because strings are immutable:\n>>> S = \"spam\"\n>>> S = S[0] + 'l' + S[2:]\n>>> S\n'slam'\n>>> S = S[0] + 'l' + S[2] + S[3]\n>>> S\n'slam'",
    "9. Immutable types. Either of the following solutions works. Index assignment\ndoesn’t, because strings are immutable:\n>>> S = \"spam\"\n>>> S = S[0] + 'l' + S[2:]\n>>> S\n'slam'\n>>> S = S[0] + 'l' + S[2] + S[3]\n>>> S\n'slam'\n\n(See also the Python 3.0 bytearray string type in Chapter 36—it’s a mutable sequence\nof small integers that is essentially processed the same as a string.)\n10. Nesting. Here is a sample:\n>>> me = {'name':('John', 'Q', 'Doe'), 'age':'?', 'job':'engineer'}\n>>> me['job']\n'engineer'\n>>> me['name'][2]\n'Doe'\n\n11. Files. Here’s one way to create and read back a text file in Python (ls is a Unix\ncommand; use dir on Windows):\n# File: maker.py\nfile = open('myfile.txt', 'w')\nfile.write('Hello file world!\\n')\nfile.close()\n\n# Or: open().write()\n# close not always needed\n\n# File: reader.py\nfile = open('myfile.txt')\nprint(file.read())\n\n# 'r' is default open mode\n# Or print(open().read())\n\n% python maker.py\n% python reader.py\nHello file world!",
    "# Or: open().write()\n# close not always needed\n\n# File: reader.py\nfile = open('myfile.txt')\nprint(file.read())\n\n# 'r' is default open mode\n# Or print(open().read())\n\n% python maker.py\n% python reader.py\nHello file world!\n\n1108 | Appendix B: Solutions to End-of-Part Exercises\n\n\f% ls -l myfile.txt\n-rwxrwxrwa\n1 0\n\n0\n\n19 Apr 13 16:33 myfile.txt\n\nPart III, Statements and Syntax\nSee “Test Your Knowledge: Part III Exercises” on page 390 in Chapter 15 for the\nexercises.\n1. Coding basic loops. As you work through this exercise, you’ll wind up with code\nthat looks like the following:\n>>> S = 'spam'\n>>> for c in S:\n...\nprint(ord(c))\n...\n115\n112\n97\n109\n>>> x = 0\n>>> for c in S: x += ord(c)\n...\n>>> x\n433\n\n# Or: x = x + ord(c)\n\n>>> x = []\n>>> for c in S: x.append(ord(c))\n...\n>>> x\n[115, 112, 97, 109]\n>>> list(map(ord, S))\n[115, 112, 97, 109]\n\n# list() required in 3.0, not 2.6",
    "# list() required in 3.0, not 2.6\n\n2. Backslash characters. The example prints the bell character (\\a) 50 times; assuming\nyour machine can handle it, and when it’s run outside of IDLE, you may get a series\nof beeps (or one sustained tone, if your machine is fast enough). Hey—I warned\nyou.\n3. Sorting dictionaries. Here’s one way to work through this exercise (see Chapter 8\nor Chapter 14 if this doesn’t make sense). Remember, you really do have to split\nup the keys and sort calls like this because sort returns None. In Python 2.2 and\nlater, you can iterate through dictionary keys directly without calling keys (e.g.,\nfor key in D:), but the keys list will not be sorted like it is by this code. In more\nrecent Pythons, you can achieve the same effect with the sorted built-in, too:\n>>> D = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6, 'g':7}\n>>> D\n{'f': 6, 'c': 3, 'a': 1, 'g': 7, 'e': 5, 'd': 4, 'b': 2}\n>>>\n>>> keys = list(D.keys())\n# list() required in 3.0, not in 2.6",
    "Part III, Statements and Syntax | 1109\n\n\f>>> keys.sort()\n>>> for key in keys:\n...\nprint(key, '=>', D[key])\n...\na => 1\nb => 2\nc => 3\nd => 4\ne => 5\nf => 6\ng => 7\n>>> for key in sorted(D):\n...\nprint(key, '=>', D[key])\n\n# Better, in more recent Pythons\n\n4. Program logic alternatives. Here’s some sample code for the solutions. For step e,\nassign the result of 2 ** X to a variable outside the loops of steps a and b, and use\nit inside the loop. Your results may vary a bit; this exercise is mostly designed to\nget you playing with code alternatives, so anything reasonable gets full credit:\n#a\nL = [1, 2, 4, 8, 16, 32, 64]\nX = 5\ni = 0\nwhile i < len(L):\nif 2 ** X == L[i]:\nprint('at index', i)\nbreak\ni += 1\nelse:\nprint(X, 'not found')\n#b\nL = [1, 2, 4, 8, 16, 32, 64]\nX = 5\nfor p in L:\nif (2 ** X) == p:\nprint((2 ** X), 'was found at', L.index(p))\nbreak\nelse:\nprint(X, 'not found')\n#c\nL = [1, 2, 4, 8, 16, 32, 64]\nX = 5\nif (2 ** X) in L:\nprint((2 ** X), 'was found at', L.index(2 ** X))",
    "1110 | Appendix B: Solutions to End-of-Part Exercises\n\n\felse:\nprint(X, 'not found')\n#d\nX = 5\nL = []\nfor i in range(7): L.append(2 ** i)\nprint(L)\nif (2 ** X) in L:\nprint((2 ** X), 'was found at', L.index(2 ** X))\nelse:\nprint(X, 'not found')\n# f\nX = 5\nL = list(map(lambda x: 2**x, range(7)))\nprint(L)\n\n# or [2**x for x in range(7)]\n# list() to print all in 3.0, not 2.6\n\nif (2 ** X) in L:\nprint((2 ** X), 'was found at', L.index(2 ** X))\nelse:\nprint(X, 'not found')\n\nPart IV, Functions\nSee “Test Your Knowledge: Part IV Exercises” on page 524 in Chapter 20 for the\nexercises.\n1. The basics. There’s not much to this one, but notice that using print (and hence\nyour function) is technically a polymorphic operation, which does the right thing\nfor each type of object:\n% python\n>>> def func(x): print(x)\n...\n>>> func(\"spam\")\nspam\n>>> func(42)\n42\n>>> func([1, 2, 3])\n[1, 2, 3]\n>>> func({'food': 'spam'})\n{'food': 'spam'}",
    "2. Arguments. Here’s a sample solution. Remember that you have to use print to see\nresults in the test calls because a file isn’t the same as code typed interactively;\nPython doesn’t normally echo the results of expression statements in files:\n\nPart IV, Functions | 1111\n\n\fdef adder(x, y):\nreturn x + y\nprint(adder(2, 3))\nprint(adder('spam', 'eggs'))\nprint(adder(['a', 'b'], ['c', 'd']))\n% python mod.py\n5\nspameggs\n['a', 'b', 'c', 'd']",
    "3. varargs. Two alternative adder functions are shown in the following file,\nadders.py. The hard part here is figuring out how to initialize an accumulator to an\nempty value of whatever type is passed in. The first solution uses manual type\ntesting to look for an integer, and an empty slice of the first argument (assumed to\nbe a sequence) if the argument is determined not to be an integer. The second\nsolution uses the first argument to initialize and scan items 2 and beyond, much\nlike one of the min function variants shown in Chapter 18.\nThe second solution is better. Both of these assume all arguments are of the same\ntype, and neither works on dictionaries (as we saw in Part II, + doesn’t work on\nmixed types or dictionaries). You could add a type test and special code to allow\ndictionaries, too, but that’s extra credit.\ndef adder1(*args):\nprint('adder1', end=' ')\nif type(args[0]) == type(0):\nsum = 0\nelse:\nsum = args[0][:0]\nfor arg in args:\nsum = sum + arg\nreturn sum",
    "type, and neither works on dictionaries (as we saw in Part II, + doesn’t work on\nmixed types or dictionaries). You could add a type test and special code to allow\ndictionaries, too, but that’s extra credit.\ndef adder1(*args):\nprint('adder1', end=' ')\nif type(args[0]) == type(0):\nsum = 0\nelse:\nsum = args[0][:0]\nfor arg in args:\nsum = sum + arg\nreturn sum\ndef adder2(*args):\nprint('adder2', end=' ')\nsum = args[0]\nfor next in args[1:]:\nsum += next\nreturn sum",
    "# Integer?\n# Init to zero\n# else sequence:\n# Use empty slice of arg1\n\n# Init to arg1\n# Add items 2..N\n\nfor func in (adder1, adder2):\nprint(func(2, 3, 4))\nprint(func('spam', 'eggs', 'toast'))\nprint(func(['a', 'b'], ['c', 'd'], ['e', 'f']))\n% python adders.py\nadder1 9\nadder1 spameggstoast\nadder1 ['a', 'b', 'c', 'd', 'e', 'f']\nadder2 9\nadder2 spameggstoast\nadder2 ['a', 'b', 'c', 'd', 'e', 'f']\n\n1112 | Appendix B: Solutions to End-of-Part Exercises",
    "# Init to arg1\n# Add items 2..N\n\nfor func in (adder1, adder2):\nprint(func(2, 3, 4))\nprint(func('spam', 'eggs', 'toast'))\nprint(func(['a', 'b'], ['c', 'd'], ['e', 'f']))\n% python adders.py\nadder1 9\nadder1 spameggstoast\nadder1 ['a', 'b', 'c', 'd', 'e', 'f']\nadder2 9\nadder2 spameggstoast\nadder2 ['a', 'b', 'c', 'd', 'e', 'f']\n\n1112 | Appendix B: Solutions to End-of-Part Exercises\n\n\f4. Keywords. Here is my solution to the first and second parts of this exercise (coded\nin the file mod.py). To iterate over keyword arguments, use the **args form in the\nfunction header and use a loop (e.g., for x in args.keys(): use args[x]), or use\nargs.values() to make this the same as summing *args positionals:\ndef adder(good=1, bad=2, ugly=3):\nreturn good + bad + ugly\nprint(adder())\nprint(adder(5))\nprint(adder(5, 6))\nprint(adder(5, 6, 7))\nprint(adder(ugly=7, good=6, bad=5))\n% python mod.py\n6\n10\n14\n18\n18\n# Second part solutions\ndef adder1(*args):\ntot = args[0]\nfor arg in args[1:]:\ntot += arg\nreturn tot",
    "# Sum any number of positional args\n\ndef adder2(**args):\nargskeys = list(args.keys())\ntot = args[argskeys[0]]\nfor key in argskeys[1:]:\ntot += args[key]\nreturn tot\n\n# Sum any number of keyword args\n# list needed in 3.0!\n\ndef adder3(**args):\nargs = list(args.values())\ntot = args[0]\nfor arg in args[1:]:\ntot += arg\nreturn tot\n\n# Same, but convert to list of values\n# list needed to index in 3.0!\n\ndef adder4(**args):\nreturn adder1(*args.values())\n\n# Same, but reuse positional version\n\nprint(adder1(1, 2, 3),\nadder1('aa', 'bb', 'cc'))\nprint(adder2(a=1, b=2, c=3), adder2(a='aa', b='bb', c='cc'))\nprint(adder3(a=1, b=2, c=3), adder3(a='aa', b='bb', c='cc'))\nprint(adder4(a=1, b=2, c=3), adder4(a='aa', b='bb', c='cc'))\n\nPart IV, Functions | 1113",
    "5. (and 6.) Here are my solutions to exercises 5 and 6 (file dicts.py). These are just\ncoding exercises, though, because Python 1.5 added the dictionary methods\nD.copy() and D1.update(D2) to handle things like copying and adding (merging)\ndictionaries. (See Python’s library manual or O’Reilly’s Python Pocket Reference\nfor more details.) X[:] doesn’t work for dictionaries, as they’re not sequences (see\nChapter 8 for details). Also, remember that if you assign (e = d) rather than copying, you generate a reference to a shared dictionary object; changing d changes e,\ntoo:\ndef copyDict(old):\nnew = {}\nfor key in old.keys():\nnew[key] = old[key]\nreturn new\ndef addDict(d1, d2):\nnew = {}\nfor key in d1.keys():\nnew[key] = d1[key]\nfor key in d2.keys():\nnew[key] = d2[key]\nreturn new\n% python\n>>> from dicts import *\n>>> d = {1: 1, 2: 2}\n>>> e = copyDict(d)\n>>> d[2] = '?'\n>>> d\n{1: 1, 2: '?'}\n>>> e\n{1: 1, 2: 2}\n>>> x = {1: 1}\n>>> y = {2: 2}\n>>> z = addDict(x, y)\n>>> z\n{1: 1, 2: 2}",
    "6. See #5.\n7. More argument-matching examples. Here is the sort of interaction you should get,\nalong with comments that explain the matching that goes on:\ndef f1(a, b): print(a, b)\n\n# Normal args\n\ndef f2(a, *b): print(a, b)\n\n# Positional varargs\n\ndef f3(a, **b): print(a, b)\n\n# Keyword varargs\n\ndef f4(a, *b, **c): print(a, b, c)\n\n# Mixed modes\n\ndef f5(a, b=2, c=3): print(a, b, c)\n\n# Defaults\n\n1114 | Appendix B: Solutions to End-of-Part Exercises\n\n\fdef f6(a, b=2, *c): print(a, b, c)\n% python\n>>> f1(1, 2)\n1 2\n>>> f1(b=2, a=1)\n1 2\n\n# Defaults and positional varargs\n\n# Matched by position (order matters)\n# Matched by name (order doesn't matter)\n\n>>> f2(1, 2, 3)\n1 (2, 3)\n\n# Extra positionals collected in a tuple\n\n>>> f3(1, x=2, y=3)\n1 {'x': 2, 'y': 3}\n\n# Extra keywords collected in a dictionary\n\n>>> f4(1, 2, 3, x=2, y=3)\n1 (2, 3) {'x': 2, 'y': 3}\n\n# Extra of both kinds\n\n>>> f5(1)\n1 2 3\n>>> f5(1, 4)\n1 4 3\n\n# Both defaults kick in\n\n>>> f6(1)\n1 2 ()\n>>> f6(1, 3, 4)\n1 3 (4,)",
    ">>> f2(1, 2, 3)\n1 (2, 3)\n\n# Extra positionals collected in a tuple\n\n>>> f3(1, x=2, y=3)\n1 {'x': 2, 'y': 3}\n\n# Extra keywords collected in a dictionary\n\n>>> f4(1, 2, 3, x=2, y=3)\n1 (2, 3) {'x': 2, 'y': 3}\n\n# Extra of both kinds\n\n>>> f5(1)\n1 2 3\n>>> f5(1, 4)\n1 4 3\n\n# Both defaults kick in\n\n>>> f6(1)\n1 2 ()\n>>> f6(1, 3, 4)\n1 3 (4,)\n\n# One argument: matches \"a\"\n\n# Only one default used\n\n# Extra positional collected",
    ">>> f3(1, x=2, y=3)\n1 {'x': 2, 'y': 3}\n\n# Extra keywords collected in a dictionary\n\n>>> f4(1, 2, 3, x=2, y=3)\n1 (2, 3) {'x': 2, 'y': 3}\n\n# Extra of both kinds\n\n>>> f5(1)\n1 2 3\n>>> f5(1, 4)\n1 4 3\n\n# Both defaults kick in\n\n>>> f6(1)\n1 2 ()\n>>> f6(1, 3, 4)\n1 3 (4,)\n\n# One argument: matches \"a\"\n\n# Only one default used\n\n# Extra positional collected\n\n8. Primes revisited. Here is the primes example, wrapped up in a function and a module (file primes.py) so it can be run multiple times. I added an if test to trap negatives, 0, and 1. I also changed / to // in this edition to make this solution immune\nto the Python 3.0 / true division changes we studied in Chapter 5, and to enable it\nto support floating-point numbers (uncomment the from statement and\nchange // to / to see the differences in 2.6):\n#from __future__ import division\ndef prime(y):\nif y <= 1:\nprint(y, 'not prime')\nelse:\nx = y // 2\nwhile x > 1:\nif y % x == 0:\nprint(y, 'has factor', x)\nbreak\nx -= 1\nelse:\nprint(y, 'is prime')",
    "# For some y > 1\n# 3.0 / fails\n# No remainder?\n# Skip else\n\nprime(13); prime(13.0)\nprime(15); prime(15.0)\nprime(3); prime(2)\nprime(1); prime(-3)\n\nPart IV, Functions | 1115\n\n\fHere is the module in action; the // operator allows it to work for floating-point\nnumbers too, even though it perhaps should not:\n% python primes.py\n13 is prime\n13.0 is prime\n15 has factor 5\n15.0 has factor 5.0\n3 is prime\n2 is prime\n1 not prime\n-3 not prime",
    "Part IV, Functions | 1115\n\n\fHere is the module in action; the // operator allows it to work for floating-point\nnumbers too, even though it perhaps should not:\n% python primes.py\n13 is prime\n13.0 is prime\n15 has factor 5\n15.0 has factor 5.0\n3 is prime\n2 is prime\n1 not prime\n-3 not prime\n\nThis function still isn’t very reusable—it could return values, instead of printing\n—but it’s enough to run experiments. It’s also not a strict mathematical prime\n(floating points work), and it’s still inefficient. Improvements are left as exercises\nfor more mathematically minded readers. (Hint: a for loop over range(y, 1, −1)\nmay be a bit quicker than the while, but the algorithm is the real bottleneck here.)\nTo time alternatives, use the built-in time module and coding patterns like those\nused in this general function-call timer (see the library manual for details):\ndef timer(reps, func, *args):\nimport time\nstart = time.clock()\nfor i in range(reps):\nfunc(*args)\nreturn time.clock() - start",
    "9. List comprehensions. Here is the sort of code you should write; I may have a preference, but I’m not telling:\n>>> values = [2, 4, 9, 16, 25]\n>>> import math\n>>> res = []\n>>> for x in values: res.append(math.sqrt(x))\n...\n>>> res\n[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]\n>>> list(map(math.sqrt, values))\n[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]\n>>> [math.sqrt(x) for x in values]\n[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]\n\n10. Timing tools. Here is some code I wrote to time the three square root options, along\nwith the results in 2.6 and 3.0. The last result of each function is printed to verify\nthat all three do the same work:\n# File mytimer.py (2.6 and 3.0)\n...same as listed in Chapter 20...\n# File timesqrt.py\n\n1116 | Appendix B: Solutions to End-of-Part Exercises\n\n\fimport sys, mytimer\nreps = 10000\nrepslist = range(reps)\nfrom math import sqrt\ndef mathMod():\nfor i in repslist:\nres = sqrt(i)\nreturn res\n\n# Pull out range list time for 2.6\n# Not math.sqrt: adds attr fetch time",
    "1116 | Appendix B: Solutions to End-of-Part Exercises\n\n\fimport sys, mytimer\nreps = 10000\nrepslist = range(reps)\nfrom math import sqrt\ndef mathMod():\nfor i in repslist:\nres = sqrt(i)\nreturn res\n\n# Pull out range list time for 2.6\n# Not math.sqrt: adds attr fetch time\n\ndef powCall():\nfor i in repslist:\nres = pow(i, .5)\nreturn res\ndef powExpr():\nfor i in repslist:\nres = i ** .5\nreturn res\nprint(sys.version)\nfor tester in (mytimer.timer, mytimer.best):\nprint('<%s>' % tester.__name__)\nfor test in (mathMod, powCall, powExpr):\nelapsed, result = tester(test)\nprint ('-'*35)\nprint ('%s: %.5f => %s' %\n(test.__name__, elapsed, result))",
    "Following are the test results for Python 3.0 and 2.6. For both, it looks like the\nmath module is quicker than the ** expression, which is quicker than the pow call;\nhowever, you should try this with your code and on your own machine and version\nof Python. Also, note that Python 3.0 is nearly twice as slow as 2.6 on this test; 3.1\nor later might perform better (time this in the future to see for yourself):\nc:\\misc> c:\\python30\\python timesqrt.py\n3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]\n<timer>\n----------------------------------mathMod: 5.33906 => 99.994999875\n----------------------------------powCall: 7.29689 => 99.994999875\n----------------------------------powExpr: 5.95770 => 99.994999875\n<best>\n----------------------------------mathMod: 0.00497 => 99.994999875\n----------------------------------powCall: 0.00671 => 99.994999875\n----------------------------------powExpr: 0.00540 => 99.994999875\nc:\\misc> c:\\python26\\python timesqrt.py",
    "Part IV, Functions | 1117\n\n\f2.6.1 (r261:67517, Dec 4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)]\n<timer>\n----------------------------------mathMod: 2.61226 => 99.994999875\n----------------------------------powCall: 4.33705 => 99.994999875\n----------------------------------powExpr: 3.12502 => 99.994999875\n<best>\n----------------------------------mathMod: 0.00236 => 99.994999875\n----------------------------------powCall: 0.00402 => 99.994999875\n----------------------------------powExpr: 0.00287 => 99.994999875\n\nTo time the relative speeds of Python 3.0 dictionary comprehensions and equivalent\nfor loops interactively, run a session like the following. It appears that the two are",
    "roughly the same in this regard under Python 3.0; unlike list comprehensions,\nthough, manual loops are slightly faster than dictionary comprehensions today\n(though the difference isn’t exactly earth-shattering—at the end we save half a\nsecond when making 50 dictionaries of 1,000,000 items each). Again, rather than\ntaking these results as gospel you should investigate further on your own, on your\ncomputer and with your Python:\nc:\\misc> c:\\python30\\python\n>>>\n>>> def dictcomp(I):\n...\nreturn {i: i for i in range(I)}\n...\n>>> def dictloop(I):\n...\nnew = {}\n...\nfor i in range(I): new[i] = i\n...\nreturn new\n...\n>>> dictcomp(10)\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n>>> dictloop(10)\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n>>>\n>>> from mytimer import best, timer\n>>> best(dictcomp, 10000)[0]\n# 10,000-item dict\n0.0013519874732672577\n>>> best(dictloop, 10000)[0]\n0.001132965223233029\n>>>\n>>> best(dictcomp, 100000)[0]\n# 100,000 items: 10 times slower",
    "return new\n...\n>>> dictcomp(10)\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n>>> dictloop(10)\n{0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}\n>>>\n>>> from mytimer import best, timer\n>>> best(dictcomp, 10000)[0]\n# 10,000-item dict\n0.0013519874732672577\n>>> best(dictloop, 10000)[0]\n0.001132965223233029\n>>>\n>>> best(dictcomp, 100000)[0]\n# 100,000 items: 10 times slower\n0.01816089754424155\n>>> best(dictloop, 100000)[0]\n0.01643484018219965\n>>>\n>>> best(dictcomp, 1000000)[0]\n# 1,000,000 items: 10X time\n0.18685105229855026\n>>> best(dictloop, 1000000)[0]\n# Time for making one dict",
    "1118 | Appendix B: Solutions to End-of-Part Exercises\n\n\f0.1769041177020938\n>>>\n>>> timer(dictcomp, 1000000, _reps=50)[0]\n10.692516087938543\n>>> timer(dictloop, 1000000, _reps=50)[0]\n10.197276050447755\n\n# 1,000,000-item dict\n# Time for making 50\n\nPart V, Modules\nSee “Test Your Knowledge: Part V Exercises” on page 605 in Chapter 24 for the\nexercises.\n1. Import basics. This one is simpler than you may think. When you’re done, your\nfile (mymod.py) and interaction should look similar to the following; remember\nthat Python can read a whole file into a list of line strings, and the len built-in\nreturns the lengths of strings and lists:\ndef countLines(name):\nfile = open(name)\nreturn len(file.readlines())\ndef countChars(name):\nreturn len(open(name).read())\ndef test(name):\nreturn countLines(name), countChars(name)\n\n# Or pass file object\n# Or return a dictionary\n\n% python\n>>> import mymod\n>>> mymod.test('mymod.py')\n(10, 291)",
    "# Or pass file object\n# Or return a dictionary\n\n% python\n>>> import mymod\n>>> mymod.test('mymod.py')\n(10, 291)\n\nNote that these functions load the entire file in memory all at once, so they won’t\nwork for pathologically large files too big for your machine’s memory. To be more\nrobust, you could read line by line with iterators instead and count as you go:\ndef countLines(name):\ntot = 0\nfor line in open(name): tot += 1\nreturn tot\ndef countChars(name):\ntot = 0\nfor line in open(name): tot += len(line)\nreturn tot\n\nOn Unix, you can verify your output with a wc command; on Windows, right-click\non your file to view its properties. But note that your script may report fewer characters than Windows does—for portability, Python converts Windows \\r\\n lineend markers to \\n, thereby dropping one byte (character) per line. To match byte\ncounts with Windows exactly, you have to open in binary mode ('rb'), or add the\nnumber of bytes corresponding to the number of lines.\nPart V, Modules | 1119",
    "Incidentally, to do the “ambitious” part of this exercise (passing in a file object so\nyou only open the file once), you’ll probably need to use the seek method of the\nbuilt-in file object. We didn’t cover it in the text, but it works just like C’s fseek\ncall (and calls it behind the scenes): seek resets the current position in the file to a\npassed-in offset. After a seek, future input/output operations are relative to the new\nposition. To rewind to the start of a file without closing and reopening it, call\nfile.seek(0); the file read methods all pick up at the current position in the file,\nso you need to rewind to reread. Here’s what this tweak would look like:\ndef countLines(file):\nfile.seek(0)\nreturn len(file.readlines())\n\n# Rewind to start of file\n\ndef countChars(file):\nfile.seek(0)\nreturn len(file.read())\n\n# Ditto (rewind if needed)\n\ndef test(name):\nfile = open(name)\nreturn countLines(file), countChars(file)\n\n# Pass file object\n# Open file only once",
    "# Rewind to start of file\n\ndef countChars(file):\nfile.seek(0)\nreturn len(file.read())\n\n# Ditto (rewind if needed)\n\ndef test(name):\nfile = open(name)\nreturn countLines(file), countChars(file)\n\n# Pass file object\n# Open file only once\n\n>>> import mymod2\n>>> mymod2.test(\"mymod2.py\")\n(11, 392)\n\n2. from/from *. Here’s the from * part; replace * with countChars to do the rest:\n% python\n>>> from mymod import *\n>>> countChars(\"mymod.py\")\n291\n\n3. __main__. If you code it properly, it works in either mode (program run or module\nimport):\ndef countLines(name):\nfile = open(name)\nreturn len(file.readlines())\ndef countChars(name):\nreturn len(open(name).read())\ndef test(name):\nreturn countLines(name), countChars(name)\n\n# Or pass file object\n# Or return a dictionary\n\nif __name__ == '__main__':\nprint(test('mymod.py'))\n% python mymod.py\n(13, 346)",
    "# Or pass file object\n# Or return a dictionary\n\nif __name__ == '__main__':\nprint(test('mymod.py'))\n% python mymod.py\n(13, 346)\n\nThis is where I would probably begin to consider using command-line arguments\nor user input to provide the filename to be counted, instead of hardcoding it in the\nscript (see Chapter 24 for more on sys.argv, and Chapter 10 for more on input):\n\n1120 | Appendix B: Solutions to End-of-Part Exercises\n\n\fif __name__ == '__main__':\nprint(test(input('Enter file name:'))\nif __name__ == '__main__':\nimport sys\nprint(test(sys.argv[1]))\n\n4. Nested imports. Here is my solution (file myclient.py):\nfrom mymod import countLines, countChars\nprint(countLines('mymod.py'), countChars('mymod.py'))\n% python myclient.py\n13 346",
    "1120 | Appendix B: Solutions to End-of-Part Exercises\n\n\fif __name__ == '__main__':\nprint(test(input('Enter file name:'))\nif __name__ == '__main__':\nimport sys\nprint(test(sys.argv[1]))\n\n4. Nested imports. Here is my solution (file myclient.py):\nfrom mymod import countLines, countChars\nprint(countLines('mymod.py'), countChars('mymod.py'))\n% python myclient.py\n13 346\n\nAs for the rest of this one, mymod’s functions are accessible (that is, importable) from\nthe top level of myclient, since from simply assigns to names in the importer (it\nworks almost as though mymod’s defs appeared in myclient). For example, another\nfile can say this:\nimport myclient\nmyclient.countLines(...)\nfrom myclient import countChars\ncountChars(...)\n\nIf myclient used import instead of from, you’d need to use a path to get to the\nfunctions in mymod through myclient:\nimport myclient\nmyclient.mymod.countLines(...)\nfrom myclient import mymod\nmymod.countChars(...)",
    "If myclient used import instead of from, you’d need to use a path to get to the\nfunctions in mymod through myclient:\nimport myclient\nmyclient.mymod.countLines(...)\nfrom myclient import mymod\nmymod.countChars(...)\n\nIn general, you can define collector modules that import all the names from other\nmodules so they’re available in a single convenience module. Using the following\ncode, you wind up with three different copies of the name somename (mod1.somename,\ncollector.somename, and __main__.somename); all three share the same integer object initially, and only the name somename exists at the interactive prompt as is:\n# File mod1.py\nsomename = 42\n# File collector.py\nfrom mod1 import *\nfrom mod2 import *\nfrom mod3 import *\n\n# Collect lots of names here\n# from assigns to my names\n\n>>> from collector import somename",
    "# Collect lots of names here\n# from assigns to my names\n\n>>> from collector import somename\n\n5. Package imports. For this, I put the mymod.py solution file listed for exercise 3 into\na directory package. The following is what I did to set up the directory and its\nrequired __init__.py file in a Windows console interface; you’ll need to interpolate\nfor other platforms (e.g., use mv and vi instead of move and edit). This works in any\nPart V, Modules | 1121",
    "directory (I just happened to run my commands in Python’s install directory), and\nyou can do some of this from a file explorer GUI, too.\nWhen I was done, I had a mypkg subdirectory that contained the files\n__init__.py and mymod.py. You need an __init__.py in the mypkg directory, but\nnot in its parent; mypkg is located in the home directory component of the module\nsearch path. Notice how a print statement coded in the directory’s initialization\nfile fires only the first time it is imported, not the second:\nC:\\python30> mkdir mypkg\nC:\\Python30> move mymod.py mypkg\\mymod.py\nC:\\Python30> edit mypkg\\__init__.py\n...coded a print statement...\nC:\\Python30> python\n>>> import mypkg.mymod\ninitializing mypkg\n>>> mypkg.mymod.countLines('mypkg\\mymod.py')\n13\n>>> from mypkg.mymod import countChars\n>>> countChars('mypkg\\mymod.py')\n346",
    "6. Reloads. This exercise just asks you to experiment with changing the changer.py\nexample in the book, so there’s nothing to show here.\n7. Circular imports. The short story is that importing recur2 first works because the\nrecursive import then happens at the import in recur1, not at a from in recur2.\nThe long story goes like this: importing recur2 first works because the recursive\nimport from recur1 to recur2 fetches recur2 as a whole, instead of getting specific\nnames. recur2 is incomplete when it’s imported from recur1, but because it uses\nimport instead of from, you’re safe: Python finds and returns the already created\nrecur2 module object and continues to run the rest of recur1 without a glitch.\nWhen the recur2 import resumes, the second from finds the name Y in recur1 (it’s\nbeen run completely), so no error is reported. Running a file as a script is not the\nsame as importing it as a module; these cases are the same as running the first",
    "recur2 module object and continues to run the rest of recur1 without a glitch.\nWhen the recur2 import resumes, the second from finds the name Y in recur1 (it’s\nbeen run completely), so no error is reported. Running a file as a script is not the\nsame as importing it as a module; these cases are the same as running the first\nimport or from in the script interactively. For instance, running recur1 as a script\nis the same as importing recur2 interactively, as recur2 is the first module imported\nin recur1.",
    "Part VI, Classes and OOP\nSee “Test Your Knowledge: Part VI Exercises” on page 816 in Chapter 31 for the\nexercises.\n1. Inheritance. Here’s the solution code for this exercise (file adder.py), along with\nsome interactive tests. The __add__ overload has to appear only once, in the superclass, as it invokes type-specific add methods in subclasses:\nclass Adder:\ndef add(self, x, y):\n\n1122 | Appendix B: Solutions to End-of-Part Exercises\n\n\fprint('not implemented!')\ndef __init__(self, start=[]):\nself.data = start\ndef __add__(self, other):\nreturn self.add(self.data, other)\n\n# Or in subclasses?\n# Or return type?",
    "1122 | Appendix B: Solutions to End-of-Part Exercises\n\n\fprint('not implemented!')\ndef __init__(self, start=[]):\nself.data = start\ndef __add__(self, other):\nreturn self.add(self.data, other)\n\n# Or in subclasses?\n# Or return type?\n\nclass ListAdder(Adder):\ndef add(self, x, y):\nreturn x + y\nclass DictAdder(Adder):\ndef add(self, x, y):\nnew = {}\nfor k in x.keys(): new[k] = x[k]\nfor k in y.keys(): new[k] = y[k]\nreturn new\n% python\n>>> from adder import *\n>>> x = Adder()\n>>> x.add(1, 2)\nnot implemented!\n>>> x = ListAdder()\n>>> x.add([1], [2])\n[1, 2]\n>>> x = DictAdder()\n>>> x.add({1:1}, {2:2})\n{1: 1, 2: 2}\n>>> x = Adder([1])\n>>> x + [2]\nnot implemented!\n>>>\n>>> x = ListAdder([1])\n>>> x + [2]\n[1, 2]\n>>> [2] + x\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: __add__ nor __radd__ defined for these operands",
    "Notice in the last test that you get an error for expressions where a class instance\nappears on the right of a +; if you want to fix this, use __radd__ methods, as described in “Operator Overloading” in Chapter 29.\nIf you are saving a value in the instance anyhow, you might as well rewrite the\nadd method to take just one argument, in the spirit of other examples in this part\nof the book:\nclass Adder:\ndef __init__(self, start=[]):\nself.data = start\ndef __add__(self, other):\nreturn self.add(other)\ndef add(self, y):\n\n# Pass a single argument\n# The left side is in self\n\nPart VI, Classes and OOP | 1123\n\n\fprint('not implemented!')\nclass ListAdder(Adder):\ndef add(self, y):\nreturn self.data + y\nclass DictAdder(Adder):\ndef add(self, y):\npass\n\n# Change to use self.data instead of x\n\nx = ListAdder([1, 2, 3])\ny = x + [4, 5, 6]\nprint(y)\n\n# Prints [1, 2, 3, 4, 5, 6]",
    "Because values are attached to objects rather than passed around, this version is\narguably more object-oriented. And, once you’ve gotten to this point, you’ll probably find that you can get rid of add altogether and simply define type-specific\n__add__ methods in the two subclasses.\n2. Operator overloading. The solution code (file mylist.py) uses a few operator overloading methods that the text didn’t say much about, but they should be straightforward to understand. Copying the initial value in the constructor is important\nbecause it may be mutable; you don’t want to change or have a reference to an\nobject that’s possibly shared somewhere outside the class. The __getattr__ method\nroutes calls to the wrapped list. For hints on an easier way to code this in Python\n2.2 and later, see “Extending Types by Subclassing” on page 775 in Chapter 31:\nclass MyList:\ndef __init__(self, start):\n#self.wrapped = start[:]\n# Copy start: no side effects\nself.wrapped = []\n# Make sure it's a list here",
    "object that’s possibly shared somewhere outside the class. The __getattr__ method\nroutes calls to the wrapped list. For hints on an easier way to code this in Python\n2.2 and later, see “Extending Types by Subclassing” on page 775 in Chapter 31:\nclass MyList:\ndef __init__(self, start):\n#self.wrapped = start[:]\n# Copy start: no side effects\nself.wrapped = []\n# Make sure it's a list here\nfor x in start: self.wrapped.append(x)\ndef __add__(self, other):\nreturn MyList(self.wrapped + other)\ndef __mul__(self, time):\nreturn MyList(self.wrapped * time)\ndef __getitem__(self, offset):\nreturn self.wrapped[offset]\ndef __len__(self):\nreturn len(self.wrapped)\ndef __getslice__(self, low, high):\nreturn MyList(self.wrapped[low:high])\ndef append(self, node):\nself.wrapped.append(node)\ndef __getattr__(self, name):\n# Other methods: sort/reverse/etc\nreturn getattr(self.wrapped, name)\ndef __repr__(self):\nreturn repr(self.wrapped)\nif __name__ == '__main__':\nx = MyList('spam')\nprint(x)\nprint(x[2])\nprint(x[1:])",
    "1124 | Appendix B: Solutions to End-of-Part Exercises\n\n\fprint(x + ['eggs'])\nprint(x * 3)\nx.append('a')\nx.sort()\nfor c in x: print(c, end=' ')\n% python mylist.py\n['s', 'p', 'a', 'm']\na\n['p', 'a', 'm']\n['s', 'p', 'a', 'm', 'eggs']\n['s', 'p', 'a', 'm', 's', 'p', 'a', 'm', 's', 'p', 'a', 'm']\na a m p s",
    "Note that it’s important to copy the start value by appending instead of slicing here,\nbecause otherwise the result may not be a true list and so will not respond to\nexpected list methods, such as append (e.g., slicing a string returns another string,\nnot a list). You would be able to copy a MyList start value by slicing because its\nclass overloads the slicing operation and provides the expected list interface; however, you need to avoid slice-based copying for objects such as strings. Also, note\nthat sets are a built-in type in Python today, so this is largely just a coding exercise\n(see Chapter 5 for more on sets).\n3. Subclassing. My solution (mysub.py) appears below. Your solution should be\nsimilar:\nfrom mylist import MyList\nclass MyListSub(MyList):\ncalls = 0\n\n# Shared by instances\n\ndef __init__(self, start):\nself.adds = 0\nMyList.__init__(self, start)\n\n# Varies in each instance\n\ndef __add__(self, other):\nMyListSub.calls += 1\nself.adds += 1\nreturn MyList.__add__(self, other)",
    "# Shared by instances\n\ndef __init__(self, start):\nself.adds = 0\nMyList.__init__(self, start)\n\n# Varies in each instance\n\ndef __add__(self, other):\nMyListSub.calls += 1\nself.adds += 1\nreturn MyList.__add__(self, other)\n\n# Class-wide counter\n# Per-instance counts\n\ndef stats(self):\nreturn self.calls, self.adds\n\n# All adds, my adds\n\nif __name__ == '__main__':\nx = MyListSub('spam')\ny = MyListSub('foo')\nprint(x[2])\nprint(x[1:])\nprint(x + ['eggs'])\nprint(x + ['toast'])\nprint(y + ['bar'])\nprint(x.stats())\n% python mysub.py\n\nPart VI, Classes and OOP | 1125\n\n\fa\n['p', 'a', 'm']\n['s', 'p', 'a', 'm', 'eggs']\n['s', 'p', 'a', 'm', 'toast']\n['f', 'o', 'o', 'bar']\n(3, 2)",
    "4. Metaclass methods. I worked through this exercise as follows. Notice that in Python\n2.6, operators try to fetch attributes through __getattr__, too; you need to return\na value to make them work. Caveat: as noted in Chapter 30, __getattr__ is not\ncalled for built-in operations in Python 3.0, so the following expression won’t work\nas shown; in 3.0, a class like this must redefine __X__ operator overloading methods\nexplicitly. More on this in Chapters 30, 37, and 38.\n>>> class Meta:\n...\ndef __getattr__(self, name):\n...\nprint('get', name)\n...\ndef __setattr__(self, name, value):\n...\nprint('set', name, value)\n...\n>>> x = Meta()\n>>> x.append\nget append\n>>> x.spam = \"pork\"\nset spam pork\n>>>\n>>> x + 2\nget __coerce__\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: call of non-function\n>>>\n>>> x[1]\nget __getitem__\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: call of non-function\n>>> x[1:5]\nget __len__\nTraceback (innermost last):",
    "...\nprint('set', name, value)\n...\n>>> x = Meta()\n>>> x.append\nget append\n>>> x.spam = \"pork\"\nset spam pork\n>>>\n>>> x + 2\nget __coerce__\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: call of non-function\n>>>\n>>> x[1]\nget __getitem__\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: call of non-function\n>>> x[1:5]\nget __len__\nTraceback (innermost last):\nFile \"<stdin>\", line 1, in ?\nTypeError: call of non-function",
    "5. Set objects. Here’s the sort of interaction you should get. Comments explain which\nmethods are called:\n% python\n>>> from setwrapper import Set\n>>> x = Set([1, 2, 3, 4])\n>>> y = Set([3, 4, 5])\n>>> x & y\nSet:[3, 4]\n>>> x | y\n\n1126 | Appendix B: Solutions to End-of-Part Exercises\n\n# Runs __init__\n# __and__, intersect, then __repr__\n# __or__, union, then __repr__\n\n\fSet:[1, 2, 3, 4, 5]\n>>> z = Set(\"hello\")\n>>> z[0], z[-1]\n('h', 'o')\n\n# __init__ removes duplicates\n# __getitem__\n\n>>> for c in z: print(c, end=' ')\n...\nh e l o\n>>> len(z), z\n(4, Set:['h', 'e', 'l', 'o'])\n\n# __getitem__\n# __len__, __repr__\n\n>>> z & \"mello\", z | \"mello\"\n(Set:['e', 'l', 'o'], Set:['h', 'e', 'l', 'o', 'm'])",
    "# __getitem__\n# __len__, __repr__\n\n>>> z & \"mello\", z | \"mello\"\n(Set:['e', 'l', 'o'], Set:['h', 'e', 'l', 'o', 'm'])\n\nMy solution to the multiple-operand extension subclass looks like the following\nclass (file multiset.py). It only needs to replace two methods in the original set. The\nclass’s documentation string explains how it works:\nfrom setwrapper import Set\nclass MultiSet(Set):\n\"\"\"\nInherits all Set names, but extends intersect\nand union to support multiple operands; note\nthat \"self\" is still the first argument (stored\nin the *args argument now); also note that the\ninherited & and | operators call the new methods\nhere with 2 arguments, but processing more than\n2 requires a method call, not an expression:\n\"\"\"\ndef intersect(self, *others):\nres = []\nfor x in self:\nfor other in others:\nif x not in other: break\nelse:\nres.append(x)\nreturn Set(res)\ndef union(*args):\nres = []\nfor seq in args:\nfor x in seq:\nif not x in res:\nres.append(x)\nreturn Set(res)",
    "# Scan first sequence\n# For all other args\n# Item in each one?\n# No: break out of loop\n# Yes: add item to end\n# self is args[0]\n# For all args\n# For all nodes\n# Add new items to result\n\nYour interaction with the extension will look something like the following. Note\nthat you can intersect by using & or calling intersect, but you must call\nintersect for three or more operands; & is a binary (two-sided) operator. Also, note\nthat we could have called MultiSet simply Set to make this change more transparent if we used setwrapper.Set to refer to the original within multiset:\n\nPart VI, Classes and OOP | 1127\n\n\f>>> from multiset import *\n>>> x = MultiSet([1,2,3,4])\n>>> y = MultiSet([3,4,5])\n>>> z = MultiSet([0,1,2])\n>>> x & y, x | y\n(Set:[3, 4], Set:[1, 2, 3, 4, 5])\n\n# Two operands\n\n>>> x.intersect(y, z)\nSet:[]\n>>> x.union(y, z)\nSet:[1, 2, 3, 4, 5, 0]\n>>> x.intersect([1,2,3], [2,3,4], [1,2,3])\nSet:[2, 3]\n>>> x.union(range(10))\nSet:[1, 2, 3, 4, 0, 5, 6, 7, 8, 9]\n\n# Three operands",
    ">>> from multiset import *\n>>> x = MultiSet([1,2,3,4])\n>>> y = MultiSet([3,4,5])\n>>> z = MultiSet([0,1,2])\n>>> x & y, x | y\n(Set:[3, 4], Set:[1, 2, 3, 4, 5])\n\n# Two operands\n\n>>> x.intersect(y, z)\nSet:[]\n>>> x.union(y, z)\nSet:[1, 2, 3, 4, 5, 0]\n>>> x.intersect([1,2,3], [2,3,4], [1,2,3])\nSet:[2, 3]\n>>> x.union(range(10))\nSet:[1, 2, 3, 4, 0, 5, 6, 7, 8, 9]\n\n# Three operands\n\n# Four operands\n# Non-MultiSets work, too",
    "# Three operands\n\n# Four operands\n# Non-MultiSets work, too\n\n6. Class tree links. Here is the way I changed the lister classes, and a rerun of the test\nto show its format. Do the same for the dir-based version, and also do this when\nformatting class objects in the tree climber variant:\nclass ListInstance:\ndef __str__(self):\nreturn '<Instance of %s(%s), address %s:\\n%s>' % (\nself.__class__.__name__,\n# My class's name\nself.__supers(),\n# My class's own supers\nid(self),\n# My address\nself.__attrnames()) )\n# name=value list\ndef __attrnames(self):\n...unchanged...\ndef __supers(self):\nnames = []\nfor super in self.__class__.__bases__:\n# One level up from class\nnames.append(super.__name__)\n# name, not str(super)\nreturn ', '.join(names)\nC:\\misc> python testmixin.py\n<Instance of Sub(Super, ListInstance), address 7841200:\nname data1=spam\nname data2=eggs\nname data3=42\n>",
    "7. Composition. My solution is below (file lunch.py), with comments from the description mixed in with the code. This is one case where it’s probably easier to\nexpress a problem in Python than it is in English:\nclass Lunch:\ndef __init__(self):\n# Make/embed Customer, Employee\nself.cust = Customer()\nself.empl = Employee()\ndef order(self, foodName):\n# Start Customer order simulation\nself.cust.placeOrder(foodName, self.empl)\ndef result(self):\n# Ask the Customer about its Food\nself.cust.printFood()\n\n1128 | Appendix B: Solutions to End-of-Part Exercises\n\n\fclass Customer:\ndef __init__(self):\n# Initialize my food to None\nself.food = None\ndef placeOrder(self, foodName, employee):\n# Place order with Employee\nself.food = employee.takeOrder(foodName)\ndef printFood(self):\n# Print the name of my food\nprint(self.food.name)\nclass Employee:\ndef takeOrder(self, foodName):\nreturn Food(foodName)\n\n# Return Food, with desired name\n\nclass Food:\ndef __init__(self, name):\nself.name = name\n\n# Store food name",
    "# Return Food, with desired name\n\nclass Food:\ndef __init__(self, name):\nself.name = name\n\n# Store food name\n\nif __name__ == '__main__':\nx = Lunch()\nx.order('burritos')\nx.result()\nx.order('pizza')\nx.result()\n\n# Self-test code\n# If run, not imported\n\n% python lunch.py\nburritos\npizza\n\n8. Zoo animal hierarchy. Here is the way I coded the taxonomy in Python (file\nzoo.py); it’s artificial, but the general coding pattern applies to many real structures,\nfrom GUIs to employee databases. Notice that the self.speak reference in Animal\ntriggers an independent inheritance search, which finds speak in a subclass. Test\nthis interactively per the exercise description. Try extending this hierarchy with\nnew classes, and making instances of various classes in the tree:\nclass Animal:\ndef reply(self):\ndef speak(self):\n\nself.speak()\nprint('spam')\n\nclass Mammal(Animal):\ndef speak(self):\n\nprint('huh?')\n\nclass Cat(Mammal):\ndef speak(self):\n\nprint('meow')\n\nclass Dog(Mammal):\ndef speak(self):\n\nprint('bark')",
    "self.speak()\nprint('spam')\n\nclass Mammal(Animal):\ndef speak(self):\n\nprint('huh?')\n\nclass Cat(Mammal):\ndef speak(self):\n\nprint('meow')\n\nclass Dog(Mammal):\ndef speak(self):\n\nprint('bark')\n\n# Back to subclass\n# Custom message\n\nclass Primate(Mammal):\ndef speak(self):\nprint('Hello world!')\nclass Hacker(Primate): pass\n\n# Inherit from Primate\n\nPart VI, Classes and OOP | 1129",
    "# Back to subclass\n# Custom message\n\nclass Primate(Mammal):\ndef speak(self):\nprint('Hello world!')\nclass Hacker(Primate): pass\n\n# Inherit from Primate\n\nPart VI, Classes and OOP | 1129\n\n\f9. The Dead Parrot Sketch. Here’s how I implemented this one (file parrot.py). Notice\nhow the line method in the Actor superclass works: by accessing self attributes\ntwice, it sends Python back to the instance twice, and hence invokes two inheritance\nsearches—self.name and self.says() find information in the specific subclasses:\nclass Actor:\ndef line(self): print(self.name + ':', repr(self.says()))\nclass Customer(Actor):\nname = 'customer'\ndef says(self): return \"that's one ex-bird!\"\nclass Clerk(Actor):\nname = 'clerk'\ndef says(self): return \"no it isn't...\"\nclass Parrot(Actor):\nname = 'parrot'\ndef says(self): return None\nclass Scene:\ndef __init__(self):\nself.clerk\n= Clerk()\nself.customer = Customer()\nself.subject = Parrot()\ndef action(self):\nself.customer.line()\nself.clerk.line()\nself.subject.line()",
    "# Embed some instances\n# Scene is a composite\n\n# Delegate to embedded\n\nPart VII, Exceptions and Tools\nSee “Test Your Knowledge: Part VII Exercises” on page 891 in Chapter 35 for the\nexercises.\n1. try/except. My version of the oops function (file oops.py) follows. As for the\nnoncoding questions, changing oops to raise a KeyError instead of an IndexError\nmeans that the try handler won’t catch the exception (it “percolates” to the top\nlevel and triggers Python’s default error message). The names KeyError and Index\nError come from the outermost built-in names scope. Import builtins\n(__builtin__ in Python 2.6) and pass it as an argument to the dir function to see\nfor yourself:\ndef oops():\nraise IndexError()\ndef doomed():\ntry:\noops()\nexcept IndexError:\n\n1130 | Appendix B: Solutions to End-of-Part Exercises\n\n\fprint('caught an index error!')\nelse:\nprint('no error caught...')\nif __name__ == '__main__': doomed()\n% python oops.py\ncaught an index error!",
    "1130 | Appendix B: Solutions to End-of-Part Exercises\n\n\fprint('caught an index error!')\nelse:\nprint('no error caught...')\nif __name__ == '__main__': doomed()\n% python oops.py\ncaught an index error!\n\n2. Exception objects and lists. Here’s the way I extended this module for an exception\nof my own:\nclass MyError(Exception): pass\ndef oops():\nraise MyError('Spam!')\ndef doomed():\ntry:\noops()\nexcept IndexError:\nprint('caught an index error!')\nexcept MyError as data:\nprint('caught error:', MyError, data)\nelse:\nprint('no error caught...')\nif __name__ == '__main__':\ndoomed()\n% python oops.py\ncaught error: <class '__main__.MyError'> Spam!",
    "Like all class exceptions, the instance comes back as the extra data; the error message shows both the class (<...>) and its instance (Spam!). The instance must be\ninheriting both an __init__ and a __repr__ or __str__ from Python’s Exception\nclass, or it would print like the class does. See Chapter 34 for details on how this\nworks in built-in exception classes.\n3. Error handling. Here’s one way to solve this one (file safe2.py). I did my tests in a\nfile, rather than interactively, but the results are about the same.\nimport sys, traceback\ndef safe(entry, *args):\ntry:\nentry(*args)\n# Catch everything else\nexcept:\ntraceback.print_exc()\nprint('Got', sys.exc_info()[0], sys.exc_info()[1])\nimport oops\nsafe(oops.oops)\n% python safe2.py\n\nPart VII, Exceptions and Tools | 1131\n\n\fTraceback (innermost last):\nFile \"safe2.py\", line 5, in safe\nentry(*args)\nFile \"oops.py\", line 4, in oops\nraise MyError, 'world'\nhello: world\nGot hello world\n\n# Catch everything else",
    "4. Here are a few examples for you to study as time allows; for more, see follow-up\nbooks and the Web:\n# Find the largest Python source file in a single directory\nimport os, glob\ndirname = r'C:\\Python30\\Lib'\nallsizes = []\nallpy = glob.glob(dirname + os.sep + '*.py')\nfor filename in allpy:\nfilesize = os.path.getsize(filename)\nallsizes.append((filesize, filename))\nallsizes.sort()\nprint(allsizes[:2])\nprint(allsizes[-2:])\n# Find the largest Python source file in an entire directory tree\nimport sys, os, pprint\nif sys.platform[:3] == 'win':\ndirname = r'C:\\Python30\\Lib'\nelse:\ndirname = '/usr/lib/python'\nallsizes = []\nfor (thisDir, subsHere, filesHere) in os.walk(dirname):\nfor filename in filesHere:\nif filename.endswith('.py'):\nfullname = os.path.join(thisDir, filename)\nfullsize = os.path.getsize(fullname)\nallsizes.append((fullsize, fullname))\nallsizes.sort()\npprint.pprint(allsizes[:2])\npprint.pprint(allsizes[-2:])\n# Find the largest Python source file on the module import search path",
    "allsizes = []\nfor (thisDir, subsHere, filesHere) in os.walk(dirname):\nfor filename in filesHere:\nif filename.endswith('.py'):\nfullname = os.path.join(thisDir, filename)\nfullsize = os.path.getsize(fullname)\nallsizes.append((fullsize, fullname))\nallsizes.sort()\npprint.pprint(allsizes[:2])\npprint.pprint(allsizes[-2:])\n# Find the largest Python source file on the module import search path\nimport sys, os, pprint\nvisited = {}\nallsizes = []\nfor srcdir in sys.path:\nfor (thisDir, subsHere, filesHere) in os.walk(srcdir):\nthisDir = os.path.normpath(thisDir)",
    "1132 | Appendix B: Solutions to End-of-Part Exercises",
    "if thisDir.upper() in visited:\ncontinue\nelse:\nvisited[thisDir.upper()] = True\nfor filename in filesHere:\nif filename.endswith('.py'):\npypath = os.path.join(thisDir, filename)\ntry:\npysize = os.path.getsize(pypath)\nexcept:\nprint('skipping', pypath)\nallsizes.append((pysize, pypath))\nallsizes.sort()\npprint.pprint(allsizes[:3])\npprint.pprint(allsizes[-3:])\n# Sum columns in a text file separated by commas\nfilename = 'data.txt'\nsums = {}\nfor line in open(filename):\ncols = line.split(',')\nnums = [int(col) for col in cols]\nfor (ix, num) in enumerate(nums):\nsums[ix] = sums.get(ix, 0) + num\nfor key in sorted(sums):\nprint(key, '=', sums[key])\n# Similar to prior, but using lists instead of dictionaries for sums\nimport sys\nfilename = sys.argv[1]\nnumcols = int(sys.argv[2])\ntotals\n= [0] * numcols\nfor line in open(filename):\ncols = line.split(',')\nnums = [int(x) for x in cols]\ntotals = [(x + y) for (x, y) in zip(totals, nums)]\nprint(totals)\n# Test for regressions in the output of a set of scripts",
    "print(key, '=', sums[key])\n# Similar to prior, but using lists instead of dictionaries for sums\nimport sys\nfilename = sys.argv[1]\nnumcols = int(sys.argv[2])\ntotals\n= [0] * numcols\nfor line in open(filename):\ncols = line.split(',')\nnums = [int(x) for x in cols]\ntotals = [(x + y) for (x, y) in zip(totals, nums)]\nprint(totals)\n# Test for regressions in the output of a set of scripts\nimport os\ntestscripts = [dict(script='test1.py', args=''),\ndict(script='test2.py', args='spam')]",
    "# Or glob script/args dir\n\nfor testcase in testscripts:\n\nPart VII, Exceptions and Tools | 1133",
    "commandline = '%(script)s %(args)s' % testcase\noutput = os.popen(commandline).read()\nresult = testcase['script'] + '.result'\nif not os.path.exists(result):\nopen(result, 'w').write(output)\nprint('Created:', result)\nelse:\npriorresult = open(result).read()\nif output != priorresult:\nprint('FAILED:', testcase['script'])\nprint(output)\nelse:\nprint('Passed:', testcase['script'])\n# Build GUI with tkinter (Tkinter in 2.6) with buttons that change color and grow\nfrom tkinter import *\n# Use Tkinter in 2.6\nimport random\nfontsize = 25\ncolors = ['red', 'green', 'blue', 'yellow', 'orange', 'white', 'cyan', 'purple']\ndef reply(text):\nprint(text)\npopup = Toplevel()\ncolor = random.choice(colors)\nLabel(popup, text='Popup', bg='black', fg=color).pack()\nL.config(fg=color)\ndef timer():\nL.config(fg=random.choice(colors))\nwin.after(250, timer)\ndef grow():\nglobal fontsize\nfontsize += 5\nL.config(font=('arial', fontsize, 'italic'))\nwin.after(100, grow)\nwin = Tk()\nL = Label(win, text='Spam',",
    "def reply(text):\nprint(text)\npopup = Toplevel()\ncolor = random.choice(colors)\nLabel(popup, text='Popup', bg='black', fg=color).pack()\nL.config(fg=color)\ndef timer():\nL.config(fg=random.choice(colors))\nwin.after(250, timer)\ndef grow():\nglobal fontsize\nfontsize += 5\nL.config(font=('arial', fontsize, 'italic'))\nwin.after(100, grow)\nwin = Tk()\nL = Label(win, text='Spam',\nfont=('arial', fontsize, 'italic'), fg='yellow', bg='navy',\nrelief=RAISED)\nL.pack(side=TOP, expand=YES, fill=BOTH)\nButton(win, text='press', command=(lambda: reply('red'))).pack(side=BOTTOM,fill=X)\nButton(win, text='timer', command=timer).pack(side=BOTTOM, fill=X)\nButton(win, text='grow', command=grow).pack(side=BOTTOM, fill=X)\nwin.mainloop()\n# Similar to prior, but use classes so each window has own state information\nfrom tkinter import *\nimport random",
    "1134 | Appendix B: Solutions to End-of-Part Exercises",
    "class MyGui:\n\"\"\"\nA GUI with buttons that change color and make the label grow\n\"\"\"\ncolors = ['blue', 'green', 'orange', 'red', 'brown', 'yellow']\ndef __init__(self, parent, title='popup'):\nparent.title(title)\nself.growing = False\nself.fontsize = 10\nself.lab = Label(parent, text='Gui1', fg='white', bg='navy')\nself.lab.pack(expand=YES, fill=BOTH)\nButton(parent, text='Spam', command=self.reply).pack(side=LEFT)\nButton(parent, text='Grow', command=self.grow).pack(side=LEFT)\nButton(parent, text='Stop', command=self.stop).pack(side=LEFT)\ndef reply(self):\n\"change the button's color at random on Spam presses\"\nself.fontsize += 5\ncolor = random.choice(self.colors)\nself.lab.config(bg=color,\nfont=('courier', self.fontsize, 'bold italic'))\ndef grow(self):\n\"start making the label grow on Grow presses\"\nself.growing = True\nself.grower()\ndef grower(self):\nif self.growing:\nself.fontsize += 5\nself.lab.config(font=('courier', self.fontsize, 'bold'))\nself.lab.after(500, self.grower)\ndef stop(self):",
    "self.fontsize += 5\ncolor = random.choice(self.colors)\nself.lab.config(bg=color,\nfont=('courier', self.fontsize, 'bold italic'))\ndef grow(self):\n\"start making the label grow on Grow presses\"\nself.growing = True\nself.grower()\ndef grower(self):\nif self.growing:\nself.fontsize += 5\nself.lab.config(font=('courier', self.fontsize, 'bold'))\nself.lab.after(500, self.grower)\ndef stop(self):\n\"stop the button growing on Stop presses\"\nself.growing = False\nclass MySubGui(MyGui):\ncolors = ['black', 'purple']",
    "# Customize to change color choices\n\nMyGui(Tk(), 'main')\nMyGui(Toplevel())\nMySubGui(Toplevel())\nmainloop()\n# Email inbox scanning and maintenance utility\n\"\"\"\nscan pop email box, fetching just headers, allowing\ndeletions without downloading the complete message\n\"\"\"\nimport poplib, getpass, sys\n\nPart VII, Exceptions and Tools | 1135\n\n\fmailserver = 'your pop email server name here'\n# pop.rmi.net\nmailuser\n= 'your pop email user name here'\n# brian\nmailpasswd = getpass.getpass('Password for %s?' % mailserver)\nprint('Connecting...')\nserver = poplib.POP3(mailserver)\nserver.user(mailuser)\nserver.pass_(mailpasswd)\ntry:",
    "Part VII, Exceptions and Tools | 1135\n\n\fmailserver = 'your pop email server name here'\n# pop.rmi.net\nmailuser\n= 'your pop email user name here'\n# brian\nmailpasswd = getpass.getpass('Password for %s?' % mailserver)\nprint('Connecting...')\nserver = poplib.POP3(mailserver)\nserver.user(mailuser)\nserver.pass_(mailpasswd)\ntry:\n\nprint(server.getwelcome())\nmsgCount, mboxSize = server.stat()\nprint('There are', msgCount, 'mail messages, size ', mboxSize)\nmsginfo = server.list()\nprint(msginfo)\nfor i in range(msgCount):\nmsgnum = i+1\nmsgsize = msginfo[1][i].split()[1]\nresp, hdrlines, octets = server.top(msgnum, 0)\n# Get hdrs only\nprint('-'*80)\nprint('[%d: octets=%d, size=%s]' % (msgnum, octets, msgsize))\nfor line in hdrlines: print(line)\nif input('Print?') in ['y', 'Y']:\nfor line in server.retr(msgnum)[1]: print(line)\nif input('Delete?') in ['y', 'Y']:\nprint('deleting')\nserver.dele(msgnum)\nelse:\nprint('skipping')\n\nfinally:\nserver.quit()\ninput('Bye.')\n\n# Get whole msg\n# Delete on srvr",
    "finally:\nserver.quit()\ninput('Bye.')\n\n# Get whole msg\n# Delete on srvr\n\n# Make sure we unlock mbox\n# Keep window up on Windows\n\n# CGI server-side script to interact with a web browser\n#!/usr/bin/python\nimport cgi\nform = cgi.FieldStorage()\n# Parse form data\nprint(\"Content-type: text/html\\n\")\n# hdr plus blank line\nprint(\"<HTML>\")\nprint(\"<title>Reply Page</title>\")\n# HTML reply page\nprint(\"<BODY>\")\nif not 'user' in form:\nprint(\"<h1>Who are you?</h1>\")\nelse:\nprint(\"<h1>Hello <i>%s</i>!</h1>\" % cgi.escape(form['user'].value))\nprint(\"</BODY></HTML>\")\n# Database script to populate and query a MySql database\nfrom MySQLdb import Connect\n\n1136 | Appendix B: Solutions to End-of-Part Exercises",
    "1136 | Appendix B: Solutions to End-of-Part Exercises\n\n\fconn = Connect(host='localhost', user='root', passwd='darling')\ncurs = conn.cursor()\ntry:\ncurs.execute('drop database testpeopledb')\nexcept:\npass\n# Did not exist\ncurs.execute('create database testpeopledb')\ncurs.execute('use testpeopledb')\ncurs.execute('create table people (name char(30), job char(10), pay int(4))')\ncurs.execute('insert people values (%s, %s, %s)', ('Bob', 'dev', 50000))\ncurs.execute('insert people values (%s, %s, %s)', ('Sue', 'dev', 60000))\ncurs.execute('insert people values (%s, %s, %s)', ('Ann', 'mgr', 40000))\ncurs.execute('select * from people')\nfor row in curs.fetchall():\nprint(row)\ncurs.execute('select * from people where name = %s', ('Bob',))\nprint(curs.description)\ncolnames = [desc[0] for desc in curs.description]\nwhile True:\nprint('-' * 30)\nrow = curs.fetchone()\nif not row: break\nfor (name, value) in zip(colnames, row):\nprint('%s => %s' % (name, value))\nconn.commit()\n\n# Save inserted records",
    "# Save inserted records\n\n# Database script to populate a shelve with Python objects\n# see also Chapter 27 shelve and Chapter 30 pickle examples\nrec1 = {'name': {'first': 'Bob', 'last': 'Smith'},\n'job': ['dev', 'mgr'],\n'age': 40.5}\nrec2 = {'name': {'first': 'Sue', 'last': 'Jones'},\n'job': ['mgr'],\n'age': 35.0}\nimport shelve\ndb = shelve.open('dbfile')\ndb['bob'] = rec1\ndb['sue'] = rec2\ndb.close()\n# Database script to print and update shelve created in prior script\nimport shelve\ndb = shelve.open('dbfile')\n\nPart VII, Exceptions and Tools | 1137\n\n\ffor key in db:\nprint(key, '=>', db[key])\nbob = db['bob']\nbob['age'] += 1\ndb['bob'] = bob\ndb.close()\n\n1138 | Appendix B: Solutions to End-of-Part Exercises\n\n\fIndex",
    "1138 | Appendix B: Solutions to End-of-Part Exercises\n\n\fIndex\n\nSymbols\n= and == (equality operators), 244\n* (repetition) operator, 200\n@ symbol, 804\n\\ (backslash), 270, 318\n\\ (backslash) escape sequences, 85\n& (bitwise AND operator), 108\n| (bitwise or operator), 108\n^ (bitwise XOR operator), 108\n: (colon), 264, 387\n{ } (curly braces), 78, 108, 269\ndictionaries and, 90, 208\nset comprehensions and, 137\nsets and, 135, 221\n/ and // (division operators), 108, 110\n(see also division)\n\" (double quotes) and strings, 158\n... (ellipses), 330\n= and == (equality operators), 108, 151\n#! (hash bang), 46\n# (hash character), 43, 376\n>, >=, <, <= (magnitude comparison\noperators), 108\n– (minus operator), 108\n* (multiplication operator), 108\n( ) (parentheses), 265, 269, 318\nfunctions and, 389\ngenerator expressions and, 497\ntuples and, 96\n+ (plus operator), 108, 200\n\"\\u...\" and \"\\U...\" escapes, 910\n% (remainder operator), 108\n; (semicolon), 265, 269\n>> and << (shift operators), 108",
    "' (single quotes) and strings, 158\n[ ] (square brackets), 78, 108, 269\ndictionaries and, 209\nlist comprehensions and, 359, 486, 504\nlists and, 89, 199\n_ (underscore), 584\n__add__ method, 634\n__all__ variable, 584\n__bases__ attribute, 697, 699\n__bool__ method, 730\n__call__ method, 725\nfunction interfaces and, 727\n__class__ attribute, 697, 699\n__cmp__ method (Python 2.6), 729\n__contains__ method, 716\n__del__ method, 732\n__delattr__ method, 956\n__delete__ method, 950\n__dict__ attribute, 550\n__doc__ attribute, 377, 701\n__enter__ method, 854\n__eq__ method, 729\n__exit__ method, 854\n__get__ method, 706, 948\n__getattr__ method, 718, 814, 942, 956–973\ncomputed attributes, 961\ndelegation using, 745\ndelegation-based managers, 970\nexample, 959\ninterception of built-in attributes, 966\nloops, avoiding in interception methods,\n958\n__getattribute__, compared to, 962\n__getattribute__ method, 794, 942, 956–973\ncomputed attributes, 961",
    "We’d like to hear your suggestions for improving our indexes. Send email to index@oreilly.com.\n\n1139",
    "delegation-based managers, 970\nexample, 959\ninterception of built-in operation attributes,\n966\nloops, avoiding in attribute interception,\n958\n__getattr__, compared to, 962\n__getitem__ method, 708\nindex iteration, 710\nmembership, 716\n__gt__ method, 728\n__iadd__ method, 723\n__init__.py files, 563\n__init__ method, 634, 644, 706\n__iter__ method, 711\ndesign purpose, 713\nmembership, 716\n__len__ method, 730\n__lt__ method, 728\n__main__ attribute\n__name__ attribute of modules and, 585\n__main__ module, 409\n__metaclass__ variable (Python 2.6), 1063\n__name__ attribute, 585, 647\ncommand-line arguments with, 587\nunit tests, 586\n__ne__ method, 729\n__next__ method, 352, 711\n__radd__ method, 723\n__repr__ method, 721\ncustom exception display using, 867\n__set__ method, 706, 949\n__setattr__ method, 719, 942, 956\n__setitem__ method, 709\n__slots__ attribute, 767, 788\ndescriptors and, 956\n__dict__ attribute and, 1026\n__str__ method, 634, 721\ncustom exception display using, 867",
    "command-line arguments with, 587\nunit tests, 586\n__ne__ method, 729\n__next__ method, 352, 711\n__radd__ method, 723\n__repr__ method, 721\ncustom exception display using, 867\n__set__ method, 706, 949\n__setattr__ method, 719, 942, 956\n__setitem__ method, 709\n__slots__ attribute, 767, 788\ndescriptors and, 956\n__dict__ attribute and, 1026\n__str__ method, 634, 721\ncustom exception display using, 867\noverload method for printing objects, 652\n__sub__ method, 706",
    "A\nabs function, 125\nabsolute imports, 570\nabstract superclasses, 690–693\nexample, 742\nPython 2.6 and 3.0, 692\naccessor functions, 417\n1140 | Index",
    "ActivePython, 1090\nannotation information, 472\nanonymous functions, 474\nanydbm module (Python 2.6), 670\nappend method, 87, 203, 388\napply built-in (Python 2.6), 449\narbitrary arguments examples\napply built-in (Python 2.6), 449\napplying functions generically, 448\ncollecting arguments, 446\nunpacking arguments, 447\narguments, 435\nargument passing basics, 435–440\nmutable argument changes, avoiding,\n438\noutput parameters, simulating, 439\nshared references, 436\nargument-matching modes, 440–453\narbitrary arguments examples, 446–450\navailable modes, 441\ndefaults, 445\nkeyword-only arguments (Python 3.0),\n450\nkeywords, 444\nkeywords and defaults combined, 446\nmatching syntax, 442\nordering rules, 443\nemulating Python 3.0 print in earlier\nversions, 457\nkeyword-only arguments, 459\ngeneralized set functions, 456\nkeyword arguments, 460\nmin wakeup call, 453\nthree ways of coding, 454\nusing max instead of min, 455\nArithmeticError class, 865\nas extension for import and from, 591",
    "450\nkeywords, 444\nkeywords and defaults combined, 446\nmatching syntax, 442\nordering rules, 443\nemulating Python 3.0 print in earlier\nversions, 457\nkeyword-only arguments, 459\ngeneralized set functions, 456\nkeyword arguments, 460\nmin wakeup call, 453\nthree ways of coding, 454\nusing max instead of min, 455\nArithmeticError class, 865\nas extension for import and from, 591\nASCII character code, 897\ncoding ASCII text, 905\nassert statement, 691, 850\ntrapping constraints example, 851\nAssertionError exception, 850\nassignment\nimport, from, and def, 546\nmutables in, 388\nwithin function classes, 409\nassignment statements, 263, 279–291\nassignment statement forms, 280\naugmented assignments, 289",
    "sequence assignments, 281–284\nextended sequence unpacking in Python\n3.0, 284\nmultiple-target assignments, 288\nassociative arrays, 207\nas_integer_ratio method, 108\nattribute fetches, 173\nattribute interception methods, 1053\nattribute tree construction, 687\nattributes, 53, 531, 543, 644\nmanaged attributes (see managed attributes)\nautomatic memory management, 15",
    "B\nbase indicators, 107\nBaseException class, 864\nbasic numeric literals, 106\nbasic statement form, 280\nbeginners’ mistakes, 387\nbehavior methods, 648\nbinary files, 98, 233, 901\nbinary numeric literals, 107\nbinary-mode files, 920\nin Python 3.0, 921\nbit_length method (Python 3.1), 108\nblank lines, 314, 388\nblock delimiters, 315\nblocks, 314\nBOM (byte order marker), 901\nPython 3.0, handling in, 926–928\nbook update websites, xlv\nbool type, 248\nBoolean numeric type, 139\nBoolean object type, 100\nBoolean operators, 320–324\nBooleans in Python 2.6, 731\nbound methods, 728, 750\nother callable objects, compared to, 754\nbreak statement, 329, 331\nbsddb extension module, 672\nbuilt-in exception classes, 864–867\ncategories, 865\nclass hierarchy, 864\ndefault printing and state, 866\nbuilt-in mathematical functions, 108\nbuilt-in object types, 15, 75–78\nadditional core types, 99–103\ndictionaries, 90–96, 207–223\nfiles, 97, 229–239",
    "issues to be aware of, 251\nassignment creates references, 251\ncyclic data structures, 252\nimmutable types, 253\nrepetition adds one level deep, 252\nlists, 86–90, 197\nnumbers, 78\nobject classifications, 240\nsets, 99\nshared properties, 239\nstrings, 80–86\ntuples, 96, 225–229\ntype, 100\nbuilt-in scope, 412\nbuiltins module, 126, 412\nbyte code, 7\ncompilation, 26\nbyte order marker (see BOM)\nbytearray, 157\nobject type, using, 917–920\nbytearray string type, 899\nbytes, 157\nbytes object, 896\ndata encoding in, 901\nliterals, 908\nbytes string type, 85, 899",
    "C\nC code, 388\ncall expressions, 173\ncalls, 400, 403\ncharacter encoding schemes, 897\ncharacter set encoding declarations, 912\nchmod command, 46\nclass attribute descriptors, 1053\nclass decorators, 984, 990\ncoding, 1011\ndecorators versus manager functions,\n1018\nretaining multiple instances, 1016\nsingleton classes, 1011\ntracing object interfaces, 1013–1016\nimplementation, 990\njustification, 1019\nmetaclasses, compared to, 1056, 1073–\n1076, 1080\nprivate attributes, implementing, 1023–\n1026\n\nIndex | 1141",
    "public attributes, implementing, 1026–\n1030\nsupporting multiple instances, 992\nusage, 990\nclass methods, 686, 795, 800\ncounting instances, 802\ncounting per class, 803\njustification, 795\nusing, 799\nclass properties, 1053\nclass statement, 611, 681–684, 1061\nexample, 682–684\ngeneral form, 681\nclasses, 611, 614, 615, 619\nabstract superclasses, 690–693\nas attributes of modules, 631\nbuilt-in types, extending, 773–777\nembedding, 774\nsubclassing, 775–777\nclass decorators, 807\nclass hierarchies, 629\nclass instances, 626\nclass method calls, 616\nclass methods (see class methods)\nclass statements, 616\nclass trees, 613, 616–619\nclassic classes, 778\ncoding, 643–675\nbehavior methods, 648\nclass statement, 681–684\ncomposition, delegation, and\nembedding, 660\nconstructors, customizing, 658–663\ndatabases, storing objects in, 669–675\ndocstrings, 701\ninheritance, 687–693\nintrospection, 663–669\nmaking instances, 644–648\nmethods, 649, 684–686\nmodules, versus, 703\nnamespaces, 693–701",
    "class statements, 616\nclass trees, 613, 616–619\nclassic classes, 778\ncoding, 643–675\nbehavior methods, 648\nclass statement, 681–684\ncomposition, delegation, and\nembedding, 660\nconstructors, customizing, 658–663\ndatabases, storing objects in, 669–675\ndocstrings, 701\ninheritance, 687–693\nintrospection, 663–669\nmaking instances, 644–648\nmethods, 649, 684–686\nmodules, versus, 703\nnamespaces, 693–701\nOOP concepts embodied in, 660\noperator overloading, 651–653\nsubclassing, 653–658\ndependencies and function design, 464\ndictionaries, versus, 639\ndistinctions of, 612\nexception classes (see exception classes)\nframeworks, 621",
    "1142 | Index",
    "function decorators, 804–808\ngotchas, 808\nchanging class attributes, 808\nchanging mutable class attributes, 810\ndelegation-based classes (Python 3.0),\n814\nmethods, classes, and nested scopes\n(Python 2.2 and before), 812\nmultiple inheritance, 811\noverwrapping, 814\ninheritance, customization by, 629\ninstances, generation of, 625–629\ninterception of Python operators, 633–636\njustification, 612\nmetaclasses, 781, 794, 807\nas namespace objects, 638\nnaming conventions, 644\n“new-style” classes, 777–795\nchanges, 778–787\npersistence and, 744\nproperties of, 626\nsimplest class, 636–640\nstatic and class methods, 795\nsubclasses and superclasses, 614\nuser-defined classes, 101\nclassic division, 110, 117\nclassmethod function, 799\nclasstree function, 700\nclose method, 231\nclosure function, 420\ncode reuse\nmodules and, 530\nOOP and, 619–621\ncode reuse and code redundancy, 395\ncodecs.open call (Python 2.6), 912\ncohesion, 463\ncollections (see lists)\ncolon (:), 387\ncommand line (see interactive prompt)",
    "subclasses and superclasses, 614\nuser-defined classes, 101\nclassic division, 110, 117\nclassmethod function, 799\nclasstree function, 700\nclose method, 231\nclosure function, 420\ncode reuse\nmodules and, 530\nOOP and, 619–621\ncode reuse and code redundancy, 395\ncodecs.open call (Python 2.6), 912\ncohesion, 463\ncollections (see lists)\ncolon (:), 387\ncommand line (see interactive prompt)\ncommand-line arguments, 587\ncomments, 43, 314, 376\ncompanies using Python, 8\ncomparison methods, 728\ncomparison operators, 728\ncomparisons in Python 3.0, 204\ncompiled extensions, 7\ncomplex numbers, 107\ncomponent integration, 10\ncomposites, 661",
    "composition, 612, 740–745\nstream processing with, 742\ncompound statements, 264, 311\ngeneral pattern, 314\ncomprehension syntax, 507–509\nconcatenation, 81\nconstructor method, 634\n__init__, 644\nconstructors\ncoding, 644\ncustomizing, 658–663\ncontext managers, 854\nfile and server connection closure, 879\ncontinue statement, 329, 331\ncontrol flow statements, 314\nconversionflag, 185\ncopy module, nested data structures, copying\nwith, 244\ncopying versus referencing of objects, 241\ncore data types, 77, 648\ncount method and tuples, 228\ncoupling, 463\nCPython, 29\ncross-file module linking, 532\ncross-file name changes, 547\ncurly braces { }, 78, 269\ndictionaries and, 90, 208\nset comprehensions and, 137\nsets and, 135, 221\nCWD (current working directory), 576\ncyclic references, 147\nCygwin, 1090\nCython, 33",
    "D\ndata attributes, 682\ndata hiding in modules, 583\ndata structures, 76\ndatabase programming, 11\ndatabases, 676\nstoring objects in, 669–675\npickles and shelves, 670–675\ndbm module, 670\ndebuggers, 888\ndebugging, 67\nassert statement, 850\ntrapping constraints example, 851\nouter try statements, using for, 879\ndecimal module, 127",
    "decimal numeric literals, 107\ndecimal numeric type, 99, 127–129\ndecoding and encoding, 898\ndecorators, 983–995, 1053\ncall and instance management, 984\nclass decorators, 990–992\ncoding, 1011–1020\ndecorator arguments, 994\nversus function annotations, 1043\nfunction decorators, 986–990\ncoding, 996–1011\nfunctions and classes, managing, 984, 995,\n1021\nopen issues, 1030–1034\nprivate and public attributes, 1023\njustification, 985\nnesting, 993\ntype testing with, 1045\nusing and defining, 984\ndef statement, 407\ndefault exception handler, 827\ndefinitions, 400, 402\ndel statement, 87\ndelegation, 661, 720, 745\ndescriptor protocol, 942\ndescriptors, 947–956\ndescriptor methods, 948\nmethod arguments, 948\nread-only descriptors, 949\n__delete__ method, 950\n__get__ method, 948\n__set__ method, 949\n__slots__ implementation by, 956\ndesign patterns, 621\ndestructor method, 732\ndeveloper community, 12\ndevelopment tools, 886–890\nPython toolset hierarchy, 886\ndiamond pattern of multiple inheritance trees,\n783",
    "descriptor protocol, 942\ndescriptors, 947–956\ndescriptor methods, 948\nmethod arguments, 948\nread-only descriptors, 949\n__delete__ method, 950\n__get__ method, 948\n__set__ method, 949\n__slots__ implementation by, 956\ndesign patterns, 621\ndestructor method, 732\ndeveloper community, 12\ndevelopment tools, 886–890\nPython toolset hierarchy, 886\ndiamond pattern of multiple inheritance trees,\n783\ndictionaries, 207–223\nbasic operations, 209\nchanging in place, 210\nclasses, versus, 639\ncoding of, 208\ncommon literals and operations, 208\nitems method, 211\nlanguages table example, 212\npop method, 211",
    "Index | 1143",
    "Python 3.0 comparisons, 246\nPython 3.0, changes in, 217\ndictionary comprehensions, 218\ndictionary magnitude comparisons, 222\ndictionary views, 219\ndictionary views and sets, 221\nsorting dictionary keys, 222\nuse of in method instead of has_key,\n223\nupdate method, 211\nusage notes, 213\nmissing-key errors, avoiding, 214\nrecords, using as, 215\nsimulating flexible lists, 213\nsparse data structures, using for, 214\nvalues method, 211\nways of making dictionaries, 216\ndictionary comprehensions, 507\ndictionary object type, 90–96\nmapping operations, 90\nmissing keys and if tests, 95\nnesting, 91\nsorting keys and for loops, 93\ndictionary view iterators, 370\ndir function, 84, 376, 550, 698\nmix-in classes, listing inherited attributes of,\n761\ndirect or indirect recursion, 467\ndisutils, 540, 889\ndivision, 110, 117–121\nPython 2.6 and Python 3.0 compared, 114\ndocstr.py, 701\ndocstrings, 113, 314, 377, 701, 887\nbuilt-in docstrings, 379\ndocstring standards, 379\nuser-defined docstrings, 378\ndoctest, 887",
    "dictionary view iterators, 370\ndir function, 84, 376, 550, 698\nmix-in classes, listing inherited attributes of,\n761\ndirect or indirect recursion, 467\ndisutils, 540, 889\ndivision, 110, 117–121\nPython 2.6 and Python 3.0 compared, 114\ndocstr.py, 701\ndocstrings, 113, 314, 377, 701, 887\nbuilt-in docstrings, 379\ndocstring standards, 379\nuser-defined docstrings, 378\ndoctest, 887\ndocumentation, 375–387\ndir function, 376\ndocstrings (see docstrings)\nhash-mark comments, 376\nPyDoc, 380–385\nreference books, 387\nstandard manual set, 386\nweb resources, 387\nDOM parsing, 935\ndotted path, 562\ndouble quotes (\") and strings, 158\ndynamic typing, 15, 78, 143–147",
    "1144 | Index\n\ngarbage collection, 146\nobjects, 144\nversus variables, 145\npolymorphism and, 153\nreferences, 145\nshared references, 148–152\nvariables, 144",
    "E\nEaster egg, 5\nEBCDIC encoding, 907\nEclipse, 63\nElementTree package, 934\nelif (else if) clause, 96, 311\nellipses (...), 330\nelse clause, 96, 837\n(see also for statement; try statement; while\nstatement)\nEmacs, 65\nembedded calls, 64\nembedding contrasted with inheritance, 661\nempty strings, 155\nencapsulation, 620, 649\nencoding and decoding, 898\nencodings module, 898\nend-of-line characters, 921\nEnthought Python Distribution, 1090\nenumerate function, 348, 363\nenv program, 47\nequality, testing for, 244\nerror checking\nPython compared to C, 832\nerror handling, 826\netree package, 935\neval function, 235\nevent notification, 826\nexcept clause, 837\n(see also try statement)\nempty clauses, 838, 883\nException class, 865\nbuilt-in exceptions and system exit events,\n884\nexception classes, 857–870\nadvantages, 857\nbuilt-in exception classes, 864–867\ncategories, 865\ndefault printing and state, 866\nhierarchies, 864\ncoding, 859",
    "custom data and behavior, 868–870\nproviding exception details, 868\nproviding exception methods, 869\ncustom print displays, 867\ndefining handler methods, 869\nexception hierarchies, 859\njustification, 861–864\nexceptions, 825\nassert statement, 850\ntrapping constraints example, 851\ncatching built-in exceptions example, 841\ncatching exceptions, 828\nclass-based exceptions, 859\n(see also exception classes)\nfor closing files and server connections,\n878\ndefault behavior, 840\ndefault exception handlers, 827\ndesign tips and gotchas, 882–885\nhandler specificity and class-based\ncategories, 885\nlimiting handler generality, 883\nwrappers, 882\nexception handlers, 826\nnested exception handlers, 873–877\nin-process testing with, 880\njustification, 825\nnonerror exceptions, 877–878\nuser-defined exceptions, 878\npurposes, 826\nraise statement, 848–850\nraising exceptions, 829\nstring exceptions, deprecation of, 858\ntermination actions, 830\ntry statement (see try statement)\ntypical uses for, 877–882",
    "limiting handler generality, 883\nwrappers, 882\nexception handlers, 826\nnested exception handlers, 873–877\nin-process testing with, 880\njustification, 825\nnonerror exceptions, 877–878\nuser-defined exceptions, 878\npurposes, 826\nraise statement, 848–850\nraising exceptions, 829\nstring exceptions, deprecation of, 858\ntermination actions, 830\ntry statement (see try statement)\ntypical uses for, 877–882\nuser-defined exceptions, 830\nwith/as statement, 851–855\ncontext management protocol, 853\nusage, 852\nexec function, 57\nloading modules from a string, 594\nexec statement (Python 2.6), 263\nexecutable files\ncreating with Python, 32\nUnix path, defining in comment, 47\nexecutable scripts, 46\nexecution optimization tools, 30\nexercises, xliii",
    "Part I, 70\nPart II, 255\nPart III, 390\nPart IV, 524\nPart V, 605\nPart VI, 816\nPart VII, 891\nexpression operators, 108\ntable of, including precedence, 108\nversions 3.0 and 2.x differences, 110\nexpression statements, 295\nin-place changes, 296\nexpressions, 75, 108\nmixing operators, 111\nparentheses and, 111\nextend method, 205\nextended slicing, 167\nextensions in Python versions 2.6 and 3.0,\nxxxv",
    "F\nfactories, 768–769\njustification, 769\nfactoring of code, 649\nfactory design pattern, 768\nfactory functions, 420\nfalse and true values, 246\nfieldname, 185\nfile execution, 25\nfile icon clicks, 47–51\nlimitations, 50\nfile input/output, Python 3.0, 900\nfile iterators, 352\nfile object methods and printing operations,\n297\nfile object type, 97\nfiles, 225, 229–239\nadvanced file methods, 238\ncommon operations, 230\nexamples of usage, 232–238\nfile context managers, 238\npacked binary data, storing and parsing\nin files, 237\nstoring and parsing of Python objects,\n234\ntext and binary files, Python 3.0, 233\nfile iterators, 233\nmode string argument for opening, 901\nopening, 230\nIndex | 1145",
    "pickle, 236\nusing, 231\nfilter, 363\nfilter function, 481\nfilter iterator, 368\nfinally clause, 837, 842\n(see also try statement)\nfind method, 83\nfixed-precision floating-point values, 127\nfloating point numbers, 106\nfloor division, 110, 117\nflush method, 232\nfor loop\niterator, as an example of, 351\nline-by-line iteration with __next__\nmethod, 353\nversus while and range, 388\nfor statement, 327, 334–341\nexamples, 335\nextended sequence unpacking in, 338\nformat, 334\nnested for loops, 339\ntuple assignment in, 336\nformat function, 187\nformat method, 184, 185\nformats.py, 587\nformatspec, 186\nformatting, 83\nfraction number object type, 99\nFraction numeric type, 129–133\nconversions, 131\nframeworks, 621\nfreeze, 32\nfrom clause (raise statement), 849\nfrom statement, 52, 53, 545\nas assignment, 546\nequivalence to import, 548\nfrom imports and reload statement, 601\ninteractive testing, 602\nimport statement, versus, 56\nname copying without linking, 600\npitfalls, 548–549\ncorruption of namespaces, 548",
    "fraction number object type, 99\nFraction numeric type, 129–133\nconversions, 131\nframeworks, 621\nfreeze, 32\nfrom clause (raise statement), 849\nfrom statement, 52, 53, 545\nas assignment, 546\nequivalence to import, 548\nfrom imports and reload statement, 601\ninteractive testing, 602\nimport statement, versus, 56\nname copying without linking, 600\npitfalls, 548–549\ncorruption of namespaces, 548\nreload statement, when used with, 548\nwhen import is required, 549\nvariables and, 601\n_ (underscore) prefix and __all__ variable,\n584\nfrom __future__ statement, 571",
    "1146 | Index",
    "from_float method, 131\nfrozen binaries, 32, 65, 889\nfrozenset built-in call, 137\nfunction argument-matching forms, 442\nfunction attributes, 431\nfunction calls, 616\nfunction decorators, 804–808, 984, 986\nbasics, 804\ncoding, 996–1020\nadding arguments, 1008–1011\ndecorating class methods, 1001–1006\nstate information retention, 997–1001\ntiming calls, 1006–1008\ntracing calls, 996\nexample, 805\nfunction arguments, validating, 1034–1046\ngeneralizing for keywords and defaults,\n1037\nimplementation details, 1040\nopen issues, 1042\nrange-tester for positional arguments,\n1035\nimplementation, 987\nproperties of managed attributes, coding\nwith, 946\nsupporting method decoration, 989\nusage, 986\nfunction introspection, 1041\nfunctional programming, 481\nfunctions, 395–399\nattributes and annotations, 469–474\ncalls, 400, 403\ncoding, 396–399\ndefinitions, 400, 402\ndependencies and function design, 464\ndesign concepts, 463\nexample, definitions and calls, 400\nexample, intersecting sequences, 402–404",
    "properties of managed attributes, coding\nwith, 946\nsupporting method decoration, 989\nusage, 986\nfunction introspection, 1041\nfunctional programming, 481\nfunctions, 395–399\nattributes and annotations, 469–474\ncalls, 400, 403\ncoding, 396–399\ndefinitions, 400, 402\ndependencies and function design, 464\ndesign concepts, 463\nexample, definitions and calls, 400\nexample, intersecting sequences, 402–404\nlocal variables, 404\nfunction annotations (Python 3.0), 472\nfunction attributes, 471\nfunction instrospection, 470\nfunction related statements and\nexpressions, 395\nglobal statement (see global statement)\ngotchas, 518–522\ndefault arguments and mutable objects,\n520\nenclosing scope loop variables, 522",
    "functions without returns, 522\nstatic detection of local names, 518\nindirect function calls, 469\nlambda expression (see lambda expression)\nlocal scope, 408\nmapping over sequences, 479\nnonlocal statement (see nonlocal statement)\nparentheses and, 389\npolymorphism, 401, 403\npurpose of, 396\nrecursive functions, 465–469\narbitrary structures, handling, 468\ncoding alternatives, 466\nloop statements, versus, 467\nsummation, 465\nreturn statement (see return statement)\nsimple functions, 796\nyield statement (see yield statement)",
    "G\ngarbage collection, 92, 146\ngenerator expressions, 492, 497, 764\ngenerator functions, 492–506\nexamples, 494\ngenerator expressions, versus, 498\niteration protocol and, 493\niteration tools\ncoding a map(func, ...), 501\ncoding zip(...) and map(None, ...), 502\nemulating zip and map functions, 500–\n505\none-shot iterations, 505\nsend method and __next__, 496\nstate suspension, 493\nvalue generation in built-in types and\nclasses, 506\ngenerator objects, 348\ngenerators, 89, 499\nget method, 96\ngetrefcount function, 152\nglobal scope, 408\naccess without the global statement, 418\nglobal statement, 409, 414–418\nminimize cross-file changes, 416\nminimize global variables, 415\nGoogle’s Unladen Swallow project, 33\nGUIs (Graphical User Interfaces), 9, 675",
    "H\nhandlers, 828\n“has-a” relationships, 740\nhash bang (#!), 46\nhash character (#), 43\nhash tables, 208\nhash-mark comments, 376\nhashes, 207\nhas_key method (Python 2.x), 96\nhelp function, 84, 380, 887\nhelper functions, 1054\nhexadecimal numeric literals, 107\nhome directory, 536",
    "I\nIDEs, 63, 888\nIDLE (see IDLE user interface)\nIDLE user interface, 58–63\ngetting support on Linux, 1094\nIDLE debugger, 62\nsource code, creation and editing in, 60\nstartup in Windows and Unix-like systems,\n58\nusage and pitfalls, 60\nif clause, 89\nif statement, 96, 311–314\nexamples, 312\nformat, 311\nmultiway branching, 312\nif/else ternary expression, 321\nimmutability, 82\nimmutable objects, 253\nimplementation of shared services and data,\n530\nimplementation-related types, 77\nimport hooks, 540\nimport statement, 51, 532, 539, 544\n.py file extension and, 45\nas assignment, 546\ncross-file name changes, 547\nenabling new language features, 584\nfrom statement, equivalence to, 548\nfrom statement, versus, 56\nusage notes, 56\nimports, 533, 546\nin expressions, 313\nin membership expression, 95\nin-place addition, 725\n\nIndex | 1147",
    "in-place change operations, 388\nincremental prototyping, 645\nindentation, 266–269, 314, 388\nrules, 315\ntabs versus spaces, 317\nindex method, 206\nand tuples, 228\nindexing, 165, 166\nindexing expressions, 80\nindirect function calls, 469\ninfinite loops, 328\ninheritance, 612, 613, 629–632, 687–693\nabstract superclasses, 690–693\nattribute inheritance, key ideas of, 629\nattribute trees, 687\nclass interface techniques, 689\nreal-world relationships, modeling with,\n739\nsimplicity of inheritance model, 636\nspecializing inherited methods, 687\ninput function, 49\ninsert method, 87, 206\ninstalling Python, 23\ninstance methods, 800\ninstances, 614, 615, 625, 626, 643\nmaking instances, 644–648\ncoding constructors, 644\nincremental testing, 645\ntest code, 646\nas namespace objects, 638\nint, 169\nint function, 235\ninteger division, Python 2.6 versus 3.0, 115\nintegers, 106\nPython 3.0, 107\nintegrated development environments (see\nIDEs)\ninteractive loops, 271–276\nmath operations on user input, 272",
    "instance methods, 800\ninstances, 614, 615, 625, 626, 643\nmaking instances, 644–648\ncoding constructors, 644\nincremental testing, 645\ntest code, 646\nas namespace objects, 638\nint, 169\nint function, 235\ninteger division, Python 2.6 versus 3.0, 115\nintegers, 106\nPython 3.0, 107\nintegrated development environments (see\nIDEs)\ninteractive loops, 271–276\nmath operations on user input, 272\nnesting code three levels deep, 275\nsimple example, 271\ntesting inputs, 273\ntry statements, handling errors with, 274\ninteractive prompt, 35–41\nexiting a session, 37\nexperimenting with code, 38\nfiles, running from, 43\nmultiline statements, entering, 41\ntesting code, 39",
    "1148 | Index\n\ntips for using, 39\nInternet scripting, 10\ninterpreters, 23\nintrospection, 591\nintrospection attributes, 1053\nIronPython, 30, 1091\nis operator, 244\n“is-a” relationships, 739\nis_integer method, 108\nitems method, 211, 370\niter function, 354\niteration, 485\nbuilt-in tools for, 362\nmanual iteration, 354\niteration protocol, 94, 351, 352, 493\niterators, 351–358\nadditional built-in iterators, 356\nfile iterators, 352\nfilter, 368\ngenerator functions (see generator\nfunctions)\nmap, 368\nin Python 3.0, 366–371\nrange, 367\nsupport for multiple iterators, 369\nrange function, 342\ntiming iteration alternatives, 509–518\nother suggestions, 517\ntime module, 509\ntime module alternatives, 513\ntiming results, 511\ntiming script, 510\nzip, 368\niters.py, 712\n\nJ\nJIT (just-in-time) compilation, 31\njump tables, 476\nJython, xlv, 29, 1091\n\nK\nkeys, 93\nkeys method, 370\nkeyword arguments, 204, 460, 646\nkeyword-only arguments (Python 3.0), 450\njustification, 453\nordering rules, 452\nKomodo, 63",
    "L\nlambda expression, 474–479\nbasics, 474\ndefining inline callback functions in tkinter,\n479\njustification for, 475\nnested lambdas and scopes, 478\npotential for code obfuscation, 477\nlambdas and nested scopes, 422\nLatin-1 character encoding, 897\nLEGB rule, 410\nlen function, 80\nlexical scoping, 408\nLinux Python command line, starting, 36\nlist comprehension expressions, 88\nlist comprehensions, 351, 358–362, 485\nbasics, 359\nbest uses of, 490\nextended syntax, 361\nfiles, using on, 359\nmap function and, 491\nmap function, versus, 486\nmatrixes and, 489\ntests and nested loops, adding, 487\nlist object type, 86–90\nbounds checking, 87\nnesting, 88\ntype specific operations, 87\nlist-unpacking assignment statements, 280\nlister.py, 758\nListInstance class, 758–761\nlists, 197\nbasic operations, 200\nchanging in place, 202–207\ndeleting items or sections in place, 206\nindex and slice assignments, 202\nlist method calls, 203–206\ncoding of lists, 199\ncommon literals and operations, 198",
    "list object type, 86–90\nbounds checking, 87\nnesting, 88\ntype specific operations, 87\nlist-unpacking assignment statements, 280\nlister.py, 758\nListInstance class, 758–761\nlists, 197\nbasic operations, 200\nchanging in place, 202–207\ndeleting items or sections in place, 206\nindex and slice assignments, 202\nlist method calls, 203–206\ncoding of lists, 199\ncommon literals and operations, 198\nindexing, slicing, and matrixes, 201\niteration and comprehensions, 200\nliterals, 77\nlocal scope, 409\nlocal variables, 404\nlong integers (Python 2.6), 107\nloop else block, 329\nloop statement versus recursive functions, 467\nloops, 327–349",
    "break, continue, pass, and loop else clause,\n329\ncoding techniques, 341–349\ncounter loops with while and range, 342\nfor statement, 334–341\ngeneral format, 329\ngeneration of offsets and items, 348\ninteractive loops (see interactive loops)\nloop else clause, 332\nnonexhaustive traversals with range and\nslices, 343\nparallel traversals with zip and map, 345\nrange function\nlists, changing with, 344\nwhile statement, 327",
    "M\nMac OS X Python command line, starting, 36\nmakedb.py, 671\nmanaged attributes, 941–947\nattribute validations example, 973–979\ndescriptors validation, 975\nproperties validation, 973\n__getattribute__, validation with, 978\n__getattr__, validation with, 977\ncoding to run on attribute access, 942\ncomparison of management techniques,\n963\ndescriptors, 947–956\ncomputed attributes, 952\ndescriptor methods, 948\nexample, 950\nmethod arguments, 948\nproperties, relation to, 955\nread-only descriptors, 949\nstate information, using in, 953\njustification, 941–943\nproperties, 943–947\ncomputed attributes, 945\ndecorators, coding with, 946\nfirst example, 944\nnew-style object derivation requirement,\n944\n__getattr__ and __getattribute__, 956–973\navoiding loops, 958\ncomparison, 962\ncomputed attributes, 961\ndelegation, 958\nexample, 959\nIndex | 1149",
    "interception of built-in attributes, 966–\n973\nManager class, 643, 653\nmanager functions, 1054\nmanual iteration, 354\nmanynames.py, 694\nmap function, 201, 346, 479\nlambda expressions and, 480\nlist comprehensions and, 491\nlist comprehensions, versus, 486\nmap iterator, 368\nmatching algorithm, 1042\nmath module, 79\nexample functions, 125\nmathematical functions, 108\nmax and min functions, 364\nmergdexc.py, 846\nmetaclass model, 1058–1062, 1058\n(see also metaclasses)\nclass statement protocol, 1061\nclasses are instances of type, 1058\nmetaclasses are subclasses of type, 1061\nmetaclasses, 781, 794, 807, 1051–1056, 1058\n(see also metaclass model)\nadding methods to classes example, 1070–\n1076\nmanual augmentation, 1070\nmetaclass-based augmentation, 1071\napplying decorators to methods example,\n1076–1083\nmanual tracing, 1076\ntracing with metaclasses and decorators,\n1077\nwith any decorators, 1079\nclass decorators, compared to, 1073–1076,\n1080\ndecorator-based augmentation, 1073",
    "(see also metaclass model)\nadding methods to classes example, 1070–\n1076\nmanual augmentation, 1070\nmetaclass-based augmentation, 1071\napplying decorators to methods example,\n1076–1083\nmanual tracing, 1076\ntracing with metaclasses and decorators,\n1077\nwith any decorators, 1079\nclass decorators, compared to, 1073–1076,\n1080\ndecorator-based augmentation, 1073\nmanaging instances instead of classes,\n1074\nclass decorators, compared with, 1056\ncoding, 1063–1069\nbasic metaclass, 1064\ncustomizing construction and\ninitialization, 1065\nfactory functions, using, 1066\ninstances versus inheritance, 1068\noverloading class creation calls with\nclasses, 1067",
    "1150 | Index",
    "overloading class creation calls with\nmetaclasses, 1066\ndeclaration, 1062\nissues around use, 1052\npotential roles, 1052\nmetafunctions, 804\nmetaprograms, 591–594\nmethod call expression, 173\nmethods, 82, 84, 203, 638, 650, 684–686\naugmenting methods, 654\nbound and unbound methods, 750–756\nbound methods, 728\ncalls to methods, 685–686\nclass methods, 686\ncoding methods, 649\ncomparison methods, 728\ndestructor method, 732\nexample, 685\nstatic methods, 686, 795\n(see also static methods)\nsuperclass constructors, calling, 686\nmin and max functions, 125\nmins.py, 454\nmix-in classes, 757\ncoding, 757–767\ninstance attributes, listing, 758\nlisting inherited attributes, 761\nlisting object attributes in class trees,\n763\nmodule packages, 561\npackage imports, 561–569\nimport example, 564–566\njustification, 566–569\npackages and search path settings, 562\n__inti__.py, 563\npackage relative imports (see package\nrelative imports)\nmodules, 42, 51, 75, 529\nas extension for import and from, 591",
    "coding, 757–767\ninstance attributes, listing, 758\nlisting inherited attributes, 761\nlisting object attributes in class trees,\n763\nmodule packages, 561\npackage imports, 561–569\nimport example, 564–566\njustification, 566–569\npackages and search path settings, 562\n__inti__.py, 563\npackage relative imports (see package\nrelative imports)\nmodules, 42, 51, 75, 529\nas extension for import and from, 591\nattributes, 53, 531, 543\nclasses, as attributes of, 631\nclasses, versus, 703\ncreating, 543\ndata hiding in, 583\ndesign concepts, 598\nexec, running module files with, 57\nfrom statement, 545\nfuture language features, enabling, 584\nglobal scope, 408",
    "gotchas, 599–604\nfrom imports and reload, 601\nfrom statement, 600\nfrom statement and variables, 601\nrecursive import failures, 603\nstatement order in top-level code, 599\nimport statement, 544\nimporting\nbyte code compilation if required, 534\nrunning, 535\nimporting by name string, 594\nimporting of modules, 533–535\nlocating, 534\nimports and reloads, 51–57\nmetaprograms, 591–594\nmixed-usage modes, 585–589\nmodule extensions, 544\nmodule namespaces, 550–554\nattribute name qualification, 552\ngeneration from files, 550\nimports versus scopes, 552\nnamespace nesting, 553\nmodule search path, 56, 534, 535–541\nadvanced module selection concepts,\n540\nmodule file selection, 539\nsearch path configuration, 537\nsearch path variations, 538\nsys.path list, 538\nthird-party extensions, 540\nmodule search path, changing, 590\nnamespaces, 55, 529\nnaming conventions, 644\nnaming of, 543\nprogram structure and, 530\nreloading modules, 554–558\nexample, 556\nroles of, 530\nscope, 550\nstandard library, 533",
    "advanced module selection concepts,\n540\nmodule file selection, 539\nsearch path configuration, 537\nsearch path variations, 538\nsys.path list, 538\nthird-party extensions, 540\nmodule search path, changing, 590\nnamespaces, 55, 529\nnaming conventions, 644\nnaming of, 543\nprogram structure and, 530\nreloading modules, 554–558\nexample, 556\nroles of, 530\nscope, 550\nstandard library, 533\ntransitive module reloads, 595–598\n__name__ attribute, 585–589\ncommand-line arguments with, 587\nunit tests, 586\nMonty Python’s Flying Circus, 17\nmultiline statements, 317\nmultiple inheritance, 617, 756–767\ndiamond pattern inheritance trees, 783\nmix-in classes (see mix-in classes)",
    "multiway branching, 312\nmutable objects, 197, 649\nmutables\nin assignments, 388\nmybooks.xml, 934\nmydir.py, 592\nmyfile.py, 53",
    "N\nname attribute, 102\nname mangling, 747–750\nnamespace objects, 646\nnamespaces, 53, 55, 407, 529, 615, 693–701\nattribute names, 693\nname assignment, 694–696\nnamespace dictionaries, 696–699\nnamespace links, 699\nsimple names, 693\nnegative offsets, 165\nnested scopes, 419–425\nabitrary nesting, 424\nexamples, 419\nfactory functions, 420\nlambdas and, 422\nnester.py, 812\n.NET and IronPython, 30\nNetBeans, 63\n“new-style” classes, 777–794\nchanges, 778–787\nclass extensions, 788–795\nclass properties, 792–794\ninstance slots, 788–791\nmetaclasses, 794\nmultiple __slot__ lists in superclasses,\n790\nslots and generic code, 788\n__getattribute__ method, 794\ndiamond inheritance change, 783–787\nexample, 784\nexplicit conflict resolution, 785\nscope of search order, 787\ntype model changes, 779–783\nobject type objects, 782\ntype testing implications, 781\nnext function, 354\n__next__ method, 352\nnon-ASCII text, coding, encoding and\ndecoding, 905–906\nNone object, 247\nIndex | 1151",
    "nonlocal statement, 409, 425–432\nabsence from Python 2.6, 263\nbasics, 425\nexamples, 426\nboundary cases, 428\njustification for, 429–432\nPython 2.6 alternatives, 429\nnormal integers (Python 2.6), 107\nnumber object type, 78\nnumber operations, 113–127\nbitwise operations, 124\ncomparisons, 116\nchained comparisons, 116\ncomplex numbers, 122\ndivision, 117–121\ninteger precision, 121\nmath module functions, 125\nnotation, hexadecimal, octal, and binary,\n122\nnumeric display formats, 115\nvariables and basic expressions, 113–115\nnumeric display formats, 115\nnumeric extensions, 140\nnumeric object type, 105–108\nbuilt-in numeric tools, 108\ncomplexity ranking, 112\nexpression operators and precedence, 108\nnumeric literals, 106\noperator overloading and polymorphism,\n112\nsome noncore types, 127–140\nBooleans, 139\ndecimal type, 127–129\nfraction types, 129–133\nsets, 133–139\nnumeric precision, setting globally, 128\nnumeric programming, 11\nNumPy numeric programming extension, 7,\n11, 140",
    "O\nobject embedding, 661\nobject persistence, 669\nobject type categories, 193\nmutable versus immutable types, 194\nshared operation sets, 194\nobject types, 102\nbuilt-in object types (see built-in object\ntypes)\n1152 | Index",
    "object-oriented programming, 13\nobject-oriented scripting language, 5\nobject.attr expression, 687\nobject.attribute expression, 613\nobject.attribute notation, 532\nobjects, 75, 105, 145\ncomparisons, equality, and truth, 244\ncompound object types, 241\ncopying versus referencing, 150\ndatabases, storing objects in, 669\ndynamic typing and, 144\niterable objects, 352\nnonbuilt-in object types, 250\nobject classifications for built-in types, 240\nreferences versus copies, 241\ntruth and falsity, 246\nbool type, 248\nNone object, 247\ntype hierarchies, 248\ntype object type, 250\noctal numeric literals, 107\nOOP (object-oriented programming), 613–\n621\nas exemplified by coding of classes, 658\nattribute inheritance search, 613\nclass method calls, 616\nclasses, 614, 615, 625\nclass trees, 616–619\ncustomization by inheritance, 629–632\ncode reuse, 619–621\ndesign issues, 737\nbound and unbound methods, 750–756\ncomposition, 740–745\ndelegation and wrapper classes, 745\ngeneric object factories, 768\ninheritance, 739",
    "621\nas exemplified by coding of classes, 658\nattribute inheritance search, 613\nclass method calls, 616\nclasses, 614, 615, 625\nclass trees, 616–619\ncustomization by inheritance, 629–632\ncode reuse, 619–621\ndesign issues, 737\nbound and unbound methods, 750–756\ncomposition, 740–745\ndelegation and wrapper classes, 745\ngeneric object factories, 768\ninheritance, 739\nmultiple inheritance, 756–767\npolymorphism, 738\npseudoprivate class attributes, 747–750\ndesign patterns, 621\nimportant concepts, 660\ninstances, 614, 615, 625\nobject.attribute expression, 613\nopen call, (Python 2.6), 912\nopen function, 97, 99, 230\nmode string argument, 901\noperator overloading, 240, 613, 633–636, 651–\n653, 652, 705–733\nattribute references, 718–720",
    "attribute privacy, 720\nBoolean tests, 730\ncall expressions, 725–728\nfunction interfaces, 727\ncommon operator overloading methods,\n706\ncomparisons, 728\nconstructors and expressions, 706\nindex iteration, 710\nindexing and slicing, 708–710\nPython 2.6, 709\niterator objects, 711\nmultiple iterators on one object, 714\nuser defined iterators, 712\njustification, 636\nmembership, 716\ncomparisons, Python 2.6, 716\nobject destruction, 732\noverloading methods, 1053\noverloading methods in Python 2.6, 747\noverview, 705–707\nright-side and in-place addition, 723–725\nstring representation, 721–723\noperator precedence, 111\noptimization, 889\nORMs (object-relational mappers), 676\nOverflowError class, 865",
    "P\npackage imports, 561\njustification, 566–569\nimport versus from, 569\nroot directory, 568\npackages and search path settings, 562\npackage relative imports, 569–581\nabsolute package paths, versus, 573\nbasics, 570\nexamples, 575–581\nimports outside packages, 575\nimports relative to CWD, 577\nimports still relative to CWD, 579\nimports within packages, 576\nmodules, selecting with relative and\nabsolute imports, 578\njustification, 572\nmodule lookup rules summary, 575\nPython 3.0, 572\nchanges, 570\nversus 2.6, 570",
    "scope, 574\npackages, 561\nparallel traversals, 345\nparentheses ( ), 265, 269, 318\nfunctions and, 389\ngenerator expressions and, 497\ntuples and, 96\nParrot project, 33\nparsing, 165\npass statement, 329, 330\nPATH environment variable, 36, 1093\npattern matching, 85\npdb debugger, 889\nPEP (Python Enhancement Proposal) protocol,\n12\nPerson class, 644\nincremental testing, 645\nsubclassing, 653\nversion portability, 647\nperson.py, 644\nPeters, Tim, 1052\npickle module, 236, 670, 744\nbinary data requirement, 933\nstring serialization (Python 3.0), 932\npizzashop.py, 741\npolymorphism, 82, 101, 113, 401, 403, 620\ndynamic typing and, 153\nexample, 656\noverloading in Python versus other\nlanguages, 738\npop method, 87, 205, 211\nportability, 14\nPortable Python, 1090\npow function, 125\nprecedence\nparentheses and, 111\nprecedence rules, 111\nprint function, 263\nprint operations, 297–307\nprint and stdout, 307\nprint function (Python 3.0), 298\nprint statement (Python 2.6), 300\nprint stream redirection, 302",
    "dynamic typing and, 153\nexample, 656\noverloading in Python versus other\nlanguages, 738\npop method, 87, 205, 211\nportability, 14\nPortable Python, 1090\npow function, 125\nprecedence\nparentheses and, 111\nprecedence rules, 111\nprint function, 263\nprint operations, 297–307\nprint and stdout, 307\nprint function (Python 3.0), 298\nprint statement (Python 2.6), 300\nprint stream redirection, 302\nversion-neutral printing, 306\nprint statement (Python 2.6), 263\nprocedure, 396\nprofile module, 517, 888\nprofilers, 888\nprogram execution, 24–28",
    "Index | 1153",
    "development implications, 28\nPython compared to other languages, 27\nprogram portability, 4\nprogram shipping options, 889\nprogram structure, imports, 531\nprogram units, 77\nprograms, 5, 42, 75\nicons, opening with, 47\nlaunching, 35\nadditional launch options, 64\nchoosing a launch option, 66\nclicking file icons, 47\nexec function, 57\nfrom the command line, 43\nIDLE user interface, 58\ninput function, 49\nmodule imports and reloads, 51, 56\nUnix executable scripts, 46\nWindows automatic file extensions, 44\nrunning interactively, 35–41\nexperimentation, 38\ntesting, 39\nsaving in files, 41\nstructure, 261, 530–533\nWindows, saving under, 45\nproperty built-in function, 942\ncomputed attributes, 945\ndecorators, 946\nfirst example, 944\nproxy classes, 745\npseudoprivate attributes, justification, 748\npseudoprivate names, 747\nPSF (Python Software Foundation), 13\nPsyco just-in-time compiler, 30, 889\n.pth file extension, 1096\n.pth path file directories, 537\nPVM (Python Virtual Machine), 27",
    "structure, 261, 530–533\nWindows, saving under, 45\nproperty built-in function, 942\ncomputed attributes, 945\ndecorators, 946\nfirst example, 944\nproxy classes, 745\npseudoprivate attributes, justification, 748\npseudoprivate names, 747\nPSF (Python Software Foundation), 13\nPsyco just-in-time compiler, 30, 889\n.pth file extension, 1096\n.pth path file directories, 537\nPVM (Python Virtual Machine), 27\n.py file extension, 25, 43, 543\npy2exe, 32, 889\n.pyc file extension, 26, 534\nPyChecker, PyLint, and PyUnit, 887\nPyDev, 63\nPyDoc, 84, 380–385, 887\nhelp function, 380\nHTML reports, 383\nPyInstaller, 32, 889\nPyPy project, 33\nPython\ncommand-line options, 1097–1098",
    "1154 | Index",
    "configuration, 1093\nDOS variables in autoexec.bat, 1095\nenvironment variables, 1093\npath files, 1096\nsetting configuration options, 1095\nUnix/Linux shell variables, 1095\nWindows environment variable GUI,\n1095\nWindows registry, 1096\ninstalling, 23\nPython 2.0\nstring module, 178\nPython 2.6, xxxii\nbackward compatibility to older versions,\nxxxii\nbinary and Unicode strings, handling of,\n895\nBooleans, 731\niteration method X.next( ), 356\nnonlocal statement, alternatives to in, 429\noperator overloading methods, 747\nPython 3.0 print function, emulating, 457\nusing keyword-only arguments, 459\nraw_input function, 50\nreload function, 53\nstring object types, 157\nunicode and str operation sets, 911\n“new-style” and “classic” classes, 777\nPython 3.0, xxxii\nbuilt-in attributes, 662\ncompared 2.x versions, xxxv\ncomparisons and sorts, 204\ndictionary changes, 217\ndictionary comparisons, 246\nextended sequence unpacking, 281, 284\nin for loops, 338\nfunction annotations, 472",
    "raw_input function, 50\nreload function, 53\nstring object types, 157\nunicode and str operation sets, 911\n“new-style” and “classic” classes, 777\nPython 3.0, xxxii\nbuilt-in attributes, 662\ncompared 2.x versions, xxxv\ncomparisons and sorts, 204\ndictionary changes, 217\ndictionary comparisons, 246\nextended sequence unpacking, 281, 284\nin for loops, 338\nfunction annotations, 472\nincompatibility with older versions, xxxii\ninput function, 50\nnew iterables, 366–371\n“new-style” classes, 777\nolder version tools removed from, xxxvi\nspecial character coding, 908\nstring object types, 157\nstring type, changes in, 896\ntext and binary files, 233\nUnicode and binary data support, 895\nunsupported raise syntax, 850\nPython interpreter, 23",
    "installing, 1089\non Linux, 1091\non PDAs, 1092\non Unix, 1091\non Windows, 1091\non Windows Vista, 1092\nwebsite downloads link, 1090\nPython programming language, xxxi\nadvantages of, 3–5\ncommon coding gotchas, 387\ncompared to other languages, 17\ndeveloper productivity and, 5\ndevelopment tools, 886\ndocumentation (see documentation)\nexecution speed, 7\niteration protocol, 493\nmanuals and resources, 1098\nold and new versions, xxxii\nPerl, compared to, 20\nportability, 14\nprimary implementations of, 29\nso-called “optional” features, 1082\nstatically-typed languages, compared to,\n401\nstring model, 897–902\nsupport, 12\ntechnical strengths, 13–17\nuser base, 7\nuses for, 9–12\nPYTHONPATH, 1094\nPYTHONPATH directories, 536\nPYTHONSTARTUP, 1094\nPythonWin, 63, 1090\nPyWin32, 1090",
    "Q\nquizzes, xliii\nChapter 1: A Python Q&A Session, 19\nChapter 2: How Python Runs Programs,\n34\nChapter 3: How You Run Programs, 68\nChapter 4: Introducing Python Object\nTypes, 103\nChapter 5: Numeric Types, 141\nChapter 6: The Dynamic Typing Interlude,\n153\nChapter 7: Strings, 195\nChapter 8: Lists and Dictionaries, 223",
    "Chapter 9: Tuples, Files, and Everything\nElse, 253\nChapter 10: Introducing Python Statements,\n276\nChapter 11: Assignments, Expressions, and\nPrints, 308\nChapter 12: if Tests and Syntax Rules, 324\nChapter 13: while and for Loops, 349\nChapter 14: Iterations and\nComprehensions, Part 1, 372\nChapter 15: The Documentation Interlude,\n389\nChapter 16: Function Basics, 405\nChapter 17: Scopes, 432\nChapter 18: Arguments, 461\nChapter 19: Advanced Function Topics,\n483\nChapter 20: Iterations and\nComprehensions, Part 2, 523\nChapter 21: Modules, the Big Picture, 541\nChapter 22: Module Coding Basics, 558\nChapter 23: Module Packages, 582\nChapter 24: Advanced Module Topics, 604\nChapter 25: OOP: The Big Picture, 622\nChapter 26: Class Coding Basics, 641\nChapter 27: A More Realistic Example,\n677\nChapter 28: Class Coding Details, 703\nChapter 29: Operator Overloading, 734\nChapter 30: Designing with Classes, 770\nChapter 31: Advanced Class Topics, 815\nChapter 32: Exception Basics, 833",
    "Chapter 23: Module Packages, 582\nChapter 24: Advanced Module Topics, 604\nChapter 25: OOP: The Big Picture, 622\nChapter 26: Class Coding Basics, 641\nChapter 27: A More Realistic Example,\n677\nChapter 28: Class Coding Details, 703\nChapter 29: Operator Overloading, 734\nChapter 30: Designing with Classes, 770\nChapter 31: Advanced Class Topics, 815\nChapter 32: Exception Basics, 833\nChapter 33: Exception Coding Details, 856\nChapter 34: Exception Objects, 870\nChapter 35: Designing with Exceptions,\n891\nChapter 36: Unicode and Byte Strings, 937\nChapter 37: Managed Attributes, 979\nChapter 38: Decorators, 1047\nChapter 39: Metaclasses, 1084\nquotes\nescaping, 158\nstrings and, 158\ntriple quotes, 162",
    "R\nraise statement, 829, 848–850\nfrom clause Python 3.0 exception chaining,\n849\nIndex | 1155",
    "nonerror conditions, signaling with, 878\nrandom module, 79, 127\nrange\nversus for loops, 388\nrange function, 342\nrange iterator, 367\nsupport for multiple iterators, 369\nrapid prototyping, 11\nrational number objects, 129\nraw string literals, 85\nraw strings, 161\nraw_input function (Python 2.x), 50\nre (regular expression) module, 85\nstring handling in Python 3.0, 929\nread method, 233\nreadline method, 98, 232\nrecursive functions, 465–469\narbitrary structures, handling, 468\ncoding alternatives, 466\ndirect or indirect, 467\nloop statements, versus, 467\nsummation, 465\nrecursive imports, 603\nreduce, 363\nreduce function, 481\nreference counters, 147\nreferences, 145\ncopies of objects, versus, 241\nshared references, 148–152\nequality, 151\nin-place changes, 149\nrelative imports, 561\nreload function, 52, 554–558\nexample, 556\nfrom imports and, 601\ninteractive testing, 602\nimport and from, contrasted with, 555\ntransitive module reloads, 595–598\nusage notes, 56\nversion 3.0 requirements, 53",
    "reduce, 363\nreduce function, 481\nreference counters, 147\nreferences, 145\ncopies of objects, versus, 241\nshared references, 148–152\nequality, 151\nin-place changes, 149\nrelative imports, 561\nreload function, 52, 554–558\nexample, 556\nfrom imports and, 601\ninteractive testing, 602\nimport and from, contrasted with, 555\ntransitive module reloads, 595–598\nusage notes, 56\nversion 3.0 requirements, 53\nreloadall.py, 596\nremove method, 87, 206\nrepetition, 81\nreplace method, 83\nrepr function, 79\nstr, compared to, 116\nreturn statement, 397, 398, 404\nreverse method, 87, 205\nround function, 126",
    "1156 | Index\n\nrstrip method, 235",
    "S\nSAX parsing, 935\nscientific programming, 11\nScientificPython programming extensions, 12\nSciPy programming extensions, 12, 140\nscopes, 407–414\nbasics, 407\nbuilt-in scope, 412\ndefaults with loop variables, versus, 423\nexample, 411\nglobal statements, 408\nmodule files and, 416\nname resolution and the LEGB rule, 410\nnamespaces, 407\nnested functions and, 419–425\nnonlocal, 408\nrules, 408\nscript0.py, 24\nscript1.py, 42\nrunning with an import, 51\nscripts, 5, 42\nsearch tables (see dictionaries)\nself argument, 685\nsemicolon (;), 265\nsend method, 496\nsequence assignment statements, 280\nsequence assignments, 281–284\nsequence operations, 80\nsequences, 80\nset comprehensions, 507\nset numeric type, 133–139\ndictionaries, compared to, 135\nimmutable constraints and frozen sets, 136\nPython 2.6, 133\nPython 3.0, 135\nset comprehensions in Python 3.0, 137\nset object type, 99\nsetsubclass.py, 776\nshared references, 148–152\nequality, 151\nin-place changes, 149\nShedskin C++ translator, 31, 889",
    "sequence assignments, 281–284\nsequence operations, 80\nsequences, 80\nset comprehensions, 507\nset numeric type, 133–139\ndictionaries, compared to, 135\nimmutable constraints and frozen sets, 136\nPython 2.6, 133\nPython 3.0, 135\nset comprehensions in Python 3.0, 137\nset object type, 99\nsetsubclass.py, 776\nshared references, 148–152\nequality, 151\nin-place changes, 149\nShedskin C++ translator, 31, 889\nshelve module, 670–675, 744\nadvantages and disadvantages, 673\ndatabase client, 672\ndatabase files, 672\nobject storage in shelve databases, 671",
    "shelves and dictionaries, 670\nupdating a shelve’s objects, 674\nsimple functions, 796\nsingle quotes (') and strings, 158\nsite module, 537\nslice assignment in lists, 202\nslice objects, 168\nslicing, 81, 165, 166\nexample, 168\nextended slicing, 167\nloops, usage in, 343\nsoftware components, 653\nsort method, 87, 203, 388, 454\nsorted function, 93, 363\nsorts in Python 3.0, 204\nsource code, 26\nsource file character set encoding declarations,\n912\nspaces, 314\nspecial characters, 897\nsplit method, 235\nsquare brackets [ ], 78, 108, 269\ndictionaries and, 209\nlist comprehensions and, 359, 486, 504\nlists and, 89, 199\nsquare roots, 126\nstack trace, 828, 840\nStackless Python, 33\nstandard library, 4, 533\nlibrary directories, 537\nstandard manual set, 386\nstandard output stream (stdout), 297\nstate information, 102, 644\nstate retention, 429–432, 727, 997–1000\nstate with classes, 430\nstatements, 75, 261–276\nassignment statements (see assignment\nstatements)\ncompound statements, 264",
    "lists and, 89, 199\nsquare roots, 126\nstack trace, 828, 840\nStackless Python, 33\nstandard library, 4, 533\nlibrary directories, 537\nstandard manual set, 386\nstandard output stream (stdout), 297\nstate information, 102, 644\nstate retention, 429–432, 727, 997–1000\nstate with classes, 430\nstatements, 75, 261–276\nassignment statements (see assignment\nstatements)\ncompound statements, 264\ndifferences from other C-like languages,\n265\nend-of-line, 265\nexpression statements, 295\nin-place changes, 296\nindentation syntax, 266\nmultiline statements, 317\nPython 3.0 statement set, 262\nsyntax, 264\nblock rule special case, 270",
    "colon (:), 264\nindentation, 266\ninteractive loops, 271–276\nsemicolons, 269\nstatement separators, 269\nstatic methods, 686, 795–801\nalternatives to, 798\ncoding with decorator syntax, 804\ncounting instances, 800\nPython 2.6 and 3.0, 796\nusing, 799\nstaticmethod function, 799\nsteps, 167\nStopIteration exception, 352\nstr, 79, 157, 169\nrepr, compared to, 116\nstr object type\ndata encoding in, 901\nstr string type, 899\nPython 2.6 operation set, 911\nPython 3.0 compared to 2.x, 899\nUnicode and, 85\nstream processors, 742\nstream redirection, 44\nstrides, 167\nstring exceptions, 859\ndeprecation of, 858\nstring formatting, 179–183\nadvanced expressions, 181\ndictionary-based formatting expressions,\n182\nstring formatting type codes, 181\nstring formatting method calls, 183–193\nformat method, 184–193\n% formatting expression, compared to,\n187\njustification for, 190\nkeys, attributes, and offsets, 184\nstring methods, 172–179\nadditional examples, 177\nchanging strings example, 174\nparsing text example, 176",
    "string formatting, 179–183\nadvanced expressions, 181\ndictionary-based formatting expressions,\n182\nstring formatting type codes, 181\nstring formatting method calls, 183–193\nformat method, 184–193\n% formatting expression, compared to,\n187\njustification for, 190\nkeys, attributes, and offsets, 184\nstring methods, 172–179\nadditional examples, 177\nchanging strings example, 174\nparsing text example, 176\nPython 2.x string module, 178\nstring method calls to format method, 185\nstring method calls, Python 3.0, 173\nstring object type, 80–86, 155–163\ncoding special characters, 85\npattern matching, 85\nraw string literals, 85",
    "Index | 1157",
    "sequence operations and, 80\nstring literals, 157–163\ncommon literals and operations, 155\nescape sequences, 158–161\nraw strings and escapes, 161\nsingle and double quoted strings, 158\nstring backslash characters, 159\ntriple quotes, 162\nversion 3.0 changes, 896\nversions 2.6 and 3.0 string types, 157\nstring operations, 163–172\nbasic operations, 164\nchanging strings, 171\nindexing, 165, 166\nslicing, 165, 166\nextended slicing, 167\nstring conversions, 169\ncharacter code conversions, 170\nstrings, 897\n16- and 32-bit Unicode values, coding of,\n907\nASCII text, coding, 905\nbytearray objects, using, 917–920\nbytes objects (Python 3.0), 913–917\nmethod calls, 913\nsequence operations, 914\nbytes string type\nmaking bytes objects, 915\ncharacter encoding schemes and, 897\nencoding conversions, 909\nescape sequence coding by type, 908\nexamples of usage (Python 3.0), 902–904\nliterals and basic properties, 902\nmixing string types, 916\nmutability or immutability of string types,\n903\nnon-ASCII text, coding, 905",
    "bytes objects (Python 3.0), 913–917\nmethod calls, 913\nsequence operations, 914\nbytes string type\nmaking bytes objects, 915\ncharacter encoding schemes and, 897\nencoding conversions, 909\nescape sequence coding by type, 908\nexamples of usage (Python 3.0), 902–904\nliterals and basic properties, 902\nmixing string types, 916\nmutability or immutability of string types,\n903\nnon-ASCII text, coding, 905\nnon-ASCII text, encoding and decoding,\n906\npickle object serialization module (Python\n3.0), 932\nPython 3.0 string types, usage, 920\nre pattern matching module (Python 3.0),\n929\nsource file character set encoding\ndeclarations, 912\nstring methods, 82\nstring types, 899",
    "1158 | Index",
    "struct binary data module (Python 3.0),\n930\ntext and binary files, 920\nBOM in Python 3.0, 926\nfile modes in Python 3.0, 921\ntype and content mismatches, 923\nUnicode in Python 2.6, 928\ntype conversions, 903\nUnicode files, using, 924\nreading and writing in Python 3.0, 924\nunicode strings, coding, 904\nUnicode strings, Python 2.6 coding, 910\nXML parsing tools, 934\nstrong typing, 78\nstruct module string handling, Python 3.0,\n930\nsubclasses, 614, 629, 653–658\ncoding, 653–658\naugmenting methods, 654–656\ninheritance, customization, and\nextension, 657\nOOP, as illustration of, 658\npolymorphism, 656\nsum function, 125\nSuper class, 689\nsuperclasses, 614, 629\nabstract superclasses, 690–693\nsyntax rules, 264–271, 314–319\nindentation, 315\nmultiline statements, 317\nopen syntactic pairs rule, 318\nsys.exc_info, 880–882\nsys.exit(statuscode) call, 883\nsys.getdefaultencoding function, 896\nsys.modules table, 534\nsys.path list, 536, 538, 590\nsystem namespace partitioning and modules,\n530",
    "sum function, 125\nSuper class, 689\nsuperclasses, 614, 629\nabstract superclasses, 690–693\nsyntax rules, 264–271, 314–319\nindentation, 315\nmultiline statements, 317\nopen syntactic pairs rule, 318\nsys.exc_info, 880–882\nsys.exit(statuscode) call, 883\nsys.getdefaultencoding function, 896\nsys.modules table, 534\nsys.path list, 536, 538, 590\nsystem namespace partitioning and modules,\n530\nsystems programming, 9",
    "T\ntermination actions, 830\ntestdriver function, 880\ntester, 426\ntesting of code, 645\ntestmixin.py, 759\ntestprint30.py, 458\ntext files, 98, 233, 901, 920\nin Python 3.0, 921",
    "text-mode files, 920\ntext.py, 912\nthreenames.py, 54\ntime module, 509\nalternatives, 513\ntimeit module, 517\ntimer module, keyword-only arguments, 516\ntkinter, 59\ngetting support on Linux, 1094\nsettings, 1094\ntop-level code, 387\ntop-level file, 51, 531\ntransitive module reloads, 595–598\ntriple quotes, 162\nTrue and False, 414\nTrue and False Boolean values, 139\ntrue and false values, 246\ntrue division, 110, 117\ntruth tests, 320\ntry\nexcept statement, 831\ntry statement, 96, 263, 826, 840\n(see also exceptions)\ndebugging with, 879\nexcept statement and, 828\nnested try statements, 873–877\nPython 2.5 and later, 835\ntry\nexcept/else, 835–842\ntry statement clause forms, 837–839\ntry/else clause, 839\ntry/finally statement, 842–843\ncoding termination actions, 843\nunified try/except/finally, 844–847\nexample, 846\nnesting finally and except, 845\nstatement syntax, 845\ntry/finally statement, 827, 830\nfile and server connection closure, 879\ntuple object type, 96\ntuple-unpacking assignment statements, 280",
    "try\nexcept/else, 835–842\ntry statement clause forms, 837–839\ntry/else clause, 839\ntry/finally statement, 842–843\ncoding termination actions, 843\nunified try/except/finally, 844–847\nexample, 846\nnesting finally and except, 845\nstatement syntax, 845\ntry/finally statement, 827, 830\nfile and server connection closure, 879\ntuple object type, 96\ntuple-unpacking assignment statements, 280\ntuples, 114, 225–229\ncommon literals and operations, 226\nconversions, methods, and immutability,\n228\nin for loops, 336\nimmutability and tuple contents, 229\nlists, compared to, 229\nsorting, 228",
    "supported sequence operations, 227\nsyntax with parentheses and commas, 227\ntype class, 1061\ntype hierarchies, 248\ntype object type, 100, 250, 1058\ntypesubclass.py, 775\n\nU\nunbound methods, 750, 796\nPython 3.0 status as functions, 752\nundefined name exception, 691\nunderscore (_), 584\nUnicode, 897\nstrings, coding of, 904\ntext, handling in versions 2.6 and 3.0, 896\nUnicode files, 924\nreading and writing (Python 3.0), 924\ndecoding mismatches, 925\nfile input decoding, 925\nfile output encoding, 925\nmanual encoding, 924\nunicode string type (Python 2.6), 911\nunicode string type (Python 2.x), 899, 910\nunicode strings, 157\nunion function, 456\nunit tests with __name__ attribute, 586\nunittest, 887\nUnix\nenv lookup trick, 47\nexecutable scripts, 46\nPython command line, starting, 36\nUnladen Swallow project, 33\nupdate method, 211\nuser base of Python language, 7\nuser-defined classes, 101\nuser-defined exceptions, 830\nUTF-8 encoding, 898\nutility modules, 108",
    "V\nvalues method, 211, 370\nvan Rossum, Guido, 14\nvariables, 113, 144–145\ndeclaration, 114\ninitialization, 546\nlocal variables, 404\nscope, 408\nvariable name rules, 292–295\nIndex | 1159\n\n\fW\nwebsites, 676\nwhile loop, 94\nversus for loops, 388\nwhile statement, 327\nrange function and, 342\nWindows\nautomatic file extensions, 45\nexecutable files, displaying output, 49\nicon clicks for program initiation, 47\nIDLE user interface and, 58\nprogram files, opening with icons, 47\nPython command line, starting in, 36\nPython files, running in, 44\nPython standard manual set, 386\nWindows Notepad, file encoding specification,\n926\nwith statement, 129, 842\nwith/as extension, 263\nwith/as statement, 832, 851–855\ncontext management protocol, 853\nusage, 852\nwrapper classes, 745\nwrapper objects, 984\nwrappers, catching exceptions with, 882\nwrite method, 232\n\nX\nXML, 934\n\nY\nyield expression, 263\nyield operator, 108\nyield statement, 397, 399\nusage in generators, 493",
    "X\nXML, 934\n\nY\nyield expression, 263\nyield operator, 108\nyield statement, 397, 399\nusage in generators, 493\n\nZ\nzip, 363, 365\nzip function, 345\ndictionary construction using, 347\nzip iterator, 368\nZODB object-oriented database system, 676\n\n1160 | Index",
    "About the Author\nMark Lutz is the world leader in Python training, the author of Python’s earliest and\nbestselling texts, and a pioneering figure in the Python community.\nMark is the author of the popular O’Reilly books Learning Python,\nProgramming Python, and Python Pocket Reference, all available in third or fourth editions in 2009. He has been using and promoting Python since 1992, started writing\nPython books in 1995, and began teaching Python classes in 1997. As of early 2009,\nMark has instructed 225 Python training sessions, taught some 3,500 students, and\nwritten Python books that have sold roughly a quarter of a million copies and been\ntranslated into more than a dozen languages.\nIn addition, he holds B.S. and M.S. degrees in computer science from the University of\nWisconsin, and during the last 25 years he has worked as a professional developer on",
    "Mark has instructed 225 Python training sessions, taught some 3,500 students, and\nwritten Python books that have sold roughly a quarter of a million copies and been\ntranslated into more than a dozen languages.\nIn addition, he holds B.S. and M.S. degrees in computer science from the University of\nWisconsin, and during the last 25 years he has worked as a professional developer on\ncompilers, programming tools, scripting applications, and assorted client/server systems. Mark can be reached on the Web at http://www.rmi.net/~lutz.",
    "Colophon\nThe animal on the cover of Learning Python, Fourth Edition, is a wood rat (Neotoma\nMuridae). The wood rat lives in a wide range of conditions (mostly rocky, scrub, and\ndesert areas) over much of North and Central America, generally at some distance from\nhumans. Wood rats are good climbers, nesting in trees or bushes up to six meters off\nthe ground; some species burrow underground or in rock crevices or inhabit other\nspecies’ abandoned holes.\nThese grayish-beige, medium-size rodents are the original pack rats: they carry anything\nand everything into their homes, whether or not it’s needed, and are especially attracted\nto shiny objects such as tin cans, glass, and silverware.\nThe cover image is a 19th-century engraving from Cuvier’s Animals. The cover font is\nAdobe ITC Garamond. The text font is Linotype Birka; the heading font is Adobe\nMyriad Condensed; and the code font is LucasFont’s TheSansMonoCondensed."
  ]
}