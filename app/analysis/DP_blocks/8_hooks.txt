

11
Introducing Hooks
React Hooks give function components access to much of the functionality of React that was
previously only available with class components. Hooks also give developers a simpler syntax
for using state, performing tasks in response to lifecycle events, and reusing code.
In this chapter, you’ll learn:
➤➤ What hooks are.
➤➤ General rules and best practices for using hooks.
➤➤ How to use React’s built-i n hooks.
➤➤ How to write custom hooks.
➤➤ How to find and use other custom hooks.
WHAT ARE HOOKS?
Hooks are functions that are part of the React library which give you access to features of
React that were previously only available by extending the React.Component class. These
features include state and lifecycle, as well as refs and caching of function results (aka memoiza-
tion). Hooks “hook into” React from functions.
WHY WERE HOOKS INTRODUCED?
Hooks were introduced to solve several problems with the React library. The first is that React
didn’t have a simple way to share reusable functionality between components. Prior to React
Hooks, solutions such as higher- order components and render props (both of which are covered
in Chapter 12) were commonly used (and still are) for sharing functionality. However, higher-
order components tend to result in code and component trees that are difficult to read and
overly complex. Code that renders multiple levels of components within components within
258 ❘ CHAPTER 11 IntroducIng Hooks
components in order to provide reusable functionality to a deeply buried component is what is com-
monly known in the React world as “wrapper hell.” Figure 11-1 shows a view of the React Developer
Tools for a component tree that’s suffering badly from this condition.
FIGURE 11- 1: Wrapper hell
React’s other big problem prior to hooks was that people found using classes to be unnecessarily
confusing and verbose. If you’ve made it this far into the book, I don’t need to explain this one to you
again. Most of the time, what requires 50 lines of code in a class can be done with a fraction of that
by using a function.
The Built-i n Hooks ❘ 259
As you’ll see, beyond just having the ability to accomplish the same thing with less code, hooks also
give you the ability to split up your components into smaller parts by creating custom hooks.
Now that you understand the motivation for hooks, let’s take a look at the specifics.
RULES OF HOOKS
Although different hooks accomplish different things, all of them have two important rules which
must be followed:
1. Hooks can only be used in function components.
2. Hooks must be called at the top level of your function components— meaning inside the
function, but not inside of a statement or inner function. Because hooks need to run just once
every time your function component runs, they can’t be called from inside of conditional
statements, loops, or nested functions.
THE BUILT- IN HOOKS
React has 10 built-i n hooks that you can use without needing to install anything else. These built- in
hooks are:
➤➤ useState
➤➤ useEffect
➤➤ useContext
➤➤ useReducer
➤➤ useCallback
➤➤ useMemo
➤➤ useRef
➤➤ useImperativeHandle
➤➤ useLayoutEffect
➤➤ useDebugValue
The first three hooks—u seState, useEffect, and useContext— are the basic hooks. They’re the
ones you’ll use most often and that are therefore the most important ones to understand.
The other seven hooks are called “Additional Hooks” in the React documentation. These are hooks
that you may only use occasionally (or never) or which are variations on the three basic hooks. There
are some really useful things (and a couple that are essential, in my opinion) in this set of hooks,
however, so I’m going to spend some time covering them and showing examples of how to use
them as well.
260 ❘ CHAPTER 11 IntroducIng Hooks
Managing State with useState
On the first render of a function component containing it, the useState hook creates a stateful
value from the argument passed to it, along with the function for updating it. After the first render,
useState returns its most recent value after updates are applied. Like class properties (such as this
.state), values created with useState persist between renders.
As with all of the hooks, the first step in using useState is to import it:
import {useState} from 'react';
IMPORTING ALL THE HOOKS
In reality, since hooks are part of the React library, you can import all of the hooks
at once by importing the entire React library and then referencing them using dot
notation, like this:
import React from 'react';
const [state,setState] = React.useState();
Although there’s no real problem with using hooks this way, it’s more common, and
perhaps more efficient, to import just the hooks you need individually using named
imports. If your component makes use of multiple hooks, separate them with com-
mas inside of the curly braces, like this:
import {useState,useEffect,useCallback} from 'react';
Once you import useState into a component, you can use it as many times as you need to create
stateful variables. React keeps track of stateful values in a function component based on the order
in which they appear in the code, which is how it can return the latest value for each stateful vari-
able each time the function renders. This is why hooks can’t be used inside of conditional or looping
code— doing so would cause the hooks in a function component to not always be called, or to not be
called in the same order with each render, which would cause React to return unexpected values.
Listing 11-1 shows a simple example of using useState to keep track of the score and the current
guess in a number guessing game.
LISTING 11- 1: A number guessing game with useState
import {useState} from 'react';
function NumberGuessing(props){
const [score,setScore] = useState(0);
const [guess,setGuess] = useState('');
const checkNumber =()=>{
const randomNumber = Math.floor(Math.random() * 10)+1;
if (Number(guess) === randomNumber){
The Built-i n Hooks ❘ 261
setScore(()=>score+1);
}
}
return (
<>
What number (between 1 and 10) am I thinking of?
<input value={guess}
type="number"
min="1"
max="10"
onChange={(e)=>setGuess(e.target.value)}
/>
<button onClick={checkNumber}>Guess!</button>
<p>Your score: {score}</p>
</>
)
}
export default NumberGuessing;
In the preceding example, the user’s guess is updated using an inline event handler in the onChange
event listener when the user enters a number into the number input field.
When the button is clicked, the checkNumber function generates a random number between 1 and 10
and then compares that number with the latest value stored in the guess stateful variable.
One important thing to notice with the comparison is that I used the Number function to convert
guess to a number. This is necessary because even numeric values from <input> elements are stored
in the browser as strings. The random number variable is of the number data type, however, so to be
able to do a strict comparison between them, one of them has to be converted.
If the two numbers match, the score variable is updated to its current value plus 1.
JAVASCRIPT LESSON: STRICT EQUALITY
JavaScript has two equality operators, == and ===. The difference between them is
that == will disregard the data type when comparing, and the === operator will com-
pare both the value and the data type of the values being compared.
If you’re coming to JavaScript from another programming language, the behavior of
the == operator will seem strange and mysterious. It’s simply not correct that “0” is
equal to 0, for example.
In fact, the existence of the == operator (and its opposite, the != operator) in
Java Script is widely regarded as a flaw in the language, because it has the potential
to create mysterious behavior and errors. It is therefore best to avoid using == and to
always perform strict equality comparisons.
262 ❘ CHAPTER 11 IntroducIng Hooks
Setting the Initial State
To set the initial state of a stateful variable created using useState, pass the initial value into
useState. The useState hook accepts a single argument, which can be any of JavaScript’s data types
(or an expression that evaluates to a single value) or a function.
If you don’t pass an argument into useState, the resulting stateful variable will be created with an
initial value of undefined.
If the initial state is an expression, that expression will still run on each render, but the result will be
ignored after the first render. For this reason, if your initial state is the result of an expensive calcu-
lation (for example, it requires a network request), pass a function that returns the initial value to
useState, as shown here:
const [mailingList,setMailingList] = useState(()=>{
const initialMailingList = loadMailingList(props);
return initialMailingList;
});
The function will only be run on the first render of the component. React calls this lazy initial state.
Using the Setter Function
Like the setState function in a class component, the setter function returned by useState will
trigger a render. If you pass a setter function down to a child component and call it from that child
component, it will still operate on the original variable it was created with, as demonstrated by
Listing 11-2.
LISTING 11- 2: Setter functions are bound to their creator components
import {useState} from 'react';
function ButtonContainer(){
const [count,setCount] = useState(0);
return (
<>
<MyButton count = {count} setCount = {setCount} /><br />
count value: {count}
</>
);
}
function MyButton(props){
return (
<button onClick = {()=>props.setCount(props.count+1)}>
Add 1 to the Count
</button>
);
}
export default ButtonContainer;
The Built-i n Hooks ❘ 263
Figure 11-2 shows the result of rendering the ButtonContainer component and clicking the button
(which is rendered by the MyButton child component).
FIGURE 11- 2: Passing a setter function as a prop
The setter function returned by useState can be used in two different ways: by passing it a function
or by passing it a single value.
Passing a Value to a Setter
When you pass a single value (or an expression that evaluates to a single value) into a useState set-
ter function, the stateful variable attached to that useState function call will be set to the new value
you pass it:
const [guess,setGuess] = useState(''); // guess === ''
setGuess('7'); // guess === '7'
setGuess('3'); // guess === '3'
Unlike when you use setState in a class component, useState’s setter functions do not merge
objects. If you pass an object into a useState setter function, the variable connected to that
useState function will be set to exactly that object.
Passing a Function to a Setter
The other way to use useState setter functions is to pass them a function. This is the method that
should be used when the new state of the variable is based on the previous state of the variable.
Passing a function ensures that the setter function will always receive the latest value of the variable.
264 ❘ CHAPTER 11 IntroducIng Hooks
The function you pass to a setter function will receive the previous value of the stateful variable as
an argument, and it’s common to name this argument prev or the name of the variable with prev
before it:
const [score,setScore] = useState(0); // score === 0
setScore((prevScore)=>prevScore+1); // score === 1
Setter Function Value Comparison
If the value that you pass into a setter function is the same as the current value of the state variable,
the setter function will “bail out” without re-r endering the component’s children.
Hooking into the Lifecycle with useEffect
The useEffect hook accepts a function, which it will run after each render of the function
component by default. The useEffect hook can be used to simulate the componentDidMount(),
componentDidUpdate(), and componentWillUnmount() lifecycle methods in function components.
The purpose of useEffect is to allow you to run imperative code that may have side effects inside a
function component. These side effects are the types of things that aren’t otherwise allowed in func-
tion components, such as network requests, setting timers, and manipulating the DOM directly. The
reason these types of operations aren’t otherwise possible in function components is that function
components are essentially just the render method of a component. Side effects shouldn’t be done in
the render method, even in class components, because the render method is likely to overwrite the
results of any side effects. Instead, side effects should be performed after the render method has run
and the DOM has been updated.
This is why side effects are handled inside of lifecycle methods, such as constructor(),
componentDidMount(), and componentDidUpdate() in class components.
JAVASCRIPT LESSON: SIDE EFFECTS
The term “side effects” comes up frequently in React, but it’s not a React-s pecific
term. In computer science, a side effect is a result of an impure function. If you recall,
a pure function is one whose return value is always the same when given the same
arguments, and that doesn’t do anything that lasts past the running of the function
except return a value.
Anything that a function does that has an effect outside of the function, other than
producing a return value, is a side effect.
Side effects in a browser- based application can include:
➤➤ Modifying global variables.
➤➤ Making a network request.
➤➤ Changing the DOM.
➤➤ Writing to a database or a file.
➤➤ Modifying an argument.
The Built-i n Hooks ❘ 265
Using the Default useEffect Behavior
In its most basic form, useEffect simply accepts a function and executes it after each render is com-
plete, as shown in Listing 11-3.
LISTING 11- 3: The most basic form of useEffect
import {useEffect,useState} from 'react';
function RenderCounter(){
const [count,setCount] = useState(0);
useEffect(()=>{console.log(count)});
return(
<>
This component will count how many times it renders.
<button onClick={()=>setCount((prev)=>prev+1)}>Update State</button>
</>
);
}
export default RenderCounter;
When you run the component in Listing 11-3, it will count each time the function passed to
useEffect runs and log the current count to the browser’s JavaScript console.
This use of useEffect is similar to if you had passed this same function into both the
componentDidMount() and the componentDidUpdate() lifecycle methods in a class component.
However, there is an important difference between these lifecycle methods and how useEffect
works. Namely, the timing of when a class component’s lifecycle methods run and when useEffect
runs are different. Most of the time this isn’t an issue, but in some cases it can cause problems or
glitches in the layout in the browser. I’ll discuss this and how to solve it when I cover the
useLayoutEffect hook.
Cleaning Up After Effects
If you use useEffect to set up subscriptions, set event listeners, or create timers, you run
the risk of introducing memory leaks into your React application. In class components, the
componentWillUnmount() lifecycle method is used for cleaning up and avoiding memory leaks, as
you saw in Chapter 4.
To clean up after effects in function components you can return a function from the function passed
into useEffect. This function will run before the component is removed from the user interface. In
addition, it will also run before every update of the component.
Although it may seem inefficient for the cleanup function to run before every update of a component,
if you think about how function components work, you’ll understand why this is necessary. Since
JavaScript functions aren’t persistent, effects will run every time a component renders. If you’re creat-
ing a subscription to a data source, or a timer, this means that a new timer or subscription will be
266 ❘ CHAPTER 11 IntroducIng Hooks
created each time the component renders. If it renders multiple times and there’s nothing cleaning up
the multiple timers or subscriptions, you’ll have a memory leak.
Using a cleanup function in useEffect is optional.
Customizing useEffect
There are times when you don’t want to run an effect on every render, but instead only on the initial
render, or only when a specific value changes. To customize the behavior of useEffect, you can pass
it an optional second argument. The second argument is an array of values that the effect depends on.
For example, Listing 11-4 shows a component that starts a timer and uses the default
useEffect behavior. With the default useEffect behavior, this timer is re- created each time the
component renders.
LISTING 11- 4: Starting a timer with each render
import {useEffect} from 'react';
function TimerFun(){
useEffect(() => {
let time = 0;
const interval = setInterval(() => {
console.log(time++);
}, 1000);
return () => clearInterval(interval);
});
return (<p>Check the console to see the timer.</p>);
}
export default TimerFun;
Since this component doesn’t use state or accept any props, there’s no reason for it to re- render, so the
timer will continue to increment and log a higher number each second for as long as the component is
mounted in the browser window.
If this component were to re-r ender, however, the default behavior of useEffect would cause the
cleanup function to run and a new timer to be created with each render, as shown in Listing 11-5.
LISTING 11- 5: Creating a new timer with each render
import {useEffect,useState} from 'react';
function TimerRestartFun(props){
const [count,setCount] = useState(0);
The Built-i n Hooks ❘ 267
useEffect(() => {
let time = 0;
const interval = setInterval(() => {
console.log(time++);
}, 1000);
return () => clearInterval(interval);
});
return (
<p>Check the console to see the timer.
<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>
</p>
);
}
export default TimerRestartFun;
Each time you click the button in the preceding example component, the state changes and the return
value changes, which causes the component to render, which causes a new timer to start, as shown in
Figure 11-3.
FIGURE 11- 3: Starting a new timer with each render
But what if you want to create a game that runs a timer to test how quickly you can click the button?
One way to do this would be to only start the timer after the component first mounts, rather than
after every render. The way to do this with useEffect is to pass it an empty array as the second argu-
ment, as shown in Listing 11-6.
268 ❘ CHAPTER 11 IntroducIng Hooks
LISTING 11- 6: Passing an empty array to only run useEffect on mount
import {useEffect,useState} from 'react';
function TimerOnceFun(props){
const [count,setCount] = useState(0);
useEffect(() => {
let time = 0;
const interval = setInterval(() => {
console.log(time++);
if(time===10){
console.log(`time's up!`);
clearInterval(interval);
}
}, 1000);
return () => clearInterval(interval);
},[]);
return (<p>Check the console to see the timer.
<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>
</p>);
}
export default TimerOnceFun;
With the effect only running when the component mounts, the render caused by incrementing the
count variable no longer creates a new timer, as shown in Figure 11-4.
FIGURE 11- 4: Running an effect only after mounting
The Built-i n Hooks ❘ 269
Passing an empty array as the second argument of useEffect causes it to simulate the behavior of
the componentDidMount() lifecycle method, and makes it a good place to put fetch requests for
data that won’t change during the life of the component, for example. The empty dependency array
works because the dependency array’s job is to say, “run the function when one of these values has
changed.” If there are no values in the dependency array, the effect only runs when it’s first created.
But, what if you wanted to change the game so that the timer could be restarted when the user wants,
or when the count gets up to a certain number, for example? What you need is to conditionally run
useEffect. To do this, you can make useEffect depend on one or more values that will determine
when it runs, as shown in Listing 11-7.
LISTING 11- 7: Specifying useEffect’s dependencies
import {useEffect,useState} from 'react';
function TimerConditionalFun(props){
const [count,setCount] = useState(0);
const [gameNumber,setGameNumber] = useState(0);
useEffect(() => {
let time = 0;
const interval = setInterval(() => {
console.log(time++);
if(time===10){
console.log(`time's up!`);
clearInterval(interval);
}
}, 1000);
return () => clearInterval(interval);
},[gameNumber]);
return (
<>
<h1>Game Number {gameNumber}</h1>
<p>Click as fast as you can!
<button onClick={()=>setCount((prev)=>prev+1)}>{count}</button>
</p>
<p>
<button onClick={()=>setGameNumber((prev)=>prev+1)}>New Game</button>
</p>
</>
);
}
export default TimerConditionalFun;
When the component in Listing 11-7 mounts, the timer will start, and it will only be restarted when
the value of gameNumber changes.
270 ❘ CHAPTER 11 IntroducIng Hooks
Even when the benefits and results of conditionally running an effect aren’t as apparent as those
in Listing 11-7, specifying the dependencies of an effect can often be a way to increase the perfor-
mance of your user interface by eliminating unnecessary renders of components, as you’ll see in the
next section.
Running Asynchronous Code with useEffect
Because useEffect is asynchronous and runs after the component has rendered, it’s the ideal place to
perform asynchronous tasks such as fetching data. Listing 11-8 shows a postal code lookup compo-
nent that uses an effect hook to look up the U.S. city and state whenever the ZIP code entered into an
input field changes.
LISTING 11- 8: Asynchronous requests with useEffect
import {useEffect, useState} from 'react';
function ShippingAddress(props){
const [zipcode,setZipcode] = useState('');
const [city,setCity] = useState('');
const [state,setState] = useState('');
const API_URL = 'https://api.zip-
codes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';
const API_KEY = 'DEMOAPIKEY';
const updateZip = (e)=>{
e.preventDefault();
setZipcode(e.target.zipcode.value);
}
useEffect(()=>{
if (zipcode){
const loadAddressData = async ()=>{
const response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);
const data = await response.json();
setCity(data.City);
setState(data.State);
}
loadAddressData();
}
},[zipcode]);
return (
<form onSubmit={updateZip}>
Zipcode: <input type="text" name="zipcode" />
<button type="submit">Lookup City/State</button><br />
City: {city}<br />
State: {state}<br />
The Built-i n Hooks ❘ 271
</form>
)
}
export default ShippingAddress;
The result of running the component in Listing 11-8 is shown in Figure 11-5.
FIGURE 11- 5: Performing an asynchronous request using useEffect
This example uses a number of the techniques that you’ve learned about in the last couple of
chapters, plus a couple of new ones, so let’s take a walk through the code step by step:
1. On its initial render, the zipcode, city, and state variables are set to empty strings. The
useEffect hook runs, but the conditional statement that checks whether zipcode has a
value that evaluates to a Boolean true prevents the inner function, loadAddress(), from
being created or running.
2. The user can enter text into an uncontrolled input. Because the input is uncontrolled, it
doesn’t cause the UI to render and useEffect doesn’t run. If this input were controlled, the
effect would run on each keystroke because the value of zipcode would be changing.
3. When the user clicks the button, the zipcode state variable is set by the
updateZip() function.
4. The change to the zipcode variable causes a render. Because zipcode is listed as a depend-
ency for the useEffect hook, the effect runs.
272 ❘ CHAPTER 11 IntroducIng Hooks
5. This time, zipcode has a value that evaluates to true, so the inner function is created and
then runs.
6. The loadAddress() function is an async function. Using the async keyword before the
function definition allows the function to use the await statement to perform asynchro-
nous tasks. In the case of this function, it will call the fetch command and then wait for
a response. When a response is received, the json() command reads the response into an
object named data.
7. The data from the API is used to set the values of the city and state stateful variables. This
causes another render of the component. The zipcode hasn’t changed, so the useEffect
hook won’t run.
This component illustrates how to use effect dependencies to eliminate unnecessary renders, which
are one of the most common types of performance problems in React components. It’s possible that
this component would still function without the dependency array, but it would make many unnec-
essary API requests, which would slow down your component (at the least) and possibly cost you
money if the API charges you for requests.
Subscribing to Global Data with useContext
Global data is data that’s used by all or many components in a program, such as a theme or user pref-
erences. It can be a hassle to have to pass global data from parent components to child components
for every component in an React app—e specially when your component tree has multiple levels.
React Context provides a way to share global data between components without having to manually
pass values as props. The useContext hook accepts a Context object as its argument and returns the
most recent value of that object.
NOTE Chapter 17 covers the React Context API in detail, along with when and
exactly how to use it.
One example of global data that can be passed to child components using Context is a style
theme. A theme refers to styles that are used by multiple components to give them a common look
within an app.
Listing 11-9 shows an example of using the useContext hook in the child component to subscribe to
a Context object.
LISTING 11- 9: Using Context with the useContext hook
import { ThemeContext } from './theme-c ontext'
function App() {
const { theme } = React.useContext(ThemeContext)
The Built-i n Hooks ❘ 273
return (
<>
<header
className="App- header"
style={{ backgroundColor: theme.backgroundColor, color: theme.color }}
>
<h1>Welcome to my app.</h1>
</header>
</>
)
}
export default App;
Combining Logic and State with useReducer
The useReducer hook is an alternative to useState that’s useful for complex state updates or situa-
tions where the new state depends on the previous state. Whereas useState takes just an initial state
as its argument, useReducer takes an initial state and a reducer as its arguments. A reducer is a pure
function that takes the current state and an object called an action and returns the new state. In other
words, here’s the signature of a reducer function:
(state, action) => newState
The useReducer hook returns a value and a dispatch function. A dispatch function can be used
in response to events, but instead of taking a value to set the stateful variable to, it takes an action
object. An action object has a type and an optional payload.
Using reducers is quite a bit more complicated than simple state updates, but once you see some
examples, they become much clearer. Listing 11-10 shows our old friend the Counter component, but
rewritten to use a reducer.
LISTING 11- 10: A Counter with useReducer
import {useReducer} from 'react';
const initialState = {count: 0};
function reducer(state, action) {
switch (action.type) {
case 'increment':
return {count: state.count + 1};
case 'decrement':
return {count: state.count - 1};
default:
throw new Error();
}
}
function Counter() {
const [state, dispatch] = useReducer(reducer, initialState);
continues
274 ❘ CHAPTER 11 IntroducIng Hooks
LISTING 1-10 (continued)
return (
<>
Count: {state.count}
<button onClick={() => dispatch({type: 'decrement'})}>-< /button>
<button onClick={() => dispatch({type: 'increment'})}>+</button>
</>
);
}
export default Counter;
In Listing 11-10, the action only has a type property. But, if you wanted to have a more advanced
counter, you could add a payload that could be used to indicate how much to increment or decrement
the counter by, as shown in Listing 11-11.
LISTING 11- 11: Passing a payload to a reducer
import {useReducer} from 'react';
const initialState = {count: 0};
function reducer(state, action) {
switch (action.type) {
case 'increment':
return {count: state.count + action.payload};
case 'decrement':
return {count: state.count - action.payload};
default:
throw new Error();
}
}
function Counter() {
const [state, dispatch] = useReducer(reducer, initialState);
return (
<>
Count: {state.count}
<button onClick={() => dispatch({type: 'decrement', payload:4})}>- 4</
button>
<button onClick={() => dispatch({type: 'increment', payload:4})}>+4</
button>
</>
);
}
export default Counter;
The Built-i n Hooks ❘ 275
Memoized Callbacks with useCallback
Functions that you define in components are normally re- created with each render. This is
not usually a problem. However, sometimes you do need to (or should for performance reasons)
return a memoized version of a function to keep it available between renderings. This is where
useCallback comes in.
Listing 11-12 shows the most common use case for useCallback. In this example, the useEffect
hook should call a function passed into it (which we call a callback function) when the value of
the phoneNumber variable changes. The useEffect hook has two dependencies—t he function and
the variable.
Because callback functions are re-c reated on each render, the effect in this example will still call its
internal function each time the component renders.
Listing 11- 12 Function dependencies cause unnecessary renders
import {useEffect,useState,useRef} from 'react';
function CallMe(props){
const [phoneNumber,setPhoneNumber] = useState();
const [currentNumber,setCurrentNumber] = useState();
const phoneInputRef = useRef();
const handleClick = (e)=>{
setPhoneNumber(currentNumber);
}
const placeCall = () => {
if(currentNumber){
console.log(`dialing ${currentNumber}`);
}
};
useEffect(() => {
placeCall(phoneNumber);
},[phoneNumber,placeCall]);
return(
<>
<label>Enter the number to call:</label>
<input type="phone" ref={phoneInputRef}
onChange={()=>{setCurrentNumber(phoneInputRef.current.value)}}/>
<button onClick={handleClick}>
Place Call
</button>
continues
276 ❘ CHAPTER 11 IntroducIng Hooks
LISTING 11-12 (continued)
<h1>{currentNumber}</h1>
</>
);
}
export default CallMe;
If you try to run the preceding component using Create React App, you’ll get a warning in the con-
sole, as shown in Figure 11-6.
FIGURE 11- 6: Unnecessary renders warning due to a function dependency
When you type into the input field, you’ll see that the placeCall() function is called each time the
component renders, which happens every time you type a character.
As the warning message tells you, there are two solutions to this problem. The first is to just define
the placeCall() function inside of the useEffect hook and then remove it from the dependencies
list, like this:
useEffect(() => {
const placeCall = () => {
if(phoneNumber){
console.log(`dialing ${phoneNumber}`);
}
};
The Built-i n Hooks ❘ 277
placeCall(phoneNumber);
},[phoneNumber]);
The other solution, which is the correct one if you’re going to use the placeCall() function in more
than one place, is to memoize the callback function using useCallback, like this:
const placeCall = useCallback(() => {
if(phoneNumber){
console.log(`dialing ${phoneNumber}`);
}
},[phoneNumber]);
The useCallback hook creates a persistent version of the function that will only be re- created when
the phoneNumber variable changes. With this change, the useEffect hook will behave the way you
want it to—o nly calling the inner function when the value of phoneNumber changes— as shown in
Listing 11-13.
LISTING 11- 13: Memoized callbacks fix the unnecessary effect problem
import {useEffect,useState,useRef,useCallback} from 'react';
function CallMe(props){
const [phoneNumber,setPhoneNumber] = useState();
const [currentNumber,setCurrentNumber] = useState();
const phoneInputRef = useRef();
const handleClick = (e)=>{
setPhoneNumber(currentNumber);
}
const placeCall = useCallback(() => {
if(phoneNumber){
console.log(`dialing ${phoneNumber}`);
}
},[phoneNumber]);
useEffect(() => {
placeCall(phoneNumber);
},[phoneNumber,placeCall]);
return(
<>
<label>Enter the number to call:</label>
<input type="phone"
ref={phoneInputRef}
onChange={()=>{setCurrentNumber(phoneInputRef.current.value)}}
/>
<button onClick={handleClick}>
Place Call
continues
278 ❘ CHAPTER 11 IntroducIng Hooks
LISTING 11-13 (continued)
</button>
<h1>{currentNumber}</h1>
</>
);
}
export default CallMe;
Caching Computed Values with useMemo
The useMemo hook memoizes (caches) values between renderings of a function component. It works
the same way as useCallback, except that it can cache any value type, not just functions.
As with useCallback, there are two reason to use useMemo:
➤➤ To solve problems with unnecessary renders.
➤➤ To solve performance problems related to computationally expensive calculations.
Solving Unnecessary Renders
I covered the first case already in the “Memoized Callbacks with useCallback” section. The issue
comes up when you have an object, array, or function serve as a dependency for a function that
should only be run when its dependencies change.
In JavaScript, when you create two objects (or functions, or arrays) with exactly the same properties,
the two objects are not equal to each other. You can test this by opening your browser’s JavaScript
console and executing the following expressions:
{} === {}
[] === []
() => {} === () => {}
In each case, the result will be false, as shown in Figure 11-7.
FIGURE 11- 7: Testing referential equality
The Built-i n Hooks ❘ 279
Because of this, using an object, array, or function in a dependency array will result in the function
running on every render of the function component. Just as useCallback is the solution for callback
functions, useMemo is the solution to unnecessary renders due to object or array dependencies.
Solving Performance Problems
Normally, JavaScript (and therefore calculations within React) is very fast. However, in rare cases, or
when you do encounter a performance problem due to a computationally expensive operation,
useMemo can be used to solve it.
For example, the component in Listing 11-14 generates a chart from a large set of data. By using
useMemo to cache the chart, you can prevent it from being regenerated each time the component ren-
ders. Instead, it will only be generated when the data supplied to it changes.
LISTING 11- 14: Solving performance problems with useMemo
import {useMemo} from 'react';
import {chartGenerator} from 'some-c hart- library';
function Chart(props){
const giantChart = useMemo(()=>{
return chartGenerator(props.chartData);
},[props.chartData]);
return {giantChart};
}
export default Chart;
Accessing Children Imperatively with useRef
The useRef hook returns a ref object with a mutable property named current. One use for a ref
object is to imperatively access the DOM. When a DOM node that a ref is attached to changes, the
ref object’s current property is updated. Changes to a ref do not cause the component to re- render.
Listing 11-15 shows a component that uses a ref to get the value of an uncontrolled <textarea> in
order to count the number of words in it.
LISTING 11- 15: Getting the value of a textarea and counting its words
import {useState,useRef} from 'react';
function WordCount(props){
const textAreaRef = useRef();
const [wordCount,setWordCount] = useState(0);
continues
280 ❘ CHAPTER 11 IntroducIng Hooks
LISTING 11-15 (continued)
const countWords = () => {
const text = textAreaRef.current.value;
setWordCount(text.split(" ").length);
}
return (
<>
<textarea ref={textAreaRef} /><br />
<button onClick={countWords}>Count Words</button>
<p>{wordCount} words.</p>
</>
)
}
export default WordCount;
Customizing Exposed Values with useImperativeHandle
The useImperativeHandle hook lets you create a “handle” or custom name for a value exposed to a
parent component using a ref. This is useful when using React.forwardRef to forward a ref attrib-
ute from one component to its child.
For example, in Listing 11-16, a component called CountingBox is created that contains a
<textarea>. The ref attribute passed into the CountingBox component will be forwarded and
attached to the <textarea>. The useImperativeHandle hook is then used to make a new property
of the ref.current object (called count in this case) available to the parent component.
LISTING 11- 16: Customizing a value exposed by a ref
import {useState,useRef,useImperativeHandle,forwardRef} from 'react';
const CountingBox = forwardRef((props, ref) => {
const [text,setText] = useState('');
useImperativeHandle(ref, () => {
return {count: text.split(" ").length}
},[text]);
return (
<>
<textarea value={text} onChange={(e)=>setText(e.target.value)} />
</>);
});
function TextEdit(props){
const countingBoxRef = useRef();
const [wordCount,setWordCount] = useState(0);
Writing Custom Hooks ❘ 281
const handleClick = (count) => {
setWordCount(count)
}
return (
<>
<CountingBox ref={countingBoxRef} /><br />
<button onClick={()=>handleClick(countingBoxRef.current.count)}>
count words
</button><br />
current count: {wordCount}<br />
</>
)
}
export default TextEdit;
NOTE Notice that useImperativeHandle has a third argument, which is a
dependency array (similar to that used by useEffect, useCallback, and
useMemo). In the current version of React, useImperativeHandle memoizes the
value of the handle, which can be a problem if you’re trying to get an updated
value (as in this case). Specifying a dependency that changes with each render
solves the problem.
The useImperativeHandle hook is the least important hook to fully understand. In most cases, any-
thing you want to do using useImperativeHandle can be better done by passing props from parent
components to child components.
Updating the DOM Synchronously with useLayoutEffect
The useLayoutEffect hook is identical to useEffect in every way, except in when and how it exe-
cutes. Whereas useEffect runs its functions asynchronously (that is, without blocking anything else)
after the component appears in the browser, useLayoutEffect runs its function before the DOM is
painted to the browser, and it runs synchronously.
The useLayoutEffect hook can be used in cases where an effect results in changes to the DOM and
where the useEffect hook may cause flicker or inconsistent display of the results.
WRITING CUSTOM HOOKS
Custom hooks are functions that make use of the built- in hooks to encapsulate reusable functional-
ity. Many different custom hooks have been written and are available for free on the web, either by
themselves as standalone components, or as features within React libraries. You can also write your
own custom hooks.
282 ❘ CHAPTER 11 IntroducIng Hooks
Custom hooks, like the built-i n hooks, have names that start with use. This is a helpful convention
rather than a requirement. To write a custom hook, write a function that uses at least one built- in
hook and export a value from the function.
Listing 11-17 shows a custom hook based on the zipcode lookup component from earlier in this
chapter. When imported into a component, useZipLookup will take a zipcode as its argument and
return an array containing the corresponding city and state.
LISTING 11- 17: useZipLookup: a custom hook to return location data based on a ZIP code
import {useEffect,useState} from 'react';
function useZipLookup(zipcode){
const [city,setCity] = useState('');
const [state,setState] = useState('');
const API_URL = 'https://api.zip-
codes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';
const API_KEY = 'DEMOAPIKEY';
useEffect(()=>{
if (zipcode){
const loadAddressData = async ()=>{
const response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);
const data = await response.json();
setCity(data.City);
setState(data.State);
}
loadAddressData();
}
},[zipcode]);
return [city,state];
}
export default useZipLookup;
To use the useZipLookup hook, import it into a component, pass it a ZIP code, and deconstruct the
returned array into two local variables, as shown in Listing 11-18.
LISTING 11- 18: Using the useZipLookup custom hook
import {useRef,useState} from 'react';
import useZipLookup from './useZipLookup';
function ShippingAddress2(props){
const [zipcode,setZipcode] = useState('');
const [city,state] = useZipLookup(zipcode);
Labeling Custom Hooks with useDebugValue ❘ 283
const setZip = (e)=>{
e.preventDefault();
setZipcode(e.target.zipcode.value);
}
return (
<form onSubmit={setZip}>
Zipcode: <input type="text" name="zipcode" />
<button type="submit">Lookup City/State</button><br />
City: {city}<br />
State: {state}<br />
</form>
)
}
export default ShippingAddress2;
By creating the useZipLookup custom hook, we’ve made this functionality reusable and we simplified
the component that outputs the user interface.
LABELING CUSTOM HOOKS WITH USEDEBUGVALUE
When you use a custom hook, it shows up in the React Developer Tools as a hook when you inspect a
component, as shown in Figure 11-8.
FIGURE 11- 8: Inspecting a custom hook
It can be helpful for debugging in some cases to output a value from a custom hook. Normally, the
time- honored practice of JavaScript developers everywhere is to use console.log to output debug-
ging code to the console. However simple this may be, it doesn’t provide any context as to what
284 ❘ CHAPTER 11 IntroducIng Hooks
function wrote the log message, unless you add that information into the console.log message.
Logged messages tend to build up in your code over time, unless you’re careful about removing them
when you no longer need them. But, when you remove them, you often end up adding them again
when you’re debugging something related. Logging to the console, while essential sometimes, is less
than ideal.
The useDebugValue hook lets you export a value from a custom hook that will be visible next to the
name of the hook in the React Developer Tools component inspector. This value can be anything you
want. Listing 11-19 shows how to use useDebugValue in the useZipLookup component to display
the value of the zipcode parameter passed into it.
LISTING 11- 19: Using useDebugValue
import {useEffect,useState,useDebugValue} from 'react';
function useZipLookup(zipcode){
const [city,setCity] = useState('');
const [state,setState] = useState('');
useDebugValue(zipcode);
const API_URL = 'https://api.zip-
codes.com/ZipCodesAPI.svc/1.0/QuickGetZipCodeDetails/';
const API_KEY = 'DEMOAPIKEY';
useEffect(()=>{
if (zipcode){
const loadAddressData = async ()=>{
const response = await fetch(`${API_URL}${zipcode}?key=${API_KEY}`);
const data = await response.json();
setCity(data.City);
setState(data.State);
}
loadAddressData();
}
},[zipcode]);
return [city,state];
}
export default useZipLookup;
Figure 11-9 shows how the value from useDebugValue displays in the component inspector.
The useDebugValue hook can also optionally accept a formatting function as its second parameter.
This function receives the debug value and can be used for doing conversions or other formatting to
the debug value. The function only runs when the hook is actually being inspected.
Finding and Using Custom Hooks ❘ 285
FIGURE 11- 9: Viewing a Custom Hook’s debug value
One example of where using the formatting function is helpful would be a case where a date is stored
as a UNIX timestamp, but you want to be able to view it in the component inspector in a human-
readable form. By using the formatting function, you can avoid doing the conversion except when the
hook is actually being inspected. Here’s what that might look like, using a function from the moment
.js date library:
useDebugValue(timestamp, timestamp=>timestamp.format("HH/mm/ss"));
FINDING AND USING CUSTOM HOOKS
Custom hooks deliver on React’s promise of a simple way for developers to share reusable compo-
nents. Thousands of custom hooks have been created for just about any common functionality that a
developer might need.
Unfortunately, finding out which custom hooks are available isn’t always easy, and this is complicated
by hooks that have the same purpose and name but are part of different Node.js packages and have
different APIs. Here are a few of the more popular custom hooks that are currently available.
use- http
The useFetch hook that’s part of the use- http package (https://use- http.com) makes isomor-
phic HTTP requests. What this means is that it can be used both on the server and in the browser.
It features caching, TypeScript support, automatic aborting of pending requests when a component
unmounts, React Native, GraphQL, and retrying.
286 ❘ CHAPTER 11 IntroducIng Hooks
react- fetch- hook
React Fetch Hook’s useFetch hook (https://www.npmjs.com/package/react- fetch- hook) takes
a URL and a response formatter function as parameters and returns a Boolean named isLoading and
formatted data. In its most basic form, using this hook looks like this:
const {isLoading,data} = useFetch("http://example-u rl.com/api/users/1");
axios- hooks
The useAxios hook (https://www.npmjs.com/package/axios- hooks) executes HTTP requests
using the popular Axios library. It takes a URL and an options object as parameters and returns an
object containing data, the loading status, and any error message that was returned by the URL. It
also returns a function that you can use to manually execute the HTTP request.
Listing 11-20 shows a simple example of using the useAxios hook.
LISTING 11- 20: Using useAxios
import {useState} from 'react';
import useAxios from 'axios- hooks';
import {API_KEY} from './config';
function WeatherWidget() {
const [city,setCity] = useState('London');
const [{data, loading, error}, refetch] =
useAxios(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${API_KEY}`);
if (loading) return <p>Loading...</p>;
if (error) return <p>There was an error. {error.message}</p>;
return (
<>
<input type="text" value={city} onChange={e=>setCity(e.target.value)} />
<pre>{JSON.stringify(data,null,2)}</pre>
</>
);
}
export default WeatherWidget;
react- hook- form
React Hook Form’s useForm hook makes building forms and validating data input simple. The
useForm hook returns a function called register() that you can pass as a ref to uncontrolled inputs
with name attributes. The handleSubmit() method returned by useForm will then handle all of the
data from your form.
You can pass options to each register() function to validate fields, make them required, and
specify other limits such as minimum and maximum values.
Listing 11-21 shows a basic use of useForm.
Finding and Using Custom Hooks ❘ 287
LISTING 11- 21: Using useForm
import {useForm} from 'react- hook- form';
function SignUpForm() {
const {register, handleSubmit} = useForm();
const onSubmit = data => {
console.log(data);
};
return (
<form onSubmit = {handleSubmit(onSubmit)}>
<label>First Name: </label>
<input name="firstname" {...register("firstname",{required:true})} />
<label>Last Name: </label>
<input name="lastname" {...register("lastname",{required:true})} />
<input type="submit" />
</form>
);
}
export default SignUpForm;
@rehooks/local- storage
The useLocalStorage hook, which is part of the Rehooks library (https://github.com/rehooks),
provides functions for working with the browser’s local storage. Browser local storage is useful for
storing data between browser sessions. This is helpful for creating offline apps, for increasing the
performance of a web app, and for remembering the user’s state between sessions.
Another feature of useLocalStorage is that it can sync data between browser tabs.
use- local- storage- state
The useLocalStorageState hook (https://www.npmjs.com/package/use- local- storage-
state) takes a key and an optional default value and returns an array with three values: a value, a
setter function, and a Boolean named isPersistent. Here’s an example:
const [reminders, setReminders, isPersistent] =
useLocalState('reminders',['sleep','eat food']);
The first two return values work the same as the values returned by useState. The third tells
you whether the value is stored in memory or in local storage. By default, of course, any
value you create using useLocalStorageState will be stored in localStorage. In the event that
localStorage isn’t available for some reason, useLocalStorageState will fall back to just keeping
the value in memory.
288 ❘ CHAPTER 11 IntroducIng Hooks
Other Fun Hooks
Going beyond the basic tasks that are used in most modern user interfaces, other custom hooks
encapsulate functionality that’s more specialized or even just for fun. Here are a few custom hooks
that fall into this category:
➤➤ The useGeolocation hook (https://github.com/streamich/react- use) tracks a user’s
geographic location.
➤➤ The useNetworkStatus hook (https://github.com/rehooks/network- status) returns
information about a user’s current network status.
➤➤ The useKonomiCode hook (https://stackblitz.com/edit/use- konami- code) is an eas-
ter egg hook for detecting when a user has entered the famous Konomi Code (↑ ↑ ↓ ↓ ← →
← → B A), which is used as a cheat code in many video games.
Lists of Hooks
Finding custom hooks for just about any purpose is becoming easier thanks to some great lists of
hooks being maintained and updated by the React community. Here are a few of the lists of hooks
that are currently available:
➤➤ Hooks.guide (https://hooks- guide.netlify.app/). A curated and categorized
list of hooks.
➤➤ Collection of React Hooks (https://nikgraf.github.io/react- hooks/). A searchable
collection of hooks that anyone can add to.
➤➤ Use Hooks (https://use- hooks.org/). Provides a tool for scaffolding React hooks and a
list of hooks created using the scaffolding.
SUMMARY
Hooks aren’t just a new and better way of doing something in React; they dramatically improve the
entire React development experience, they make learning React easier, and they solve the problem of
creating a standard and simple way to share code between components.
In this chapter, you learned:
➤➤ What React Hooks are.
➤➤ Why React Hooks were created.
➤➤ How to use each of the built-i n hooks.
➤➤ How to use and create custom hooks.
➤➤ How to find pre-b uilt custom hooks.
In the next chapter you’ll learn how to manage complex user interfaces and applications by associat-
ing URLs with components and layouts using React Router.