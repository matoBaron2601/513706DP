
16
Fetching and Caching Data
It’s possible to build great user interfaces that are self- contained and don’t need to interact with
the outside world (such as many games, calculators, and utilities). But, most web apps have a
need to receive and store data.
In this chapter, you’ll learn:
➤➤ When to fetch and store data in React.
➤➤ How to use window.fetch.
➤➤ What promises are.
➤➤ How async/await works.
➤➤ How to simplify network requests with Axios.
➤➤ How to store data in localStorage.
➤➤ How to read data from localStorage.
ASYNCHRONOUS CODE: IT’S ALL ABOUT TIMING
Whenever you update state, do a side effect, or store data in the user’s browser, these tasks take
time. One of the trickiest, but also most important, skills that a React developer needs to have is
learning how to properly handle asynchronous tasks.
With state updates, ReactDOM handles everything for you. You simply call setState (in a
class component) or pass data to a function returned by the useState hook (in a function
component). Most of the time, the asynchronous nature of setting React state is seamless and
invisible to the developer and the user.
With network and cache requests, on the other hand, every request has the potential to
adversely impact the user experience. In the worst case, a remote resource won’t be available.
More often, the amount of time a request takes will be wildly variable, depending on the user’s
internet connection, network congestion, and the remote server’s current workload.
370 ❘ CHAPTER 16 Fetching and caching data
JavaScript itself is rarely the issue—J avaScript is fast and usually only gets bogged down if the devel-
oper made a mistake (such as creating an infinite loop or a memory leak). One reason why JavaScript
is so fast and the reason that handling asynchronous code correctly is so important is that JavaScript
doesn’t wait for anything.
JAVASCRIPT NEVER SLEEPS
JavaScript doesn’t have a sleep or wait command. Instead, a JavaScript engine (such as the V8 Engine
built into the Chrome web browser and Node.js) starts at the beginning of your script and runs the
code as fast as it can, using a single thread. Because JavaScript is single- threaded, it must complete the
previous statement before moving on to the next.
The call stack in a JavaScript engine is where commands waiting to be executed sit until they can be
executed in a First In Last Out (FILO) order.
You might be asking yourself at this point how it’s possible to do asynchronous tasks (like network
requests and caching data) in JavaScript with only one thread. The answer is that although JavaScript
itself is single- threaded, the environment in which it runs (your browser or Node.js) is multithreaded.
Asynchronous tasks (like network requests) are handled by parts of the browser that are outside of
the JavaScript engine, such as the Web APIs, in conjunction with two other parts of the runtime envi-
ronment outside of JavaScript: the event loop and the callback queue.
Consider the following code:
console.log("get ready...");
setTimeout(() => {
console.log("here it is!");
}, 1000);
console.log("end of the code.");
The result of running this code in a browser console is shown in Figure 16-1.
What’s going on here is that when this program starts up, three function calls are added to the call
stack to be executed in order. After the first statement is executed and removed from the call stack,
JavaScript sees the setTimeout() function, which creates an event that is only indirectly managed
by JavaScript. It hands it off to the browser to execute, and then removes it from the call stack.
Java Script can then move on to the third statement.
The Web API, in the meantime, waits for one second (because of the 1,000-millisecond timeout
length you passed to it) and then adds your callback function to the browser’s callback queue. The
event loop (which is in charge of listening for events and registering event listeners in the JavaScript
environment) picks up the function from the callback queue and adds it to JavaScript’s call stack to
be executed.
Figure 16-2 shows a diagram of the whole process.
Callback functions, which get executed upon completion of an asynchronous task, are how
Java Script programmers can write code that depends on the result of that asynchronous task. If you
want to have multiple asynchronous tasks that happen in a particular order, you can put them inside
the callback functions from other asynchronous tasks, as shown in Listing 16-1.
JavaScript Never Sleeps ❘ 371
FIGURE 16- 1: Executing asynchronous JavaScript
JavaScript
Web APIs
Call
Stack DOM
Fetch
setTimeout
Callback Queue
Event Loop
FIGURE 16- 2: How asynchronous tasks are handled
372 ❘ CHAPTER 16 Fetching and caching data
LISTING 16- 1: Callbacks within callbacks
function userCheck(username, password, callback){
db.verifyUser(username, password, (error, userInfo) => {
if (error) {
callback(error)
}else{
db.getRoles(username, (error, roles) => {
if (error){
callback(error)
}else {
db.logAccess(username, (error) => {
if (error){
callback(error);
}else{
callback(null, userInfo, roles);
}
})
}
})
}
})
};
In the preceding example, what should happen when the userCheck() function is called (absent any
errors) is the following:
1. Verify the user’s credentials.
2. Get the user’s access permissions.
3. Create a log entry.
Nested callbacks can be difficult to read, however, so more intuitive ways to perform tasks in
response to asynchronous tasks have been created— namely promises and async/await.
JAVASCRIPT LESSON: PROMISES AND ASYNC/AWAIT
This JavaScript lesson examines promises, async, and await.
Promises
A promise is a placeholder for the result of an asynchronous action. It lets you write
asynchronous code in a synchronous way, but instead of returning the final value, it
returns a “promise” to return the final value at some point.
Promises can be in one of three states:
➤➤ Pending: This is the initial state of a promise.
➤➤ Fulfilled: The operation was completed successfully.
➤➤ Rejected: The operation failed.
JavaScript Never Sleeps ❘ 373
When a promise becomes fulfilled, it can be chained to additional promises using the
then method, as in the following example:
receiveHamburger
.then(eatHamburger)
.then(payForHamburger)
In order for the preceding code to work, each of the functions must return a Promise
object. For example, here’s what the receiveHamburger function might look like:
const receiveHamburger = function(){
return new Promise((resolve,reject) => {
getHamburger((result) => {
resolve(result);
})
))
};
If something goes wrong and the promise is rejected, the catch method can be used
to handle the error:
receiveHamburger
.then(eatHamburger)
.then(payForHamburger)
.catch((err)=>{ //handle the error here }
async/await
Promises are great, but they still require the use of callbacks. A couple of the best
improvements to how asynchronous code is written are the async and await state-
ments. With async and await, you can write code that really does look synchronous.
For example, here’s our hamburger example written with async and await:
const tradeForHamburger = async function() {
try {
await receiveHamburger();
await eatHamburger();
await payForHamburger();
} catch(e) {
// handle errors
}
}
Although async/await is an abstraction of promises, it’s easier to write and read than
either callbacks or promises. Behind the scenes, an async function always returns a
Promise. If the return value of an async function isn’t explicitly a Promise, it will
be implicitly wrapped in one.
For example, the following function:
async function eatHamburger(){
return 1;
} continues
374 ❘ CHAPTER 16 Fetching and caching data
continued
is essentially the same as this one:
function eatHamburger(){
return Promise.resolve(1);
}
Once you make an async function, you can use the await keyword inside of it to
wait for any promise inside of it without having to make any changes to other func-
tions. Inside an async function, the await keyword will cause the function to wait
until the statement following it returns before moving on to the next statement.
WHERE TO RUN ASYNC CODE IN REACT
Asynchronous code, such as data fetching, can be done at several points in the life of a component,
including:
➤➤ When the component first mounts.
➤➤ In response to a user action (such as clicking a button).
➤➤ In response to changes in the component (such as receiving new props).
➤➤ In response to timers (such as apps that refresh periodically).
In a class component, initial data can be loaded using the componentDidMount lifecycle method,
and updates to data in response to component changes can be done using the componentDidUpdate
method, as shown in Listing 16-2.
NOTE To try out Listing 16‑2 and Listing 16‑3, you’ll need a free API key from
https://newsapi.org/.
LISTING 16- 2: Loading initial data in a class component
import {Component} from 'react';
class NewsFeed extends Component {
constructor(props){
super(props);
this.state={
news:[]
}
}
componentDidMount(){
fetch('https://newsapi.org/v2/top-h eadlines?country=us&apiKey=[YOUR KEY]')
Where to Run Async Code in React ❘ 375
.then(response => response.json())
.then(data => {
this.setState({news:data.articles})})
.catch(error => console.error(error))
}
render(){
const todaysNews = this.state.news.map((article)=>{
return (<p>{article.title}</p>);
})
return(
<>
<h1>Today's News</h1>
{todaysNews}
</>
)
}
}
export default NewsFeed;
In a function component, the useEffect hook can be used for fetching a component’s initial data as
well as in response to the component receiving new data, as shown in Listing 16-3.
LISTING 16- 3: Loading initial data in a function component
import {useState,useEffect} from 'react';
const NewsFeedFunction = () => {
const [news,setNews] = useState([]);
useEffect(()=> {
fetch('https://newsapi.org/v2/top-h eadlines?country=us&apiKey=[YOUR KEY]')
.then(response => response.json())
.then(data => {
setNews(data.articles)
})
.catch(error => console.error(error))
},[])
const todaysNews = news.map((article)=>{
return (<p>{article.title}</p>);
})
return(
<>
<h1>Today's News</h1>
{todaysNews}
</>
)
}
export default NewsFeedFunction;
376 ❘ CHAPTER 16 Fetching and caching data
WAYS TO FETCH
Once you know how and where to run asynchronous code in React components, the rest is just a
matter of knowing the properties and methods of the tool you want to use and knowing the structure
of the data source.
Most single page web applications access data sources using web APIs based on the REST archi-
tecture style. Data sent and received between a user interface and a RESTful API is usually in the
JSON format.
JAVASCRIPT LESSON: REST
Representational State Transfer, or REST, is an architectural style for application
programming interfaces (APIs). RESTful APIs use HTTP requests to get, add, update,
and delete data using unique URLs. RESTful APIs rely on the fact that HTTP has
built into it different methods for accessing resources. REST maps these methods to
operations that can be performed using the API:
➤➤ To fetch data, use the HTTP GET method.
➤➤ To add data, use the HTTP POST method.
➤➤ To update data, use the HTTP PUT method.
➤➤ To delete data, use the HTTP DELETE method.
For example, to get data about a user with an ID of 23 using a RESTful API, you
might make an HTTP GET request to the following URL:
https://www.example.com/user/23/
To delete the user with the ID of 23, you would use the HTTP DELETE method to
access that same URL.
To try out a RESTful API, open a browser window and enter the following URL into
the address bar:
https://api.github.com/users/facebook/repos
This will do an HTTP GET to retrieve a list of Facebook’s repositories on GitHub
and display the returned JSON in the browser window.
To fetch and return the data from this same URL in a JavaScript program, you can
use the Fetch API along with Promises:
fetch('https://api.github.com/users/facebook/repos', {
method: 'GET',
headers: {
'Content- Type': 'application/json'
}
})
.then(response => response.json())
.then(data => {
console.log('Success:', data);
})
Getting Data with Axios ❘ 377
GETTING DATA WITH FETCH
window.fetch is a method built into all modern browsers that allows you to perform HTTP requests
from JavaScript without loading a separate library. Listing 16-4 shows an example of using the Fetch
API to fetch data and log it to the console in a React component.
LISTING 16- 4: Using Fetch in response to events
import {useState} from 'react';
function Restful(){
const [repos,setRepos] = useState([]);
const [status,setStatus] = useState();
const getRepos = function(){
fetch('https://api.github.com/users/facebook/repos')
.then(response => response.json())
.then(data => {
setRepos(data);})
.then(setStatus("fetched"))
.catch(error => console.error(error))
}
const logRepos = function(){
console.log(repos);
}
return(
<>
<button onClick={getRepos}>{status?"Fetched":"Fetch Repos"}</button>
<button onClick={logRepos}>Log Repos</button>
</>
)
}
export default Restful;
GETTING DATA WITH AXIOS
Axios is a popular AJAX library that you can use instead of the browser’s native Fetch API. Axios has
advantages over window.fetch in terms of ease of use and capabilities, but using it does require you
to load a separate library.
To install Axios, use the following command:
npm install axios
378 ❘ CHAPTER 16 Fetching and caching data
Axios has a method named axios that takes a configuration object as its parameter. The configu-
ration object can contain many different properties, but the only ones required to perform a basic
HTTP GET request are method and url:
axios({
method: 'GET',
url:'https://api.github.com/users/facebook/repos'
});
Like the window.fetch method, the axios method returns a Promise, which you can then chain to
additional methods to work with the returned data.
Unlike window.fetch, axios automatically decodes the returned JSON data. What this means is that
when you use Axios, you don’t need to convert the response to JSON data before you can make use
of it as you do with window.fetch.
Listing 16-5 shows an example of using Axios to perform a GET request in a component.
LISTING 16- 5: Performing a GET request with Axios
import {useState} from 'react';
import axios from 'axios';
function Restful(){
const [repos,setRepos] = useState([]);
const [status,setStatus] = useState();
const getRepos = function(){
axios({
method:'get',
url:'https://api.github.com/users/facebook/repos'
}).then(resp => {setRepos(resp.data);})
.then(setStatus("fetched"))
.catch(error => console.error(error))
}
const logRepos = function(){
console.log(repos);
}
return(
<>
<button onClick={getRepos}>{status?"Fetched":"Fetch Repos"}</button>
<button onClick={logRepos}>Log Repos</button>
</>
)
}
export default Restful;
In addition to the axios method, Axios also provides convenience functions for each HTTP
method. The convenience functions are aliases to full axios calls that you can use without passing a
Using Web Storage ❘ 379
configuration object. The convenience methods include:
➤➤ axios.get
➤➤ axios.post
➤➤ axios.delete
➤➤ axios.put
Using one of these methods can be as easy as passing it the URL for the request, like this:
axios.get('/user/1');
Both GET and DELETE calls are frequently made without passing any additional data, since all of the
data required to perform their actions on the server are contained in the URL. The POST and PUT
methods require a payload. That can be specified using the data property in the config object.
For example, to post data from a signup form using Axios, you might use the following:
axios.post('/user/',{
firstName:'Frank',
lastName:'Columbo',
email:'f.columbo@lapdonline.org'
});
USING WEB STORAGE
Web applications, by default, don’t persist data between sessions. What this means for React user
interfaces is that if a user leaves your application and returns later, or refreshes the browser window,
the state data returns to the initial state.
One solution to persisting data between sessions is to save data on the server and associate it with the
user’s login info or a unique key stored in a browser cookie. When the user visits the app again, they
can log in or the cookie can be read and the data can be downloaded from the server.
Downloading from the server is slow and inefficient, however, and if you can store data locally, you’ll
improve the performance of a user interface. The Web Storage API, which is supported by all modern
browsers, is an easy way to store key/value pairs of string data in a user’s browser.
Two Types of Web Storage
Web Storage includes two objects, window.sessionStorage and window.localStorage. Both
properties work the same: they access a Storage object that stores data associated with the current
application, as identified by its origin. A web application’s origin is made up of the protocol (HTTP
or HTTPS), host domain, and port. Web Storage provides at least 5MB of storage per origin.
The difference between sessionStorage and localStorage is that sessionStorage only lasts as
long as the current browser tab is open, while localStorage persists between tabs and sessions.
Because localStorage gives you all the benefits of sessionStorage plus persistence between
sessions, it’s more commonly used.
380 ❘ CHAPTER 16 Fetching and caching data
When to Use Web Storage
Web Storage can be used to remember where the user was in an application the last time they visited.
For example, if your application includes a lengthy form, the user’s input into that form can be saved
to Web Storage so that if something happens (such as a browser crash) while they’re filling it out,
they can return to the form and continue where they left off. One simple and common use for Web
Storage is to remember a user’s login name between sessions, such as in the user interface shown in
Figure 16-3.
FIGURE 16- 3: Remembering a user with Web Storage
When Not to Use Web Storage
Web Storage can’t save data between browsers, different computers, or different origins and it will be
erased if a user clears their browser’s cache. For these reasons, it’s not a replacement for storing data
on a server that can be downloaded to any device with internet access. Instead, Web Storage should
be used like a temporary cache of data entered by the user or downloaded from the server.
Web Storage should also never be used for storing sensitive data, such as credit card info or pass-
words. Although the same-o rigin policy provides some security from other sites being able to read
data stored in an application’s Web Storage, it’s not much protection. If one of the hundreds of mod-
ules that make up a JavaScript application were to be compromised, code could be inserted into it to
access and transmit stolen Web Storage data to a remote server.
Web Storage Is Synchronous
Although Web Storage is useful for improving the performance of your application, it can also cause
performance problems if overused. Unlike APIs for retrieving data from servers (such as Fetch) and
even other local storage APIs (such as indexedDB), Web Storage is synchronous. Each call to read or
write from Web Storage blocks the execution of your app until the operation is complete.
That said, Web Storage is very fast. In most cases, using Web Storage to avoid making an HTTP
request will improve the performance of your user interface. But, be careful not to overuse it.
Using Web Storage ❘ 381
Working with localStorage
To demonstrate how to use localStorage, we’ll start with a simple app that doesn’t use
localStorage. Listing 16-6 shows a simple counter web application that could be used on a mobile
device by someone at a retail store, for example. Every time the button is clicked, it increments
a counter.
LISTING 16- 6: A Clicker app
import {useState} from 'react';
import './style.css';
function Clicker(){
const [count,setCount] = useState(0);
const incrementCount = ()=>{
setCount((prev)=>prev+1);
}
return(
<div className="container">
<h1 className="current-c ount">{count}</h1>
<button className="increment-b utton"
onClick={incrementCount}>+</button>
</div>
)
}
export default Clicker;
The idea of the Clicker app is that the staff can use it to keep track of how many people visit the store
during a day. But, as it’s written now, the data is erased each time you leave the page and return. To
fix it, we can cache its value locally.
Storing Data with localStorage
To store a key/value pair in localStorage, use the setItem method. This method takes two
arguments— the key and the value:
localStorage.setItem('zipcode', '97103');
Keep in mind that Web Storage can only store string data. If you want to store another data type in
Web Storage, you’ll need to convert it to a string and then back again when you read it.
Because storing data in localStorage is a side effect, the best place to put a call to setItem is inside
the useEffect hook (in a function component) or in a lifecycle method (in a class component). You
can use the second parameter of useEffect to specify that the effect should run each time the state
value you want to store changes, as shown in Listing 16-7.
382 ❘ CHAPTER 16 Fetching and caching data
LISTING 16- 7: Writing to localStorage when the state changes
import {useState,useEffect} from 'react';
import './style.css';
function Clicker(){
const [count,setCount] = useState(0);
const incrementCount = ()=>{
setCount((prev)=>prev+1);
}
useEffect(()=>{
localStorage.setItem('counter',count);
},[count]);
return(
<div className="container">
<h1 className="current-c ount">{count}</h1>
<button className="increment-b utton"
onClick={incrementCount}>+</button>
</div>
)
}
export default Clicker;
To verify that the value is being written to localStorage, you can open Chrome’s developer console
and go to the Application tab. You’ll find an entry in the left pane of the Application tab for Local
Storage, as shown in Figure 16-4.
Reading Data from localStorage
Now that the Clicker app is storing data in localStorage, the next thing to do is to load that data
when the page loads. To get data out of localStorage, use the getItem method, which takes a key
you want to get from localStorage and returns the value:
localStorage.getItem('zipcode');
The easiest place to retrieve cached data in a function component is in the initial state parameter of
useState. By using a conditional operator, you can update the initial state to be set to the value from
localStorage if it exists, and to a default value if it doesn’t.
Listing 16-8 shows the Clicker app with the value of count being set to the cached value when
it exists.
Using Web Storage ❘ 383
FIGURE 16- 4: Viewing Local Storage in Chrome Developer Tools
LISTING 16- 8: Reading localStorage data in Clicker
import {useState,useEffect} from 'react';
import './style.css';
function Clicker(){
const [count,setCount] = useState(Number(localStorage.getItem('counter')) || 0);
const incrementCount = ()=>{
setCount((prev)=>prev+1);
}
useEffect(()=>{
localStorage.setItem('counter',count);
},[count]);
continues
384 ❘ CHAPTER 16 Fetching and caching data
LISTING 16-8 (continued)
return(
<div className="container">
<h1 className="current-c ount">{count}</h1>
<button className="increment-b utton"
onClick={incrementCount}>+</button>
</div>
)
}
export default Clicker;
Now the Clicker will increment and remember data every time it’s accessed. The next step is to
implement a way for the counter to be reset.
Removing Data from localStorage
To remove data from localStorage, you can use one of two methods:
➤➤ removeItem takes a key as its argument, and removes that key from localStorage.
➤➤ clear clears all of the keys for the current origin.
Since the Clicker app only has one key, we can use either method to reset localStorage. But,
because we’re using an effect to update localStorage when the counter changes, we could also just
implement a reset button that changes the counter to 0. One thing to watch out for when resetting
localStorage or removing keys is that resetting the localStorage value by itself won’t change the
current state of the application.
In Listing 16-9, the Clicker has been updated with a Reset button that both clears the localStorage
and sets the value of the counter to 0.
LISTING 16- 9: Clearing localStorage in the Clicker
import {useState,useEffect} from 'react';
import './style.css';
function Clicker(){
const [count,setCount] = useState(Number(localStorage.getItem('counter')) || 0);
const incrementCount = ()=>{
setCount((prev)=>prev+1);
}
const resetCount = ()=>{
localStorage.clear();
setCount(0);
}
Summary ❘ 385
useEffect(()=>{
localStorage.setItem('counter',count);
},[count]);
return(
<div className="container">
<h1 className="current-c ount">{count}</h1>
<button className="increment-b utton"
onClick={incrementCount}>+</button><br />
<button className="reset- button"
onClick={resetCount}>reset</button>
</div>
)
}
export default Clicker;
SUMMARY
Although React doesn’t have its own AJAX and browser storage capabilities, integrating the
native browser APIs or third- party APIs for these common tasks is easily done from within React
components.
In this chapter, you learned:
➤➤ How JavaScript runs asynchronous code.
➤➤ How to use promises.
➤➤ How to use async/await.
➤➤ How to make HTTP requests using window.fetch.
➤➤ How to make HTTP requests using Axios.
➤➤ How to store, retrieve, and delete data using Web Storage.
In the next chapter, you’ll learn how to use React’s Context API to share global data in a component
tree.