7
Events
Events, and the functions that run in response to events, are what make React reactive. In this
chapter, you’ll learn:
➤➤ How and where to use event listeners.
➤➤ The difference between native events and SyntheticEvents.
➤➤ How to write event handlers in class and function components.
➤➤ How to use the Event object.
➤➤ How to bind functions to class components.
➤➤ How to pass data to event handlers.
➤➤ How to use arrow functions for inline event handlers.
➤➤ How passing functions to child components works.
HOW EVENTS WORK IN REACT
To put it simply, listening for events in a React component and handling events is done similarly
to how HTML event attributes trigger actions in a browser.
In HTML, it’s possible to use event attributes to call JavaScript functions. These event attrib‑
utes have names starting with “on” and they take a function call as their value. For example,
the HTML onsubmit event attribute can be used with the <form> element to invoke a func‑
tion when the form is submitted. Listing 7‑1 shows an example of using the HTML onsubmit
attribute. This example assumes that a JavaScript function named validate() has been defined
or imported elsewhere in the HTML file.
200 ❘ CHAPTER 7 EvEnts
LISTING 7- 1: Using an event attribute in HTML
<form id="signup- form" onsubmit="validate()">
<input type="text" id="email">
<input type="text" id="fullname">
<input type="submit">
</form>
Because HTML event attributes violate the “separation of concerns” rule that says markup and
scripts should be kept separate, it’s generally not a good practice to rely on them too heavily in web
apps. Instead, most JavaScript programmers use the addEventListener DOM method to attach
event listeners to HTML elements, as shown in Listing 7‑2.
LISTING 7- 2: Using addEventListener
<html>
<head>
<script>
function validate(e){
//do something here
}
</script>
</head>
<body>
<form id="signup- form">
<input type="text" id="email">
<input type="text" id="fullname">
<input type="submit">
</form>
<script>
document.getElementById("signup-f orm").addEventListener("submit",validate);
</script>
</body>
</html>
NOTE In Listing 7‑2, the event listener is registered at the end of the body of
the document, so the form element will be loaded beforehand. Another way
to accomplish the same thing is to add another event listener to the document
that waits until the entire page (the HTML document) is loaded before regis‑
tering event listeners.
In React, setting event listeners is a hybrid between the two approaches for doing so in HTML. The
syntax in the JSX code looks very similar to an HTML event attribute, but because it’s JSX, it actually
compiles to something that more closely resembles using addEventListener.
What Is SyntheticEvent? ❘ 201
Listing 7‑3 shows how to set an event listener in a React component to listen for a form’s
submit event.
LISTING 7- 3: Setting an event listener in a React component
function MyForm(props){
return (
<form onSubmit={props.handleSubmit}>
<input type="text" id="fullName" />
<input type="text" id="phoneNumber" />
<button>Submit</button>
</form>
);
}
export default MyForm;
As you’ll frequently see in React, it would seem that the use of an event listener attribute would
violate the same separation of concerns rule that dictates that the use of event attributes in HTML
should be avoided. However, keep in mind that JSX is, essentially, JavaScript. So, in reality, it’s not
that you’re using HTML to trigger JavaScript, but that you’re using JavaScript to write HTML and to
add an event listener to the form element created using JavaScript.
The two biggest clues as to what’s really going on when you write event attributes in JSX are:
1. As with the DOM addEventListener method, React event attributes take a function,
rather than a string containing a function call, as their value. The value of a React event
attribute must be in curly braces and it should not have the pair of parentheses after the
function name.
2. React event attributes use JavaScript‑s tyle camelCase names, rather than the HTML‑ style
lowercase attribute names used by HTML event attributes.
React events are actually a wrapper around native HTML DOM events, which take the same names
as the native events (albeit with different capitalization). These wrapped events are instances of a
React class called SyntheticEvent.
WHAT IS SYNTHETICEVENT?
SyntheticEvent is a cross‑ browser wrapper around the browser’s native events. Historically, web
browsers have always had slightly different ways of handling events. Most famously, in Microsoft’s
now defunct Internet Explorer browser, the event object was a global property of the browser’s
window object, whereas in Chrome and Firefox, it was a property passed to event handlers (as is the
case with SyntheticEvent). Another important difference between how browsers handle events is at
what point in the propagation of events do the event listeners handle them. Today, every modern
browser handles events during the event “bubbling” phase, but in the earlier days of web browsers,
Internet Explorer handled events during the “capture” phase.
202 ❘ CHAPTER 7 EvEnts
NOTE Event bubbling refers to the upward propagation of an event from
a lower level in the element hierarchy to a higher one. Event capture is the
opposite. In event bubbling, an event that happens on a button (such as a
click) is dispatched by the button before the form element that contains the
button dispatches it.
These historic and major differences between how web browsers handle events have largely been
ironed out, and today the real value of having a cross‑ browser wrapper for events is that it can pro‑
vide additional and consistent properties across every browser.
SyntheticEvent also shields developers from the implementation details of exactly how events in React
are translated to DOM events in the browser. The React documentation is intentionally vague about
exactly how SyntheticEvents map to native events (although it is possible to find this out, as you’ll
see). Except in rare cases, these details won’t matter to a React developer, and because these details
are not part of the official React documentation, they are subject to change at any time.
USING EVENT LISTENER ATTRIBUTES
To create an event listener in React, use one of the supported event listener attributes on a built‑i n
HTML DOM element. If the HTML event that will be created by a React component supports a
certain event, it should also be supported by the React component, except in a few cases where things
work differently in React.
Using an event listener attribute in an element created by a custom component won’t have any effect
on the custom component except to create a prop inside of it with same name as the event listener
attribute. For example, inside the following element, a prop named onClick will be created:
<MyButton onClick={handleEvent} />
The preceding onClick attribute is not an event listener attribute. It’s common to use the names of
event listener attributes to pass event handlers between custom components, but doing so doesn’t
actually add the event listener to the resulting browser DOM.
In order for the MyButton component to actually be able to handle events, you must have an HTML
DOM element inside the MyButton component that has an event listener attribute. For example,
here’s what the return statement of the MyButton component might look like:
return (
<button onClick={props.onClick}>Click Me</button>
);
The Event Object ❘ 203
THE EVENT OBJECT
When an event happens in React, it triggers an event in the DOM. This, in turn, creates an instance
of the Event object, which triggers the creation of a SyntheticEvent object in React. This is what we
mean by SyntheticEvent being a wrapper around native DOM events.
The Event object contains the properties and methods that are common to all events. The most
important of these base Event properties and methods are the following:
➤➤ Event.cancelable indicates whether an event can be canceled. Canceling an event prevents
the event from happening. Canceling events is useful when you want to prevent a user from
clicking something or to prevent a form element from submitting a form, for example.
➤➤ Event.target references the object onto which the event was originally dispatched (such as
an element that was clicked or a form input that was typed into).
➤➤ Event.type contains the name of the event, such as click, change, load, mouseover,
and so forth.
➤➤ Event.preventDefault cancels an event if it’s cancelable.
The wrapper that React creates around the JavaScript Event object is named SyntheticBaseEvent.
To access the properties and methods of the SyntheticBaseEvent object, specify a parameter in
the function definition for your event handler. The SyntheticBaseEvent object will take the name
of this parameter inside the function. It’s a standard practice for this parameter to be named either
event or simply e, but there’s no restriction in React or JavaScript on what valid JavaScript variable
name you give it.
Listing 7‑4 is a React component that listens for a click event on a button and then prints out the
properties of the dispatched SyntheticBaseEvent object to the console.
LISTING 7- 4: Viewing the properties of the Event object
function EventProps(){
const logClick=(e)=>{
console.dir(e);
}
return(
<button onClick={logClick}>Click Me</button>
)
}
export default EventProps;
With modifications, this basic function can be used to view the properties of the SyntheticBaseEvent
object for any event. Figure 7‑1 shows the object that’s output to the console when you click the button
in this component.
204 ❘ CHAPTER 7 EvEnts
FIGURE 7- 1: Viewing the properties of a SyntheticEvent
The SyntheticBaseEvent object has a property called NativeEvent, which is an object that
contains all the properties from the native Event object that SyntheticBaseEvent wraps around.
Compare the properties in this NativeEvent object, shown in Figure 7‑2, with the properties in the
SyntheticEvent shown in Figure 7‑1.
SUPPORTED EVENTS
All interactivity in a web browser happens as a result of events. Events are what is emitted (or
“fired”) by software in reaction to interactions or significant things (including automated processes)
happening in the browser. For example, when a user clicks a mouse button while the pointer is
hovered over a button, that causes the button element to emit a click event. The movement of the
mouse pointer within the browser window and the mouse pointer hovering over an element trigger
additional events.
Supported Events ❘ 205
FIGURE 7- 2: The NativeEvent properties
Many DOM events are defined in official specifications, and others are defined and used by specific
browsers. These events can be detected using the HTML DOM and responded to using JavaScript
running in the browser.
React supports listening for and handling many of the standard DOM events. Many of these events
add properties to the Event object, which you can use to find out more about the event. For example,
the keyboard events include properties that tell which key was pressed.
Table 7‑1 lists the events that are currently supported within React, along with a brief description of
each one. To view the properties added to the Event object, you can log the Event object to the con‑
sole, as shown in Listing 7‑4, or visit the excellent Event API documentation available at https://
developer.mozilla.org/en- US/docs/Web/API/Event.
206 ❘ CHAPTER 7 EvEnts
TABLE 7-1 : Events Supported by React
CATEGORY EVENT LISTENER DESCRIPTION
Clipboard onCopy The copy event fires when data is copied to the
Events clipboard.
onCut The cut event fires when data is cut to the
clipboard.
onPaste The paste event fires when data is pasted from the
clipboard.
Composition onCompositionEnd The compositionend event fires when a text
Events composition system completes or cancels a session.
Text composition systems include input method
editors (IMEs) for entering Chinese, Japanese, or
Korean text using a Latin keyboard.
onCompositionStart The compositionstart event fires when a text
composition system starts a session.
onCompositionUpdate The compositionupdate event fires when a new
character is received during a composition session.
Keyboard onKeyDown The keydown event fires when a key is pressed.
Events
onKeyPress The keypress event fires when a key that produces
a character is pressed.
onKeyUp The keyup event fires when a key is released.
Focus Events onFocus The focus event fires when an element receives
focus, for example when an input element is
selected.
onBlur The blur event fires when an element loses focus,
for example when an input element becomes
unselected (by tabbing out of it or clicking another
input element).
Form Events onChange The change event is fired for input, select, and
textarea elements when the value of the input is
changed by the user.
onInput The input event fires when the value of an element
changes.
onInvalid The invalid event fires when a submittable
element’s content is checked and doesn’t meet
its constraints. For example, when a number input
receives a number outside of the range specified by
min and max attributes.
Supported Events ❘ 207
CATEGORY EVENT LISTENER DESCRIPTION
onReset The reset event fires when a form is reset.
onSubmit The submit event fires when a form is submitted.
Generic onError The error event fires when a resource fails to load.
Events
onLoad The load event fires when a resource finishes
loading.
Mouse onClick The click event fires when a pointing device (such
Events as a mouse) has been pressed and released.
onContextMenu The contextmenu event fires when the right mouse
button is clicked.
onDoubleClick The doubleclick event fires when the mouse
button is double- clicked.
onDrag The drag event fires while an element or text
selection is being dragged.
onDragEnd The dragend event fires when a drag event ends
(such as when the mouse button is released).
onDragEnter The dragenter event fires when a draggable
element enters a drop target.
onDragExit The dragexit event fires when a draggable
element exits a drop target. Note: onDragExit
may not work in all browsers. Use onDragLeave
instead.
onDragLeave The dragleave event fires when a draggable
element exits a drop target.
onDragOver The dragover event fires while a draggable
element is being dragged over a drop target.
onDragStart The dragstart event fires when the user begins
dragging an element.
onDrop The drop event fires when an element is dropped
on a drop target.
onMouseDown The mousedown event fires when a pointing device
button (such as a mouse button) is pressed on an
element.
onMouseEnter The mouseenter event fires when a pointing device
is moved onto an element.
continues
208 ❘ CHAPTER 7 EvEnts
TABLE 7-1 (continued)
CATEGORY EVENT LISTENER DESCRIPTION
onMouseLeave The mouseleave event fires when a pointing device
is moved off an element.
onMouseMove The mousemove event fires when a pointing device
is moved over an element.
onMouseOut The mouseout event fires when a pointing device
is moved off an element that has the onMouseOut
event listener attached to one of its children.
onMouseOver The mouseover event fires when a pointing
device is moved onto an element that has the
onMouseOver event listener attached to one of its
children.
onMouseUp The mouseup event fires when a pointing device
button is released over an element.
Pointer onPointerDown The pointerdown event fires when a pointer device
Events (such as a mouse, pen, or touch) becomes active,
for example when a button is clicked or a touch-
sensitive device is touched.
onPointerMove The pointermove event fires when a pointer
changes coordinates.
onPointerUp The pointerup event fires when a pointer is no
longer active.
onPointerCancel The pointercancel event fires when a browser
decides there are unlikely to be more pointer
events (such as when the browser window becomes
inactive).
onGotPointerCapture The gotpointercapture event fires when the
setPointerCapture method is used to capture a
pointer.
onLostPointerCapture The lostpointercapture event fires when a
captured pointer is released.
onPointerEnter The pointerenter event fires when a pointer
moves into the boundaries of an element on a
device that doesn’t support hover (such as a pen or
touch device with no mouse).
onPointerLeave The pointerleave event fires when a pointer
moves out of the boundaries of an element.
Supported Events ❘ 209
CATEGORY EVENT LISTENER DESCRIPTION
onPointerOver The pointerover event fires when a pointing
device moves into an element’s boundaries.
onPointerOut The pointerout event fires when a pointer leaves
the boundaries of an element.
Selection onSelect The select event fires when text is selected.
Events
Touch Events onTouchCancel The touchcancel event fires when a touch point
has been disrupted.
onTouchEnd The touchend event fires when a touch point is
removed from a touch surface.
onTouchMove The touchmove event fires when a touch point is
moved along a touch surface.
onTouchStart The touchstart event fires when a touch point is
placed on a touch surface.
UI Events onScroll The scroll event fires when the document or an
element is scrolled.
Wheel onWheel The wheel event fires when a wheel button of a
Events pointing device is rotated.
Media Events onAbort The abort event fires when playback of the media
is aborted.
onCanPlay The canplay event fires when enough data is
available that the media can start playing.
onCanPlayThrough The canplaythrough event fires when enough of
a media file is downloaded that the file can play
without interruption.
onDurationChange The durationchange event fires when the
metadata indicating the duration of the media
file changes, such as when enough of it has
downloaded that the duration is known.
onEmptied The emptied event fires when the media has
become empty, such as when it’s reloaded.
onEncrypted The encrypted event fires when the media
indicates that it’s encrypted.
onEnded The ended event fires when playback of the media
ends.
continues
210 ❘ CHAPTER 7 EvEnts
TABLE 7-1 (continued)
CATEGORY EVENT LISTENER DESCRIPTION
onError The error event fires when an error occurs.
onLoadedData The loadeddata event fires when the media has
finished loading.
onLoadedMetadata The loadedmetadata event fires when the media’s
metadata is loaded.
onLoadStart The loadstart event fires when loading of the
media starts.
onPause The pause event fires when playback is paused.
onPlay The play event fires when playback begins or
resumes as a result of the play method.
onPlaying The playing event fires after the play event, when
the media has enough data to begin playing.
onProgress The progress event fires during loading of media
and contains information about the amount of data
loaded.
onRateChange The ratechange event fires when playback
changes speed.
onSeeked The seeked event fires when a seek operation
finishes.
onSeeking The seeking event fires when a seek operation
starts.
onStalled The stalled event fires when loading of media is
unexpectedly not happening.
onSuspend The suspend event fires when loading of media is
paused or completed.
onTimeUpdate The timeupdate event fires when the
currentTime attribute of the element changes.
onVolumeChange The volumechange event fires when the audio
volume changes.
onWaiting The waiting event fires when a requested
operation is delayed.
Image Events onLoad The load event fires when an image is fully loaded.
onError The error event fires when an error occurs in
loading of an image.
Event Handler Functions ❘ 211
CATEGORY EVENT LISTENER DESCRIPTION
Animation onAnimationStart The animationstart event fires when an
Events animation starts.
onAnimationEnd The animationend event fires when an animation
stops.
onAnimationIteration The animationiteration event fires when one
iteration of an animation ends and another starts.
Transition onTransitionEnd The transitionend event fires when a CSS
Events transition completes.
Other Events onToggle The toggle event fires when the state of a
details element (open or closed) is toggled.
EVENT HANDLER FUNCTIONS
Once your React component has detected an event, you can write a function that will take some
action in response to the event. This function is called an event handler function.
Writing Inline Event Handlers
An inline event handler is an anonymous function that’s written as the value of an event listener
attribute. Inline event handlers are often used as wrappers for calling another function that’s defined
outside of the return statement. They may also be used for performing simple tasks that perhaps
don’t warrant the creation of a full event handler function.
Listing 7‑5 shows an example of an inline event handler.
LISTING 7- 5: Using an inline event handler to show an alert
function WarningButton(){
return (
<button onClick={()=>{alert('Are you sure?');}}>Don't Click Here</button>
);
}
export default WarningButton;
It’s possible to call multiple functions or execute a block of code from inside an inline event handler,
but there are several reasons for not using inline event handlers for complex code:
1. Inline event handlers aren’t reusable.
2. Inline event handlers can be difficult to read and they reduce the organization of your code.
212 ❘ CHAPTER 7 EvEnts
3. Inline event handlers are re‑ created every time the component re‑r enders. In function com‑
ponents, this is what happens to all inner functions. But, in class components, inline event
handlers may affect performance, although the effect is not likely to be noticeable, and
prematurely optimizing your code for this kind of problem before you have it will cause you
more problems (in terms of time wasted alone) than it solves.
NOTE I’ll talk about how to use React Hooks to cache event handler functions
in function components in Chapter 11.
Inline event handlers are often also used when the result of some user interaction should be simply to
update the state in some way. In a class component, this means that setState is called, or in a func‑
tion component, when the state setter function is called. Listing 7‑6 shows an example of using an
inline event handler to call setState.
LISTING 7- 6: Using an inline event handler to call setState
import {Component} from 'react';
class ScreenDoor extends Component {
constructor(props){
super(props);
this.state={
isOpen:true
}
}
render(){
return(
<button onClick={()=>this.setState({isOpen:!this.state.isOpen})}>
{this.state.isOpen?'Close the Door':'Open the Door'}
</button>
)
}
}
export default ScreenDoor;
Writing Event Handlers in Function Components
An event handler inside a function component is written as an inner function, using either arrow
syntax or the function keyword.
If you’re comfortable with the class method of writing components, you can think of function compo‑
nents as being the render method from a class component. The event handlers in a function compo‑
nent only exist for a single render, unlike in class components where they’re methods of the class and
persist between renders.
Event Handler Functions ❘ 213
Function components don’t have the this keyword, and so there’s no need to bind event handlers
declared inside of functions.
Writing functions inside of function components is as simple as writing a function anywhere else.
Once you’ve written an event handler function, you can assign it to a particular event listener by pass‑
ing the name of the function as the value of an event listener attribute, as shown in Listing 7‑7.
LISTING 7- 7: Using an event handler function in a function component
import {useState} from 'react';
function Search(props){
const [term,setTerm] = useState('');
const updateTerm = (searchTerm)=>{
setTerm(searchTerm);
}
return(
<>
<input type="text" value={term} onChange={(e)=>{updateTerm(e.target.value)}}
/><br />
You're searching for: {term}
</>
);
}
export default Search;
Writing Event Handlers in Class Components
Event handlers in class components are methods of the class. They’re written outside of the render
method and must be bound to the specific instance of the class.
Listing 7‑8 shows one way to write and bind an event handler method in a class component.
LISTING 7- 8: Writing and binding an event handler method in a class
import {Component} from 'react';
class CoffeeMachine extends Component {
constructor(props){
super(props);
this.state={
brewing:false
}
this.toggleBrewing = this.toggleBrewing.bind(this);
}
continues
214 ❘ CHAPTER 7 EvEnts
LISTING 7-8 (continued)
toggleBrewing = function(){
this.setState({brewing:!this.state.brewing});
}
render(){
return(
<>
The Coffee Maker is {this.state.brewing?'on':'off'}.<br />
<button onClick={this.toggleBrewing}>toggle brewing state</button>
</>
);
}
}
export default CoffeeMachine;
JAVASCRIPT LESSON: METHOD DEFINITION SYNTAX
In JavaScript classes, functions in the class (also known as methods) can be created
using method definition syntax, which is a shorthand way of assigning a function to
a method name.
For example, you can define a method by assigning a function to a property,
like this:
toggleBrewing = function(){
this.setState({brewing:!this.state.brewing});
}
Or you can use method definition syntax, like this:
toggleBrewing(){
this.setState({brewing:!this.state.brewing});
}
Binding Event Handler Functions
To be useful, event handler functions need to be passed as values to React’s built‑i n components that
support event listener attributes. For example, the built‑ in input element represents an input compo‑
nent that can receive an onChange event handler prop and will call an associated callback function
when it receives a change event.
Because event handler functions are passed to child components via props, they need to be bound to
the context in which they were created so that the value of this will refer to the parent component in
which the event handler was defined.
Event Handler Functions ❘ 215
Only class components have a this keyword, so binding only applies in class components. Plus, as
you’ll see, binding only applies in class components to methods defined using function or method
definition syntax.
Using bind
If you’re still not clear on how this and bind work in JavaScript classes, go back and review the
JavaScript lesson from Chapter 4. Or, just remember this rule:
In class components, if a function defined using method definition syntax or the function
keyword will be passed as a prop, bind it.
Functions can be bound in one of two ways. The first is the method you’ve seen most often so far: in
the constructor. In this method, you overwrite the value of the unbound function with a new function
that includes the context of the class, as shown in Listing 7‑9.
LISTING 7- 9: Binding a function in the constructor
import {Component} from 'react';
class ColorWheel extends Component {
constructor(props){
super(props);
this.state = {
currentColor: '#ff0000'
}
this.changeColor = this.changeColor.bind(this);
}
changeColor(e) {
this.setState({currentColor:e.target.value});
}
render(){
const wheelStyle = {
width: "200px",
height: "200px",
borderRadius: "50%",
backgroundColor: this.state.currentColor
}
return(
<>
<div style={wheelStyle}></div>
<input onChange={this.changeColor} value={this.state.currentColor} />
</>
)
}
}
export default ColorWheel;
216 ❘ CHAPTER 7 EvEnts
The other method of binding a function is to do it inline. In this method, you bind the function inside
the value of the event listener attribute, as shown in Listing 7‑10.
LISTING 7- 10: Binding an event handler inline
import {Component} from 'react';
class ColorWheel extends Component {
constructor(props){
super(props);
this.state = {
currentColor: '#ff0000'
}
}
changeColor(e) {
this.setState({currentColor:e.target.value});
}
render(){
const wheelStyle = {
width: "200px",
height: "200px",
borderRadius: "50%",
backgroundColor: this.state.currentColor
}
return(
<>
<div style={wheelStyle}></div>
<input onChange={this.changeColor.bind(this)} value={this.state.currentColor} />
</>
)
}
}
export default ColorWheel;
While the inline method may be more convenient in some cases, it has the drawback of living inside
the render method, which means that it will re‑r un every time the component renders. Also, it may
result in duplication of effort if you use the same event handler function more than once in a class.
Because the constructor only runs once, binding in the constructor has the benefit of being efficient as
well as of keeping your code tidy.
Using Arrow Functions
Arrow functions use lexical this binding. What this means is that they are automatically bound to
the scope in which they’re created. As a result, if you define your event handlers using arrow func‑
tions, or write your event handlers as inline arrow functions, they don’t need to be bound.
Event Handler Functions ❘ 217
Listing 7‑11 shows how to use an arrow function as an event handler.
LISTING 7- 11: Using an arrow function as an event handler
import {Component} from 'react';
class ColorWheel extends Component {
constructor(props){
super(props);
this.state = {
currentColor: '#ff0000'
}
}
changeColor = (e)=>{
this.setState({currentColor:e.target.value});
}
render(){
const wheelStyle = {
width: "200px",
height: "200px",
borderRadius: "50%",
backgroundColor: this.state.currentColor
}
return(
<>
<div style={wheelStyle}></div>
<input onChange={this.changeColor} value={this.state.currentColor} />
</>
)
}
}
export default ColorWheel;
Using the same syntax that you used to eliminate the binding of the event handler in the constructor,
you may also be able to eliminate the constructor completely and define your component’s state using
a class property, as shown in Listing 7‑12.
LISTING 7- 12: Defining state using a class property
import {Component} from 'react';
class ColorWheel extends Component {
state = {currentColor: '#ff0000'};
continues
218 ❘ CHAPTER 7 EvEnts
LISTING 7-12 (continued)
changeColor = (e)=>{
this.setState({currentColor:e.target.value});
}
render(){
const wheelStyle = {
width: "200px",
height: "200px",
borderRadius: "50%",
backgroundColor: this.state.currentColor
}
return(
<>
<div style={wheelStyle}></div>
<input onChange={this.changeColor} value={this.state.currentColor} />
</>
)
}
}
export default ColorWheel;
Passing Data to Event Handlers
Event handlers often need to receive data from within the render method. Most commonly, event
handlers need access to the Event object so they can make use of its properties to get form field val‑
ues, mouse position, and the other properties that you saw in Table 7‑1.
If you specify your event handler using just the name of the event handler function, the good news is
that there’s nothing more to do. The Event object is passed to the event handler function automati‑
cally, as demonstrated in Listing 7‑13.
LISTING 7- 13: The Event object is passed automatically
function LogInput(){
const logChange=(e)=>{
console.dir(e);
}
return(
<input onChange={logChange} />
)
}
export default LogInput;
If you use an anonymous arrow function to call your event handler, you do need to specifically pass
the Event object into the event handler, as shown in Listing 7‑14.
Summary ❘ 219
LISTING 7- 14: Passing the Event object to the event handler
function LogInput(){
const logChange=(e)=>{
console.dir(e);
}
return(
<input onChange={(e)=>{logChange(e)}} />
)
}
export default LogInput;
SUMMARY
Through its use of a familiar and simple interface and standard, idiomatic JavaScript, React allows
programmers to enable interactivity within user interfaces while also gaining the benefits of one‑ way
data flow.
In this chapter, you learned:
➤➤ What SyntheticEvents are.
➤➤ How to log the properties of the SyntheticBaseEvent object.
➤➤ What event listeners React can respond to.
➤➤ How to write event handlers in both function and class components.
➤➤ How to bind event handlers in class components.
➤➤ How to pass data into event handlers.
In the next chapter, you’ll learn how to create interactive forms in React and how to listen for and
respond to form events.