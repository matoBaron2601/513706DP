3
JSX
Newcomers to React often remark on how it appears that React breaks one of the cardinal
rules of web development, which is to not mix your programming logic with your HTML.
This chapter explains where this misperception about React comes from and introduces JSX,
which gives us an easy, HTML- like syntax for composing React components. In this chapter,
you’ll learn:
➤➤ How to write JSX.
➤➤ How modules work in JavaScript.
➤➤ What a transpiler does.
➤➤ How to include literal JavaScript in JSX code.
➤➤ How to do conditional rendering in React.
➤➤ How to render children in JSX.
JSX IS NOT HTML
Take a look first at Listing 3-1. If you know some HTML, you can probably guess what the
result of this function will be—a form containing two input fields and a button will be returned.
LISTING 3- 1: A React component
import React from "react";
function Login(){
const handleSubmit = (e)=>{
e.preventDefault();
console.log(`logging in ${e.target[0].value}`);
continues
24 ❘ CHAPTER 3 JSX
LISTING 3-1 (continued)
// do something else here
}
return (
<form id="login- form" onSubmit={handleSubmit}>
<input type="email"
id="email"
placeholder="E- Mail Address"/>
<input type="password"
id="password"/>
<button>Login</button>
</form>
);
}
export default Login;
But, if you know some JavaScript, you might think the result of running this JavaScript function
should be an error— HTML is not valid JavaScript, and so the value of the return statement will
cause this function to fail.
However, this is a perfectly well-f ormed React component and that markup inside of the return
statement actually isn’t HTML. Instead, it’s written in JSX, which is an extension of JavaScript that’s
used as a visual aid to help you describe what a component should look like.
JAVASCRIPT LESSON: MAKING SENSE OF MODULES WITH AMD,
CJS, AND ESM
Modularization is a fundamental concept in software development in which a pro-
gram is organized into reusable units of code. Modularization makes software easier
to build, debug, test, and manage and it also enables team development of software.
Just as functions create units of functionality that can be reused in a JavaScript file,
modules create JavaScript files that can be reused within a program.
A computer program made up of modules might look something like this:
JSX Is Not HTML ❘ 25
main program
data
module 1 module 2 module 3
data + data data + data data + data
1 2 3
module 4
data + data + data
1 4
THE HISTORY OF JAVASCRIPT MODULES
JavaScript started its life as a scripting language for web browsers. In its early days,
scripts written in JavaScript were small. Because it was seen as less than a “real” pro-
gramming language, no thought was given to including a way to create modules in
JavaScript. Instead, programmers would just write their JavaScript in a single file and
import it into HTML files using the script element, or write all of their JavaScript
directly into the script element.
As JavaScript became a more powerful language, and as the number of things that
people were doing with JavaScript began to grow, so too did the complexity and size
of JavaScript files.
The Rise of the JavaScript Module
Because JavaScript couldn’t do modules natively, when the need for and benefits of
breaking up large JavaScript programs into smaller pieces became apparent, Java-
Script developers did what they always do and created new libraries that could be
used to add modularization into JavaScript.
RequireJS
The library that became the most popular way to modularize JavaScript in the web
browser was RequireJS. The method used by RequireJS to load modules is called
Asynchronous Module Definition (AMD).
As the name implies, AMD modules are loaded asynchronously, meaning that
all of the imports in a module run prior to any of the code in those modules
being executed.
continues
26 ❘ CHAPTER 3 JSX
(continued)
With RequireJS, you can create modules by using the define function, and then
those modules can be included into other JavaScript code using the require() func-
tion. All you have to do to use RequireJS is to include the RequireJS script into your
HTML file using a script tag, like this:
<script data- main="scripts/main" src="scripts/require.js">
</script>
The preceding script tag specifies that the single entry point into the app is
scripts/main.js.
Once you’ve included the script tag in your HTML file, you can create individual
modules in other files by using RequireJS’s define function, like this:
// messages.js
define(function () {
return {
getHello: function () {
return 'Hello World';
}
};
});
Modules you define can then be loaded into main.js using the requirejs function,
where individual functions from the module can be assigned to variables and used,
like this:
requirejs(["messages"], function(messages) {
// module usage here
});
This function is called when scripts/messages.js is loaded. If messages.js calls
define, then this function is not fired until messages’s dependencies have loaded,
and the messages argument will hold the module value.
CommonJS
While RequireJS created a way to have modules in the web browser, web browsers
aren’t the only place where JavaScript code runs. Prior to 2009, there was no agreed-
upon standard way to modularize JavaScript code running outside the browser.
This changed when CommonJS (also known as CJS) was created. CommonJS was
built into Node.js and quickly became the most widely used modularization library
for server- side JavaScript.
With CommonJS, you can export variables, functions, or objects from a file by using
the exports function, like this:
// mathhelpers.js
exports.getSum = function(num1,num2) { return num1 + num2; }
JSX Is Not HTML ❘ 27
Once you’ve defined a module, you can import it into any other JavaScript files by
using the require function:
const mathHelpersModule = require('mathHelpers.js');
var theSum = mathHelpersModule.getSum(1,1);
Unlike RequireJS, CommonJS loads and parses modules synchronously, parsing and
executing each module as it’s loaded.
The following image illustrates the difference between how CommonJS and AMD
systems like RequireJS load modules.
CommonJS (CJS)
module 1 module 2 module 3
Asynchronous Module Definition (AMD)
module 1
module 3
module 2
ES Modules
Having more than one way to create and use modules made modules less reusable,
however, and the ultimate dream of JavaScript programmers was always that Java-
Script would someday have a built-i n way to modularize code. This dream became a
reality with the standardization of ECMAScript Modules (ESM).
ESM features asynchronous module loading, like RequireJS, but has a simple syntax,
like CommonJS. The statements that you use to create and use ES Modules are
import and export.
USING IMPORT AND EXPORT
React components are JavaScript modules, and so you’ll see import and export
statements everywhere in React. The most basic thing to know about import and
export is that the export statement creates modules, and the import statement
imports modules into other JavaScript code. Since import and export are built into
JavaScript now, there’s no need to include a separate library to make use of them.
continues
28 ❘ CHAPTER 3 JSX
(continued)
export Creates Modules
Let’s say that you have a function that calculates shipping charges for your ecom-
merce store. The basic skeleton of this function might look something like this:
function calculateShippingCharge(weight,shippingMethod){
// do something here
return shippingCharge;
}
Turning this function into a module would make it more reusable, since you’d then
be able to simply include it into any file that needs to calculate shipping charges, and
you could even make use of it in different programs as well.
The basic syntax for using export is to put the export keyword before the defini-
tion of the function, like this:
export function calculateShippingCharge(weight,shippingMethod){
// do something here
return shippingcharge;
}
Now, you can put this module into a file with other modules (maybe the file would
be named ecommerce- utilities.js) and you can import individual functions, or
every function, from this file into any other file in your program.
import Imports Modules
To import a function, variable, or object from a JavaScript module, you use the
import statement. To use import, name at least one module, followed by the from
keyword, followed by the path to the file that contains the module or modules you
want to import.
You can import individual items from a file by surrounding them with curly braces,
like this:
import { shippingMethods, calculateShippingCharges } from
'./modules/ecommerce- utilities.js';
Using Default Exports
Another way to use export is to create a default export. A default export can be
used to specify a default function provided by a module:
function calculateShippingCharge(weight,shippingMethod){
// do something here
}
export default calculateShippingCharge;
JSX Is Not HTML ❘ 29
You can only have one default export per file. When you have a default export, you
can import the module specified with the default export by using the import state-
ment without the curly braces, like this:
import calculateShippingCharge from
'./modules/calculateShippingCharge.js';
React components are usually created using default exports, unless you’re creating a
library of components.
Note: you’ll often see the path to a module specified without the .js at the end.
For example:
import calculateShippingCharge from
'./modules/calculateShippingCharge';
When you omit .js at the end of a filename in an import, the import will work
exactly the same as if you had specifically written it. Also notice that the path to the
module file starts with './'. This is the UNIX way of saying to start with the cur-
rent directory and to create a relative path from it. ES Modules require that the path
to the module is a relative path, so it will always start with ./ (the current directory)
or ../ (indicating the parent directory). Oftentimes, you may need to have more
than one ../, if the module you want to load is higher up in the file hierarchy.
So, in the previous case, the modules folder is a subdirectory of the directory con-
taining the file that’s importing the module.
If you’ve installed Node.js packages using npm, such as the React library itself, you
don’t need to use ./ or to specify the path to the Node.js package when you import
it. For example, components that use the React library’s functions have an import
statement that imports React. This usually looks like this:
import React from 'react';
Although you may also see individual objects from the React library imported
separately, like this:
import React, {Component} from 'react';
Some Important ES2015 Module Rules
There are just a few more important rules for how to use import and export:
➤➤ Both import and export statements need to be at the top level of your
JavaScript file— that is, not inside of a function or any other statement.
➤➤ Imports must be done before any other statements in a module.
➤➤ import and export can only be used inside modules (not inside of
ordinary JavaScript files).
30 ❘ CHAPTER 3 JSX
WHAT IS JSX?
JSX is an XML- based syntax extension to JavaScript. In plain English, it’s a way to write JavaScript
code using XML. Although it’s not specific to React, and it’s not even required in order to write
React components, JSX is an integral part of how every React developer writes components because
it makes writing components so much easier and has no negative impact in terms of performance or
functionality.
How JSX Works
React uses JSX elements to represent custom components (which are also known as user- defined
components). If you create a component named SearchInput, you can make use of that component
in other components by using a JSX element named SearchInput, as shown in Listing 3-2.
LISTING 3- 2: Using a user- defined React component in JSX
import {useState} from 'react';
import SearchInput from './SearchInput';
import SearchResults from './SearchResults';
function SearchBox() {
const [searchTerm,setSearchTerm] = useState(");
return (
<div id="search- box">
<SearchInput term={searchTerm} onChange={setSearchTerm}/>
<SearchResults term={searchTerm}/>
</div>
)
}
export default SearchBox;
In the same way, React has components built into it for each of the elements in HTML5, and you can
use any HTML5 element name when you write your React components and the result will be that
React will output that HTML5 element. For example, say you want your React component to result
in the rendering of the following piece of HTML markup:
<label class="inputLabel">Search:
<input type="text" id="searchInput">
</label>
The JSX code for telling your React component to output that HTML would look like this:
<label className="inputLabel">Search:
<input type="text" id="searchInput"/>
</label>
If you study both of the preceding snippets closely, you’ll find a couple of differences. The difference
between them, and the fact that JSX is not HTML, are of vital importance to understanding what
JSX is really doing.
What Is JSX? ❘ 31
It’s fully possible to create React components without using JSX by using the React.createElement
method. Here’s what the code to output the previous HTML markup looks like when you write it
using React.createElement:
React.createElement("label", {className: "inputLabel"}, "Search:",
React.createElement("input", {type: "text", id: "searchInput"}));
If you examine this JavaScript code closely, you should be able to figure out basically how it works.
The React.createElement method accepts an element name, any attributes of the HTML element,
the element’s content ("Search:" in this example) and its child element or elements. In this case, the
label element has one child, input.
That’s pretty much all there is to React.createElement. If you’re interested in learning the exact
syntax of React.createElement, you can read more about it here:
https://reactjs.org/docs/react- without- jsx.html
In reality, however, very few React developers ever have to think about React.createElement,
because we use a tool called a transpiler as part of our development environment.
Transpiler . . . Huh?
Before you can run a React application that uses JSX and modules, it must first be compiled. During
the compile (also known as “build”) process, all of the modules are joined together and the JSX code
is converted into pure JavaScript.
Compilation vs. Transpilation
Compilation of React applications is somewhat different from how programmers of truly “compiled”
languages (like C++ or Java) understand compilation. In compiled languages, the code that you write
is converted into low- level code that can be understood by the computer’s software interpreter. This
low- level code is called bytecode.
When React applications are compiled, on the other hand, they’re converted from one version of
JavaScript to another version of JavaScript. Because the React compilation process doesn’t actually
create bytecode, a more technically correct word for what happens is transpilation.
JSX Transform
One of the steps in the transpilation of React code is the JSX Transform. The JSX Transform is a
process in which the transpiler takes JSX code (which isn’t natively understood by web browsers) and
converts it into plain JavaScript (which is natively understood by web browsers).
Introducing Babel
The tool we use for transpilation in JavaScript is called Babel. Babel is integrated into Create React
App and is an automatic part of compiling a React app built with Create React App.
32 ❘ CHAPTER 3 JSX
NOTE Prior to version 17 of React, the JSX Transform converted JSX into
React.createElement() statements. With React 17, the JSX Transform was
rewritten so that it transforms JSX into browser- readable code without using
React.createElement(). The result is that developers no longer need to import
React into every component in order to use JSX.
It can be interesting sometimes to see how Babel converts JSX into JavaScript, and you can do this by
either viewing the source code for a running React application or by pasting your JSX code into the
web- based version of Babel at https://babeljs.io/repl, as shown in Figure 3-1.
FIGURE 3- 1: Trying out Babel on the web
Babel does much more than just convert JSX into JavaScript. It also takes JavaScript in your com-
ponents that’s written using new and experimental syntax that might not be supported by all of
your target web browsers and converts it into JavaScript that can be understood and run in any web
browser that you expect to access your React user interface.
Syntax Basics of JSX ❘ 33
Eliminating Browser Incompatibilities
Using transpilation does away with the age- old problem of browser incompatibilities and having
to wait until every browser supports a new JavaScript language feature before using it. Rather than
developers having to write special code and multiple if/then branches to accommodate older brows-
ers, Babel makes it possible for developers to just write JavaScript using the latest syntax and then
transpile that new JavaScript into a common denominator that will run in any web browser that’s
likely to access the app.
SYNTAX BASICS OF JSX
As I may have mentioned (and I’ll mention again, because it’s a really important point), JSX is not
HTML. Because it’s not HTML, you can’t write JSX in the same loosey- goosey way that you may be
used to writing HTML.
JSX Is JavaScript XML
The first thing to know about JSX is that it’s XML. So, if you know a little bit about XML (or if
you’ve used XHTML), the rules of writing JSX should sound familiar. Namely:
➤➤ All elements must be closed.
➤➤ Elements that cannot have child nodes (so- called “empty” elements) must be closed with a
slash. The most commonly used empty elements in HTML are br, img, input, and link.
➤➤ Attributes that are strings must have quotes around them.
➤➤ HTML elements in JSX must be written in all lowercase letters.
Beware of Reserved Words
Because JSX compiles to JavaScript, there is the potential that an element name or attribute name
that you use in your JSX code can cause errors in your compiled program. To guard against this,
certain HTML attribute names that are also reserved words used in JavaScript have to be renamed,
as follows:
➤➤ The class attribute becomes className.
➤➤ The for attribute becomes htmlFor.
JSX Uses camelCase
Attribute names in HTML that contain more than one word are camel- cased in JSX. For example:
➤➤ The onclick attribute becomes onClick.
➤➤ The tabindex attribute becomes tabIndex.
34 ❘ CHAPTER 3 JSX
Preface Custom Attributes in DOM Elements with data-
Prior to version 16 of React, if you needed to add an attribute to a DOM element that doesn’t exist
in the HTML or SVG specification for the element, you had to preface it with data-, or else React
would ignore it. Listing 3-3 shows a JSX HTML equivalent element with a custom attribute.
LISTING 3- 3: Custom attributes in HTML must start with data-
<div data- size="XL"
data- color="black"
data- description="awesome">
My Favorite T- Shirt
</div>
Starting with React 16, however, you can use any custom attribute name with built- in DOM ele-
ments. Custom attributes in DOM elements can be useful for including arbitrary data with your
markup that doesn’t have any special meaning or affect the presentation of the HTML in the browser.
Although it is possible to use custom attributes for DOM elements, this is not generally considered a
good practice.
User- defined elements, on the other hand, can have custom attributes with any name, as shown in
Listing 3-4.
LISTING 3- 4: User- defined elements can have any attributes
import MyFancyWidget from './MyFancyWidget';
function MyFancyComponent(props){
return(
<MyFancyWidget
widgetSize="huge"
numberOfColumns="3"
title="Welcome to My Widget" />
)
}
export default MyFancyComponent;
Using custom attributes with user-d efined elements is the primary way that React passes data between
components, as you’ll see in Chapter 4.
JSX Boolean Attributes
In HTML and in JSX, certain attributes don’t require values, because their presence is interpreted as
setting their value to a Boolean true. For example, in HTML, the disabled attribute of input ele-
ments causes an input to not be changeable by the user:
<input type="text" name="username" disabled>
Syntax Basics of JSX ❘ 35
In JSX, the value of an attribute can be omitted when it is explicitly true. So, to set the disabled
attribute of a JSX input element to true, you can do either of the following:
<input type="text" name="username" disabled = {true}/>
<input type="text" name="username" disabled/>
Use Curly Braces to Include Literal JavaScript
When you need to include a variable or a piece of JavaScript in your JSX that shouldn’t be interpreted
by the transpiler, use curly braces around it. Listing 3-5 shows a component whose return statement
includes literal JavaScript in JSX attributes.
LISTING 3- 5: Using literal JavaScript inside of JSX
function SearchInput(props) {
return (
<div id="search- box">
<input type="text"
name="search"
value={props.term}
onChange={(e)=>{props.onChange(e.target.value)}}/>
</div>
)
}
export default SearchInput;
Remember to Use Double Curly Braces with Objects
One common mistake is to forget that if you’re including a JavaScript object literal inside of JSX, the
JSX code will have double curly braces, as shown in Listing 3-6.
LISTING 3- 6: Object literals in JSX result in double curly braces
function Header(props){
return (
<h1 style={{fontSize:"24px",color:"blue"}}>
Welcome to My Website
</h1>
)
}
export default Header;
Put Comments in Curly Braces
Because JSX is actually a way of writing JavaScript, HTML comments don’t work in JSX. Instead,
you can use JavaScript block comment syntax (/* and */).
36 ❘ CHAPTER 3 JSX
However, because you don’t want to transpile your comments, they must be enclosed in curly braces,
as shown in Listing 3-7.
LISTING 3- 7: Enclose comments in curly braces
function Header(props){
return (
<h1 style={{fontSize:"24px",color:"blue"}}>
{/* Todo: Make this header dynamic */}
Welcome to My Website
</h1>
)
}
export default Header;
When to Use JavaScript in JSX
The concept of separation of concerns in programming says that layout code should be separated
from logic. What this means in practice is that code that does calculations, retrieves data, combines
data, and controls the flow of an application should be written as functions outside of the return
statement in a component, rather than inside of curly braces in JSX.
Limited amounts of logic are necessary and perfectly normal inside of the return statement, however.
There’s no hard-a nd- fast rule for how much is too much, but, generally, any JavaScript that you write
in your JSX should only have to do with presentation, and it should be single JavaScript expressions,
rather than functions or complex logic.
An example of purely presentational JavaScript would be the case of conditional rendering.
Conditionals in JSX
Oftentimes, a component needs to output different subcomponents, or hide certain components,
based on the results of expressions or the values of variables. We call this conditional rendering.
There are three ways to write conditional statements in JavaScript, and you may use any of these to
do conditional rendering.
Conditional Rendering with if/else and Element Variables
JSX elements can be assigned to variables, and these variables can be substituted for the elements
inside a component’s return statement, as shown in Listing 3-8.
LISTING 3- 8: Using element variables
import Header from './Header';
function Welcome(){
Syntax Basics of JSX ❘ 37
let header = <Header/>;
return(
<div>
{header}
</div>
);
}
export default Welcome;
By using a conditional statement, you can assign a different element to a variable and thus change
what gets rendered, as shown in Listing 3-9.
LISTING 3- 9: Conditional rendering with element variables
import Header from './Header';
import Login from './Login';
function Welcome({loggedIn}) {
let header;
if (loggedIn) {
header = <Header/>;
} else {
header = <Login/>;
}
return (
<div>
{header}
</div>
);
}
export default Welcome;
Conditional Rendering with the && Operator
Rather than having your conditional logic outside of the return statement, you can write it inline by
using the logical AND operator, &&. The && operator evaluates the expressions on its left and right. If
both expressions evaluate to a Boolean true, the && will return the one on the right. If either side of
the && operator is false, then a value of false will be returned.
By applying this fact, you can conditionally return an expression from the right side of && if the left
side of && is true.
This can be a little confusing at first. Take a look at Listing 3-10. This code will render the
Header component if loggedIn evaluates to true.
38 ❘ CHAPTER 3 JSX
LISTING 3- 10: Conditional rendering with &&
import Header from './Header';
function Welcome({loggedIn}){
return (
<div>
{loggedIn&&<Header />}
Note: if you don't see the header messsage,
you're not logged in.
</div>
)
}
export default Welcome;
Conditional Rendering with the Conditional Operator
The conditional operator is a way to combine the simplicity and conciseness of inline conditional
rendering with the ability to have an else case that element variables combined with if and
else gives us.
Listing 3-11 shows an example of using the conditional operator.
LISTING 3- 11: Using the conditional operator
import Header from './Header';
import Login from './Login';
function Welcome({loggedIn}){
return(
<div>
{loggedIn ? <Header /> : <Login />}
</div>
)
}
export default Welcome;
In this example, the expression to the left of the question mark is evaluated. If it’s true, the
WelcomeMessage component is returned. If it’s false, the Login component is returned.
Expressions in JSX
You can use any JavaScript expression inside of your JSX or inside of React element attribute values
by surrounding it with curly braces. JSX elements themselves are JavaScript expressions as well,
because they get converted into function calls during compilation.
To understand what JavaScript you can and can’t include in JSX, let’s take a brief look at what a
JavaScript expression is.
Syntax Basics of JSX ❘ 39
An expression is any valid unit of code that resolves to a value. Here are some examples of valid
JavaScript expressions:
➤➤ Arithmetic: 1+1
➤➤ String: "Hello, " + "World!"
➤➤ Logical: this !== that
➤➤ Basic keywords and general expressions: This includes certain keywords (such as this, null,
true, and false) as well as variable references and function calls.
Examples of structures in JavaScript that do not return a value (and are thus not expressions) include
for loops and if statements, as well as function declarations (using the function keyword). You can
still use these in your React components, of course, but you’ll need to use them outside of the return
statement, as we did in Listing 3-9.
Functions can be included in JSX, provided that they’re invoked immediately and that they return a
value that can be parsed by JSX, or that they’re passed as values for an attribute. The component in
Listing 3-12 has a return statement that includes a function as an event handler.
LISTING 3- 12: Using an arrow function as an event handler
import {useState} from 'react';
function CountUp(){
const [count,setCount] = useState(0);
return (
<div>
<button onClick={()=>setCount(count+1)}>Add One</button>
{count}
</div>
);
}
export default CountUp;
Listing 3-13 shows an example of using a function that’s immediately invoked and that’s valid in JSX.
LISTING 3- 13: Immediately invoking a function in JSX
function ImmediateInvoke(){
return(
<div>
{(()=><h1>The Header</h1>)()}
</div>
);
}
export default ImmediateInvoke;
40 ❘ CHAPTER 3 JSX
Using Children in JSX
The return statement in a React component can only return one thing. This one thing can be a
string, a number, an array, a Boolean, or a single JSX element. Keep in mind, however, that a single
JSX element can have as many children as you like. As long as you start and end your return state-
ment with a matching opening tag and closing tag, everything in between (provided that it’s valid JSX
or a JavaScript expression) is fine.
Here’s an example of an invalid JSX return value:
return(
<MyComponent />
<MyOtherComponent />
);
One way to make this a valid JSX return value is to wrap two elements with another element,
like this:
return(
<div>
<MyComponent />
<MyOtherComponent />
</div>
);
With the div element wrapping the two user- defined elements, we now have a single element
being returned.
React Fragments
Although it’s quite common to see multiple elements wrapped with a div element or another element
for the purpose of returning a single JSX element, adding div elements just for the sake of eliminat-
ing errors in your code, rather than to add necessary meaning or structure to your code, creates code
bloat and decreases the accessibility of your code.
To prevent the introduction of unnecessary elements, you can use the built- in React.Fragment com-
ponent. React.Fragment wraps your JSX into a single JSX element, but doesn’t return any HTML.
You can use the React.Fragment component in one of three ways:
1. By using dot notation: <React.Fragment></React.Fragment>
2. By importing Fragment from the react library using curly braces
3. By using its short syntax, which is just a nameless element: < > < / >
Listing 3-14 shows how to use React.Fragment in a component.
LISTING 3- 14: Using React.Fragment
import {Fragment} from 'react';
function MyComponent(){
Summary ❘ 41
return(
<Fragment>
<h1>The heading</h1>
<h2>The subheading</h2>
</Fragment>
);
}
export default MyComponent;
Listing 3-15 shows how to use the short syntax for React.Fragment.
LISTING 3- 15: Using React.Fragment’s short syntax
function MyComponent(){
return(
<>
<h1>The heading</h1>
<h2>The subheading</h2>
</>
);
}
export default MyComponent;
NOTE Notice that when you use React.Fragment’s short syntax, you don’t
need to import Fragment from React.
The result of running either Listing 3-14 or Listing 3-15 is that just the h1 and h2 HTML elements
will be returned.
SUMMARY
JSX is an important tool that is used in the development of nearly every React component. In this
chapter, you learned:
➤➤ Why we use JSX, the XML language that React uses to make it easier to visualize and write
the output of components.
➤➤ That JSX is not HTML, but that React uses JSX to generate HTML.
➤➤ The history of JavaScript modules, which make distributed development and reusable com-
ponents possible, and how to use import and export to create and use modules.
➤➤ What transpiling is.
➤➤ How to write JSX code.
42 ❘ CHAPTER 3 JSX
➤➤ What conditional rendering is and how to do it in JSX.
➤➤ How to use JavaScript expressions inside JSX.
➤➤ How to use comments in JSX.
➤➤ How to use React.Fragment to group elements together without returning extra
HTML elements.
In the next chapter, you’ll learn about the React library itself, and about the basic unit of every React
user interface: the component.