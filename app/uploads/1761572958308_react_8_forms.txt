222 ❘ CHAPTER 8 Forms
CONTROLLED INPUTS VS. UNCONTROLLED INPUTS
The default behavior of an input element is to allow the user to change its value directly. In one- way
data flow, on the other hand, every interaction with the user interface results in an event which, when
handled, updates the state. Changes to state then update the user interface.
React calls a form input that can be directly manipulated by the user an uncontrolled input, and one
that can only be changed through changes to the state object a controlled input.
Figure 8-1 illustrates the difference between controlled and uncontrolled inputs.
FIGURE 8- 1: Controlled and uncontrolled inputs
To create an uncontrolled input, omit the value attribute from the JSX code for that input, as shown
in Listing 8-1.
LISTING 8- 1: Omiting the value attribute creates an uncontrolled input
function SignUp(props){
return(
<form>
<input type="text" name="emailAddress" />
<button>Sign up for our newsletter</button>
</form>
)
}
export default SignUp;
Figure 8-2 shows the result of rendering the preceding component and typing into the input. This is
exactly the behavior you’d expect with an HTML form.
Controlled Inputs vs. Uncontrolled Inputs ❘ 223
FIGURE 8- 2: Rendering an uncontrolled input
To make this form be controlled, add a value attribute, as shown in Listing 8-2.
LISTING 8- 2: Adding the value attribute creates a controlled input
function SignUp(props){
return(
<form>
<input value="" type="text" name="emailAddress" />
<button>Sign up for our newsletter</button>
</form>
)
}
export default SignUp;
Simply adding the value attribute causes React to “control” the input. Now, when you render the
SignUp component and try to type into it, nothing will happen. It’s impossible to demonstrate noth-
ing happening in a figure, so if you’d like to see this, you can create a component similar to the one in
Listing 8-2 or download the example code from this book’s GitHub repository.
Updating a Controlled Input
Unless your goal is to create an input that can’t be edited, a controlled input must also have an event
listener attribute and an event handler function. Even though the internal state of the input element
in Listing 8-2 doesn’t change when you type into it, it still fires a change event with every keystroke.
224 ❘ CHAPTER 8 Forms
Using the onChange event listener, you can detect this event and use the target.value property of
the Event object to update the state property, which can then be assigned to the value attribute of
the input.
The process for controlling a controlled input is the same in function and class components, but the
JavaScript code you need to write in each differs somewhat.
Controlling an Input in a Function Component
Listing 8-3 shows a controlled text input that updates using one- way data flow in a function
component.
LISTING 8- 3: Updating an input element with one-w ay data flow
import {useState} from 'react';
function SignUp(props){
const [emailAddress,setEmailAddress] = useState('');
const handleChange = (e)=>{
setEmailAddress(e.target.value);
}
return(
<>
<form>
<label>Enter your email address:
<input value={emailAddress} onChange={handleChange} type="text" />
</label>
</form>
<p>Your email address: {emailAddress}</p>
</>
)
}
export default SignUp;
When you run this component in a browser, typing into the input updates the value of the
emailAddress state variable, which is used as the value of the input and is also output in the para-
graph below the input. The input behaves like a normal HTML input, but the component also has
access to the value of the input.
Controlling an Input in a Class Component
In a class component, controlling an input works the same way, but the JavaScript is slightly differ-
ent and a bit more verbose because of the need to write and bind the event handler and to correctly
address the state property.
Listing 8-4 shows the same controlled input as Listing 8-3, but written as a class component.
Controlled Inputs vs. Uncontrolled Inputs ❘ 225
LISTING 8- 4: Controlling an input in a class component
import {Component} from 'react';
class SignUp extends Component{
constructor(props){
super(props);
this.state = {
emailAddress:''
}
this.handleChange = this.handleChange.bind(this);
}
handleChange(e){
this.setState({emailAddress:e.target.value});
}
render(){
return(
<>
<form>
<label>Enter your email address:
<input value={this.state.emailAddress} onChange={this.handleChange}
type="text" />
</label>
</form>
<p>Your email address: {this.state.emailAddress}</p>
</>
)
}
}
export default SignUp;
The class component in Listing 8-4 can be written a bit more succinctly by using arrow functions, an
inline event handler, and by creating state as a class property, as shown in Listing 8-5.
LISTING 8- 5: Simplifying a controlled input in a class
import {Component} from 'react';
class SignUp extends Component{
state = {emailAddress:''};
render(){
return(
<>
<form>
<label>Enter your email address:
<input value={this.state.emailAddress}
onChange={(e)=>{this.setState({emailAddress:e.target.value})}}
type="text" />
continues
226 ❘ CHAPTER 8 Forms
LISTING 8-5 (continued)
</label>
</form>
<p>Your email address: {this.state.emailAddress}</p>
</>
)
}
}
export default SignUp;
LIFTING UP INPUT STATE
Most of the time, when you have a form in a user interface, input into the form should affect some
other part of the user interface. For example, words typed into a search form are used to perform a
search, and then the searched-f or words and the search results are presented in some sort of results
component, as shown in Figure 8-3.
FIGURE 8- 3: Form input often affects other components
Lifting Up Input State ❘ 227
Because the search term entered into the search form in Figure 8-3 needs to be used by other compo-
nents, the state variable that the search form updates should be lifted up to a common ancestor of the
search form and search results components.
Listings 8-6, 8- 7, and 8-8 show three components that might make up a very basic version of the
search interface from Figure 8-3. Notice that the setSearchTerm function is passed down to the
SearchInput component and the searchTerm variable is passed down to both the SearchInput and
SearchResults components.
LISTING 8- 6: The SearchBox component
import {useState} from 'react';
import SearchInput from './SearchInput';
import SearchResults from './SearchResults';
function SearchBox(){
const [searchTerm,setSearchTerm] = useState('');
return(
<>
<SearchInput searchTerm = {searchTerm} setSearchTerm = {setSearchTerm} />
<SearchResults searchTerm = {searchTerm}/>
</>
);
}
export default SearchBox;
LISTING 8- 7: The SearchInput component
function SearchInput(props){
const handleChange = (e)=>{
props.setSearchTerm(e.target.value);
}
return(
<label>Enter your search term:
<input type="text" value={props.searchTerm} onChange={handleChange} />
</label>
);
}
export default SearchInput;
LISTING 8- 8: The SearchResults component
function SearchResults(props){
return(
<p>You're searching for: {props.searchTerm}</p>
continues
228 ❘ CHAPTER 8 Forms
LISTING 8-8 (continued)
);
}
export default SearchResults;
As you saw in Chapter 6, lifting state up minimizes the number of components that need to be state-
ful. Having a single stateful component eliminates duplication of data processing and provides the
application with a single source of truth. In other words, the behavior of the subcomponents can be
known and tested based on how the state changes in the stateful component.
USING UNCONTROLLED INPUTS
Using controlled inputs ensures that your user interface strictly adheres to the pattern of one-w ay
data binding, and it enables you to easily work with the current values of your input fields. However,
it also creates a lot of overhead work that may be unnecessary.
For example, a “Contact Us” form within a user interface doesn’t need to store the data entered into
it or do anything with the data as it’s being entered. Essentially, such a form isn’t really part of the
larger application at all, and there’s maybe no reason for React to track and run an event handler
function for every keystroke that someone enters into a textarea input. Binding each input of a large
form can be tedious and the additional processing that it takes to listen for and respond to a large
number of form inputs can create performance issues.
In cases where you don’t need to track the user’s input as they’re typing and you don’t need to store
the input in state, it may be a better choice to use uncontrolled inputs and simply attach an event
listener to the form itself to run a function when the form is submitted.
Listing 8-9 shows a comment form, such as you might see on a blog, which uses an uncontrolled
input. When the user submits the form, an event handler function runs that retrieves the data from
the uncontrolled input and adds it to the state.
LISTING 8- 9: A blog comment interface using an uncontrolled input
import {useState,useRef} from 'react';
function BlogComment(props){
const [comments,setComments] = useState([]);
const textAreaRef = useRef(null);
const recordComment = (e)=>{
e.preventDefault();
setComments([...comments,textAreaRef.current.value]);
}
const commentList = comments.map((comment,index)=>{
return (<p key={index}>{comment}</p>);
})
return(
<>
Using Different Form Elements ❘ 229
<form onSubmit={recordComment}>
<p>Enter your comment:</p>
<textarea ref={textAreaRef}></textarea><br />
<button>Submit Comment</button>
<p>All Comments:</p>
{commentList}
</form>
</>
);
}
export default BlogComment;
To get values from uncontrolled inputs, you can use a technique called a ref. The ref creates a refer-
ence to the underlying DOM node, which allows React to access its properties directly. You’ll learn
more about refs and how and when to use them in Chapter 9.
USING DIFFERENT FORM ELEMENTS
HTML input elements are the most commonly used types of interactive elements. By changing the
type attribute of the input element, you can create inputs for a large and growing number of data
types, including:
➤➤ button
➤➤ checkbox
➤➤ color
➤➤ date
➤➤ datetime- local
➤➤ email
➤➤ file
➤➤ hidden
➤➤ image
➤➤ month
➤➤ number
➤➤ password
➤➤ radio
➤➤ range
➤➤ reset
➤➤ search
➤➤ submit
➤➤ tel
230 ❘ CHAPTER 8 Forms
➤➤ text
➤➤ time
➤➤ url
➤➤ week
The different input types may look different or have different validation that they perform on user
input. For example, the number input type will only allow numbers to be entered, the color input
type will display a color picker (in browsers that support it), and the hidden input type doesn’t dis-
play anything in the browser window.
Controlling the Input Element
With the exception of the input types that create buttons, and the special case of the file input type,
the way to get the value of a controlled input element in React is by using the onChange attribute.
The button inputs (submit, reset, and button) use the onClick attribute. The button element,
which does the same thing as an input with a type of button, also uses the onClick attribute.
The file input, which allows you to choose a file from your computer to upload to the browser, is a
read- only input. In React, an input with the type of file is always uncontrolled.
Controlling a textarea
In HTML, a textarea element’s value is its children, as shown in Listing 8-10.
LISTING 8- 10: An HTML textarea’s value is its children
<textarea name="terms- of- use">
Make sure to read all of these terms of use. By reading this book, you agree
to learn React and to never try to mutate a prop or forget to bind an event
handler in a class component. Furthermore, although it is not required, you
agree to consider writing a review of this book and to tell your friends how
great this book is.
</textarea>
In React, a textarea is written more like an input element: as an empty element (meaning it doesn’t
have an end tag or content) with a value attribute. You can use the onChange event listener to handle
input into a textarea in React, as shown in Listing 8-11.
LISTING 8- 11: Using a textarea in React
function TermsOfUse(props){
return(
<textarea value={props.terms} onChange={props.updateTerms} />
);
}
export default TermsOfUse;
Preventing Default Actions ❘ 231
Controlling a Select Element
A select element in HTML creates a dropdown list, with any number of option element chil-
dren forming the items in the dropdown list. In HTML, each option element has a Boolean attrib-
ute named selected, which determines the current value of the select element, as shown in
Listing 8-12.
LISTING 8- 12: A select element in HTML
<select name="pizza- type">
<option value="thin">Thin Crust</option>
<option value="thick">Thick Crust</option>
<option value="deep">Deep Dish</option>
<option value="detroit" selected>Detroit-s tyle</option>
<option value="chicago">Chicago-s tyle</option>
</select>
In React, the select element has a value attribute that determines which option is currently
selected, and the onChange attribute on the select input can be used to detect and handle changes to
the currently selected option, as shown in Listing 8-13.
LISTING 8- 13: Using a select input in React
function SizeSelect(props){
return(
<select name="size" value={props.size} onChange={props.changeSize}>
<option value="xs">Extra Small</option>
<option value="sm">Small</option>
<option vlue="md">Medium</option>
<option value="lg">Large</option>
<option value="xl">Extra Large</option>
</select>
);
}
export default SizeSelect;
PREVENTING DEFAULT ACTIONS
When you submit a form in a browser window, the default action that the browser will take is to
reload the current page, passing the values from the form as a querystring appended to the URL.
You can change the default action of the form element by using the action and method attributes
of the form element. The action attribute changes the URL that the form will submit to, and the
method attribute changes the HTTP method used to submit the form (either using HTTP GET or
HTTP POST).
232 ❘ CHAPTER 8 Forms
